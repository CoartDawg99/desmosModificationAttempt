// shared.js
(() => {
    const
        __dcg_chunk_exports__ = {};
    var u_ = Object.create;
    var wh = Object.defineProperty;
    var c_ = Object
        .getOwnPropertyDescriptor;
    var l_ = Object
        .getOwnPropertyNames;
    var p_ = Object.getPrototypeOf,
        f_ = Object.prototype
            .hasOwnProperty;
    var GH = (e => typeof require !=
        "undefined" ? require :
        typeof Proxy !=
            "undefined" ? new Proxy(
                e, {
                get: (t, n) => (
                    typeof require !=
                        "undefined" ?
                        require :
                        t)[n]
            }) : e)(function (
                e) {
                if (typeof require !=
                    "undefined")
                    return require
                        .apply(this,
                            arguments
                        );
                throw Error(
                    'Dynamic require of "' +
                    e +
                    '" is not supported'
                )
            });
    var kH = (e, t) => () => (e && (
        t = e(e = 0)), t);
    var zH = (e, t) => () => (t ||
        e((t = {
            exports: {}
        }).exports, t), t
            .exports),
        No = (e, t) => {
            for (var n in t) wh(e,
                n, {
                get: t[n],
                enumerable:
                    !0
            })
        },
        d_ = (e, t, n, r) => {
            if (t && typeof t ==
                "object" ||
                typeof t ==
                "function")
                for (let i of l_(t))
                    !f_.call(e,
                        i) && i !== n &&
                        wh(e, i, {
                            get: () =>
                                t[
                                i],
                            enumerable:
                                !(r =
                                    c_(t,
                                        i
                                    )
                                ) ||
                                r
                                    .enumerable
                        });
            return e
        };
    var HH = (e, t, n) => (n = e !=
        null ? u_(p_(e)) : {},
        d_(t || !e || !e
            .__esModule ? wh(n,
                "default", {
                value: e,
                enumerable:
                    !0
            }) : n, e));
    var UH = (() => {
        for (var e =
            new Uint8Array(
                128),
            t = 0; t <
            64; t++) e[t <
                26 ? t +
            65 : t <
                52 ? t +
            71 : t <
                62 ? t - 4 :
                t * 4 - 205
            ] = t;
        return n => {
            for (var r =
                n
                    .length,
                i =
                    new Uint8Array(
                        (r - (n[r -
                            1] ==
                            "="
                        ) -
                            (n[r -
                                2] ==
                                "="
                            )
                        ) *
                        3 /
                        4 |
                        0
                    ),
                s =
                    0,
                o =
                    0; s <
                r;) {
                var a =
                    e[n.charCodeAt(
                        s++
                    )],
                    u =
                        e[n.charCodeAt(
                            s++
                        )],
                    c =
                        e[n.charCodeAt(
                            s++
                        )],
                    l =
                        e[n.charCodeAt(
                            s++
                        )];
                i[o++] =
                    a <<
                    2 |
                    u >>
                    4,
                    i[
                    o++] =
                    u <<
                    4 |
                    c >>
                    2,
                    i[
                    o++] =
                    c <<
                    6 |
                    l
            }
            return i
        }
    })();
    var AM = function () {
        {
            var e =
                function () { },
                t = ["log",
                    "info",
                    "warn",
                    "error",
                    "assert",
                    "dir",
                    "clear",
                    "profile",
                    "profileEnd",
                    "time",
                    "timeEnd",
                    "group",
                    "groupCollapsed",
                    "groupEnd",
                    "trace"
                ],
                n = {},
                r = function (
                    i) {
                    typeof window
                        !=
                        "undefined" &&
                        window
                            .console &&
                        window
                            .console[
                        i] ?
                        n[i] =
                        function () {
                            Function
                                .prototype
                                .apply
                                .call(
                                    window
                                        .console[
                                    i
                                    ],
                                    window
                                        .console,
                                    arguments
                                )
                        } : n[
                        i] = e
                };
            return t.forEach(r),
                n
        }
    }(),
        $H = AM,
        {
            log: YH,
            warn: XH,
            error: ZH,
            assert: WH,
            dir: jH,
            clear: JH,
            profile: QH,
            profileEnd: KH,
            time: eU,
            timeEnd: tU,
            group: nU,
            groupCollapsed: rU,
            groupEnd: iU,
            trace: sU
        } = AM;
    var Jd = {};
    No(Jd, {
        getFrame: () => bL
    });

    function yi(e, t, n) {
        return {
            input: e,
            start: t,
            end: n
        }
    }

    function to(e, t) {
        return yi(e, t, t)
    }

    function Kr(e, t) {
        if (e.input !== t.input)
            throw new Error(
                "Programming Error: cannot form a span on different inputs"
            );
        return yi(e.input, e.start,
            t.end)
    }

    function Cn(e) {
        return e.input.slice(e
            .start, e.end)
    }
    var aa = () => ({
        type: "empty"
    }),
        Xn = () => m_([-1 / 0, 1 /
            0]),
        Ao = () => Xi([-1 / 0, 1 /
            0]),
        Xi = e => Ad(e, !0),
        m_ = e => Ad(e, !1),
        Ad = (e, t) => isNaN(e[
            0]) || isNaN(e[1]) || e[1] <
            e[0] ? aa() : {
            type: "interval",
            bounds: e,
            tight: t
        };

    function gi(e) {
        return e.type === "empty"
    }

    function Yi(e) {
        return gi(e) || e.tight
    }
    var Xc = (e, t) => {
        if (t === 0) return e >
            0 ? Ao() : aa();
        let n = -e / t,
            r = t < 0 ? [-1 / 0,
                n
            ] : [n, 1 / 0];
        return Xi(r)
    },
        Dn = (e, t) => {
            if (gi(e) || gi(t))
                return aa();
            let n = [Math.max(e
                .bounds[0],
                t.bounds[0]
            ), Math.min(
                e.bounds[1],
                t.bounds[1])
            ],
                r = Yi(e) && Yi(t);
            return Ad(n, r)
        },
        Dp = (e, t) => {
            if (gi(e)) return t;
            if (gi(t)) return e;
            let n = [Math.min(e
                .bounds[0],
                t.bounds[0]
            ), Math.max(
                e.bounds[1],
                t.bounds[1])
            ],
                r;
            return !Yi(e) && !Yi(
                t) ? r = !1 : Yi(
                    e) && !Yi(t) ? r = e
                        .bounds[0] <= t
                            .bounds[0] && e
                                .bounds[1] >= t
                                    .bounds[1] : !Yi(
                                        e) && Yi(t) ? r = t
                                            .bounds[0] <= e
                                                .bounds[0] && t
                                                    .bounds[1] >= e
                                                        .bounds[1] : r = e
                                                            .bounds[0] <= t
                                                                .bounds[1] && t
                                                                    .bounds[0] <= e
                                                                        .bounds[1], Ad(n, r)
        },
        LM = (e, t, n) => {
            if (gi(e)) return n;
            let r = Dn(e, t);
            return Yi(e) ? (e
                .bounds[0] > -
                1 / 0 && (r =
                    Dp(r, Dn(Xi([-1 /
                        0,
                    e
                        .bounds[
                    0
                    ]
                    ]),
                        n))), e
                            .bounds[1] < 1 /
                        0 && (r = Dp(r,
                            Dn(Xi([e.bounds[
                                1],
                            1 /
                            0
                            ]),
                                n)))) :
                r = Dp(r, Dn(n,
                    Xn())), r
        };
    var Oe = {};
    No(Oe, {
        Action: () => rt,
        AngleMarker: () =>
            Ge,
        Any: () => Ht,
        Arc: () => ce,
        Bool: () => ge,
        Circle: () => pe,
        DirectedAngleMarker: () =>
            Ae,
        Distribution: () =>
            St,
        EmptyList: () => We,
        ErrorType: () => no,
        Line: () => fe,
        ListOfAngleMarker: () =>
            gn,
        ListOfAny: () => sn,
        ListOfArc: () => Vn,
        ListOfBool: () =>
            Ln,
        ListOfCircle: () =>
            Fn,
        ListOfColor: () =>
            Zn,
        ListOfDirectedAngleMarker: () =>
            hn,
        ListOfDistribution: () =>
            wn,
        ListOfLine: () =>
            Bn,
        ListOfMapInterval2DPoint: () =>
            Or,
        ListOfMapInterval2DPoint3D: () =>
            Cr,
        ListOfMapIntervalPoint: () =>
            Dr,
        ListOfMapIntervalPoint3D: () =>
            Sr,
        ListOfNumber: () =>
            se,
        ListOfPoint: () =>
            Pt,
        ListOfPoint3D: () =>
            Kn,
        ListOfPolygon: () =>
            Rn,
        ListOfRay: () => Gn,
        ListOfRestriction: () =>
            Hr,
        ListOfSegment: () =>
            Tn,
        ListOfSegment3D: () =>
            er,
        ListOfSphere3D: () =>
            yr,
        ListOfTone: () =>
            Ur,
        ListOfTransformation: () =>
            mr,
        ListOfTriangle3D: () =>
            tr,
        ListOfVector: () =>
            kn,
        ListOfVector3D: () =>
            nr,
        MapInterval2DPoint: () =>
            sr,
        MapInterval2DPoint3D: () =>
            or,
        MapIntervalPoint: () =>
            Wn,
        MapIntervalPoint3D: () =>
            jn,
        Number: () => T,
        Point: () => R,
        Point3D: () => V,
        Polygon: () => Be,
        RGBColor: () => Ut,
        Ray: () => Le,
        Restriction: () =>
            Vt,
        SeedType: () => ot,
        Segment: () => Ie,
        Segment3D: () => Nt,
        Sphere3D: () => Nn,
        Tone: () => mn,
        Transformation: () =>
            Ue,
        Triangle3D: () =>
            In,
        Vector: () => he,
        Vector3D: () => Se,
        allListTypes: () =>
            Zi,
        allValueTypes: () =>
            y_,
        argTypeAtIndex: () =>
            Uu,
        assertTypeIsOneOf: () =>
            Op,
        broadcastable: () =>
            ti,
        broadcastableArg: () =>
            Hu,
        commonCoerceableTypeWithBroadcast: () =>
            ua,
        elementType: () =>
            ke,
        getAllowedTypesForArg: () =>
            Np,
        hasListType: () =>
            ei,
        hasMapType: () =>
            kh,
        isGeometryType: () =>
            Sp,
        isList: () => W,
        isMapOrListOfMap: () =>
            ca,
        isOneOf: () => Wc,
        isSubType: () => ro,
        isSubTypeOrCoercible: () =>
            zr,
        isTypeOrListOfType: () =>
            oe,
        isValidOnLogScales: () =>
            Zc,
        listType: () => ar,
        mapType: () => zh,
        maxArity: () => Cp,
        minArity: () => Ga,
        prettyPrint: () =>
            ne,
        repr: () => on,
        straightTypes: () =>
            _d,
        summableElementTypes: () =>
            Bh,
        typeSatisfiesArgType: () =>
            Hh,
        typeSatisfiesArgTypeUncoerced: () =>
            Rp,
        valueTypes: () =>
            FM,
        vectorTypes: () =>
            Gh
    });

    function S(e, t) {
        return {
            key: e,
            vars: t
        }
    }
    var Ht = 0,
        T = 1,
        ge = 2,
        R = 3,
        St = 4,
        rt = 5,
        sn = 6,
        se = 7,
        Ln = 8,
        Pt = 9,
        wn = 10,
        We = 11,
        no = 12,
        ot = 13,
        Ut = 14,
        Zn = 15,
        Be = 16,
        Rn = 17,
        Ie = 18,
        Tn = 19,
        pe = 20,
        Fn = 21,
        ce = 22,
        Vn = 23,
        fe = 24,
        Bn = 25,
        Le = 26,
        Gn = 27,
        Ge = 28,
        gn = 29,
        Ae = 30,
        hn = 31,
        Ue = 32,
        mr = 33,
        he = 34,
        kn = 35,
        Vt = 36,
        Hr = 37,
        mn = 50,
        Ur = 51,
        V = 100,
        Kn = 101,
        Nt = 102,
        er = 103,
        In = 104,
        tr = 105,
        Nn = 106,
        yr = 107,
        Se = 108,
        nr = 109,
        Wn = 200,
        jn = 201,
        sr = 202,
        or = 203,
        Dr = 204,
        Sr = 205,
        Or = 206,
        Cr = 207,
        FM = {
            Any: Ht,
            Number: T,
            Bool: ge,
            Point: R,
            Point3D: V,
            Distribution: St,
            Action: rt,
            ListOfAny: sn,
            ListOfNumber: se,
            ListOfBool: Ln,
            ListOfPoint: Pt,
            ListOfPoint3D: Kn,
            ListOfDistribution: wn,
            EmptyList: We,
            ErrorType: no,
            SeedType: ot,
            RGBColor: Ut,
            ListOfColor: Zn,
            Polygon: Be,
            ListOfPolygon: Rn,
            Segment: Ie,
            ListOfSegment: Tn,
            Circle: pe,
            ListOfCircle: Fn,
            Arc: ce,
            ListOfArc: Vn,
            Line: fe,
            ListOfLine: Bn,
            Ray: Le,
            ListOfRay: Gn,
            Vector: he,
            ListOfVector: kn,
            Restriction: Vt,
            ListOfRestriction: Hr,
            AngleMarker: Ge,
            ListOfAngleMarker: gn,
            DirectedAngleMarker: Ae,
            ListOfDirectedAngleMarker: hn,
            Transformation: Ue,
            ListOfTransformation: mr,
            Segment3D: Nt,
            ListOfSegment3D: er,
            Triangle3D: In,
            ListOfTriangle3D: tr,
            Sphere3D: Nn,
            ListOfSphere3D: yr,
            Vector3D: Se,
            ListOfVector3D: nr,
            Tone: mn,
            ListOfTone: Ur,
            MapIntervalPoint: Wn,
            MapIntervalPoint3D: jn,
            MapInterval2ToPoint: sr,
            MapInterval2DPoint3D: or,
            ListOfMapIntervalPoint: Dr,
            ListOfMapIntervalPoint3D: Sr,
            ListOfMapInterval2ToPoint: Or,
            ListOfMapInterval2DPoint3D: Cr
        },
        y_ = Object.values(FM);

    function on(e) {
        switch (e) {
            case Ht:
                return "Any";
            case T:
                return "Number";
            case ge:
                return "Bool";
            case R:
                return "Point";
            case V:
                return "Point3D";
            case St:
                return "Distribution";
            case rt:
                return "Action";
            case sn:
                return "ListOfAny";
            case se:
                return "ListOfNumber";
            case Ln:
                return "ListOfBool";
            case Pt:
                return "ListOfPoint";
            case Kn:
                return "ListOfPoint3D";
            case wn:
                return "ListOfDistribution";
            case We:
                return "EmptyList";
            case no:
                return "ErrorType";
            case ot:
                return "SeedType";
            case Ut:
                return "RGBColor";
            case Zn:
                return "ListOfColor";
            case Be:
                return "Polygon";
            case Rn:
                return "ListOfPolygon";
            case Ie:
                return "Segment";
            case Tn:
                return "ListOfSegment";
            case pe:
                return "Circle";
            case Fn:
                return "ListOfCircle";
            case ce:
                return "Arc";
            case Vn:
                return "ListOfArc";
            case fe:
                return "Line";
            case Bn:
                return "ListOfLine";
            case Le:
                return "Ray";
            case Gn:
                return "ListOfRay";
            case he:
                return "Vector";
            case kn:
                return "ListOfVector";
            case Vt:
                return "Restriction";
            case Hr:
                return "ListOfRestriction";
            case Ge:
                return "Angle";
            case gn:
                return "ListOfAngle";
            case Ae:
                return "DirectedAngle";
            case hn:
                return "ListOfDirectedAngle";
            case Ue:
                return "Transformation";
            case mr:
                return "ListOfTransformation";
            case Nt:
                return "Segment3D";
            case er:
                return "ListOfSegment3D";
            case Se:
                return "Vector3D";
            case nr:
                return "ListOfVector3D";
            case In:
                return "Triangle3D";
            case tr:
                return "ListOfTriangle3D";
            case Nn:
                return "Sphere3D";
            case yr:
                return "ListOfSphere3D";
            case mn:
                return "Tone";
            case Ur:
                return "ListOfTone";
            case Wn:
                return "MapIntervalPoint";
            case jn:
                return "MapIntervalPoint3D";
            case sr:
                return "MapInterval2ToPoint";
            case or:
                return "MapInterval2DPoint3D";
            case Dr:
                return "ListOfMapIntervalPoint";
            case Sr:
                return "ListOfMapIntervalPoint3D";
            case Or:
                return "ListOfMapInterval2ToPoint";
            case Cr:
                return "ListOfMapInterval2DPoint3D";
            default:
                let t = e;
                throw new Error(
                    `Invalid type: ${t}`
                )
        }
    }

    function ne(e) {
        switch (e) {
            case Ht:
                return S(
                    "shared-calculator-label-value-type-any"
                );
            case T:
                return S(
                    "shared-calculator-label-value-type-number"
                );
            case ge:
                return S(
                    "shared-calculator-label-value-type-bool"
                );
            case R:
                return S(
                    "shared-calculator-label-value-type-point"
                );
            case V:
                return S(
                    "shared-calculator-label-value-type-point3d"
                );
            case St:
                return S(
                    "shared-calculator-label-value-type-distribution"
                );
            case rt:
                return S(
                    "shared-calculator-label-value-type-action"
                );
            case sn:
                return S(
                    "shared-calculator-label-value-type-list-of-any"
                );
            case se:
                return S(
                    "shared-calculator-label-value-type-list-of-numbers"
                );
            case Ln:
                return S(
                    "shared-calculator-label-value-type-list-of-bool"
                );
            case Pt:
                return S(
                    "shared-calculator-label-value-type-list-of-points"
                );
            case Kn:
                return S(
                    "shared-calculator-label-value-type-list-of-3d-points"
                );
            case wn:
                return S(
                    "shared-calculator-label-value-type-list-of-distributions"
                );
            case We:
                return S(
                    "shared-calculator-label-value-type-empty-list"
                );
            case no:
                return S(
                    "shared-calculator-label-value-type-error"
                );
            case ot:
                return S(
                    "shared-calculator-label-value-type-seed"
                );
            case Ut:
                return S(
                    "shared-calculator-label-value-type-color"
                );
            case Zn:
                return S(
                    "shared-calculator-label-value-type-list-of-colors"
                );
            case Be:
                return S(
                    "shared-calculator-label-value-type-polygon"
                );
            case Rn:
                return S(
                    "shared-calculator-label-value-type-list-of-polygons"
                );
            case Ie:
                return S(
                    "shared-calculator-label-value-type-segment"
                );
            case Tn:
                return S(
                    "shared-calculator-label-value-type-list-of-segments"
                );
            case pe:
                return S(
                    "shared-calculator-label-value-type-circle"
                );
            case Fn:
                return S(
                    "shared-calculator-label-value-type-list-of-circles"
                );
            case ce:
                return S(
                    "shared-calculator-label-value-type-arc"
                );
            case Vn:
                return S(
                    "shared-calculator-label-value-type-list-of-arcs"
                );
            case fe:
                return S(
                    "shared-calculator-label-value-type-line"
                );
            case Bn:
                return S(
                    "shared-calculator-label-value-type-list-of-lines"
                );
            case Le:
                return S(
                    "shared-calculator-label-value-type-ray"
                );
            case Gn:
                return S(
                    "shared-calculator-label-value-type-list-of-rays"
                );
            case he:
                return S(
                    "shared-calculator-label-value-type-vector"
                );
            case kn:
                return S(
                    "shared-calculator-label-value-type-list-of-vectors"
                );
            case Vt:
                return S(
                    "shared-calculator-label-value-type-restriction"
                );
            case Hr:
                return S(
                    "shared-calculator-label-value-type-list-of-restrictions"
                );
            case Ge:
                return S(
                    "shared-calculator-label-value-type-angle"
                );
            case gn:
                return S(
                    "shared-calculator-label-value-type-list-of-angles"
                );
            case Ae:
                return S(
                    "shared-calculator-label-value-type-directed-angle"
                );
            case hn:
                return S(
                    "shared-calculator-label-value-type-list-of-directed-angles"
                );
            case Ue:
                return S(
                    "shared-calculator-label-value-type-transformation"
                );
            case mr:
                return S(
                    "shared-calculator-label-value-type-list-of-transformations"
                );
            case Nt:
                return S(
                    "shared-calculator-label-value-type-segment3d"
                );
            case er:
                return S(
                    "shared-calculator-label-value-type-list-of-segment3d"
                );
            case Se:
                return S(
                    "shared-calculator-label-value-type-vector3d"
                );
            case nr:
                return S(
                    "shared-calculator-label-value-type-list-of-vector3d"
                );
            case In:
                return S(
                    "shared-calculator-label-value-type-triangle3d"
                );
            case tr:
                return S(
                    "shared-calculator-label-value-type-list-of-triangle3d"
                );
            case Nn:
                return S(
                    "shared-calculator-label-value-type-sphere3d"
                );
            case yr:
                return S(
                    "shared-calculator-label-value-type-list-of-sphere3d"
                );
            case mn:
                return S(
                    "shared-calculator-label-value-type-tone"
                );
            case Ur:
                return S(
                    "shared-calculator-label-value-type-list-of-tone"
                );
            case Wn:
            case sr:
                return S(
                    "shared-calculator-label-value-type-lambda-point"
                );
            case jn:
            case or:
                return S(
                    "shared-calculator-label-value-type-lambda-point3d"
                );
            case Dr:
            case Or:
                return S(
                    "shared-calculator-label-value-type-list-of-lambda-point"
                );
            case Sr:
            case Cr:
                return S(
                    "shared-calculator-label-value-type-list-of-lambda-point3d"
                );
            default:
                let t = e;
                throw new Error(
                    `Invalid type: ${t}`
                )
        }
    }
    var Zi = [sn, se, Ln, Hr, Pt,
        Kn, wn, We, Zn, Rn, Tn,
        Fn, Vn, Bn, Gn, kn, gn,
        hn, mr, er, nr, tr, yr,
        Ur, Dr, Sr, Or, Cr
    ],
        aU = {
            [sn]: Ht,
            [We]: T,
            [se]: T,
            [Ln]: ge,
            [Hr]: Vt,
            [Pt]: R,
            [Kn]: V,
            [wn]: St,
            [Zn]: Ut,
            [Rn]: Be,
            [Tn]: Ie,
            [Fn]: pe,
            [Vn]: ce,
            [Bn]: fe,
            [Gn]: Le,
            [kn]: he,
            [gn]: Ge,
            [hn]: Ae,
            [mr]: Ue,
            [er]: Nt,
            [nr]: Se,
            [tr]: In,
            [yr]: Nn,
            [Ur]: mn,
            [Dr]: Wn,
            [Sr]: jn,
            [Or]: sr,
            [Cr]: or
        };

    function W(e) {
        switch (e) {
            case void 0:
                return !1;
            case sn:
            case se:
            case Ln:
            case Hr:
            case Pt:
            case Kn:
            case wn:
            case Zn:
            case Rn:
            case Tn:
            case Fn:
            case Vn:
            case Bn:
            case Gn:
            case kn:
            case gn:
            case hn:
            case mr:
            case er:
            case nr:
            case tr:
            case yr:
            case Ur:
            case Dr:
            case Sr:
            case Or:
            case Cr:
                return !0;
            case We:
                return !0;
            case Ht:
            case T:
            case ge:
            case Vt:
            case R:
            case V:
            case St:
            case no:
            case ot:
            case Ut:
            case rt:
            case Be:
            case Ie:
            case pe:
            case ce:
            case fe:
            case Le:
            case he:
            case Ge:
            case Ae:
            case Ue:
            case Nt:
            case Se:
            case In:
            case mn:
            case Nn:
            case Wn:
            case jn:
            case sr:
            case or:
                return !1;
            default:
                throw new Error(
                    `Invalid type: ${e}`
                )
        }
    }

    function ke(e) {
        switch (e) {
            case We:
            case se:
                return T;
            case Ln:
                return ge;
            case Hr:
                return Vt;
            case Pt:
                return R;
            case Kn:
                return V;
            case wn:
                return St;
            case Zn:
                return Ut;
            case Rn:
                return Be;
            case er:
                return Nt;
            case nr:
                return Se;
            case tr:
                return In;
            case yr:
                return Nn;
            case sn:
                return Ht;
            case Tn:
                return Ie;
            case Fn:
                return pe;
            case Vn:
                return ce;
            case Bn:
                return fe;
            case Gn:
                return Le;
            case kn:
                return he;
            case gn:
                return Ge;
            case hn:
                return Ae;
            case mr:
                return Ue;
            case Ur:
                return mn;
            case Dr:
                return Wn;
            case Sr:
                return jn;
            case Or:
                return sr;
            case Cr:
                return or;
            case Ht:
            case T:
            case ge:
            case R:
            case V:
            case St:
            case no:
            case ot:
            case Ut:
            case rt:
            case Be:
            case Ie:
            case pe:
            case ce:
            case fe:
            case Le:
            case he:
            case Vt:
            case Ge:
            case Ae:
            case Ue:
            case Nt:
            case Se:
            case In:
            case Nn:
            case mn:
            case Wn:
            case jn:
            case sr:
            case or:
                throw new Error(
                    "Type " +
                    on(e) +
                    " does not implement elementType."
                );
            default:
                let t = e;
                throw new Error(
                    `Invalid type: ${t}`
                )
        }
    }

    function ar(e) {
        switch (e) {
            case Ht:
                return sn;
            case T:
                return se;
            case ge:
                return Ln;
            case Vt:
                return Hr;
            case R:
                return Pt;
            case V:
                return Kn;
            case St:
                return wn;
            case Ut:
                return Zn;
            case Be:
                return Rn;
            case Ie:
                return Tn;
            case pe:
                return Fn;
            case ce:
                return Vn;
            case fe:
                return Bn;
            case Le:
                return Gn;
            case he:
                return kn;
            case Ge:
                return gn;
            case Ae:
                return hn;
            case Ue:
                return mr;
            case Nt:
                return er;
            case Se:
                return nr;
            case In:
                return tr;
            case Nn:
                return yr;
            case mn:
                return Ur;
            case Wn:
                return Dr;
            case jn:
                return Sr;
            case sr:
                return Or;
            case or:
                return Cr;
            case We:
            case se:
            case Ln:
            case Hr:
            case Pt:
            case Kn:
            case wn:
            case Zn:
            case Rn:
            case Tn:
            case Fn:
            case Vn:
            case Bn:
            case Gn:
            case kn:
            case gn:
            case hn:
            case mr:
            case er:
            case nr:
            case tr:
            case yr:
            case sn:
            case Ur:
            case no:
            case ot:
            case rt:
            case Dr:
            case Sr:
            case Or:
            case Cr:
                throw new Error(
                    "Type " +
                    on(e) +
                    " does not implement listType."
                );
            default:
                let t = e;
                throw new Error(
                    `Invalid type: ${t}`
                )
        }
    }

    function ei(e) {
        switch (e) {
            case Ht:
            case T:
            case ge:
            case Vt:
            case R:
            case V:
            case St:
            case Ut:
            case Be:
            case Ie:
            case pe:
            case ce:
            case fe:
            case Le:
            case he:
            case Ge:
            case Ae:
            case Ue:
            case Nt:
            case Se:
            case In:
            case Nn:
            case mn:
            case Wn:
            case jn:
            case sr:
            case or:
                return !0;
            case We:
            case se:
            case Ln:
            case Hr:
            case Pt:
            case Kn:
            case wn:
            case Zn:
            case Rn:
            case Tn:
            case Fn:
            case Vn:
            case Bn:
            case Gn:
            case kn:
            case gn:
            case hn:
            case mr:
            case er:
            case nr:
            case tr:
            case yr:
            case sn:
            case Ur:
            case Dr:
            case Sr:
            case Or:
            case Cr:
            case ot:
            case rt:
            case no:
                return !1;
            default:
                throw new Error(
                    `Invalid type: ${e}`
                )
        }
    }

    function Sp(e) {
        if (e === void 0) return !1;
        switch (e) {
            case R:
            case Be:
            case Ie:
            case pe:
            case ce:
            case fe:
            case Le:
            case he:
            case Ge:
            case Ae:
            case Ue:
                return !0;
            default:
                return !1
        }
    }

    function Zc(e) {
        switch (e) {
            case T:
            case Ht:
            case ge:
            case Vt:
            case R:
            case St:
            case rt:
            case sn:
            case se:
            case Ln:
            case Hr:
            case Pt:
            case wn:
            case We:
            case no:
            case ot:
            case Ut:
            case Zn:
            case mn:
            case Ur:
                return !0;
            case V:
            case Kn:
            case Nt:
            case er:
            case Se:
            case nr:
            case In:
            case tr:
            case Nn:
            case yr:
            case Be:
            case Rn:
            case Ie:
            case Tn:
            case pe:
            case Fn:
            case ce:
            case Vn:
            case fe:
            case Bn:
            case Le:
            case Gn:
            case he:
            case kn:
            case Ge:
            case gn:
            case Ae:
            case hn:
            case Ue:
            case mr:
            case Wn:
            case jn:
            case sr:
            case or:
            case Dr:
            case Sr:
            case Or:
            case Cr:
                return !1;
            default:
                let t = e;
                throw new Error(
                    `Invalid type: ${t}`
                )
        }
    }

    function Wc(e, t) {
        for (let n of t)
            if (e === n) return !0;
        return !1
    }

    function ro(e, t) {
        return e === We && W(t) ||
            t === sn && W(e) ||
            t === Ht && !W(e) ? !0 :
            e === t
    }

    function zr(e, t) {
        return !!(ro(e, t) || t ===
            g_(e))
    }

    function g_(e) {
        switch (e) {
            case Ge:
            case Ae:
            case Vt:
                return T;
            case gn:
            case hn:
            case Hr:
                return se;
            default:
                return
        }
    }

    function wM(e) {
        switch (e) {
            case Vt:
                return T;
            case Hr:
                return se;
            default:
                return e
        }
    }

    function Vh(e, t) {
        var n, r;
        if (zr(e, t)) return t;
        if (zr(t, e)) return e;
        if (e = (n = wM(e)) !=
            null ? n : e, t = (r =
                wM(t)) != null ? r :
                t, zr(e, t)) return t;
        if (zr(t, e)) return e
    }

    function ua(e, t) {
        return W(e) && ei(t) ? Vh(e,
            ar(t)) : ei(e) && W(
                t) ? Vh(ar(e), t) :
            Vh(e, t)
    }
    var Bh = [T, R, V],
        _d = [fe, Le, Ie, he],
        Gh = {
            meta: "union",
            types: [he, Se]
        };

    function oe(e, t) {
        return e === t ? !0 : W(e) ?
            e === We ? !0 : ke(
                e) === t : !1
    }

    function ca(e) {
        return Wc(e, [Wn, jn, sr,
            or, Dr, Sr, Or,
            Cr
        ])
    }
    var h_ = {
        [R]: Wn,
        [V]: jn
    },
        b_ = {
            [R]: sr,
            [V]: or
        };

    function kh(e) {
        return Wc(e, [R, V])
    }

    function zh(e, t) {
        if (e !== R && e !== V)
            throw new Error(
                `Unexpected return type for map: ${on(e)}`
            );
        return t === 1 ? h_[e] : b_[
            e]
    }

    function Op(e, t) {
        if (!Wc(e, t))
            throw new Error(
                `Programming error: expected one of ${t.map(ne)} but found ${e} instead.`
            )
    }

    function Ga(e) {
        return Array.isArray(e) ? e
            .length : e.initial
            .length
    }

    function Cp(e) {
        return Array.isArray(e) ? e
            .length : 1 / 0
    }

    function Hu(e) {
        if (typeof e == "number")
            return ei(e) ? {
                meta: "union",
                types: [e, ar(
                    e)]
            } : e;
        let t = [];
        for (let n of e.types) {
            let r = Hu(n);
            typeof r == "number" ? t
                .push(r) : t.push(
                    ...r.types)
        }
        return {
            meta: "union",
            types: t
        }
    }

    function ti(e) {
        return Array.isArray(e) ? e
            .map(Hu) : {
            type: "variadic",
            initial: e.initial
                .map(Hu),
            rest: Hu(e.rest)
        }
    }

    function Hh(e, t) {
        return typeof t ==
            "number" ? zr(e, t) : t
                .types.some(n => zr(e,
                    n))
    }

    function Rp(e, t) {
        return typeof t ==
            "number" ? ro(e, t) : t
                .types.some(n => ro(e,
                    n))
    }

    function Uu(e, t) {
        return Array.isArray(e) ?
            t > e.length - 1 ?
                void 0 : e[t] : t < e
                    .initial.length ? e
                        .initial[t] : e.rest
    }

    function Np(e, t) {
        let n = new Set;
        for (let r of e) {
            let i;
            if (Array.isArray(r)) {
                if (t >= r.length)
                    continue;
                i = VM(r[t])
            } else i = VM(t < r
                .initial
                .length ? r
                    .initial[t] : r
                .rest);
            for (let s of i) n.add(
                s)
        }
        return [...n]
    }

    function VM(e) {
        return typeof e ==
            "number" ? [e] : e.types
    }
    var Tt = class {
        constructor() {
            this.exportPenalty =
                0;
            this._dependencies = [],
                this
                    ._dummyDependencies = [],
                this
                    ._updateSymbols = [],
                this
                    ._substitutionSymbols = [],
                this
                    ._scope = {
                    definitions: [],
                    dependencies: [],
                    substitutionDependencies: [],
                    scopes: []
                }, this
                    ._exports = []
        }
        setInputSpan(t) {
            this._inputSpan =
                t
        }
        getInputString() {
            return this
                ._inputSpan ===
                void 0 ?
                "" : Cn(this
                    ._inputSpan
                )
        }
        getInputSpan() {
            return this
                ._inputSpan
        }
        shouldExportAns() {
            return !1
        }
        getAnsVariable() {
            return this
                .shouldExportAns() &&
                this
                    .userData &&
                this
                    .userData
                    .hasOwnProperty(
                        "index"
                    ) ? [
                "ans_" +
                this
                    .userData
                    .index
            ] : []
        }
        addDependency(t) {
            this._dependencies
                .indexOf(
                    t) === -1 &&
                this
                    ._dependencies
                    .push(t),
                this._scope
                    .dependencies
                    .indexOf(
                        t) === -1 &&
                this._scope
                    .dependencies
                    .push(t)
        }
        addDependencies(t) {
            for (var n =
                0; n < t
                    .length; n++
            ) this
                .addDependency(
                    t[n])
        }
        addDummyDependency(t) {
            this._dependencies
                .indexOf(
                    t) === -1 &&
                this
                    ._dependencies
                    .push(t),
                this
                    ._dummyDependencies
                    .indexOf(
                        t) === -1 &&
                this
                    ._dummyDependencies
                    .push(t)
        }
        addDummyDependencies(
            t) {
            for (var n =
                0; n < t
                    .length; n++
            ) this
                .addDummyDependency(
                    t[n])
        }
        addUpdateSymbol(t) {
            this._dependencies
                .indexOf(
                    t) === -1 &&
                this
                    ._dependencies
                    .push(t),
                this
                    ._updateSymbols
                    .indexOf(
                        t) === -1 &&
                this
                    ._updateSymbols
                    .push(t)
        }
        addSubstitutionSymbol(
            t) {
            this._dummyDependencies
                .indexOf(
                    t) === -1 &&
                this
                    ._dummyDependencies
                    .push(t),
                this
                    ._substitutionSymbols
                    .indexOf(
                        t) === -1 &&
                this
                    ._substitutionSymbols
                    .push(t)
        }
        addSubstitutionDependencies
            (t) {
            for (var n =
                0; n < t
                    .length; n++
            ) {
                var r = t[
                    n];
                if (this
                    ._dependencies
                    .indexOf(
                        r
                    ) ===
                    -1)
                    throw new Error(
                        "Programming error: substitution dependency " +
                        r +
                        " must also be registered as a regular dependency"
                    );
                this._scope
                    .substitutionDependencies
                    .indexOf(
                        r
                    ) ===
                    -1 &&
                    this
                        ._scope
                        .substitutionDependencies
                        .push(r)
            }
        }
        mergeDependencies(...
            t) {
            for (var n =
                0; n < t
                    .length; n++
            ) {
                var r = t[
                    n],
                    i;
                for (i =
                    0; i < r
                        ._dependencies
                        .length; i++
                ) this
                    ._dependencies
                    .indexOf(
                        r
                            ._dependencies[
                        i
                        ]
                    ) ===
                    -1 &&
                    this
                        ._dependencies
                        .push(r
                            ._dependencies[
                            i
                        ]
                        );
                for (i =
                    0; i < r
                        ._updateSymbols
                        .length; i++
                ) this
                    ._updateSymbols
                    .indexOf(
                        r
                            ._updateSymbols[
                        i
                        ]
                    ) ===
                    -1 &&
                    this
                        ._updateSymbols
                        .push(r
                            ._updateSymbols[
                            i
                        ]
                        );
                for (i =
                    0; i < r
                        ._substitutionSymbols
                        .length; i++
                ) this
                    ._substitutionSymbols
                    .indexOf(
                        r
                            ._substitutionSymbols[
                        i
                        ]
                    ) ===
                    -1 &&
                    this
                        ._substitutionSymbols
                        .push(r
                            ._substitutionSymbols[
                            i
                        ]
                        );
                for (i =
                    0; i < r
                        ._scope
                        .dependencies
                        .length; i++
                ) this
                    ._scope
                    .dependencies
                    .indexOf(
                        r
                            ._scope
                            .dependencies[
                        i
                        ]
                    ) ===
                    -1 &&
                    this
                        ._scope
                        .dependencies
                        .push(r
                            ._scope
                            .dependencies[
                            i
                        ]
                        );
                for (i =
                    0; i < r
                        ._scope
                        .substitutionDependencies
                        .length; i++
                ) this
                    ._scope
                    .substitutionDependencies
                    .indexOf(
                        r
                            ._scope
                            .substitutionDependencies[
                        i
                        ]
                    ) ===
                    -1 &&
                    this
                        ._scope
                        .substitutionDependencies
                        .push(r
                            ._scope
                            .substitutionDependencies[
                            i
                        ]
                        );
                this.addDummyDependencies(
                    r
                        .getDummyDependencies()
                ),
                    Array
                        .prototype
                        .push
                        .apply(
                            this
                                ._scope
                                .scopes,
                            r
                                ._scope
                                .scopes
                        )
            }
        }
        mergeDependenciesInScope
            (t, n, r, i) {
            this.addDummyDependencies(
                n);
            var s = r
                .getScope(),
                o = {
                    kind: t,
                    definitions: n,
                    dependencies: s
                        .dependencies,
                    substitutionDependencies: s
                        .substitutionDependencies,
                    scopes: s
                        .scopes,
                    functionDefinitionSymbol: i ==
                        null ?
                        void 0 :
                        i
                            .functionDefinitionSymbol
                };
            this._scope
                .scopes
                .push(o);
            for (var a =
                0; a < r
                    ._dependencies
                    .length; a++
            ) this
                ._dependencies
                .indexOf(r
                    ._dependencies[
                    a]
                ) === -
                1 && this
                    ._dependencies
                    .push(r
                        ._dependencies[
                        a]);
            for (a = 0; a <
                r
                    ._updateSymbols
                    .length; a++
            ) this
                ._updateSymbols
                .indexOf(r
                    ._updateSymbols[
                    a]
                ) === -
                1 && this
                    ._updateSymbols
                    .push(r
                        ._updateSymbols[
                        a]);
            for (a = 0; a <
                r
                    ._substitutionSymbols
                    .length; a++
            ) this
                ._substitutionSymbols
                .indexOf(r
                    ._substitutionSymbols[
                    a]
                ) === -
                1 && this
                    ._substitutionSymbols
                    .push(r
                        ._substitutionSymbols[
                        a]);
            this.addDummyDependencies(
                r
                    .getDummyDependencies()
            )
        }
        getDependencies() {
            return this
                ._dependencies
        }
        graphmodeDependencies(t,
            n) {
            return this
                .getDependencies()
        }
        getDummyDependencies() {
            return this
                ._dummyDependencies
        }
        getUpdateSymbols() {
            return this
                ._updateSymbols
        }
        getSubstitutionSymbols
            () {
            return this
                ._substitutionSymbols
        }
        getScope() {
            return this
                ._scope
        }
        dependsOn(t) {
            return this
                ._dependencies
                .indexOf(
                    t) > -1
        }
        getExports(t) {
            var n = this
                ._exports ||
                [];
            if (this
                .userData &&
                "id" in this
                    .userData) {
                var r = this
                    .userData
                    .id;
                n = n
                    .concat(
                        ["idref_" +
                            r
                        ])
            }
            return t
                .ansEnabled() &&
                (n = n
                    .concat(
                        this
                            .getAnsVariable()
                    )),
                n
        }
        getLegalExports(t) {
            return this
                .getExports(
                    t)
                .filter(
                    function (
                        n) {
                        return !
                            t
                                .assignmentForbidden(
                                    n
                                )
                    })
        }
        exportsSymbol(t) {
            return this
                ._exports
                .indexOf(
                    t) > -1
        }
        exportTo(t, n, r) {
            for (var i =
                this
                    .getLegalExports(
                        t),
                s =
                    0; s < i
                        .length; s++
            ) {
                var o = i[
                    s];
                if (r[o])
                    return;
                r[o] = n
                    .blocksExport ?
                    n : this
            }
        }
        getOperator() {
            return this
                .operator ||
                "="
        }
        isInequality() {
            return !1
        }
        isShadeBetween() {
            return !1
        }
        getAllIds() {
            return this
                .userData ?
                [this
                    .userData
                    .id
                ] : []
        }
        getEvaluationInfo() {
            return !1
        }
        shouldPromoteToSlider(
            t) {
            return !1
        }
        getSliderVariables(t, n,
            r) {
            var i = t
                .sliderVariables(
                    r !=
                        null ?
                        r : n
                            .getDependencies()
                );
            return n
                .valueType ===
                R || n
                    .valueType ===
                Pt || n
                    .valueType ===
                V || n
                    .valueType ===
                Kn ? t
                    .is3dPolicy() ?
                i.includes(
                    "t") &&
                    !i.includes(
                        "u") &&
                    !i.includes(
                        "v") ? i
                            .filter(s =>
                                s != "t"
                            ) : !i
                                .includes(
                                    "t") &&
                                (i.includes(
                                    "u"
                                ) ||
                                    i
                                        .includes(
                                            "v")
                                ) ? i
                                    .filter(s =>
                                        s !=
                                        "u" &&
                                        s != "v"
                                    ) : i :
                i.filter(
                    function (
                        s) {
                        return !
                            t
                                .validParametricVariable(
                                    s
                                )
                    }) : i
        }
        getCompiledDerivative
            () {
            var t = this
                .getDependencies(),
                r = this
                    .takeDerivative(
                        t[0] ||
                        "x");
            return r
                .getCompiledFunction()
        }
        asValue() { }
        boundDomain(t) {
            return Xn()
        }
        getCursorContext() { }
        polynomialOrder(t) { }
        getPolynomialCoefficients
            (t) { }
        asTypedValue() { }
        substitute(t) { }
        getExpressionType(t,
            n) { }
        tableInfo(t, n) { }
        analyzeFourFunction(t,
            n, r) { }
        analyzeScientific(t, n,
            r) { }
        analyzeSingleExpressionScientific
            (t, n, r) { }
        getGraphMode(t, n) { }
    };
    var j = class extends Tt {
        constructor(t, n) {
            if (!Array
                .isArray(t))
                throw new TypeError(
                    "Argument to expression constructor must be an Array."
                );
            super(), this
                .args = t, (
                    !n || !n
                        .skipRegisterDependencies
                ) &&
                this
                    .registerDependencies()
        }
        shouldExportAns() {
            return !0
        }
        registerDependencies() {
            for (var t =
                0; t < this
                    .args
                    .length; t++
            ) this
                .mergeDependencies(
                    this
                        .args[t]
                )
        }
        copyWithArgs(t) {
            throw new Error(
                `Programming Error: copyWithArgs not implemented for ${this.constructor.name}`
            )
        }
    };

    function la(e, t = 1e6) {
        if (e === 1 / 0) return {
            n: 1 / 0,
            d: 1
        };
        if (e === -1 / 0) return {
            n: -1 / 0,
            d: 1
        };
        if (!isFinite(e)) return {
            n: NaN,
            d: 1
        };
        let n, r = 0,
            i = 1,
            s = 1,
            o = 0,
            a, u;
        for (; n = Math.floor(e),
            a = n * i + r, u = n *
            o + s, !(u > t || (r =
                i, s = o, i = a,
                o = u, e === n));)
            e = 1 / (e - n);
        return {
            n: i,
            d: o
        }
    }

    function BM(e, t, n) {
        if (e = jc(e), n > 0) {
            let r = jc(t);
            return e < r && (e +=
                2 * Math.PI), (
                    e - r) / n
        } else {
            let r = jc(t + n);
            return e < r && (e +=
                2 * Math.PI),
                1 + (e - r) / n
        }
    }

    function Ld(e, t, n) {
        e = jc(e);
        let r = jc(t),
            i = jc(t + n);
        if (n < 0) {
            let s = r;
            r = i, i = s
        }
        return r < i ? r <= e &&
            e <= i : r <= e || e <=
            i
    }

    function jc(e) {
        let t = 2 * Math.PI;
        return (e % t + t) % t
    }

    function bU(e, t) {
        if (!(isNaN(e) || isNaN(t)))
            return e >= 0 ? Math
                .atan(t / e) : Math
                    .atan(t / e) + Math
                .PI
    }
    var as = Math.hypot;

    function pa(e, t) {
        return e > 0 == t > 0 ? e +
            .5 * (t - e) : .5 * (e +
                t)
    }

    function P_(e, t, n, r, i, s) {
        return e * r + t * i + n * s
    }

    function Rs(e, t, n, r, i, s, o,
        a, u) {
        let c = as(o - r, a - i, u -
            s);
        return c === 0 ? 0 : P_((e -
            r) / c, (t -
                i) / c, (n - s) / c,
            (o - r) / c, (a -
                i) / c, (u - s) / c)
    }

    function T_(e, t, n, r, i, s) {
        let o = Rs(e, t, 0, n, r, 0,
            i, s, 0);
        return o <= 0 ? [n, r] :
            o >= 1 ? [i, s] : [n +
                o * (i - n), r + o *
                (s - r)
            ]
    }

    function I_(e, t, n, r, i, s, o,
        a, u) {
        let c = Rs(e, t, n, r, i, s,
            o, a, u);
        return c <= 0 ? [r, i, s] :
            c >= 1 ? [o, a, u] : [
                r + c * (o - r), i +
                c * (a - i), s + c *
                (u - s)
            ]
    }

    function PU(e, t, n, r, i, s, o,
        a) {
        let u = Rs(e, t, 0, n, r, 0,
            i, s, 0);
        return u <= 0 && !o ? [n,
            r] : u >= 1 && !a ? [i,
                s
            ] : [n + u * (i - n),
            r + u * (s - r)
        ]
    }

    function GM(e, t, n, r, i, s) {
        let o = T_(e, t, n, r, i,
            s);
        return as(e - o[0], t - o[
            1])
    }

    function kM(e, t, n, r, i, s, o,
        a, u) {
        let c = I_(e, t, n, r, i, s,
            o, a, u);
        return as(e - c[0], t - c[
            1], n - c[2])
    }

    function TU(e, t, n, r, i, s,
        o) {
        var a = Math.atan2(t - r,
            e - n);
        if (Ld(a, s, o - s))
            return [i * Math.cos(
                a) + n, i * Math
                    .sin(a) + r
            ]
    }

    function Li(e, t, n = 1) {
        if (e === t) return !0;
        if (!isFinite(e) || !
            isFinite(t)) return !1;
        if (n > 50) throw new Error(
            "Within " + (
                52 - n) +
            " bits isn't really approximate any more"
        );
        let r = Math.max(Math.max(
            Math.abs(e),
            Math.abs(t)), 1),
            i = n === 1 ? .5 : Math
                .pow(.5, n);
        return r === r + i * Math
            .abs(t - e)
    }

    function IU(e) {
        return Math.round(e - .5) +
            .5
    }

    function qu(e, t) {
        if (isNaN(e) || isNaN(t))
            return NaN;
        if (e = Math.round(e), t =
            Math.round(t), e < 0 &&
            (e = -e), t < 0 && (
                t = -t), t > e) {
            let r = t;
            t = e, e = r
        }
        if (t === 0) return e;
        let n = e % t;
        for (; n > 0;) e = t, t = n,
            n = e % t;
        return t
    }

    function $u(e, t) {
        if (!isFinite(e) && t === 0)
            return NaN;
        if (e >= 0 || t === Math
            .floor(t)) return Math
                .pow(e, t);
        let n = la(t, 100);
        return Li(n.n / n.d, t,
            2) && n.d % 2 === 1 ? (n
                .n % 2 === 0 ? 1 : -
            1) * Math.pow(-e,
                t) : NaN
    }

    function Jc(e, t) {
        return {
            n: e,
            d: t
        }
    }

    function En(e) {
        return typeof e ==
            "object" && typeof e
                .n == "number" &&
            typeof e.d == "number"
    }
    var Ap = Math.pow(2, 53) - 1;

    function Yu(e) {
        let t = e.match(
            /^(-)?(\d*)?(?:\.(\d*))?$/
        );
        if (!t) return NaN;
        let n = t[1],
            r = t[2],
            i = t[3];
        if (!r && !i) return NaN;
        let s = !!n;
        if (i) {
            let o = i.replace(/0+$/,
                ""),
                a = o.length,
                u = Math.pow(10, a),
                c = parseInt(r ||
                    "0", 10) * u +
                    parseInt(o || "0",
                        10);
            return c > Ap || u >
                Ap ? parseFloat(e) :
                De(s ? -c : c, u)
        } else {
            let o = parseInt(r, 10);
            return o > Ap ?
                parseFloat(e) : De(
                    s ? -o : o, 1)
        }
    }

    function q(e) {
        return En(e) ? e.n / e.d : +
            e
    }

    function Wi(e) {
        return En(e) ? !1 : isNaN(e)
    }

    function De(e, t) {
        if (!isFinite(e) || !
            isFinite(t) || t ===
            0 || Math.floor(e) !==
            e || Math.floor(t) !==
            t || Math.abs(e) > Ap ||
            Math.abs(t) > Ap)
            return e / t;
        t < 0 && (e = -e, t = -t);
        let n = qu(e, t);
        return Jc(e / n, t / n)
    }

    function hi(e) {
        return En(e) ? Jc(-e.n, e
            .d) : -e
    }

    function zM(e) {
        return En(e) ? Jc(Math.abs(e
            .n), Math.abs(e
                .d)) : Math.abs(e)
    }

    function _p(e) {
        return En(e) ? e.n === 0 ? e
            .d / e.n : Jc(e.n < 0 ?
                -e.d : e.d, Math
                    .abs(e.n)) : 1 / e
    }

    function us(e, t) {
        if (!En(e) || !En(t))
            return q(e) + q(t);
        var n = qu(e.d, t.d);
        return De(e.n * (t.d / n) +
            t.n * (e.d / n), e
                .d / n * t.d)
    }

    function cs(e, t) {
        if (!En(e) || !En(t))
            return q(e) * q(t);
        var n = qu(e.n, t.d),
            r = qu(t.n, e.d);
        return De(e.n / n * (t.n /
            r), e.d / r * (t
                .d / n))
    }

    function ji(e, t) {
        return us(e, hi(t))
    }

    function Ji(e, t) {
        return !En(e) || !En(t) ? q(
            e) / q(t) : cs(e,
                _p(t))
    }

    function M_(e, t) {
        let n = e,
            r = t;
        if (t.n < 0 && (r = hi(t),
            n = _p(e)), !En(
                n) || !En(r)) return $u(
                    q(e), q(t));
        if (e = n, t = r, t.d === 1)
            return De(Math.pow(e.n,
                t.n), Math
                    .pow(e.d, t.n));
        let i = e.n < 0;
        if (i && t.d % 2 !== 1)
            return NaN;
        let o = (i ? -1 : 1) * Math
            .round(Math.pow(Math
                .abs(e.n), 1 / t
                    .d)),
            a = Math.round(Math.pow(
                Math.abs(e.d),
                1 / t.d));
        return Math.pow(o, t.d) !==
            e.n || Math.pow(a, t
                .d) !== e.d ? $u(q(e),
                    q(t)) : De(Math.pow(
                        o, t.n), Math
                            .pow(a, t.n))
    }

    function Uh(e, t) {
        if (!En(e) || !En(t))
            return $u(q(e), q(t));
        let n = M_(e, t);
        return En(n) ? n : $u(q(e),
            q(t))
    }

    function HM(e) {
        if (!En(e)) return Math
            .sqrt(e);
        let t = Math.round(Math
            .sqrt(e.n)),
            n = Math.round(Math
                .sqrt(e.d));
        return t * t !== e.n || n *
            n !== e.d ? Math.sqrt(q(
                e)) : De(t, n)
    }

    function wd(e, t) {
        return Uh(e, _p(t))
    }

    function UM(e, t) {
        if (!En(e) || !En(t)) {
            let n = q(e),
                r = q(t);
            return n - r * Math
                .floor(n / r)
        }
        return ji(e, cs(t, Jc(Math
            .floor(q(Ji(e,
                t
            ))), 1)))
    }

    function qM(e) {
        let t = Jc(0, 1);
        for (let n of e) t = us(t,
            n);
        return t
    }
    var Zt = class extends j {
        constructor(n) {
            super([]);
            this.isConstant = !
                0;
            typeof n ==
                "number" &&
                (n = De(n,
                    1)),
                this
                    ._constantValue =
                n
        }
        asValue() {
            let n = this
                ._constantValue;
            return typeof n ==
                "boolean" ?
                n : q(n)
        }
        asCompilerValue() {
            return this
                ._constantValue
        }
        scalarExprString() {
            return this
                .asValue() >
                0 ? String(
                    this
                        .asValue()
                ) :
                "(" +
                String(this
                    .asValue()
                ) + ")"
        }
        getEvaluationInfo() {
            return [{
                val: this
                    .asValue()
            }]
        }
        isNaN() {
            let n = this
                .asValue();
            return typeof n ==
                "number" &&
                isNaN(n)
        }
    };
    var da = {};
    No(da, {
        canDisplayAsFraction: () =>
            xv,
        formatSymbol: () =>
            X,
        geoParentToLatex: () =>
            pL,
        identifierToHTML: () =>
            fL,
        identifierToLatex: () =>
            ur,
        latexToIdentifier: () =>
            Lo,
        numericLabel: () =>
            $d,
        point: () => sL,
        removeSpaces: () =>
            dL,
        roundDecimal: () =>
            cL,
        trimLatex: () => wo,
        truncatedHTMLLabel: () =>
            lL,
        truncatedLatexLabel: () =>
            Qh,
        truncatedPlainmathLabel: () =>
            Yd,
        value: () => jh
    });
    var Fd = typeof self ==
        "object" && self.self ===
        self && self ||
        typeof global == "object" &&
        global.global === global &&
        global || Function(
            "return this")() || {},
        Gd = Array.prototype,
        Yh = Object.prototype,
        $M = typeof Symbol !=
            "undefined" ? Symbol
            .prototype : null,
        DU = Gd.push,
        JM = Gd.slice,
        Vd = Yh.toString,
        v_ = Yh.hasOwnProperty,
        D_ = Array.isArray,
        YM = Object.keys,
        XM = Object.create,
        QM = Fd.isNaN,
        S_ = Fd.isFinite,
        qh = function () { };

    function gr(e) {
        if (e instanceof gr)
            return e;
        if (!(this instanceof gr))
            return new gr(e);
        this._wrapped = e
    }
    var SU = gr.VERSION = "1.10.2";

    function kd(e, t, n) {
        if (t === void 0) return e;
        switch (n == null ? 3 : n) {
            case 1:
                return function (r) {
                    return e
                        .call(t,
                            r)
                };
            case 3:
                return function (r,
                    i, s) {
                    return e
                        .call(t,
                            r,
                            i, s
                        )
                };
            case 4:
                return function (r,
                    i, s, o) {
                    return e
                        .call(t,
                            r,
                            i,
                            s, o
                        )
                }
        }
        return function () {
            return e.apply(t,
                arguments)
        }
    }

    function KM(e, t, n) {
        return e == null ? tL : fa(
            e) ? kd(e, t, n) :
            nl(e) && !tl(e) ? nL(
                e) : pv(e)
    }
    gr.iteratee = ev;

    function ev(e, t) {
        return KM(e, t, 1 / 0)
    }

    function io(e, t, n) {
        return gr.iteratee !== ev ?
            gr.iteratee(e, t) : KM(
                e, t, n)
    }

    function ls(e, t) {
        return t = t == null ? e
            .length - 1 : +t,
            function () {
                for (var n = Math
                    .max(
                        arguments
                            .length -
                        t, 0),
                    r = Array(
                        n), i =
                        0; i <
                    n; i++) r[i] =
                        arguments[i +
                        t];
                switch (t) {
                    case 0:
                        return e
                            .call(
                                this,
                                r);
                    case 1:
                        return e
                            .call(
                                this,
                                arguments[
                                0
                                ],
                                r);
                    case 2:
                        return e
                            .call(
                                this,
                                arguments[
                                0
                                ],
                                arguments[
                                1
                                ],
                                r)
                }
                var s = Array(t +
                    1);
                for (i = 0; i <
                    t; i++) s[i] =
                        arguments[i];
                return s[t] = r, e
                    .apply(this, s)
            }
    }

    function O_(e) {
        if (!nl(e)) return {};
        if (XM) return XM(e);
        qh.prototype = e;
        var t = new qh;
        return qh.prototype = null,
            t
    }

    function tv(e) {
        return function (t) {
            return t == null ?
                void 0 : t[e]
        }
    }

    function Kc(e, t) {
        return e != null && v_.call(
            e, t)
    }

    function nv(e, t) {
        for (var n = t.length, r =
            0; r < n; r++) {
            if (e == null) return;
            e = e[t[r]]
        }
        return n ? e : void 0
    }
    var C_ = Math.pow(2, 53) - 1,
        za = tv("length");

    function ps(e) {
        var t = za(e);
        return typeof t ==
            "number" && t >= 0 &&
            t <= C_
    }

    function el(e, t, n) {
        t = kd(t, n);
        var r, i;
        if (ps(e))
            for (r = 0, i = e
                .length; r < i; r++)
                t(e[r], r, e);
        else {
            var s = bi(e);
            for (r = 0, i = s
                .length; r < i; r++)
                t(e[s[r]], s[r], e)
        }
        return e
    }

    function zd(e, t, n) {
        t = io(t, n);
        for (var r = !ps(e) && bi(
            e), i = (r || e)
                .length, s = Array(
                    i), o = 0; o <
            i; o++) {
            var a = r ? r[o] : o;
            s[o] = t(e[a], a, e)
        }
        return s
    }

    function rv(e) {
        var t = function (n, r, i,
            s) {
            var o = !ps(n) &&
                bi(n),
                a = (o || n)
                    .length,
                u = e > 0 ? 0 :
                    a - 1;
            for (s || (i = n[o ?
                o[u] : u
            ], u +=
                e); u >=
                0 && u < a; u +=
                e) {
                var c = o ? o[
                    u] : u;
                i = r(i, n[c],
                    c, n)
            }
            return i
        };
        return function (n, r, i,
            s) {
            var o = arguments
                .length >= 3;
            return t(n, kd(r, s,
                4), i,
                o)
        }
    }
    var OU = rv(1),
        CU = rv(-1);

    function R_(e, t, n) {
        var r = [];
        return t = io(t, n), el(e,
            function (i, s, o) {
                t(i, s, o) && r
                    .push(i)
            }), r
    }

    function RU(e, t, n) {
        t = io(t, n);
        for (var r = !ps(e) && bi(
            e), i = (r || e)
                .length, s = 0; s <
            i; s++) {
            var o = r ? r[s] : s;
            if (!t(e[o], o, e))
                return !1
        }
        return !0
    }

    function NU(e, t, n) {
        t = io(t, n);
        for (var r = !ps(e) && bi(
            e), i = (r || e)
                .length, s = 0; s <
            i; s++) {
            var o = r ? r[s] : s;
            if (t(e[o], o, e))
                return !0
        }
        return !1
    }

    function Qc(e, t, n, r) {
        return ps(e) || (e = Lp(e)),
            (typeof n != "number" ||
                r) && (n = 0), V_(e,
                    t, n) >= 0
    }
    var AU = ls(function (e, t, n) {
        var r, i;
        return fa(t) ? i =
            t : tl(t) && (
                r = t.slice(
                    0, -1),
                t = t[t
                    .length -
                1]), zd(
                    e,
                    function (
                        s) {
                        var o =
                            i;
                        if (!
                            o) {
                            if (r &&
                                r
                                    .length &&
                                (s = nv(s,
                                    r
                                )),
                                s ==
                                null
                            )
                                return;
                            o = s[
                                t]
                        }
                        return o ==
                            null ?
                            o :
                            o
                                .apply(
                                    s,
                                    n
                                )
                    })
    });

    function iv(e, t) {
        return zd(e, pv(t))
    }

    function N_(e, t, n) {
        var r = -1 / 0,
            i = -1 / 0,
            s, o;
        if (t == null || typeof t ==
            "number" && typeof e[
            0] != "object" && e !=
            null) {
            e = ps(e) ? e : Lp(e);
            for (var a = 0, u = e
                .length; a <
                u; a++) s = e[a],
                    s != null && s >
                    r && (r = s)
        } else t = io(t, n), el(e,
            function (c, l, p) {
                o = t(c, l, p),
                    (o > i ||
                        o === -
                        1 / 0 &&
                        r === -
                        1 / 0
                    ) && (
                        r = c,
                        i = o)
            });
        return r
    }

    function _U(e, t, n) {
        var r = 1 / 0,
            i = 1 / 0,
            s, o;
        if (t == null || typeof t ==
            "number" && typeof e[
            0] != "object" && e !=
            null) {
            e = ps(e) ? e : Lp(e);
            for (var a = 0, u = e
                .length; a <
                u; a++) s = e[a],
                    s != null && s <
                    r && (r = s)
        } else t = io(t, n), el(e,
            function (c, l, p) {
                o = t(c, l, p),
                    (o < i ||
                        o ===
                        1 / 0 &&
                        r ===
                        1 / 0
                    ) && (
                        r = c,
                        i = o)
            });
        return r
    }

    function LU(e) {
        return A_(e, 1 / 0)
    }

    function A_(e, t, n) {
        if (t == null || n)
            return ps(e) || (e = Lp(
                e)), e[WM(e
                    .length - 1
                )];
        var r = ps(e) ? Y_(e) : Lp(
            e),
            i = za(r);
        t = Math.max(Math.min(t, i),
            0);
        for (var s = i - 1, o =
            0; o < t; o++) {
            var a = WM(o, s),
                u = r[o];
            r[o] = r[a], r[a] = u
        }
        return r.slice(0, t)
    }

    function wU(e, t, n) {
        var r = 0;
        return t = io(t, n), iv(zd(
            e,
            function (i, s,
                o) {
                return {
                    value: i,
                    index: r++,
                    criteria: t(
                        i,
                        s,
                        o
                    )
                }
            }).sort(
                function (i, s) {
                    var o = i
                        .criteria,
                        a = s
                            .criteria;
                    if (o !==
                        a) {
                        if (o >
                            a ||
                            o ===
                            void 0
                        )
                            return 1;
                        if (o <
                            a ||
                            a ===
                            void 0
                        )
                            return -
                                1
                    }
                    return i
                        .index -
                        s.index
                }), "value")
    }

    function Hd(e, t) {
        return function (n, r, i) {
            var s = t ? [
                [],
                []
            ] : {};
            return r = io(r, i),
                el(n, function (
                    o, a) {
                    var u =
                        r(o, a,
                            n
                        );
                    e(s, o,
                        u)
                }), s
        }
    }
    var FU = Hd(function (e, t, n) {
        Kc(e, n) ? e[n]
            .push(t) : e[
            n] = [t]
    }),
        VU = Hd(function (e, t, n) {
            e[n] = t
        }),
        BU = Hd(function (e, t, n) {
            Kc(e, n) ? e[n]++ :
                e[n] = 1
        });

    function GU(e) {
        return e == null ? 0 : ps(
            e) ? e.length : bi(e)
            .length
    }
    var kU = Hd(function (e, t, n) {
        e[n ? 0 : 1].push(t)
    }, !0);

    function Xu(e, t, n, r) {
        r = r || [];
        for (var i = r.length, s =
            0, o = za(e); s <
            o; s++) {
            var a = e[s];
            if (ps(a) && (tl(a) ||
                Bd(a)))
                if (t)
                    for (var u = 0,
                        c = a
                            .length; u <
                        c;) r[i++] =
                            a[u++];
                else Xu(a, t, n, r),
                    i = r.length;
            else n || (r[i++] = a)
        }
        return r
    }

    function zU(e, t) {
        return Xu(e, t, !1)
    }
    var HU = ls(function (e, t) {
        return Xh(e, t)
    });

    function wp(e, t, n, r) {
        eL(t) || (r = n, n = t,
            t = !1), n !=
            null && (n = io(n, r));
        for (var i = [], s = [], o =
            0, a = za(e); o <
            a; o++) {
            var u = e[o],
                c = n ? n(u, o, e) :
                    u;
            t && !n ? ((!o || s !==
                c) && i
                    .push(u), s = c
            ) : n ? Qc(s,
                c) || (s.push(c), i
                    .push(u)) : Qc(
                        i, u) || i.push(
                            u)
        }
        return i
    }
    var UU = ls(function (e) {
        return wp(Xu(e, !0,
            !0))
    });
    var Xh = ls(function (e, t) {
        return t = Xu(t, !0,
            !0), R_(e,
                function (
                    n) {
                    return !
                        Qc(t,
                            n
                        )
                })
    });

    function __(e) {
        for (var t = e && N_(e, za)
            .length || 0, n =
                Array(t), r = 0; r <
            t; r++) n[r] = iv(e, r);
        return n
    }
    var qU = ls(__);

    function sv(e) {
        return function (t, n, r) {
            n = io(n, r);
            for (var i = za(t),
                s = e > 0 ?
                    0 : i -
                    1; s >= 0 &&
                s < i; s += e)
                if (n(t[s], s,
                    t))
                    return s;
            return -1
        }
    }
    var L_ = sv(1),
        w_ = sv(-1);

    function F_(e, t, n, r) {
        n = io(n, r, 1);
        for (var i = n(t), s = 0,
            o = za(e); s < o;) {
            var a = Math.floor((s +
                o) / 2);
            n(e[a]) < i ? s = a +
                1 : o = a
        }
        return s
    }

    function ov(e, t, n) {
        return function (r, i, s) {
            var o = 0,
                a = za(r);
            if (typeof s ==
                "number") e >
                    0 ? o = s >= 0 ?
                        s : Math.max(s +
                            a, o) : a =
                s >= 0 ? Math
                    .min(s + 1, a) :
                    s + a + 1;
            else if (n && s &&
                a) return s = n(
                    r, i),
                    r[s] === i ?
                        s : -1;
            if (i !== i)
                return s = t(JM
                    .call(r,
                        o, a
                    ),
                    K_),
                    s >= 0 ? s +
                        o : -1;
            for (s = e > 0 ? o :
                a - 1; s >= 0 &&
                s < a; s += e)
                if (r[s] === i)
                    return s;
            return -1
        }
    }
    var V_ = ov(1, L_, F_),
        $U = ov(-1, w_);

    function YU(e, t) {
        if (t == null || t < 1)
            return [];
        for (var n = [], r = 0, i =
            e.length; r < i;) n
                .push(JM.call(e, r, r +=
                    t));
        return n
    }

    function av(e, t, n, r, i) {
        if (!(r instanceof t))
            return e.apply(n, i);
        var s = O_(e.prototype),
            o = e.apply(s, i);
        return nl(o) ? o : s
    }
    var B_ = ls(function (e, t, n) {
        if (!fa(e))
            throw new TypeError(
                "Bind must be called on a function"
            );
        var r = ls(function (
            i) {
            return av(
                e,
                r,
                t,
                this,
                n
                    .concat(
                        i
                    )
            )
        });
        return r
    }),
        Ud = ls(function (e, t) {
            var n = Ud
                .placeholder,
                r = function () {
                    for (var i =
                        0,
                        s =
                            t
                                .length,
                        o =
                            Array(
                                s
                            ),
                        a =
                            0; a <
                        s; a++)
                        o[a] =
                            t[a] ===
                                n ?
                                arguments[
                                i++
                                ] :
                                t[a];
                    for (; i <
                        arguments
                            .length;
                    ) o
                        .push(
                            arguments[
                            i++
                            ]
                        );
                    return av(e,
                        r,
                        this,
                        this,
                        o)
                };
            return r
        });
    Ud.placeholder = gr;
    var XU = ls(function (e, t) {
        t = Xu(t, !1, !1);
        var n = t.length;
        if (n < 1)
            throw new Error(
                "bindAll must be passed function names"
            );
        for (; n--;) {
            var r = t[n];
            e[r] = B_(e[r],
                e)
        }
    });
    var uv = ls(function (e, t, n) {
        return setTimeout(
            function () {
                return e
                    .apply(
                        null,
                        n
                    )
            }, t)
    }),
        ZU = Ud(uv, gr, 1);

    function WU(e, t, n) {
        var r, i, s, o, a = 0;
        n || (n = {});
        var u = function () {
            a = n.leading === !
                1 ? 0 : jM(),
                r = null, o = e
                    .apply(i, s),
                r || (i = s =
                    null)
        },
            c = function () {
                var l = jM();
                !a && n.leading ===
                    !1 && (a = l);
                var p = t - (l - a);
                return i = this, s =
                    arguments, p <=
                        0 || p > t ? (
                        r && (
                            clearTimeout(
                                r),
                            r = null
                        ), a =
                        l, o = e
                            .apply(i,
                                s), r || (
                                    i = s =
                                    null)) :
                        !r && n
                            .trailing !== !
                        1 && (r =
                            setTimeout(
                                u, p)),
                    o
            };
        return c.cancel =
            function () {
                clearTimeout(r), a =
                    0, r = i = s =
                    null
            }, c
    }

    function jU(e, t, n) {
        var r, i, s = function (a,
            u) {
            r = null, u && (i =
                e.apply(a,
                    u))
        },
            o = ls(function (a) {
                if (r &&
                    clearTimeout(
                        r), n) {
                    var u = !r;
                    r = setTimeout(
                        s, t
                    ),
                        u && (
                            i =
                            e
                                .apply(
                                    this,
                                    a
                                )
                        )
                } else r = uv(s,
                    t, this,
                    a);
                return i
            });
        return o.cancel =
            function () {
                clearTimeout(r), r =
                    null
            }, o
    }

    function G_(e) {
        return function () {
            return !e.apply(
                this,
                arguments)
        }
    }

    function k_(e, t) {
        var n;
        return function () {
            return --e > 0 && (
                n = t.apply(
                    this,
                    arguments
                )), e <=
                1 && (t = null),
                n
        }
    }
    var JU = Ud(k_, 2),
        cv = !{
            toString: null
        }.propertyIsEnumerable(
            "toString"),
        ZM = ["valueOf",
            "isPrototypeOf",
            "toString",
            "propertyIsEnumerable",
            "hasOwnProperty",
            "toLocaleString"
        ];

    function lv(e, t) {
        var n = ZM.length,
            r = e.constructor,
            i = fa(r) && r
                .prototype || Yh,
            s = "constructor";
        for (Kc(e, s) && !Qc(t,
            s) && t.push(s); n--;)
            s = ZM[n], s in e && e[
                s] !== i[s] && !Qc(
                    t, s) && t.push(s)
    }

    function bi(e) {
        if (!nl(e)) return [];
        if (YM) return YM(e);
        var t = [];
        for (var n in e) Kc(e, n) &&
            t.push(n);
        return cv && lv(e, t), t
    }

    function Zh(e) {
        if (!nl(e)) return [];
        var t = [];
        for (var n in e) t.push(n);
        return cv && lv(e, t), t
    }

    function Lp(e) {
        for (var t = bi(e), n = t
            .length, r = Array(
                n), i = 0; i <
            n; i++) r[i] = e[t[i]];
        return r
    }

    function z_(e) {
        for (var t = {}, n = bi(e),
            r = 0, i = n
                .length; r < i; r++)
            t[e[n[r]]] = n[r];
        return t
    }

    function Wh(e, t) {
        return function (n) {
            var r = arguments
                .length;
            if (t && (n =
                Object(n)),
                r < 2 || n ==
                null) return n;
            for (var i = 1; i <
                r; i++)
                for (var s =
                    arguments[
                    i],
                    o = e(
                        s), a =
                        o
                            .length,
                    u =
                        0; u <
                    a; u++) {
                    var c = o[
                        u];
                    (!t || n[
                        c] ===
                        void 0
                    ) && (n[
                        c] =
                        s[c])
                }
            return n
        }
    }
    var H_ = Wh(Zh),
        U_ = Wh(bi);

    function q_(e, t, n) {
        return t in n
    }
    var $_ = ls(function (e, t) {
        var n = {},
            r = t[0];
        if (e == null)
            return n;
        fa(r) ? (t.length >
            1 && (r =
                kd(r, t[
                    1])
            ), t =
            Zh(e)) : (
            r = q_, t =
            Xu(t, !1, !
                1), e =
            Object(e));
        for (var i = 0, s =
            t
                .length; i <
            s; i++) {
            var o = t[i],
                a = e[o];
            r(a, o, e) && (
                n[o] = a
            )
        }
        return n
    }),
        QU = ls(function (e, t) {
            var n = t[0],
                r;
            return fa(n) ? (n =
                G_(n), t
                    .length >
                1 && (r = t[
                    1])) : (
                t = zd(Xu(t,
                    !1,
                    !1),
                    String),
                n =
                function (i,
                    s) {
                    return !
                        Qc(t,
                            s
                        )
                }), $_(e, n,
                    r)
        }),
        KU = Wh(Zh, !0);

    function Y_(e) {
        return nl(e) ? tl(e) ? e
            .slice() : H_({}, e) : e
    }

    function X_(e, t) {
        var n = bi(t),
            r = n.length;
        if (e == null) return !r;
        for (var i = Object(e), s =
            0; s < r; s++) {
            var o = n[s];
            if (t[o] !== i[o] || !(
                o in i))
                return !1
        }
        return !0
    }

    function $h(e, t, n, r) {
        if (e === t) return e !==
            0 || 1 / e === 1 / t;
        if (e == null || t == null)
            return !1;
        if (e !== e) return t !== t;
        var i = typeof e;
        return i !== "function" &&
            i !== "object" &&
            typeof t != "object" ? !
        1 : Z_(e, t, n, r)
    }

    function Z_(e, t, n, r) {
        e instanceof gr && (e = e
            ._wrapped),
            t instanceof gr && (t =
                t._wrapped);
        var i = Vd.call(e);
        if (i !== Vd.call(t))
            return !1;
        switch (i) {
            case "[object RegExp]":
            case "[object String]":
                return "" + e ==
                    "" + t;
            case "[object Number]":
                return +e != +e ? +
                    t != +t : +e ==
                        0 ? 1 / +e ===
                1 / t : +e == +
                t;
            case "[object Date]":
            case "[object Boolean]":
                return +e == +t;
            case "[object Symbol]":
                return $M.valueOf
                    .call(e) === $M
                        .valueOf.call(t)
        }
        var s = i ===
            "[object Array]";
        if (!s) {
            if (typeof e !=
                "object" ||
                typeof t != "object"
            ) return !1;
            var o = e.constructor,
                a = t.constructor;
            if (o !== a && !(fa(
                o) &&
                o instanceof o &&
                fa(a) &&
                a instanceof a
            ) &&
                "constructor" in
                e &&
                "constructor" in t)
                return !1
        }
        n = n || [], r = r || [];
        for (var u = n.length; u--;)
            if (n[u] === e)
                return r[u] === t;
        if (n.push(e), r.push(t),
            s) {
            if (u = e.length, u !==
                t.length) return !1;
            for (; u--;)
                if (!$h(e[u], t[u],
                    n, r))
                    return !1
        } else {
            var c = bi(e),
                l;
            if (u = c.length, bi(t)
                .length !== u)
                return !1;
            for (; u--;)
                if (l = c[u], !(Kc(
                    t, l) &&
                    $h(e[l], t[
                        l],
                        n, r)))
                    return !1
        }
        return n.pop(), r.pop(), !0
    }

    function _o(e, t) {
        return $h(e, t)
    }

    function e8(e) {
        return e == null ? !0 : ps(
            e) && (tl(e) || W_(
                e) || Bd(e)) ? e
                    .length === 0 : bi(e)
                        .length === 0
    }

    function fs(e) {
        return function (t) {
            return Vd.call(
                t) ===
                "[object " + e +
                "]"
        }
    }
    var tl = D_ || fs("Array");

    function nl(e) {
        var t = typeof e;
        return t === "function" ||
            t === "object" && !!e
    }
    var Bd = fs("Arguments"),
        fa = fs("Function"),
        W_ = fs("String"),
        j_ = fs("Number"),
        t8 = fs("Date"),
        n8 = fs("RegExp"),
        r8 = fs("Error"),
        J_ = fs("Symbol"),
        i8 = fs("Map"),
        s8 = fs("WeakMap"),
        o8 = fs("Set"),
        a8 = fs("WeakSet");
    (function () {
        Bd(arguments) || (Bd =
            function (e) {
                return Kc(e,
                    "callee"
                )
            })
    })();
    var Q_ = Fd.document && Fd
        .document.childNodes;
    typeof /./ != "function" &&
        typeof Int8Array != "object" &&
        typeof Q_ != "function" && (
            fa = function (e) {
                return typeof e ==
                    "function" || !1
            });

    function u8(e) {
        return !J_(e) && S_(e) && !
            QM(parseFloat(e))
    }

    function K_(e) {
        return j_(e) && QM(e)
    }

    function eL(e) {
        return e === !0 || e === !
            1 || Vd.call(e) ===
            "[object Boolean]"
    }

    function tL(e) {
        return e
    }

    function pv(e) {
        return tl(e) ? function (t) {
            return nv(t, e)
        } : tv(e)
    }

    function nL(e) {
        return e = U_({}, e),
            function (t) {
                return X_(t, e)
            }
    }

    function WM(e, t) {
        return t == null && (t = e,
            e = 0), e + Math
                .floor(Math.random() * (
                    t - e + 1))
    }
    var jM = Date.now ||
        function () {
            return new Date()
                .getTime()
        },
        fv = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#x27;",
            "`": "&#x60;"
        },
        rL = z_(fv);

    function dv(e) {
        var t = function (s) {
            return e[s]
        },
            n = "(?:" + bi(e).join(
                "|") + ")",
            r = RegExp(n),
            i = RegExp(n, "g");
        return function (s) {
            return s = s ==
                null ? "" : "" +
            s, r.test(s) ? s
                .replace(i, t) :
                    s
        }
    }
    var mv = dv(fv),
        c8 = dv(rL);
    var iL = 0;

    function l8(e) {
        var t = ++iL + "";
        return e ? e + t : t
    }
    var p8 = gr.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    function yv(e, t) {
        return e._chain ? gr(t)
            .chain() : t
    }
    el(["pop", "push", "reverse",
        "shift", "sort",
        "splice", "unshift"
    ], function (e) {
        var t = Gd[e];
        gr.prototype[e] =
            function () {
                var n = this
                    ._wrapped;
                return t
                    .apply(
                        n,
                        arguments
                    ), (
                        e ===
                        "shift" ||
                        e ===
                        "splice"
                    ) &&
                    n
                        .length ===
                    0 &&
                    delete n[
                    0],
                    yv(this,
                        n)
            }
    });
    el(["concat", "join", "slice"],
        function (e) {
            var t = Gd[e];
            gr.prototype[e] =
                function () {
                    return yv(
                        this,
                        t
                            .apply(
                                this
                                    ._wrapped,
                                arguments
                            )
                    )
                }
        });
    gr.prototype.value =
        function () {
            return this._wrapped
        };
    gr.prototype.valueOf = gr
        .prototype.toJSON = gr
            .prototype.value;
    gr.prototype.toString =
        function () {
            return String(this
                ._wrapped)
        };

    function jh(e, t = e, n = !1) {
        if (isNaN(e) || !isFinite(
            e)) return {
                string: "undefined",
                latex: "undefined",
                value: e
            };
        if (e === 0) return {
            string: "0",
            latex: "0",
            value: e
        };
        Math.abs(e) > Math.abs(t) &&
            (t = e);
        let r = la(e / Math.PI, 24),
            i, s, o, a, u, c;
        if (gv(t) && Li(r.n / r.d *
            Math.PI, e, 3))
            return r.n === 0 ? (i =
                "0", a = "0") :
                r.n === 1 ? (i =
                    "", a = "\\pi"
                ) : r.n === -1 ?
                    (i = "-", a =
                        "-\\pi") : (i =
                            r.n.toString() +
                            "", a = r.n
                                .toString() +
                            "\\pi"), r.d ===
                                1 ? (s = "", u =
                                    "") : (s = "/" + r.d
                                        .toString(), u =
                                        r.d.toString()),
                o = i + s, u ===
                    "" ? c = a : a[
                        0] === "-" ? c =
                `-\\frac{${a.slice(1)}}{${u}}` :
                    c =
                    `\\frac{${a}}{${u}}`, {
                string: o,
                latex: c,
                value: r.n / r
                    .d * Math.PI
            };
        if (!n && gv(t) || uL(t))
            return o = aL(hv(e
                .toFixed(qd(
                    t)))), {
                string: o,
                latex: o,
                value: parseFloat(
                    o)
            };
        {
            let p = Jh(e
                .toExponential(
                    qd(t / e)))
                .split("e"),
                f = p[0] === "1" &&
                    n ? "10" : p[0] +
                "\xD710",
                m = p[1].replace(
                    "+", "");
            return o = Jh(e
                .toExponential(
                    qd(t / e)))
                .replace("+", ""),
                c =
                `${p[0]}\\times10^{${m}}`, {
                string: o,
                latex: c,
                mantissa: f,
                superscript: m,
                value: parseFloat(
                    o)
            }
        }
    }

    function sL(e, t, n, r) {
        let i = jh(e, t),
            s = jh(r(i.value), n);
        return [i, s]
    }
    var oL = /\.?0+$/;

    function hv(e) {
        return e.indexOf(".") === -
            1 ? e : e.replace(oL,
                "")
    }

    function Jh(e) {
        let t = /\.?0+e/;
        return e.replace(t, "e")
    }

    function aL(e) {
        return e === "-0" ? "0" : e
    }

    function gv(e) {
        return e = Math.abs(e),
            1e-4 < e && e < 1e7
    }

    function uL(e) {
        return e = Math.abs(e),
            .001 < e && e < 1e4
    }

    function qd(e) {
        return e = Math.abs(e), e =
            Math.max(e, 1e-16), Math
                .max(3, Math.floor(4.5 -
                    Math.log(e) /
                    Math.LN10))
    }

    function cL(e) {
        return Math.abs(e) >=
            1e-20 ? parseFloat(e
                .toFixed(qd(e))) : e
    }

    function bv(e) {
        return 1e6 / Math.sqrt(Math
            .abs(e))
    }

    function xv(e) {
        let t = bv(e);
        if (t < 1 || t > 1e12)
            return !1;
        let {
            n,
            d: r
        } = la(e, t);
        return r === 1 ? !1 : e ===
            e + Math.pow(2, -3) *
            Math.abs(n / r - e)
    }

    function $d(e, t) {
        if (t = t || {}, isNaN(e) ||
            !isFinite(e)) return {
                type: "undefined"
            };
        if (e === 0 || t
            .zeroCutoff && Math.abs(
                e) < t.zeroCutoff)
            return {
                type: "decimal",
                value: "0"
            };
        let n = t.smallCutoff ||
            .001,
            r = t.bigCutoff || 1e6,
            i = t.digits || 10,
            o = Jh(e.toExponential(
                i - 2)).match(
                    /([\d\.\-]+)e\+?([\d\-]+)/
                );
        if (!o) return {
            type: "undefined"
        };
        let a = parseInt(o[2],
            10) >= i;
        if (xv(e) && t
            .displayAsFraction) {
            let c = la(e, bv(e));
            return {
                type: "fraction",
                numerator: c.n
                    .toString(),
                denominator: c.d
                    .toString()
            }
        } else {
            if (Math.abs(e) > r ||
                Math.abs(e) < n || a
            ) return {
                type: "scientific",
                mantissa: o[1],
                exponent: o[2]
            };
            {
                let c = hv(e
                    .toPrecision(
                        i));
                return e !== Number(
                    c) && t
                        .addEllipses &&
                    (c += "..."), {
                    type: "decimal",
                    value: c
                }
            }
        }
    }

    function lL(e, t) {
        let n = $d(e, t);
        switch (n.type) {
            case "undefined":
                return "undefined";
            case "decimal":
                return n.value;
            case "scientific":
                return n.mantissa +
                    "<span class='dcg-cross'>\xD7</span>10<sup>" +
                    n.exponent +
                    "</sup>";
            case "fraction":
                return n
                    .denominator ===
                    "1" ? n
                    .numerator :
                    `${n.numerator}/${n.denominator}`;
            default:
                return n
        }
    }

    function Yd(e, t) {
        let n = $d(e, t);
        switch (n.type) {
            case "undefined":
                return "undefined";
            case "decimal":
                return n.value;
            case "scientific":
                return n.mantissa +
                    " * 10^" + n
                        .exponent;
            case "fraction":
                return n
                    .denominator ===
                    "1" ? n
                    .numerator :
                    `${n.numerator}/${n.denominator}`;
            default:
                return n
        }
    }

    function Qh(e, t) {
        let n = $d(e, t);
        switch (n.type) {
            case "undefined":
                return "undefined";
            case "decimal":
                return n.value;
            case "scientific":
                return n.mantissa +
                    "\\times10^{" +
                    n.exponent +
                    "}";
            case "fraction":
                return n
                    .denominator ===
                    "1" ? n
                    .numerator : n
                        .numerator[
                        0] === "-" ?
                    `-\\frac{${n.numerator.slice(1)}}{${n.denominator}}` :
                    `\\frac{${n.numerator}}{${n.denominator}}`;
            default:
                return n
        }
    }

    function X(e) {
        if (e.startsWith(
            "_base_case")) {
            let [n, r, i] = e.split(
                ":"), s = [];
            for (let o of i.split(
                ",")) {
                let a = parseFloat(
                    o);
                isNaN(a) ? s.push(X(
                    o)) : s
                        .push(Yd(a))
            }
            return `${X(r)}(${s.join(",")})`
        }
        e = e.replace("\\", "");
        let t = {
            alpha: "",
            beta: "",
            gamma: "",
            delta: "",
            epsilon: "",
            varepsilon: "",
            zeta: "",
            eta: "",
            theta: "",
            vartheta: "",
            iota: "",
            kappa: "",
            varkappa: "",
            lambda: "",
            mu: "",
            xi: "",
            pi: "",
            varpi: "",
            rho: "",
            varrho: "",
            sigma: "",
            varsigma: "",
            tau: "",
            phi: "",
            varphi: "",
            chi: "",
            psi: "",
            omega: "",
            Gamma: "",
            Delta: "",
            Theta: "",
            Lambda: "",
            Xi: "",
            Pi: "",
            Sigma: "",
            Phi: "",
            Psi: "",
            Omega: "",
            div: "\xF7",
            cdot: "",
            times: "\xD7",
            lt: "<",
            gt: ">",
            le: "",
            ge: "",
            sim: "",
            ldots: "",
            prime: "",
            approx: "",
            to: "",
            "->": ""
        };
        return t.hasOwnProperty(e) ?
            t[e] : e
    }

    function pL(e) {
        if (!e) return "";
        let t = ur(e[0]);
        return e[1] !== void 0 && (
            t += "\\left[" + e[
            1] + "\\right]"
        ), t
    }

    function ur(e) {
        let t = e.match(
            /^\$(\d+)$/);
        if (t)
            return `\\token{${t[1]}}`;
        let n = e.split("_"),
            r = "";
        return n[0].length > 1 && (
            r += "\\"), r += n[
            0], n[1] && (r +=
                "_{" + n[1] + "}"),
            r
    }

    function fL(e) {
        if (!e) return "";
        let t = e.split("_");
        t[0] = X(t[0]);
        let n = t.map(mv);
        return n[1] && (n[1] =
            "<sub>" + n[1] +
            "</sub>"), n.join(
                "")
    }

    function Lo(e) {
        let t = e.match(
            /\\token\{(\d+)\}/);
        return t ? `$${t[1]}` : (e =
            e.replace(
                /\\operatorname\{(.*)\}/,
                "$1"), e
                    .replace(/[{}\\]/g,
                        ""))
    }

    function wo(e) {
        return e.replace(
            /^(\\ |\s|\\space(?![a-zA-Z]))+/,
            "").replace(
                /(\\ |\s|\\space(?![a-zA-Z]))+$/,
                "")
    }

    function dL(e) {
        return e.replace(
            /\\ |\\space(?![a-zA-Z])/g,
            "")
    }
    var ze = class extends j {
        constructor(t) {
            super([]), this
                ._symbol =
                Lo(t), this
                    ._errorSymbol =
                this
                    ._symbol,
                this
                    .addDependency(
                        this
                            ._symbol
                    )
        }
        setInputSpan(t) {
            super
                .setInputSpan(
                    t), this
                        ._errorSymbol =
                Lo(this
                    .getInputString()
                )
        }
        getInputSpan() {
            return this
                ._inputSpan ===
                void 0 ? yi(
                    this
                        ._symbol,
                    0, this
                        ._symbol
                    .length
                ) : this
                ._inputSpan
        }
    };

    function mL(e) {
        switch (e) {
            case "default":
            case "trig":
            case "inverseTrig":
            case "trig2":
            case "never-broadcast":
                return [T];
            case "reducer":
                return [se];
            case "doubleReducer":
                return [se, se];
            case "parameterizedReducer":
                return [se, T];
            case "color":
                return [T, T, T]
        }
    }

    function yL(e) {
        switch (e) {
            case "default":
            case "trig":
            case "inverseTrig":
            case "trig2":
            case "doubleReducer":
            case "color":
            case "never-broadcast":
                return !1;
            case "reducer":
            case "parameterizedReducer":
                return !0
        }
    }

    function gL(e, t, n) {
        return e === "reducer" ? 1 /
            0 : t + n
    }

    function _(e, t, n) {
        var m, g, d, y, h;
        n === void 0 && (n = {});
        let r = (m = n.tag) !=
            null ? m : "default",
            i = (g = n
                .argumentTypes) !=
                null ? g : mL(r),
            s = n.defaultArguments ?
                n.defaultArguments
                    .length : 0,
            o = i.length - s,
            a = gL(r, o, s),
            u = (d = n
                .allowDotCall) != null ?
                d : yL(r),
            c = (y = n.noPeel) !=
                null ? y : !1,
            {
                defaultArguments: l,
                minArityExampleArgs: p,
                maxArityExampleArgs: f
            } = n;
        return {
            module: e,
            symbol: t,
            argumentTypes: i,
            defaultArguments: l,
            returnType: (h = n
                .returnType) !=
                null ? h : T,
            tag: r,
            minArity: o,
            maxArity: a,
            allowDotCall: u,
            noPeel: c,
            minArityExampleArgs: p,
            maxArityExampleArgs: f
        }
    }

    function nb(e) {
        if (!En(e)) throw new Error(
            "Programming Error: numeric constants should be rational"
        );
        return {
            type: 1,
            valueType: T,
            value: e
        }
    }
    var Zu = nb(De(0, 1)),
        Wu = nb(De(1, 1)),
        Zd = nb(De(1, 2));

    function Ha(e) {
        let t;
        return e in bn && (t = bn[e]
            .tag), t ===
                "trig" || t ===
                "trig2" || t ===
                "inverseTrig" ? !0 :
                e === "angle" || e ===
                "angles" || e ===
                "directedangle" || e ===
                "directedangles" ||
                e === "rotate"
    }
    var bn = {
        sin: _("BuiltIn",
            "sin", {
            tag: "trig"
        }),
        cos: _("BuiltIn",
            "cos", {
            tag: "trig"
        }),
        tan: _("BuiltIn",
            "tan", {
            tag: "trig"
        }),
        cot: _("BuiltIn",
            "cot", {
            tag: "trig"
        }),
        sec: _("BuiltIn",
            "sec", {
            tag: "trig"
        }),
        csc: _("BuiltIn",
            "csc", {
            tag: "trig"
        }),
        arcsin: _("Math",
            "asin", {
            tag: "inverseTrig"
        }),
        arccos: _("Math",
            "acos", {
            tag: "inverseTrig"
        }),
        arctan: _("Math",
            "atan2", {
            argumentTypes: [
                T, T
            ],
            defaultArguments: [
                Wu
            ],
            tag: "inverseTrig"
        }),
        arccot: _("BuiltIn",
            "acot", {
            tag: "inverseTrig"
        }),
        arcsec: _("BuiltIn",
            "asec", {
            tag: "inverseTrig"
        }),
        arccsc: _("BuiltIn",
            "acsc", {
            tag: "inverseTrig"
        }),
        sinh: _("BuiltIn",
            "sinh"),
        cosh: _("BuiltIn",
            "cosh"),
        tanh: _("BuiltIn",
            "tanh"),
        coth: _("BuiltIn",
            "coth"),
        sech: _("BuiltIn",
            "sech"),
        csch: _("BuiltIn",
            "csch"),
        arcsinh: _("BuiltIn",
            "asinh"),
        arccosh: _("BuiltIn",
            "acosh"),
        arctanh: _("BuiltIn",
            "atanh"),
        arccoth: _("BuiltIn",
            "acoth"),
        arcsech: _("BuiltIn",
            "asech"),
        arccsch: _("BuiltIn",
            "acsch"),
        sqrt: _("Math", "sqrt"),
        rtxsqpone: _("BuiltIn",
            "sqrtxsqp1"),
        rtxsqmone: _("BuiltIn",
            "sqrtxsqm1"),
        nthroot: _("BuiltIn",
            "nthroot", {
            argumentTypes: [
                T, T
            ]
        }),
        hypot: _("BuiltIn",
            "hypot", {
            argumentTypes: [
                T, T
            ]
        }),
        log: _("BuiltIn",
            "common_log"),
        logbase: _("BuiltIn",
            "log_base", {
            argumentTypes: [
                T, T
            ]
        }),
        ln: _("BuiltIn", "log"),
        exp: _("Math", "exp"),
        floor: _("Math",
            "floor"),
        ceil: _("Math", "ceil"),
        round: _("Math",
            "round"),
        abs: _("Math", "abs"),
        sign: _("BuiltIn",
            "sign"),
        mod: _("BuiltIn",
            "mod", {
            argumentTypes: [
                T, T
            ]
        }),
        nCr: _("BuiltIn",
            "nCr", {
            argumentTypes: [
                T, T
            ]
        }),
        nPr: _("BuiltIn",
            "nPr", {
            argumentTypes: [
                T, T
            ]
        }),
        factorial: _("BuiltIn",
            "factorial"),
        polyGamma: _("BuiltIn",
            "polyGamma", {
            argumentTypes: [
                T, T
            ]
        }),
        lcm: _("BuiltIn",
            "listLCM", {
            tag: "reducer"
        }),
        gcd: _("BuiltIn",
            "listGCD", {
            tag: "reducer"
        }),
        distance: _("BuiltIn",
            "distance", {
            argumentTypes: [
                R, R
            ]
        }),
        polygon: _("BuiltIn",
            "polygon", {
            tag: "reducer",
            argumentTypes: [
                Pt
            ],
            returnType: Be
        }),
        area: _("BuiltIn",
            "polygonArea", {
            argumentTypes: [
                Be
            ]
        }),
        perimeter: _("BuiltIn",
            "polygonPerimeter", {
            argumentTypes: [
                Be
            ]
        }),
        pointDet: _("BuiltIn",
            "pointDet", {
            argumentTypes: [
                R, R
            ]
        }),
        pointDot: _("BuiltIn",
            "pointDot", {
            argumentTypes: [
                R, R
            ]
        }),
        pointPerp: _("BuiltIn",
            "pointPerp", {
            argumentTypes: [
                R
            ],
            returnType: R
        }),
        segment: _("BuiltIn",
            "segment", {
            argumentTypes: [
                R, R
            ],
            returnType: Ie
        }),
        line: _("BuiltIn",
            "line", {
            argumentTypes: [
                R, R
            ],
            returnType: fe
        }),
        ray: _("BuiltIn",
            "ray", {
            argumentTypes: [
                R, R
            ],
            returnType: Le
        }),
        vector: _("BuiltIn",
            "vector", {
            argumentTypes: [
                R, R
            ],
            returnType: he
        }),
        vectorThreeD: _(
            "BuiltIn",
            "vectorThreeD", {
            argumentTypes: [
                V, V
            ],
            returnType: Se
        }),
        mathVector: _("BuiltIn",
            "mathVector", {
            argumentTypes: [
                R, R
            ],
            returnType: he
        }),
        mathVectorThreeD: _(
            "BuiltIn",
            "mathVectorThreeD", {
            argumentTypes: [
                V, V
            ],
            returnType: Se
        }),
        vectorDisplacementAsPoint: _(
            "BuiltIn",
            "vectorDisplacementAsPoint", {
            argumentTypes: [
                he
            ],
            returnType: R
        }),
        vectorThreeDDisplacementAsPoint: _(
            "BuiltIn",
            "vectorThreeDDisplacementAsPoint", {
            argumentTypes: [
                Se
            ],
            returnType: V
        }),
        basePointFromVector: _(
            "BuiltIn",
            "basePointFromVector", {
            argumentTypes: [
                he
            ],
            returnType: R
        }),
        basePointFromVectorThreeD: _(
            "BuiltIn",
            "basePointFromVectorThreeD", {
            argumentTypes: [
                Se
            ],
            returnType: V
        }),
        circle: _("BuiltIn",
            "circle", {
            argumentTypes: [
                R, T
            ],
            returnType: pe
        }),
        center: _("BuiltIn",
            "center", {
            argumentTypes: [
                pe
            ],
            returnType: R,
            allowDotCall:
                !0
        }),
        radius: _("BuiltIn",
            "radius", {
            argumentTypes: [
                pe
            ],
            returnType: T,
            allowDotCall:
                !0
        }),
        arc: _("BuiltIn",
            "arc", {
            argumentTypes: [
                R,
                R, R
            ],
            returnType: ce
        }),
        arcCenter: _("BuiltIn",
            "arcCenter", {
            argumentTypes: [
                ce
            ],
            returnType: R
        }),
        arcOmega: _("BuiltIn",
            "arcOmega", {
            argumentTypes: [
                ce
            ],
            returnType: T
        }),
        undirectedAngleMarker: _(
            "BuiltIn",
            "undirectedAngleMarker", {
            argumentTypes: [
                Ae
            ],
            returnType: Ge
        }),
        directedAngleMarker: _(
            "BuiltIn",
            "directedAngleMarker", {
            argumentTypes: [
                R,
                T,
                T, T
            ],
            returnType: Ae
        }),
        directedCoterminalAngle: _(
            "BuiltIn",
            "directedCoterminalAngle", {
            argumentTypes: [
                Ae
            ],
            returnType: Ae
        }),
        undirectedCoterminalAngle: _(
            "BuiltIn",
            "undirectedCoterminalAngle", {
            argumentTypes: [
                Ge
            ],
            returnType: Ge
        }),
        supplement: _("BuiltIn",
            "supplementAngle", {
            argumentTypes: [
                Ae
            ],
            returnType: Ae
        }),
        directedAngleMarkerRawDelta: _(
            "BuiltIn",
            "angleMarkerRawDelta", {
            argumentTypes: [
                Ae
            ],
            returnType: T
        }),
        undirectedAngleMarkerRawDelta: _(
            "BuiltIn",
            "angleMarkerRawDelta", {
            argumentTypes: [
                Ge
            ],
            returnType: T
        }),
        directedAngleMarkerMultiplier: _(
            "BuiltIn",
            "angleMarkerMultiplier", {
            argumentTypes: [
                Ae
            ],
            returnType: T
        }),
        undirectedAngleMarkerMultiplier: _(
            "BuiltIn",
            "angleMarkerMultiplier", {
            argumentTypes: [
                Ge
            ],
            returnType: T
        }),
        polygonInteriorUndirectedAngles: _(
            "BuiltIn",
            "polygonInteriorUndirectedAngles", {
            argumentTypes: [
                Be,
                T
            ],
            returnType: gn,
            allowDotCall:
                !0,
            tag: "never-broadcast"
        }),
        polygonInteriorDirectedAngles: _(
            "BuiltIn",
            "polygonInteriorDirectedAngles", {
            argumentTypes: [
                Be,
                T
            ],
            returnType: hn,
            allowDotCall:
                !0,
            tag: "never-broadcast"
        }),
        vertices: _("BuiltIn",
            "vertices", {
            argumentTypes: [
                Be
            ],
            returnType: Pt,
            allowDotCall:
                !0,
            tag: "never-broadcast"
        }),
        segments: _("BuiltIn",
            "polygonEdges", {
            argumentTypes: [
                Be
            ],
            returnType: Tn,
            allowDotCall:
                !0,
            tag: "never-broadcast"
        }),
        scaleTangentSegment: _(
            "BuiltIn",
            "scaleTangentSegment", {
            argumentTypes: [
                Ie,
                T
            ],
            returnType: Ie
        }),
        scaleTangentLine: _(
            "BuiltIn",
            "scaleTangentLine", {
            argumentTypes: [
                fe,
                T
            ],
            returnType: fe
        }),
        scaleTangentRay: _(
            "BuiltIn",
            "scaleTangentRay", {
            argumentTypes: [
                Le,
                T
            ],
            returnType: Le
        }),
        scaleTangentCircle: _(
            "BuiltIn",
            "scaleTangentCircle", {
            argumentTypes: [
                pe,
                T
            ],
            returnType: pe
        }),
        scaleTangentArc: _(
            "BuiltIn",
            "scaleTangentArc", {
            argumentTypes: [
                ce,
                T
            ],
            returnType: pe
        }),
        scaleTangentDirectedAngleMarker: _(
            "BuiltIn",
            "scaleTangentAngle", {
            argumentTypes: [
                Ae,
                T
            ],
            returnType: Ae
        }),
        scaleTangentUndirectedAngleMarker: _(
            "BuiltIn",
            "scaleTangentAngle", {
            argumentTypes: [
                Ge,
                T
            ],
            returnType: Ge
        }),
        addTangentSegment: _(
            "BuiltIn",
            "addTangentSegment", {
            argumentTypes: [
                Ie,
                Ie
            ],
            returnType: Ie
        }),
        addTangentSegmentThreeD: _(
            "BuiltIn",
            "addTangentSegmentThreeD", {
            argumentTypes: [
                Nt,
                Nt
            ],
            returnType: Nt
        }),
        addTangentLine: _(
            "BuiltIn",
            "addTangentLine", {
            argumentTypes: [
                fe,
                fe
            ],
            returnType: fe
        }),
        addTangentRay: _(
            "BuiltIn",
            "addTangentRay", {
            argumentTypes: [
                Le,
                Le
            ],
            returnType: Le
        }),
        addTangentCircle: _(
            "BuiltIn",
            "addTangentCircle", {
            argumentTypes: [
                pe,
                pe
            ],
            returnType: pe
        }),
        addTangentArc: _(
            "BuiltIn",
            "addTangentArc", {
            argumentTypes: [
                ce,
                ce
            ],
            returnType: ce
        }),
        addTangentDirectedAngleMarker: _(
            "BuiltIn",
            "addTangentAngle", {
            argumentTypes: [
                Ae,
                Ae
            ],
            returnType: Ae
        }),
        addTangentUndirectedAngleMarker: _(
            "BuiltIn",
            "addTangentAngle", {
            argumentTypes: [
                Ge,
                Ge
            ],
            returnType: Ge
        }),
        segmentGlider: _(
            "BuiltIn",
            "segmentGlider", {
            argumentTypes: [
                Ie,
                T
            ],
            returnType: R
        }),
        segmentThreeDGlider: _(
            "BuiltIn",
            "segmentThreeDGlider", {
            argumentTypes: [
                Nt,
                T
            ],
            returnType: V
        }),
        lineGlider: _("BuiltIn",
            "lineGlider", {
            argumentTypes: [
                fe,
                T
            ],
            returnType: R
        }),
        rayGlider: _("BuiltIn",
            "rayGlider", {
            argumentTypes: [
                Le,
                T
            ],
            returnType: R
        }),
        circleGlider: _(
            "BuiltIn",
            "circleGlider", {
            argumentTypes: [
                pe,
                T
            ],
            returnType: R
        }),
        arcGlider: _("BuiltIn",
            "arcGlider", {
            argumentTypes: [
                ce,
                T
            ],
            returnType: R
        }),
        polygonGlider: _(
            "BuiltIn",
            "polygonGlider", {
            argumentTypes: [
                Be,
                T
            ],
            returnType: R
        }),
        chooseNonIncidentPoint: _(
            "BuiltIn",
            "chooseNonIncidentPoint", {
            argumentTypes: [
                R,
                R, R
            ],
            returnType: R
        }),
        circleCircleIntersection: _(
            "BuiltIn",
            "circleCircleIntersection", {
            argumentTypes: [
                pe,
                pe,
                T
            ],
            returnType: R
        }),
        circleArcIntersection: _(
            "BuiltIn",
            "circleArcIntersection", {
            argumentTypes: [
                pe,
                ce,
                T
            ],
            returnType: R
        }),
        circleLineIntersection: _(
            "BuiltIn",
            "circleLineIntersection", {
            argumentTypes: [
                pe,
                fe,
                T
            ],
            returnType: R
        }),
        arcCircleIntersection: _(
            "BuiltIn",
            "arcCircleIntersection", {
            argumentTypes: [
                ce,
                pe,
                T
            ],
            returnType: R
        }),
        arcArcIntersection: _(
            "BuiltIn",
            "arcArcIntersection", {
            argumentTypes: [
                ce,
                ce,
                T
            ],
            returnType: R
        }),
        arcLineIntersection: _(
            "BuiltIn",
            "arcLineIntersection", {
            argumentTypes: [
                ce,
                fe,
                T
            ],
            returnType: R
        }),
        lineCircleIntersection: _(
            "BuiltIn",
            "lineCircleIntersection", {
            argumentTypes: [
                fe,
                pe,
                T
            ],
            returnType: R
        }),
        lineArcIntersection: _(
            "BuiltIn",
            "lineArcIntersection", {
            argumentTypes: [
                fe,
                ce,
                T
            ],
            returnType: R
        }),
        lineLineIntersection: _(
            "BuiltIn",
            "lineLineIntersection", {
            argumentTypes: [
                fe,
                fe,
                T
            ],
            returnType: R
        }),
        lineFromSegment: _(
            "BuiltIn",
            "identity", {
            argumentTypes: [
                Ie
            ],
            returnType: fe
        }),
        lineFromRay: _(
            "BuiltIn",
            "identity", {
            argumentTypes: [
                Le
            ],
            returnType: fe
        }),
        parallel: _("BuiltIn",
            "parallel", {
            argumentTypes: [
                fe,
                R
            ],
            returnType: fe
        }),
        perpendicular: _(
            "BuiltIn",
            "perpendicular", {
            argumentTypes: [
                fe,
                R
            ],
            returnType: fe
        }),
        translation: _(
            "BuiltIn",
            "translation", {
            argumentTypes: [
                R
            ],
            returnType: Ue
        }),
        dilation: _("BuiltIn",
            "dilation", {
            argumentTypes: [
                R, T
            ],
            returnType: Ue
        }),
        rotation: _("BuiltIn",
            "rotation", {
            tag: "trig2",
            argumentTypes: [
                R, T
            ],
            returnType: Ue
        }),
        reflection: _("BuiltIn",
            "reflection", {
            argumentTypes: [
                fe
            ],
            returnType: Ue
        }),
        compose: _("BuiltIn",
            "composeTransformation", {
            argumentTypes: [
                Ue,
                Ue
            ],
            returnType: Ue
        }),
        inverse: _("BuiltIn",
            "invertTransformation", {
            argumentTypes: [
                Ue
            ],
            returnType: Ue
        }),
        transformPoint: _(
            "BuiltIn",
            "transformPoint", {
            argumentTypes: [
                Ue,
                R
            ],
            returnType: R
        }),
        transformSegment: _(
            "BuiltIn",
            "transformSegment", {
            argumentTypes: [
                Ue,
                Ie
            ],
            returnType: Ie
        }),
        transformLine: _(
            "BuiltIn",
            "transformLine", {
            argumentTypes: [
                Ue,
                fe
            ],
            returnType: fe
        }),
        transformRay: _(
            "BuiltIn",
            "transformRay", {
            argumentTypes: [
                Ue,
                Le
            ],
            returnType: Le
        }),
        transformVector: _(
            "BuiltIn",
            "transformVector", {
            argumentTypes: [
                Ue,
                he
            ],
            returnType: he
        }),
        transformCircle: _(
            "BuiltIn",
            "transformCircle", {
            argumentTypes: [
                Ue,
                pe
            ],
            returnType: pe
        }),
        transformArc: _(
            "BuiltIn",
            "transformArc", {
            argumentTypes: [
                Ue,
                ce
            ],
            returnType: ce
        }),
        transformPolygon: _(
            "BuiltIn",
            "transformPolygon", {
            argumentTypes: [
                Ue,
                Be
            ],
            returnType: Be
        }),
        transformAngleMarker: _(
            "BuiltIn",
            "transformAngleMarker", {
            argumentTypes: [
                Ue,
                Ge
            ],
            returnType: Ge
        }),
        transformDirectedAngleMarker: _(
            "BuiltIn",
            "transformAngleMarker", {
            argumentTypes: [
                Ue,
                Ae
            ],
            returnType: Ae
        }),
        distanceThreeD: _(
            "BuiltIn",
            "distanceThreeD", {
            argumentTypes: [
                V, V
            ]
        }),
        segmentThreeD: _(
            "BuiltIn",
            "segmentThreeD", {
            argumentTypes: [
                V, V
            ],
            returnType: Nt
        }),
        triangle: _("BuiltIn",
            "triangle", {
            argumentTypes: [
                V,
                V, V
            ],
            returnType: In
        }),
        sphere: _("BuiltIn",
            "sphere", {
            argumentTypes: [
                V, T
            ],
            returnType: Nn,
            minArityExampleArgs: "((0,0,0), 1)",
            maxArityExampleArgs: "((0,0,0), 1)"
        }),
        mean: _("BuiltIn",
            "mean", {
            tag: "reducer"
        }),
        total: _("BuiltIn",
            "total", {
            tag: "reducer"
        }),
        stdev: _("BuiltIn",
            "stdev", {
            tag: "reducer"
        }),
        stdevp: _("BuiltIn",
            "stdevp", {
            tag: "reducer"
        }),
        mad: _("BuiltIn",
            "mad", {
            tag: "reducer"
        }),
        count: _("BuiltIn",
            "listLength", {
            tag: "reducer",
            argumentTypes: [
                sn
            ],
            noPeel: !0
        }),
        min: _("BuiltIn",
            "listMin", {
            tag: "reducer"
        }),
        max: _("BuiltIn",
            "listMax", {
            tag: "reducer"
        }),
        argmin: _("BuiltIn",
            "argMin", {
            tag: "reducer",
            noPeel: !0
        }),
        argmax: _("BuiltIn",
            "argMax", {
            tag: "reducer",
            noPeel: !0
        }),
        median: _("BuiltIn",
            "median", {
            tag: "reducer"
        }),
        var: _("BuiltIn",
            "variance", {
            tag: "reducer"
        }),
        varp: _("BuiltIn",
            "varp", {
            tag: "reducer"
        }),
        cov: _("BuiltIn",
            "cov", {
            tag: "doubleReducer"
        }),
        covp: _("BuiltIn",
            "covp", {
            tag: "doubleReducer"
        }),
        corr: _("BuiltIn",
            "corr", {
            tag: "doubleReducer"
        }),
        spearman: _("BuiltIn",
            "spearman", {
            tag: "doubleReducer"
        }),
        quantile: _("BuiltIn",
            "quantile", {
            tag: "parameterizedReducer"
        }),
        quartile: _("BuiltIn",
            "quartile", {
            tag: "parameterizedReducer"
        }),
        upperQuantileIndex: _(
            "BuiltIn",
            "upperQuantileIndex", {
            tag: "parameterizedReducer"
        }),
        lowerQuantileIndex: _(
            "BuiltIn",
            "lowerQuantileIndex", {
            tag: "parameterizedReducer"
        }),
        quartileIndex: _(
            "BuiltIn",
            "quartileIndex", {
            tag: "parameterizedReducer"
        }),
        upperQuartileIndex: _(
            "BuiltIn",
            "upperQuartileIndex", {
            tag: "parameterizedReducer"
        }),
        lowerQuartileIndex: _(
            "BuiltIn",
            "lowerQuartileIndex", {
            tag: "parameterizedReducer"
        }),
        normalcdf: _("BuiltIn",
            "normalcdf", {
            argumentTypes: [
                T,
                T,
                T, T
            ],
            defaultArguments: [
                Zu,
                Wu
            ]
        }),
        normalpdf: _("BuiltIn",
            "normalpdf", {
            argumentTypes: [
                T,
                T, T
            ],
            defaultArguments: [
                Zu,
                Wu
            ]
        }),
        binomcdf: _("BuiltIn",
            "binomcdf", {
            argumentTypes: [
                T,
                T,
                T, T
            ],
            defaultArguments: [
                Zd
            ]
        }),
        binompdf: _("BuiltIn",
            "binompdf", {
            argumentTypes: [
                T,
                T, T
            ],
            defaultArguments: [
                Zd
            ]
        }),
        poissoncdf: _("BuiltIn",
            "poissoncdf", {
            argumentTypes: [
                T,
                T, T
            ]
        }),
        poissonpdf: _("BuiltIn",
            "poissonpdf", {
            argumentTypes: [
                T,
                T, T
            ]
        }),
        uniformcdf: _("BuiltIn",
            "uniformcdf", {
            argumentTypes: [
                T,
                T,
                T, T
            ],
            defaultArguments: [
                Zu,
                Wu
            ]
        }),
        uniformpdf: _("BuiltIn",
            "uniformpdf", {
            argumentTypes: [
                T,
                T, T
            ],
            defaultArguments: [
                Zu,
                Wu
            ]
        }),
        invT: _("BuiltIn",
            "invT", {
            argumentTypes: [
                T, T
            ]
        }),
        invPoisson: _("BuiltIn",
            "invPoisson", {
            argumentTypes: [
                T, T
            ]
        }),
        invBinom: _("BuiltIn",
            "invBinom", {
            argumentTypes: [
                T,
                T, T
            ]
        }),
        invUniform: _("BuiltIn",
            "invUniform", {
            argumentTypes: [
                T,
                T, T
            ]
        }),
        tpdf: _("BuiltIn",
            "tpdf", {
            argumentTypes: [
                T, T
            ]
        }),
        tcdf: _("BuiltIn",
            "tcdf", {
            argumentTypes: [
                T,
                T, T
            ]
        }),
        erf: _("BuiltIn",
            "erf"),
        invNorm: _("BuiltIn",
            "invNorm"),
        tscore: _("BuiltIn",
            "tscore", {
            tag: "parameterizedReducer",
            defaultArguments: [
                Zu
            ]
        }),
        normalSample: _(
            "BuiltIn",
            "normalSample", {
            argumentTypes: [
                ot,
                T, T
            ]
        }),
        uniformSample: _(
            "BuiltIn",
            "uniformSample", {
            argumentTypes: [
                ot,
                T, T
            ]
        }),
        tSample: _("BuiltIn",
            "tSample", {
            argumentTypes: [
                ot,
                T
            ]
        }),
        poissonSample: _(
            "BuiltIn",
            "poissonSample", {
            argumentTypes: [
                ot,
                T
            ]
        }),
        binomSample: _(
            "BuiltIn",
            "binomSample", {
            argumentTypes: [
                ot,
                T, T
            ]
        }),
        rgb: _("BuiltIn",
            "rgb", {
            returnType: Ut,
            tag: "color"
        }),
        hsv: _("BuiltIn",
            "hsv", {
            returnType: Ut,
            tag: "color"
        }),
        tone: _("BuiltIn",
            "tone", {
            argumentTypes: [
                T, T
            ],
            returnType: mn,
            defaultArguments: [
                Zd
            ],
            minArityExampleArgs: "(440)",
            maxArityExampleArgs: "(440, 0.5)"
        }),
        validateRangeLength: _(
            "BuiltIn",
            "validateRangeLength", {
            returnType: T,
            argumentTypes: [
                se,
                se,
                T, T
            ],
            tag: "never-broadcast",
            noPeel: !0
        }),
        validateSampleCount: _(
            "BuiltIn",
            "validateSampleCount", {
            returnType: T,
            argumentTypes: [
                T
            ]
        }),
        select: _("BuiltIn",
            "select", {
            argumentTypes: [
                sn,
                Ln
            ],
            returnType: e =>
                e[0],
            tag: "never-broadcast",
            noPeel: !0
        }),
        shuffle: _("BuiltIn",
            "shuffle", {
            argumentTypes: [
                ot,
                sn
            ],
            returnType: e =>
                e[1],
            tag: "never-broadcast"
        }),
        sortPerm: _("BuiltIn",
            "sortPerm", {
            argumentTypes: [
                se
            ],
            returnType: se,
            tag: "never-broadcast",
            noPeel: !0
        }),
        elementsAt: _("BuiltIn",
            "elementsAt", {
            argumentTypes: [
                sn,
                se
            ],
            returnType: e =>
                e[0],
            tag: "never-broadcast",
            noPeel: !0
        }),
        uniquePerm: _("BuiltIn",
            "uniquePerm", {
            argumentTypes: [
                sn
            ],
            returnType: se,
            tag: "never-broadcast",
            noPeel: !0
        }),
        restriction: _(
            "BuiltIn",
            "restriction", {
            argumentTypes: [
                ge
            ],
            returnType: Vt
        }),
        restrictionToBoolean: _(
            "BuiltIn",
            "restrictionToBoolean", {
            argumentTypes: [
                Vt
            ],
            returnType: ge
        })
    };

    function qe(e, t) {
        var m, g, d, y;
        let n = t == null ? void 0 :
            t.defaultArguments,
            r = 1 / 0,
            i = 0,
            s = (m = n == null ?
                void 0 : n.length
            ) != null ? m : 0;
        t != null && t
            .noBroadcast || (e = e
                .map(ti));
        for (let h of e) {
            let b = Ga(h) - s;
            b < r && (r = b);
            let x = Cp(h);
            x > i && (i = x)
        }
        let o = (g = t == null ?
            void 0 : t
                .fallthroughUnlessDistribution
        ) != null ? g : !1,
            a = (d = t == null ?
                void 0 : t
                    .allowDotCall) !=
                null ? d : !1,
            u = (y = t == null ?
                void 0 : t.isSeeded
            ) != null ? y : !1,
            c = t == null ? void 0 :
                t.minArityExampleArgs,
            l = t == null ? void 0 :
                t.maxArityExampleArgs,
            p = t == null ? void 0 :
                t
                    .dotMinArityExampleArgs,
            f = t == null ? void 0 :
                t
                    .dotMaxArityExampleArgs;
        return {
            minArity: r,
            argumentTypes: e,
            maxArity: i,
            defaultArguments: n,
            fallthroughUnlessDistribution: o,
            minArityExampleArgs: c,
            maxArityExampleArgs: l,
            dotMinArityExampleArgs: p,
            dotMaxArityExampleArgs: f,
            allowDotCall: a,
            isSeeded: u
        }
    }

    function so() {
        return qe([{
            type: "variadic",
            initial: [],
            rest: Ht
        }], {})
    }
    var Xd = {
        meta: "union",
        types: [Ie, pe, fe, Le,
            ce
        ]
    },
        Kh = {
            meta: "union",
            types: [Ie, fe, Le, he]
        },
        rl = {
            meta: "union",
            types: [R, Ie, pe, fe,
                Le, he, ce, Be,
                Ge, Ae, Ue
            ]
        },
        eb = {
            meta: "union",
            types: [...Zi.filter(
                e => e !==
                    wn), St]
        },
        oo = {
            midpoint: qe([
                [R, R],
                [V, V],
                [Ie],
                [Nt]
            ], {
                allowDotCall:
                    !0
            }),
            segment: qe([
                [R, R],
                [V, V]
            ]),
            vector: qe([
                [R, R],
                [V, V]
            ]),
            distance: qe([
                [R, R],
                [V, V]
            ]),
            glider: qe([
                [{
                    meta: "union",
                    types: [Ie,
                        pe,
                        fe,
                        Le,
                        ce,
                        Be
                    ]
                }, T]
            ]),
            circle: qe([
                [R, Ie],
                [R, R],
                [R, T]
            ], {}),
            center: qe([
                [pe],
                [ce]
            ], {
                allowDotCall:
                    !0
            }),
            radius: qe([
                [pe],
                [ce]
            ], {
                allowDotCall:
                    !0
            }),
            intersection: qe([
                [Xd, Xd]
            ]),
            strictintersection: qe([
                [Xd, Xd]
            ]),
            parallel: qe([
                [Kh, R]
            ]),
            perpendicular: qe([
                [Kh, R]
            ]),
            start: qe([
                [he],
                [Se]
            ], {
                allowDotCall:
                    !0
            }),
            end: qe([
                [he],
                [Se]
            ], {
                allowDotCall:
                    !0
            }),
            length: qe([
                [{
                    meta: "union",
                    types: Zi
                }], ti([
                    Nt]), ti([
                        Se]),
                ti([Ie]),
                ti([ce]), {
                    type: "variadic",
                    initial: [
                        Ht
                    ],
                    rest: Ht
                }
            ], {
                allowDotCall:
                    !0,
                noBroadcast:
                    !0
            }),
            translate: qe([
                [rl, he],
                [rl, R, R]
            ]),
            dilate: qe([
                [rl, R, T]
            ]),
            rotate: qe([
                [rl, R, T]
            ]),
            reflect: qe([
                [rl, Kh]
            ]),
            apply: qe([
                [Ue, rl]
            ]),
            points: qe([]),
            lines: qe([]),
            circles: qe([]),
            arcs: qe([]),
            polygons: qe([]),
            rays: qe([]),
            vectors: qe([]),
            angle: qe([
                [R, R, R]
            ]),
            directedangle: qe([
                [R, R, R]
            ]),
            angles: qe([
                [Be]
            ], {
                allowDotCall:
                    !0
            }),
            directedangles: qe([
                [Be]
            ], {
                allowDotCall:
                    !0
            }),
            coterminal: qe([
                [Ge],
                [Ae]
            ]),
            round: qe([
                [T],
                [T, T]
            ]),
            sort: qe([
                [se],
                [{
                    meta: "union",
                    types: Zi
                }, se]
            ], {
                minArityExampleArgs: "([3,2,1])",
                maxArityExampleArgs: "([1,2,3],[3,2,1])",
                dotMaxArityExampleArgs: "([3,4])",
                allowDotCall:
                    !0
            }),
            shuffle: qe([
                [ot, {
                    meta: "union",
                    types: Zi
                }],
                [ot, {
                    meta: "union",
                    types: Zi
                }, T]
            ], {
                minArityExampleArgs: "([1,2,3])",
                maxArityExampleArgs: "([1,2,3],2)",
                dotMaxArityExampleArgs: "(2)",
                allowDotCall:
                    !0,
                isSeeded: !
                    0,
                noBroadcast:
                    !0
            }),
            join: qe([{
                type: "variadic",
                initial: [
                    Ht,
                    Ht
                ],
                rest: Ht
            }], {
                minArityExampleArgs: "([1,2],[3,4])",
                dotMinArityExampleArgs: "([3,4])",
                allowDotCall:
                    !0
            }),
            unique: qe([
                [{
                    meta: "union",
                    types: Zi
                        .filter(
                            e =>
                                e !==
                                wn &&
                                e !==
                                sn
                        )
                }]
            ], {
                minArityExampleArgs: "([1,2,3])",
                maxArityExampleArgs: "([1,2,3])",
                allowDotCall:
                    !0
            }),
            normaldist: qe([
                [T, T]
            ], {
                defaultArguments: [
                    Zu,
                    Wu
                ]
            }),
            tdist: qe([
                [T]
            ]),
            binomialdist: qe([
                [T, T]
            ], {
                defaultArguments: [
                    Zd
                ]
            }),
            poissondist: qe([
                [T]
            ]),
            uniformdist: qe([
                [T, T]
            ], {
                defaultArguments: [
                    Zu,
                    Wu
                ]
            }),
            pdf: qe([
                [St, T]
            ], {
                allowDotCall:
                    !0
            }),
            cdf: qe([
                [St, T],
                [St, T, T]
            ], {
                allowDotCall:
                    !0
            }),
            median: qe([
                [St]
            ], {
                fallthroughUnlessDistribution:
                    !0,
                allowDotCall:
                    !0
            }),
            stdev: qe([
                [St]
            ], {
                fallthroughUnlessDistribution:
                    !0,
                allowDotCall:
                    !0
            }),
            var: qe([
                [St]
            ], {
                fallthroughUnlessDistribution:
                    !0,
                allowDotCall:
                    !0
            }),
            quantile: qe([
                [St, T]
            ], {
                fallthroughUnlessDistribution:
                    !0,
                allowDotCall:
                    !0,
                minArityExampleArgs: "([1,2,3], 1)",
                maxArityExampleArgs: "([1,2,3], 1)",
                dotMinArityExampleArgs: "(x)",
                dotMaxArityExampleArgs: "(x)"
            }),
            random: qe([
                [ot],
                [ot, T],
                [ot, T, T],
                [ot, eb],
                [ot, eb, T],
                [ot, eb, T,
                    T
                ]
            ], {
                allowDotCall:
                    !0,
                isSeeded: !
                    0,
                noBroadcast:
                    !0
            }),
            polygon: qe([{
                type: "variadic",
                initial: [],
                rest: R
            },
            [Pt],
            [se, se],
            [T, se],
            [se, T]
            ]),
            total: qe([T, R, V].map(
                tb), {
                allowDotCall:
                    !0
            }),
            mean: qe([
                [St], ...[T,
                    R, V
                ].map(tb)
            ], {
                allowDotCall:
                    !0
            }),
            histogram: so(),
            dotplot: so(),
            boxplot: so(),
            ttest: so(),
            ittest: so(),
            stats: so(),
            det: so(),
            inv: so(),
            transpose: so(),
            rref: so(),
            trace: so()
        };

    function sl(e) {
        return !!oo[e]
    }

    function il(e) {
        return !!bn[e]
    }

    function Vp(e) {
        let t = sl(e) ? oo[e] :
            void 0;
        if (!t && !il(e)) return;
        let n = [];
        return t && (n = [...t
            .argumentTypes
        ]), il(e) && (!t || t
            .fallthroughUnlessDistribution
        ) && n.push(...rb(
            e)), n
    }

    function tb(e) {
        return ti({
            type: "variadic",
            initial: [e],
            rest: e
        })
    }

    function rb(e) {
        let t = [],
            n = bn[e];
        switch (n.tag) {
            case "reducer": {
                if (Array.isArray(n
                    .argumentTypes
                ) &&
                    typeof n
                        .argumentTypes[
                    0] ==
                    "number" && W(n
                        .argumentTypes[
                        0])) {
                    let r = n
                        .argumentTypes[
                        0],
                        i = ke(r);
                    t.push(tb(i))
                } else throw new Error(
                    `Programming error: declared argumentTypes for built-in function ${e} is not consistent with "reducer"`
                );
                break
            }
            case "parameterizedReducer": {
                t.push(n
                    .argumentTypes),
                    Array.isArray(n
                        .argumentTypes
                    ) && n
                        .argumentTypes
                        .length === 2 &&
                    t.push([n
                        .argumentTypes[
                        0],
                    Hu(n.argumentTypes[
                        1
                    ])
                    ]);
                break
            }
            case "doubleReducer":
            case "never-broadcast": {
                t.push(n
                    .argumentTypes);
                break
            }
            default: {
                t.push(ti(n
                    .argumentTypes));
                break
            }
        }
        return t
    }
    var cn = class extends j {
        constructor(t, n) {
            super(n, {
                skipRegisterDependencies:
                    !
                    0
            }),
                typeof t ==
                "string" &&
                (t = new ze(
                    t)),
                this
                    ._identifier =
                t, this
                    ._symbol = t
                    ._symbol,
                this
                    ._errorSymbol =
                t
                    ._errorSymbol ===
                    "logbase" ?
                    "log" : t
                        ._errorSymbol,
                this
                    .registerDependencies()
        }
        registerDependencies() {
            this.addDependency(
                this
                    ._symbol
            ), super
                .registerDependencies(),
                Ha(this
                    ._symbol
                ) &&
                this
                    .addDependency(
                        "trigAngleMultiplier"
                    )
        }
    };
    var Qi = class extends j { };
    var Wd = {
        pi: new Zt(Math.PI),
        tau: new Zt(2 * Math
            .PI),
        e: new Zt(Math.E),
        trigAngleMultiplier: new Zt(
            De(1, 1)),
        infty: new Zt(1 / 0),
        identityTransformation: new cn(
            "translation", [
            new Qi([new Zt(
                0
            ),
            new Zt(
                0
            )
            ])
        ])
    };
    var jd = class extends Tt {
        constructor() {
            super(...
                arguments
            );
            this.isFunction = !
                0
        }
    },
        Fo, Ke = {};
    for (Fo in Wd) Wd
        .hasOwnProperty(Fo) && (Ke[
            Fo] = Wd[Fo]);
    for (Fo in bn) bn
        .hasOwnProperty(Fo) && (Ke[
            Fo] = new jd);
    for (Fo in oo) oo
        .hasOwnProperty(Fo) && (Ke[
            Fo] = new jd);

    function bL(e) {
        var t = {};
        return e
            .additionalFunctions &&
            e.additionalFunctions
                .indexOf("sqrt") !== -
            1 && (t.sqrt = Ke.sqrt),
            e.width && (t.width = e
                .width), e.height &&
            (t.height = e.height), t
    }
    var ib = {};
    No(ib, {
        getFrame: () => xL
    });
    var Pv = ["pi", "e",
        "trigAngleMultiplier"
    ],
        Tv = ["sqrt", "nthroot",
            "abs", "ln", "sin",
            "cos", "tan", "log",
            "arcsin", "arccos",
            "arctan", "mean",
            "round", "stdev",
            "stdevp", "nCr", "nPr",
            "exp", "factorial"
        ];

    function Iv(e, t) {
        for (var n = 0; n < e
            .length; n++) {
            var r = e[n];
            if (!t.hasOwnProperty(
                r)) throw new Error(
                    "Programming Error: key '" +
                    r + `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`))
        }
    }
    Iv(Pv, Ke);
    Iv(Tv, Ke);

    function xL(e) {
        var t = {};
        return Pv.forEach(function (
            n) {
            t[n] = Ke[n]
        }), Tv.forEach(function (
            n) {
            e.replaceRoundWithReciprocal &&
                n ===
                "round" || (
                    t[n] =
                    Ke[n])
        }), e
            .trigAngleMultiplier &&
            (t.trigAngleMultiplier =
                e
                    .trigAngleMultiplier
            ), e.width && (t
                .width = e.width), e
                    .height && (t.height = e
                        .height), t
    }
    var sb = {};
    No(sb, {
        getFrame: () => PL
    });
    var Ev = ["pi", "e",
        "trigAngleMultiplier"
    ],
        Mv = ["sqrt", "nthroot",
            "abs", "ln", "sin",
            "cos", "tan", "log",
            "arcsin", "arccos",
            "arctan", "exp",
            "factorial"
        ];

    function vv(e, t) {
        for (var n = 0; n < e
            .length; n++) {
            var r = e[n];
            if (!t.hasOwnProperty(
                r)) throw new Error(
                    "Programming Error: key '" +
                    r + `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`))
        }
    }
    vv(Ev, Ke);
    vv(Mv, Ke);

    function PL(e) {
        var t = {};
        return Ev.forEach(function (
            n) {
            t[n] = Ke[n]
        }), Mv.forEach(function (
            n) {
            t[n] = Ke[n]
        }), e
            .trigAngleMultiplier &&
            (t.trigAngleMultiplier =
                e
                    .trigAngleMultiplier
            ), e.width && (t
                .width = e.width), e
                    .height && (t.height = e
                        .height), t
    }
    var Bp = {};
    No(Bp, {
        getFrame: () => ML
    });
    var Dv = {
        segment: !0,
        line: !0,
        ray: !0,
        circle: !0,
        arc: !0,
        vector: !0,
        glider: !0,
        parallel: !0,
        perpendicular: !0,
        center: !0,
        radius: !0,
        area: !0,
        perimeter: !0,
        start: !0,
        end: !0,
        angles: !0,
        angle: !0,
        directedangles: !0,
        directedangle: !0,
        coterminal: !0,
        supplement: !0,
        vertices: !0,
        segments: !0,
        intersection: !0,
        translate: !0,
        dilate: !0,
        rotate: !0,
        reflect: !0,
        construction: !0,
        points: !0,
        lines: !0,
        circles: !0,
        arcs: !0,
        polygons: !0,
        rays: !0
    };
    var Sv = {
        segment: !0,
        triangle: !0,
        vector: !0,
        start: !0,
        end: !0,
        sphere: !0
    };
    var Ov = ["csc", "sec", "cot",
        "arccsc", "arcsec",
        "arccot", "csch",
        "sech", "coth",
        "arccsch", "arcsech",
        "arccoth", "mad", "cov",
        "covp", "distance",
        "midpoint"
    ],
        Cv = ["histogram",
            "dotplot", "boxplot"
        ],
        TL = [...Cv, "polygon"],
        Rv = ["erf", "ttest",
            "tscore", "ittest",
            "normaldist", "tdist",
            "poissondist",
            "binomialdist", "pdf",
            "cdf", "random", ...Cv
        ],
        IL = ["distance",
            "midpoint"],
        EL = ["det", "inv",
            "transpose", "rref",
            "trace"
        ],
        Nv = Object.keys(Dv).filter(
            function (e) {
                return e !==
                    "construction"
            });

    function ob(e, t) {
        for (var n = 0; n < e
            .length; n++) {
            var r = e[n];
            if (!t.hasOwnProperty(
                r)) throw new Error(
                    "Programming Error: key '" +
                    r + `' does not exist in table. Must be one of:
` + Object.keys(t).join(`
`))
        }
    }
    ob(Ov, Ke);
    ob(Rv, Ke);
    ob(Nv, Ke);

    function ML(e) {
        var t = {},
            n;
        for (n in Ke) {
            if (!Ke.hasOwnProperty(
                n) || e
                    .restrictedFunctions ===
                !0 && Ov.indexOf(
                    n) !== -1 && !(e
                        .forceEnableGeometryFunctions ===
                        !0 && IL
                            .indexOf(n) !==
                        -1) || e
                            .distributions === !
                        1 && Rv.indexOf(
                            n) !== -1) continue;
            let r = Nv.indexOf(
                n) !== -1,
                i = n in Sv;
            if (r && i) {
                if (!(e.isGeometryCalculator ||
                    e
                        .is3DCalculator
                )) continue
            } else if (r) {
                if (!e
                    .isGeometryCalculator
                ) continue
            } else if (i) {
                if (!e
                    .is3DCalculator)
                    continue
            } else if (TL.indexOf(
                n) !== -1 && e
                    .is3DCalculator)
                continue;
            EL.indexOf(n) === -1 &&
                (t[n] = Ke[n])
        }
        return e
            .trigAngleMultiplier &&
            (t.trigAngleMultiplier =
                e
                    .trigAngleMultiplier
            ), e
                .globalRandomSeed && (t
                    .globalRandomSeed =
                    e.globalRandomSeed),
            e.initialEvaluation && (
                t
                    .initialEvaluation =
                e.initialEvaluation
            ), e
                .globalEventCount && (t
                    .globalEventCount =
                    e.globalEventCount),
            e.width && (t.width = e
                .width), e.height &&
            (t.height = e.height), t
    }
    var ZA = {};
    No(ZA, {
        parse: () => Vs,
        setInput: () => UC
    });

    function Av(e) {
        let t = function (...i) {
            return new e(...i)
        };
        t.prototype = e.prototype;
        var n = Object
            .getOwnPropertyNames(e);
        for (var r of n) {
            let i = e[r];
            if (typeof i ==
                "function") try {
                    t[r] = i
                } catch (s) { }
        }
        return t
    }
    var C = class extends Tt {
        constructor(n) {
            super();
            this.isError = !
                0;
            this._msg = n,
                this
                    .blocksExport = !
                0
        }
        evaluateOnce(n) {
            return this._msg
        }
        getError() {
            return this._msg
        }
        setDependencies(n) {
            return this
                .addDependencies(
                    n), this
        }
        setActionValue(n) {
            this.actionValue =
                n
        }
        allowExport() {
            return this
                .blocksExport = !
                1, this
        }
        setCursorContext(n) {
            this.cursorContext =
                n
        }
        getCursorContext() {
            return this
                .cursorContext
        }
    };
    var Qd = class extends Zt {
        constructor() {
            super(...
                arguments
            );
            this.is_mixed_number = !
                0
        }
    };
    var Kd = class extends ze { };

    function vL(e) {
        for (var t = 1 / 0, n =
            0; n < e.length; n++)(e[
                n].isList || e[
                    n].isBroadcast) && (
                    t = Math.min(t, e[n]
                        .length));
        return t
    }
    var Gp = class Gp extends j {
        constructor(n) {
            super(n);
            this.isList = !
                0;
            this.length = n
                .length
        }
        asValue() {
            for (var n = [],
                r =
                    0; r <
                this.args
                    .length; r++
            ) n.push(
                this
                    .args[r]
                    .asValue()
            );
            return n
        }
        asCompilerValue() {
            for (var n = [],
                r =
                    0; r <
                this.args
                    .length; r++
            ) n.push(
                this
                    .args[r]
                    .asCompilerValue()
            );
            return n
        }
        getEvaluationInfo() {
            if (this.args
                .every(
                    function (
                        n) {
                        return n
                            .isConstant
                    }))
                return [{
                    val: this
                        .args
                        .map(
                            function (
                                n
                            ) {
                                return n
                                    .asValue()
                            }
                        )
                }]
        }
    };
    Gp.eachArgs = function (n, r) {
        var i = vL(n);
        if (!isFinite(i)) {
            r(n);
            return
        }
        for (var s = 0; s <
            i; s++) {
            for (var o = [], a =
                0; a < n
                    .length; a++) o
                        .push(n[a]
                            .isList ||
                            W(n[a]
                                .valueType
                            ) ? n[a]
                                .elementAt(
                                    s) : n[
                        a]);
            r(o, s)
        }
    }, Gp.wrap = function (n) {
        return n.isList || W(n
            .valueType) ?
            n : new Gp([n])
    };
    var Vo = Gp;
    var ol = class extends j {
        constructor(t) {
            super(t), this
                .beginning =
                t[0], this
                    .end = t[1]
        }
        isHalfEmpty() {
            return this
                .end && this
                    .end.args &&
                this.end
                    .args
                    .length ===
                0
        }
    };
    var Ua = class extends j {
        constructor(t) {
            super(t), this
                .list = t[
                0], this
                    .index = t[
                1]
        }
    };
    var xi = class extends j {
        registerDependencies() {
            if (super
                .registerDependencies(),
                this.args[1]
                    .type ===
                "Identifier"
            ) {
                var t = this
                    .args[1]
                    ._symbol;
                Ha(t) &&
                    this
                        .addDependency(
                            "trigAngleMultiplier"
                        )
            }
        }
    };
    var ju = class extends j {
        constructor(n) {
            var r = n.map(
                function (
                    i) {
                    return new ze(
                        "\\idref_{" +
                        i +
                        "}"
                    )
                });
            super(r);
            this.constructedObjectIds =
                n;
            this._exports
                .push(
                    "construction"
                )
        }
    };
    var em = class extends Qi {
        constructor(n, r, i) {
            super(n);
            this.isTypedConstant = !
                0;
            this.isMovablePoint = !
                0;
            this.moveStrategy =
                r, this
                    .defaultDragMode =
                i, this
                    .valueType =
                R
        }
        asValue() {
            return [+this
                .args[0]
                .asValue(),
            +this
                .args[1]
                .asValue()
            ]
        }
        asTypedValue() {
            return {
                valueType: this
                    .valueType,
                value: this
                    .asValue()
            }
        }
        asCompilerValue() {
            return [this
                .args[0]
                .asCompilerValue(),
            this
                .args[1]
                .asCompilerValue()
            ]
        }
    };
    var Ju = class extends j {
        constructor(t, n) {
            super(n), this
                .symbol = t
        }
    };
    var qa = class extends j { };
    var al = class extends j { };
    var ni = class extends j { };
    var Rr = {
        "<": {
            inclusive: !1,
            direction: -1
        },
        "!=": {
            inclusive: !1,
            direction: 0
        },
        ">": {
            inclusive: !1,
            direction: 1
        },
        "<=": {
            inclusive: !0,
            direction: -1
        },
        "=": {
            inclusive: !0,
            direction: 0
        },
        ">=": {
            inclusive: !0,
            direction: 1
        }
    };

    function Qu(e, t) {
        switch (t) {
            case -1:
                return e ? "<=" :
                    "<";
            case 0:
                return e ? "=" :
                    "!=";
            case 1:
                return e ? ">=" :
                    ">";
            default:
                throw "Programming error.  Comparators must have a direction of -1, 0, or 1"
        }
    }
    var Ns = class e extends j {
        constructor(n, r) {
            super(r);
            this.operator =
                n;
            this._difference =
                Rr[this
                    .operator
                ]
                    .direction ===
                    -1 ? new ni(
                        [r[1],
                        r[0]
                        ]) :
                    new ni([r[
                        0],
                    r[1]
                    ])
        }
        static create(n) {
            class r extends e {
                constructor(
                    s) {
                    super
                        (n,
                            s)
                }
            }
            return r
        }
        asComparator() {
            return this
        }
        isInequality() {
            return Rr[this
                .operator
            ]
                .direction !==
                0
        }
    };
    var qr = {
        "<": Ns.create("<"),
        ">": Ns.create(">"),
        "<=": Ns.create("<="),
        ">=": Ns.create(">="),
        "=": Ns.create("=")
    };
    var hr = class extends j { };
    var nn = {};
    No(nn, {
        actionMergeFreeVariable: () =>
            tx,
        addArgumentsToDefinition: () =>
            rf,
        addTypeError: () =>
            bb,
        adjacentMixedNumber: () =>
            bm,
        adjacentNumbers: () =>
            vx,
        andTypeError: () =>
            Db,
        ansUndefined: () =>
            JP,
        assignmentsUnsupported: () =>
            lf,
        badEqualitySlice: () =>
            Bo,
        badForInputListDependency: () =>
            tT,
        badForIntervalDependency: () =>
            nT,
        badImplicitCall: () =>
            hm,
        badIntegralBoundDependency: () =>
            XP,
        badLogExponent: () =>
            $x,
        badProductBoundDependency: () =>
            BP,
        badSampleSize: () =>
            WP,
        badSumBoundDependency: () =>
            VP,
        badSymbolContext: () =>
            uf,
        badTrigExponent: () =>
            qx,
        badTupleDimensions: () =>
            Mx,
        baseCaseCannotDependOnRecursiveParameter: () =>
            pb,
        baseCaseTooComplicatedUsePiecewise: () =>
            Hp,
        baseCasesMustAllHaveSameReturnType: () =>
            zp,
        binaryOperatorMissingOperand: () =>
            tf,
        blankExpression: () =>
            nf,
        boxplotBreadthInvalid: () =>
            fx,
        boxplotOffsetInvalid: () =>
            px,
        cannotAssignColor: () =>
            yP,
        cannotRedefine: () =>
            fl,
        cannotRestrict: () =>
            mP,
        cannotRestrictWithEquality: () =>
            gP,
        cannotSubscript: () =>
            Jx,
        cantCombineSphericalAndCylindrical: () =>
            Dm,
        cdfMaxInvalid: () =>
            lP,
        cdfMaxLessThanMin: () =>
            pP,
        cdfMinInvalid: () =>
            cP,
        cdfRequiresArguments: () =>
            mx,
        cdfTooManyArguments: () =>
            yx,
        clickableObjectAlreadyAssigned: () =>
            wL,
        clickableObjectAssignmentNotDefined: () =>
            LL,
        clickableObjectAssignmentNotIdentifier: () =>
            FL,
        clickableObjectInvalidExpression: () =>
            VL,
        colonMissingCondition: () =>
            Zx,
        colorArity: () =>
            xx,
        combineTypeError: () =>
            dm,
        comparatorTypeError: () =>
            vb,
        complicatedDoubleInequality: () =>
            Rm,
        complicatedPolarImplicit: () =>
            EP,
        constantUnsupported: () =>
            ic,
        cycle: () => vm,
        deeplyNested: () =>
            sx,
        dependsOnDeletedGeoObject: () =>
            cT,
        derivativeMissingBody: () =>
            $P,
        derivativeTypeError: () =>
            qb,
        derivativeVariableTypeError: () =>
            $b,
        differentialWithSuperscript: () =>
            zP,
        distributionAsFunction: () =>
            _m,
        divideTypeError: () =>
            Pb,
        domainMaxInvalid: () =>
            aP,
        domainMaxLessThanMin: () =>
            uP,
        domainMinInvalid: () =>
            oP,
        dotLHSTypeError: () =>
            Lb,
        duplicateFunctionParameter: () =>
            Wx,
        duplicateUpdateRules: () =>
            Qb,
        eachBaseCaseArgumentMustBeSimple: () =>
            sm,
        emptyParen: () =>
            zx,
        emptyPipe: () => Ux,
        emptyRadical: () =>
            Gx,
        emptyRadicalIndex: () =>
            kx,
        emptySquareBracket: () =>
            Hx,
        emptySubscript: () =>
            xm,
        emptySuperscript: () =>
            Lx,
        equationRequired: () =>
            Nm,
        equationsUnsupported: () =>
            ma,
        eventHandlerTypeError: () =>
            jp,
        expectedArgumentToBeButFound: () =>
            gb,
        exponentTypeError: () =>
            Tb,
        featureUnavailable: () =>
            ff,
        fractionEmpty: () =>
            _x,
        fractionMissingDenominator: () =>
            Ax,
        fractionMissingNumerator: () =>
            Nx,
        fractionsUnavailable: () =>
            Gm,
        functionDefinitionsUnsupported: () =>
            pf,
        functionFreeVariable: () =>
            CL,
        functionNameAsParameter: () =>
            jx,
        functionNotDefined: () =>
            Im,
        functionRequiresNumberOfArguments: () =>
            yb,
        functionTypeError: () =>
            Pi,
        functionUnsupported: () =>
            ms,
        geometryLengthTypeError: () =>
            Ab,
        getLogInternalErrors: () =>
            DL,
        gpuLongProduct: () =>
            lx,
        gpuLongSum: () =>
            cx,
        gpuMaxListSize: () =>
            pl,
        gpuUnsupportedFunction: () =>
            ll,
        gpuUnsupportedIntegral: () =>
            ux,
        gpuVariableListLength: () =>
            tc,
        gpuVariableProduct: () =>
            ym,
        gpuVariableSum: () =>
            mm,
        heterogeneousList: () =>
            Jp,
        identifierAsFunction: () =>
            Sx,
        identifierIsNotFunction: () =>
            Ox,
        illegalBinWidth: () =>
            af,
        illegalDotCall: () =>
            Wp,
        implicitsDisabled: () =>
            IP,
        incorrectProductLowerBound: () =>
            FP,
        incorrectSumLowerBound: () =>
            wP,
        indexTypeError: () =>
            Zp,
        inequalitiesDisabled: () =>
            Sm,
        inequalitiesUnsupported: () =>
            sc,
        integralArgumentTypeError: () =>
            Ub,
        integralLowerBoundTypeError: () =>
            zb,
        integralMissingBody: () =>
            qP,
        integralMissingBound: () =>
            GP,
        integralMissingDifferential: () =>
            kP,
        integralUpperBoundTypeError: () =>
            Hb,
        internal: () => J,
        invalidDependentFirstTableColumn: () =>
            OL,
        invalidDoubleEquality3d: () =>
            vP,
        invalidDoubleInequality3d: () =>
            MP,
        invalidDoubleInequalityVariables: () =>
            Om,
        invalidFirstTableColumn: () =>
            OP,
        invalidFunctionName: () =>
            Bm,
        invalidHalfEmptyRange: () =>
            AP,
        invalidImplicitVariables: () =>
            rc,
        invalidImplicitVariables3d: () =>
            PP,
        invalidInequalityVariables: () =>
            xP,
        invalidIntervalComprehensionArity: () =>
            pT,
        invalidIntervalComprehensionParameter: () =>
            bl,
        invalidIntervalComprehensionReturnType: () =>
            lT,
        invalidLHS: () =>
            hP,
        invalidNestedIntervalComprehension: () =>
            fT,
        invalidOperatorName: () =>
            Fx,
        invalidRegressionParameter: () =>
            CP,
        invalidSubscript: () =>
            wx,
        invalidTableEntry: () =>
            ml,
        invalidTableHeader: () =>
            SP,
        listComprehensionIncorrectInput: () =>
            eT,
        listComprehensionInputListTypeError: () =>
            KP,
        listTypeError: () =>
            ec,
        logScaleBoxPlot: () =>
            ix,
        logScaleDotPlot: () =>
            rx,
        logScaleHistogram: () =>
            nx,
        logScaleTypeError: () =>
            cl,
        logbaseUnsupported: () =>
            QP,
        malformedList: () =>
            Ex,
        malformedPoint: () =>
            Ix,
        matrixAddDimensions: () =>
            GL,
        matrixAssignment: () =>
            BL,
        matrixElementTypeError: () =>
            qL,
        matrixFractionalPower: () =>
            HL,
        matrixInvalidVariable: () =>
            $L,
        matrixMultiplyDimensions: () =>
            zL,
        matrixPowerDimensions: () =>
            UL,
        matrixSubtractDimensions: () =>
            kL,
        maxListSize: () =>
            Qp,
        methodRequiresList: () =>
            As,
        mismatchedBraces: () =>
            YP,
        mismatchedDoubleInequality: () =>
            Cm,
        mixedComparatorChain: () =>
            Eb,
        mixedRestrictionEquation: () =>
            ax,
        multipleEqualityRestrictions: () =>
            ox,
        multiplyDefined: () =>
            dl,
        multiplyDefinedByTables: () =>
            Qx,
        multiplyTypeError: () =>
            qp,
        multiplyTypeError2D: () =>
            Yp,
        multiplyTypeError3D: () =>
            Xp,
        multiplyTypeErrorCross: () =>
            $p,
        negativeTypeError: () =>
            Ib,
        nonArithmeticRange: () =>
            of,
        nonListDoubleReducer: () =>
            sf,
        nonListParameterizedReducer: () =>
            NP,
        nonSquareDeterminant: () =>
            RL,
        nonSquareInverse: () =>
            AL,
        nonSquareTrace: () =>
            NL,
        opaque: () => Up,
        optimizationError: () =>
            RP,
        orTypeError: () =>
            Sb,
        orderedPairAccessTypeError: () =>
            Cb,
        parameterAlreadyDefined: () =>
            Em,
        pdfWrongArity: () =>
            dx,
        percentMissingOf: () =>
            ZP,
        piecewiseBranchTypeError: () =>
            Yb,
        piecewiseConditionTypeError: () =>
            lm,
        piecewiseMissingCondition: () =>
            Yx,
        piecewisePartMissingCondition: () =>
            Xx,
        pointTypeError: () =>
            Ob,
        pointsUnsupported: () =>
            ac,
        polygonTwoNumbersError: () =>
            Kp,
        polygonUnsupportedIn3d: () =>
            Fm,
        primeWithoutParen: () =>
            Tm,
        primedFunctionArity: () =>
            nc,
        productArgumentTypeError: () =>
            kb,
        productInfiniteBoundError: () =>
            cm,
        productLowerBoundTypeError: () =>
            Bb,
        productMissingBody: () =>
            UP,
        productMissingBound: () =>
            LP,
        productUpperBoundTypeError: () =>
            Gb,
        randomArity: () =>
            hx,
        randomFromBroadcastDistribution: () =>
            bx,
        recursionCyclicDependency: () =>
            fb,
        recursionDoesNotTerminate: () =>
            db,
        recursiveDepthExceeded: () =>
            mb,
        recursiveFunctionCannotDependOnFreeVariable: () =>
            lb,
        recursiveFunctionMissingBaseCase: () =>
            im,
        recursiveFunctionMissingBaseCaseWithMetadata: () =>
            cb,
        regressionTypeError: () =>
            Wb,
        regressionsUnsupported: () =>
            oc,
        selfReferentialFunctions: () =>
            $a,
        setLogInternalErrors: () =>
            ub,
        shadowedIndex: () =>
            Mm,
        shadowedIntegrationVariable: () =>
            Lm,
        shadowedListComprehensionInput: () =>
            km,
        singleVariableImplicitEquationsDisabled: () =>
            TP,
        singularInverse: () =>
            _L,
        sliderLimitReferencesExport: () =>
            tP,
        sliderMaxInvalid: () =>
            rP,
        sliderMaxLessThanMin: () =>
            iP,
        sliderMinInvalid: () =>
            nP,
        sliderStepInvalid: () =>
            sP,
        substitutionAmbiguousComma: () =>
            Ya,
        substitutionBodyAction: () =>
            XL,
        substitutionBodyDependsOnRegression: () =>
            aT,
        substitutionDuplicateSymbol: () =>
            uT,
        substitutionFunctionLHS: () =>
            hl,
        substitutionIllegalLHS: () =>
            gl,
        substitutionInvalidAssignments: () =>
            mf,
        substitutionLocalLHS: () =>
            yf,
        substitutionNested: () =>
            zm,
        substitutionRecursiveShadow: () =>
            gf,
        substitutionTypeError: () =>
            YL,
        substitutionUnsupportedInterval: () =>
            Hm,
        subtractTypeError: () =>
            xb,
        sumArgumentTypeError: () =>
            Vb,
        sumInfiniteBoundError: () =>
            um,
        sumLowerBoundTypeError: () =>
            wb,
        sumMissingBody: () =>
            HP,
        sumMissingBound: () =>
            _P,
        sumUpperBoundTypeError: () =>
            Fb,
        superscriptWithPrime: () =>
            Bx,
        tableCycleWithoutGlobalDefinition: () =>
            Kx,
        tableEntryTypeError: () =>
            Zb,
        tableHeaderTypeError: () =>
            Xb,
        tdistWrongArity: () =>
            gx,
        threeDLengthTypeError: () =>
            _b,
        tickerMinStepNonNegativeNumber: () =>
            eP,
        tokenWithSubscript: () =>
            Dx,
        tooManyArguments: () =>
            gm,
        tooManyVariables: () =>
            tn,
        transformationDefinitionTypeError: () =>
            Rb,
        transformationTypeError: () =>
            Nb,
        ttestListTooShort: () =>
            yl,
        unaryOperatorMissingLeft: () =>
            Cx,
        unaryOperatorMissingRight: () =>
            Rx,
        unexpectedEquality: () =>
            hb,
        unexpectedInequality: () =>
            am,
        unexpectedPrime: () =>
            Pm,
        unexpectedSubscript: () =>
            Vx,
        unexpectedSymbol: () =>
            Nr,
        unplottableEqualityChain: () =>
            DP,
        unplottableLongInequalityChain: () =>
            Mb,
        unplottablePolarFunction: () =>
            bP,
        unrecognizedSymbol: () =>
            om,
        updateRuleFunctionLHS: () =>
            pm,
        updateRuleIllegalLHS: () =>
            ex,
        updateRuleLocalLHS: () =>
            fm,
        updateRuleNonIdentifierLHS: () =>
            Jb,
        updateRuleTypeError: () =>
            jb,
        updateRuleUndefinedLHS: () =>
            Kb,
        useRForCylindricalCoordinates: () =>
            dP,
        useRhoForSphericalCoordinates: () =>
            fP,
        variableAsFunction: () =>
            Am,
        variableLengthDistributionList: () =>
            df,
        variableLengthIntegralDependsOnIntegrationVariable: () =>
            oT,
        variableLengthProductBodyDependsOnIndex: () =>
            sT,
        variableLengthSumBodyDependsOnIndex: () =>
            iT,
        variableLengthTopLevelList: () =>
            rT,
        variableSeed: () =>
            jP,
        variableUnsupported: () =>
            Vm,
        variablesUnsupported: () =>
            cf,
        writeIntegral: () =>
            wm,
        wrongArity: () =>
            ds,
        wrongDoubleReducerArity: () =>
            ef,
        wrongParameterizedReducerArity: () =>
            Px,
        zeroArgReducer: () =>
            Tx
    });

    function kp(e) {
        return {
            __isLocalizableNumericValue:
                !0,
            value: e
        }
    }

    function Iq(e) {
        return e && e
            .__isLocalizableNumericValue
    }
    var rm = !1;

    function ub(e) {
        rm = e
    }

    function DL() {
        return rm
    }

    function SL(...e) {
        rm && console.error(...e)
    }

    function J(e) {
        if (rm) {
            let t =
                e instanceof Error ?
                    e : new Error(
                        `${e}`);
            return SL(t.stack),
                new C(S("shared-calculator-error-internal-error", {
                    msg: t
                        .message
                }))
        }
        return new C(S(
            "shared-calculator-error-parse-error"
        ))
    }

    function im(e) {
        let t = e.length,
            n = e[0];
        return new C(S(
            "shared-calculator-error-recursion-missing-base-case", {
            count: kp(
                t),
            lastSymbol: X(
                n),
            symbols: e
                .slice(
                    1)
                .map(
                    r =>
                        X(r)
                )
                .join(
                    "', '"
                )
        }))
    }

    function cb(e, t) {
        let n = im(e);
        return n.recursionMetadata =
            t, n
    }

    function lb(e) {
        return new C(S(
            "shared-calculator-error-recursion-base-case-free-variable", {
            freeVariable: X(
                e)
        }))
    }

    function pb(e) {
        return new C(S(
            "shared-calculator-error-recursion-base-case-free-variable", {
            freeVariable: X(
                e)
        }))
    }

    function zp() {
        return new C(S(
            "shared-calculator-error-recursion-base-case-same-type"
        )).allowExport()
    }

    function Hp() {
        return new C(S(
            "shared-calculator-error-recursion-base-case-too-complicated"
        ))
    }

    function sm() {
        return new C(S(
            "shared-calculator-error-recursion-base-case-argument-non-number"
        ))
    }

    function fb() {
        return new C(S(
            "shared-calculator-error-recursion-does-not-terminate"
        ))
    }

    function db() {
        return new C(S(
            "shared-calculator-error-recursion-does-not-terminate"
        ))
    }

    function mb() {
        return new C(S(
            "shared-calculator-error-recursion-depth-limit-exceeded"
        ))
    }

    function yb(e, t) {
        return new C(S(
            "shared-calculator-error-recursion-wrong-arity", {
            fnSymbol: X(
                e),
            count: kp(t)
        }))
    }

    function gb(e, t, n) {
        return new C(S(
            "shared-calculator-error-recursion-argument-type", {
            index: e +
                1,
            expectedType: t,
            foundType: n
        })).allowExport()
    }

    function Up() {
        return new C(S(
            "shared-calculator-error-parse-error"
        ))
    }

    function om(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-unrecognized-symbol", {
            symbol: e
        }))
    }

    function am() {
        return new C(S(
            "shared-calculator-error-unexpected-inequality"
        ))
    }

    function hb() {
        return new C(S(
            "shared-calculator-error-unexpected-equality"
        ))
    }

    function Nr(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-unexpected-symbol", {
            symbol: e
        }))
    }

    function bb(e) {
        return new C(S(
            "shared-calculator-error-add-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function xb(e) {
        return new C(S(
            "shared-calculator-error-subtract-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function qp(e) {
        return new C(S(
            "shared-calculator-error-multiply-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function $p(e) {
        return new C(S(
            "shared-calculator-error-multiply-type-error-cross", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Yp(e) {
        return new C(S(
            "shared-calculator-error-multiply-type-error-2d", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Xp(e) {
        return new C(S(
            "shared-calculator-error-multiply-type-error-3d", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Pb(e) {
        return new C(S(
            "shared-calculator-error-divide-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Tb(e) {
        return new C(S(
            "shared-calculator-error-exponent-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Ib(e) {
        return new C(S(
            "shared-calculator-error-negative-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function Eb() {
        return new C(S(
            "shared-calculator-error-mixed-comparator-chain"
        ))
    }

    function Mb() {
        return new C(S(
            "shared-calculator-error-unplottable-long-inequality-chain"
        ))
    }

    function vb(e) {
        return new C(S(
            "shared-calculator-error-comparator-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Db(e) {
        return new C(S(
            "shared-calculator-error-operator-type-error", {
            symbol: "and",
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Sb(e) {
        return new C(S(
            "shared-calculator-error-operator-type-error", {
            symbol: "or",
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function ec(e) {
        return new C(S(
            "shared-calculator-error-list-type-error", {
            symbol1: e[
                0]
        })).allowExport()
    }

    function Ob(e) {
        return new C(S(
            "shared-calculator-error-point-type-error", {
            symbol1: e,
            symbol2: ne(
                R)
        })).allowExport()
    }

    function Zp(e) {
        return new C(S(
            "shared-calculator-error-index-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Cb(e) {
        return new C(S(
            "shared-calculator-error-ordered-pair-access-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function Pi(e, t) {
        switch (t.length) {
            case 1:
                return new C(S(
                    "shared-calculator-error-function-type-error-1", {
                    fn: X(
                        e),
                    arg: t[
                        0]
                }))
                    .allowExport();
            case 2:
                return new C(S(
                    "shared-calculator-error-function-type-error-2", {
                    fn: X(
                        e),
                    arg1: t[
                        0],
                    arg2: t[
                        1]
                }))
                    .allowExport();
            default:
                return new C(S(
                    "shared-calculator-error-function-type-error-many", {
                    fn: X(
                        e)
                }))
                    .allowExport()
        }
    }
    var ab = {
        translate: "translation",
        rotate: "rotation",
        dilate: "dilation",
        reflect: "reflection"
    };

    function Rb(e, t, n) {
        let r = [];
        if (!Array.isArray(n))
            return Pi(e, t);
        for (let s = 1; s < n
            .length; s++) {
            let o = n[s];
            typeof o == "number" ? r
                .push(ne(o)) : r
                    .push(ne(o.types[
                        0]))
        }
        let i = "";
        switch (r.length) {
            case 1:
                i = S(t.length > r
                    .length ?
                    "shared-calculator-error-transformation-definition-expected-types-use-fewer-1" :
                    "shared-calculator-error-transformation-definition-expected-types-1", {
                    arg: r[
                        0]
                });
                break;
            case 2:
                i = S(t.length > r
                    .length ?
                    "shared-calculator-error-transformation-definition-expected-types-use-fewer-2" :
                    "shared-calculator-error-transformation-definition-expected-types-2", {
                    arg1: r[
                        0],
                    arg2: r[
                        1]
                });
                break
        }
        switch (t.length) {
            case 1:
                return new C(S(t
                    .length <
                    r
                        .length ?
                    "shared-calculator-error-transformation-definition-type-error-use-more-1" :
                    "shared-calculator-error-transformation-definition-type-error-1", {
                    fn: X(ab[
                        e]),
                    arg: t[
                        0],
                    expectedTypeMessage: i
                }));
            case 2:
                return new C(S(t
                    .length <
                    r
                        .length ?
                    "shared-calculator-error-transformation-definition-type-error-use-more-2" :
                    "shared-calculator-error-transformation-definition-type-error-2", {
                    fn: X(ab[
                        e]),
                    arg1: t[
                        0],
                    arg2: t[
                        1],
                    expectedTypeMessage: i
                }));
            default:
                return new C(S(
                    "shared-calculator-error-transformation-definition-type-error-many", {
                    fn: X(ab[
                        e])
                }))
        }
    }

    function Nb(e, t) {
        switch (t.length) {
            case 1:
                return new C(S(
                    "shared-calculator-error-transformation-type-error-1", {
                    fn: X(
                        e),
                    arg: t[
                        0]
                }))
                    .allowExport();
            case 2:
                return new C(S(
                    "shared-calculator-error-transformation-type-error-2", {
                    fn: X(
                        e),
                    arg1: t[
                        0],
                    arg2: t[
                        1]
                }))
                    .allowExport();
            default:
                return new C(S(
                    "shared-calculator-error-transformation-type-error-many", {
                    fn: X(
                        e)
                }))
                    .allowExport()
        }
    }

    function Ab(e, t) {
        let n = X(e),
            r = X("count");
        return new C(S(
            "shared-calculator-error-geometry-length-type-error", {
            fn: n,
            alternativeFn: r,
            arg: t
        })).allowExport()
    }

    function _b(e, t) {
        let n = X(e),
            r = X("count");
        return new C(S(
            "shared-calculator-error-3d-length-type-error", {
            fn: n,
            alternativeFn: r,
            arg: t
        })).allowExport()
    }

    function Wp(e) {
        return new C(S(
            "shared-calculator-error-illegal-dot-call", {
            symbol: X(e)
        }))
    }

    function Lb(e, t) {
        return new C(S(
            "shared-calculator-error-dot-lhs-type-error", {
            symbol: X(
                e),
            type: t
        })).allowExport()
    }

    function wb(e) {
        return new C(S(
            "shared-calculator-error-sum-lower-bound-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function Fb(e) {
        return new C(S(
            "shared-calculator-error-sum-upper-bound-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function um() {
        return new C(S(
            "shared-calculator-error-sum-infinite-bound-type-error"
        ))
    }

    function Vb(e) {
        return new C(S(
            "shared-calculator-error-sum-argument-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function Bb(e) {
        return new C(S(
            "shared-calculator-error-product-lower-bound-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function Gb(e) {
        return new C(S(
            "shared-calculator-error-product-upper-bound-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function cm() {
        return new C(S(
            "shared-calculator-error-product-infinite-bound-type-error"
        ))
    }

    function kb(e) {
        return new C(S(
            "shared-calculator-error-product-argument-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function zb(e) {
        return new C(S(
            "shared-calculator-error-integral-lower-bound-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function Hb(e) {
        return new C(S(
            "shared-calculator-error-integral-upper-bound-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function Ub(e) {
        return new C(S(
            "shared-calculator-error-integral-argument-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function qb(e) {
        return new C(S(
            "shared-calculator-error-derivative-type-error", {
            symbol: e[0]
        })).allowExport()
    }

    function $b(e, t) {
        return new C(S(
            "shared-calculator-error-derivative-variable-type-error", {
            symbol1: X(
                e),
            symbol2: t[
                0]
        }))
    }

    function lm(e) {
        return new C(S(
            "shared-calculator-error-piecewise-condition-type-error", {
            symbol1: ne(
                ge),
            symbol2: e[
                0]
        })).allowExport()
    }

    function Yb(e) {
        return new C(S(
            "shared-calculator-error-piecewise-branch-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function Xb(e) {
        return new C(S(
            "shared-calculator-error-table-header-type-error", {
            symbol: e[0]
        }))
    }

    function Zb(e) {
        return new C(S(
            "shared-calculator-error-table-entry-type-error", {
            symbol: e[0]
        }))
    }

    function Wb(e) {
        return new C(S(
            "shared-calculator-error-regression-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        }))
    }

    function jb(e) {
        return new C(S(
            "shared-calculator-error-update-rule-type-error", {
            symbol: e
        }))
    }

    function Jb() {
        return new C(S(
            "shared-calculator-error-update-rule-non-identifier-lhs", {
            arrow: "",
            example: "a"
        }))
    }

    function Qb(e) {
        return new C(S(
            "shared-calculator-error-duplicate-update-rules", {
            symbol: X(e)
        }))
    }

    function Kb(e) {
        return new C(S(
            "shared-calculator-error-update-rule-undefined-lhs", {
            symbol: X(e)
        }))
    }

    function ex(e) {
        return new C(S(
            "shared-calculator-error-update-rule-illegal-lhs", {
            symbol: X(e)
        }))
    }

    function pm(e) {
        return new C(S(
            "shared-calculator-error-update-rule-function-lhs", {
            symbol: X(e)
        }))
    }

    function fm(e) {
        return new C(S(
            "shared-calculator-error-update-rule-local-lhs", {
            symbol: X(e)
        }))
    }

    function tx(e) {
        let t = e.filter(n => n
            .scope === "free")
            .map(n => n.symbol);
        return new C(S(
            "shared-calculator-error-action-merge-free-variable", {
            symbol: X(t[
                0] ||
                "")
        })).setDependencies(
            t).allowExport()
    }

    function jp(e) {
        return new C(S(
            "shared-calculator-error-event-handler-type-error", {
            example: "aa+1"
        }))
    }

    function Jp() {
        return new C(S(
            "shared-calculator-error-heterogeneous-list"
        )).allowExport()
    }

    function dm(e) {
        return new C(S(
            "shared-calculator-error-combine-type-error", {
            symbol1: e[
                0],
            symbol2: e[
                1]
        })).allowExport()
    }

    function cl(e) {
        return new C(S(
            "shared-calculator-error-log-scale-type-error", {
            symbol: e
        })).allowExport()
    }

    function nx() {
        return new C(S(
            "shared-calculator-error-log-scale-histogram"
        ))
    }

    function rx() {
        return new C(S(
            "shared-calculator-error-log-scale-dot-plot"
        ))
    }

    function ix() {
        return new C(S(
            "shared-calculator-error-log-scale-box-plot"
        ))
    }

    function sx() {
        return new C(S(
            "shared-calculator-error-deeply-nested"
        )).allowExport()
    }

    function ox() {
        return new C(S(
            "shared-calculator-error-3d-multiple-equality-restrictions"
        )).allowExport()
    }

    function ax() {
        return new C(S(
            "shared-calculator-error-3d-mixed-restriction-equation"
        )).allowExport()
    }

    function Bo() {
        return new C(S(
            "shared-calculator-error-3d-bad-equality-slice"
        )).allowExport()
    }

    function tc(e) {
        return new C(S(
            "shared-calculator-error-gpu-variable-list-length", {
            symbol: X(e
                .filter(
                    t =>
                        t
                            .symbol !==
                        "globalRandomSeed"
                )[
                0
            ]
                .symbol
            )
        }))
    }

    function mm(e) {
        return new C(S(
            "shared-calculator-error-gpu-variable-sum", {
            symbol: X(e[
                0]
                .symbol
            )
        }))
    }

    function ym(e) {
        return new C(S(
            "shared-calculator-error-gpu-variable-product", {
            symbol: X(e[
                0]
                .symbol
            )
        }))
    }

    function ll(e) {
        return new C(S(
            "shared-calculator-error-gpu-function-unsupported", {
            symbol: X(e)
        }))
    }

    function ux() {
        return new C(S(
            "shared-calculator-error-gpu-integral-unsupported"
        ))
    }

    function cx() {
        return new C(S(
            "shared-calculator-error-gpu-long-sum", {
            maxTermCount: 1e3
                .toLocaleString()
        }))
    }

    function lx() {
        return new C(S(
            "shared-calculator-error-gpu-long-product", {
            maxTermCount: 1e3
                .toLocaleString()
        }))
    }

    function pl() {
        return new C(S(
            "shared-calculator-error-gpu-max-list-size", {
            maxListSize: 100
                .toLocaleString()
        }))
    }

    function Qp() {
        return new C(S(
            "shared-calculator-error-max-list-size", {
            maxListSize: 1e4
                .toLocaleString()
        })).allowExport()
    }

    function Kp() {
        return new C(S(
            "shared-calculator-error-two-numbers-error"
        ))
    }

    function px() {
        return new C(S(
            "shared-calculator-error-boxplot-offset-invalid"
        ))
    }

    function fx() {
        return new C(S(
            "shared-calculator-error-boxplot-breadth-invalid"
        ))
    }

    function gm(e, t) {
        return new C(S(
            "shared-calculator-error-too-many-arguments", {
            symbol: e,
            max: t
        }))
    }

    function dx() {
        var e = S(
            "shared-calculator-error-pdf-wrong-arity-recommendation"
        ),
            t = S(
                "shared-calculator-error-pdf-wrong-arity", {
                recommendation: e
            });
        return new C(t)
    }

    function mx() {
        var e = S(
            "shared-calculator-error-cdf-wrong-arity-recommendation"
        ),
            t = S(
                "shared-calculator-error-cdf-wrong-arity", {
                recommendation: e
            });
        return new C(t)
    }

    function yx() {
        var e = S(
            "shared-calculator-error-cdf-too-many-arguments-recommendation"
        ),
            t = S(
                "shared-calculator-error-cdf-too-many-arguments", {
                recommendation: e
            });
        return new C(t)
    }

    function gx() {
        return new C(S(
            "shared-calculator-error-tdist-wrong-arity"
        ))
    }

    function hx() {
        return new C(S(
            "shared-calculator-error-random-arity"
        ))
    }

    function bx() {
        return new C(S(
            "shared-calculator-error-random-from-broadcast-distribution"
        ))
    }

    function xx(e) {
        var t = e === "rgb" ? [150,
            30, 100
        ] : [180, .5, .5],
            n = S(
                "shared-calculator-error-color-arity-recommendation", {
                recommendation: X(
                    e) +
                    "(" + t
                        .join(
                            ", ") + ")"
            }),
            r = S(
                "shared-calculator-error-color-arity", {
                symbol: e,
                recommendation: n
            });
        return new C(r)
    }

    function ds(e, t, n, r) {
        e = X(e);
        var i, s;
        if (t === 1) r || (r = e +
            "(x)"), s = S(
                "shared-calculator-error-wrong-arity-supplement", {
                recommendation: r
            }), n > 1 ? i = S(
                "shared-calculator-error-wrong-arity-single-arg-too-many", {
                dependency: e,
                supplement: s
            }) : i = S(
                "shared-calculator-error-wrong-arity-single-arg-too-few", {
                dependency: e,
                supplement: s
            });
        else {
            var o = [];
            if (!r) {
                for (var a = 0; a <
                    t; a++) o[a] =
                        a + 1;
                r = X(e) + "(" + o
                    .join(", ") +
                    ")"
            }
            s = S("shared-calculator-error-wrong-arity-supplement", {
                recommendation: r
            }), i = S(
                "shared-calculator-error-wrong-arity-many-arg", {
                dependency: e,
                assignment_arity: t,
                supplement: s
            })
        }
        return new C(i)
    }

    function Px(e) {
        return new C(S(
            "shared-calculator-error-wrong-two-arg-arity", {
            symbol: X(
                e),
            recommendation: X(
                e) +
                "([1,2,3], 1)"
        }))
    }

    function ef(e) {
        return new C(S(
            "shared-calculator-error-wrong-two-arg-arity", {
            symbol: X(
                e),
            recommendation: X(
                e) +
                "([1,2,3], [3,2,1])"
        }))
    }

    function nc() {
        return new C(S(
            "shared-calculator-error-primed-function-arity"
        ))
    }

    function Tx(e) {
        return new C(S(
            "shared-calculator-error-zero-arg-reducer", {
            symbol: X(e)
        }))
    }

    function Ix() {
        return new C(S(
            "shared-calculator-error-malformed-point"
        ))
    }

    function Ex() {
        return new C(S(
            "shared-calculator-error-malformed-list"
        ))
    }

    function Mx(e) {
        return new C(S(
            "shared-calculator-error-bad-tuple-dimensions", {
            symbol: e
        }))
    }

    function hm(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-bad-implicit-call", {
            symbol: e
        }))
    }

    function vx(e, t) {
        return new C(S(
            "shared-calculator-error-adjacent-numbers", {
            left: e,
            right: t
        }))
    }

    function bm(e) {
        return new C(S(
            "shared-calculator-error-adjacent-mixed-number", {
            mixedNumber: e
        }))
    }

    function Dx() {
        return new C(S(
            "shared-calculator-error-token-with-subscript"
        ))
    }

    function Sx(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-identifier-as-function", {
            symbol: e
        }))
    }

    function Ox(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-identifier-is-not-function", {
            symbol: e
        }))
    }

    function tf(e) {
        return e = X(e), e ===
            "%" && (e = "% of"),
            new C(S("shared-calculator-error-binary-operator-missing-operand", {
                symbol: e
            }))
    }

    function Cx(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-unary-operator-missing-left", {
            symbol: e
        }))
    }

    function Rx(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-unary-operator-missing-right", {
            symbol: e
        }))
    }

    function Nx() {
        return new C(S(
            "shared-calculator-error-fraction-missing-numerator"
        ))
    }

    function Ax() {
        return new C(S(
            "shared-calculator-error-fraction-missing-denominator"
        ))
    }

    function _x() {
        return new C(S(
            "shared-calculator-error-fraction-empty"
        ))
    }

    function xm() {
        return new C(S(
            "shared-calculator-error-empty-subscript"
        ))
    }

    function Lx() {
        return new C(S(
            "shared-calculator-error-empty-superscript"
        ))
    }

    function wx(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-invalid-subscript", {
            symbol: e
        }))
    }

    function Fx() {
        return new C(S(
            "shared-calculator-error-invalid-operator-name"
        ))
    }

    function Vx() {
        return new C(S(
            "shared-calculator-error-unexpected-subscript"
        ))
    }

    function Bx() {
        return new C(S(
            "shared-calculator-error-superscript-with-prime"
        ))
    }

    function Pm() {
        return new C(S(
            "shared-calculator-error-unexpected-prime"
        ))
    }

    function Tm() {
        return new C(S(
            "shared-calculator-error-prime-without-paren"
        ))
    }

    function Gx() {
        return new C(S(
            "shared-calculator-error-empty-radical"
        ))
    }

    function kx() {
        return new C(S(
            "shared-calculator-error-empty-radical-index"
        ))
    }

    function zx() {
        return new C(S(
            "shared-calculator-error-empty-paren"
        ))
    }

    function Hx() {
        return new C(S(
            "shared-calculator-error-empty-square-bracket"
        ))
    }

    function Ux() {
        return new C(S(
            "shared-calculator-error-empty-pipe"
        ))
    }

    function qx(e) {
        var t = e + "^2",
            n = e + "^-1";
        return new C(S(
            "shared-calculator-error-bad-trig-exponent", {
            form1: t,
            form2: n
        }))
    }

    function $x(e) {
        var t = e + "^2";
        return new C(S(
            "shared-calculator-error-bad-log-exponent", {
            form: t
        }))
    }

    function Yx() {
        return new C(S(
            "shared-calculator-error-piecewise-missing-condition"
        ))
    }

    function Xx() {
        return new C(S(
            "shared-calculator-error-piecewise-part-missing-condition"
        ))
    }

    function Zx() {
        return new C(S(
            "shared-calculator-error-colon-missing-condition"
        ))
    }

    function nf() {
        return new C(S(
            "shared-calculator-error-blank-expression"
        ))
    }

    function Im(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-function-not-defined", {
            dependency: e
        }))
    }

    function Em(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-parameter-already-defined", {
            dependency: e
        }))
    }

    function Wx(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-duplicate-function-parameter", {
            dependency: e
        }))
    }

    function jx(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-function-name-as-parameter", {
            dependency: e
        }))
    }

    function fl(e, t) {
        return e = X(e), t ===
            void 0 ? new C(S(
                "shared-calculator-error-cannot-redefine", {
                symbol: e
            })) : new C(S(
                "shared-calculator-error-cannot-redefine-root", {
                symbol: e,
                symbolRoot: t
            }))
    }

    function Jx(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-cannot-subscript", {
            symbol: e
        }))
    }

    function dl(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-multiply-defined", {
            dependency: e
        }))
    }

    function Qx(e) {
        let t = dl(e);
        return t
            .isMultiplyDefinedByTables = !
            0, t
    }

    function Mm(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-shadowed-index", {
            symbol: e
        }))
    }

    function vm(e) {
        e = e.map(X);
        var t = e.pop() || "";
        return new C(S(
            "shared-calculator-error-dependency-cycle", {
            symbols: e
                .join(
                    "', '"
                ),
            lastSymbol: t
        }))
    }

    function Kx(e) {
        let t = vm(e);
        return t
            .isTableCycleWithoutGlobalDefinition = !
            0, t
    }

    function $a(e) {
        let t = e.length,
            n = e[0];
        return new C(S(
            "shared-calculator-error-self-referential-functions", {
            symbols: e
                .slice(
                    1)
                .map(
                    r =>
                        X(r)
                )
                .join(
                    "', '"
                ),
            lastSymbol: X(
                n),
            count: kp(t)
        }))
    }

    function eP() {
        return new C(S(
            "shared-calculator-error-ticker-min-step-nonnegative"
        ))
    }

    function tP(e) {
        return new C(S(
            "shared-calculator-error-slider-limit-references-export", {
            symbol: X(e)
        }))
    }

    function nP() {
        return new C(S(
            "shared-calculator-error-slider-min-invalid"
        ))
    }

    function rP() {
        return new C(S(
            "shared-calculator-error-slider-max-invalid"
        ))
    }

    function iP() {
        return new C(S(
            "shared-calculator-error-slider-max-less-than-min"
        ))
    }

    function sP() {
        return new C(S(
            "shared-calculator-error-slider-step-invalid"
        ))
    }

    function oP() {
        return new C(S(
            "shared-calculator-error-domain-min-invalid"
        ))
    }

    function aP() {
        return new C(S(
            "shared-calculator-error-domain-max-invalid"
        ))
    }

    function uP() {
        return new C(S(
            "shared-calculator-error-domain-max-less-than-min"
        ))
    }

    function cP() {
        return new C(S(
            "shared-calculator-error-cdf-min-invalid"
        ))
    }

    function lP() {
        return new C(S(
            "shared-calculator-error-cdf-max-invalid"
        ))
    }

    function pP() {
        return new C(S(
            "shared-calculator-error-cdf-max-less-than-min"
        ))
    }

    function fP() {
        return new C(S(
            "shared-calculator-error-use-rho-for-spherical-coordinates"
        ))
    }

    function dP() {
        return new C(S(
            "shared-calculator-error-use-r-for-cylindrical-coordinates"
        ))
    }

    function Dm() {
        return new C(S(
            "shared-calculator-error-cant-combine-spherical-and-cylindrical"
        ))
    }

    function tn(e) {
        if (e = e.map(X), e
            .length === 0)
            return new C(S(
                "shared-calculator-error-too-many-variables-no-symbols"
            ));
        var t = e.pop() || "";
        return e.length > 0 ? new C(
            S("shared-calculator-error-too-many-variables-many-symbols", {
                variables: e
                    .join(
                        "', '"
                    ),
                lastVariable: t
            })) : new C(S(
                "shared-calculator-error-too-many-variables-one-symbol", {
                variable: t
            }))
    }

    function mP(e) {
        return new C(S(
            "shared-calculator-error-cannot-restrict", {
            variable: X(
                e)
        }))
    }

    function yP(e) {
        return new C(S(
            "shared-calculator-error-cannot-assign-color", {
            variable: X(
                e)
        }))
    }

    function gP(e) {
        return new C(S(
            "shared-calculator-error-cannot-restrict-with-equality", {
            variable: X(
                e)
        }))
    }

    function rf(e, t, n) {
        e = e.map(X), t = X(t), n =
            n.map(X);
        var r = t + "(" + n.join(
            ",") + "," + e.join(
                ",") + ")",
            i = e.pop() || "",
            s = {
                symbols: e.join(
                    "', '"),
                lastSymbol: i,
                newSignature: r
            };
        return e.length ? new C(S(
            "shared-calculator-error-add-arguments-to-definition-many",
            s)) : new C(S(
                "shared-calculator-error-add-arguments-to-definition-one",
                s))
    }

    function hP(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-invalid-lhs", {
            symbol: e
        }))
    }

    function bP() {
        return new C(S(
            "shared-calculator-error-unplottable-polar-function"
        ))
    }

    function xP() {
        return new C(S(
            "shared-calculator-error-invalid-inequality-variables"
        ))
    }

    function rc() {
        return new C(S(
            "shared-calculator-error-invalid-implicit-variables"
        ))
    }

    function PP() {
        return new C(S(
            "shared-calculator-error-invalid-implicit-variables-3d"
        ))
    }

    function TP() {
        return new C(S(
            "shared-calculator-error-single-variable-implicit-equations-disabled"
        ))
    }

    function IP() {
        return new C(S(
            "shared-calculator-error-implicits-disabled"
        ))
    }

    function Sm() {
        return new C(S(
            "shared-calculator-error-inequalities-disabled"
        ))
    }

    function EP() {
        return new C(S(
            "shared-calculator-error-complicated-polar-implicit"
        ))
    }

    function MP() {
        return new C(S(
            "shared-calculator-error-invalid-double-inequality-3d"
        ))
    }

    function vP() {
        return new C(S(
            "shared-calculator-error-invalid-double-equality-3d"
        ))
    }

    function DP() {
        return new C(S(
            "shared-calculator-error-unplottable-chained-equality"
        ))
    }

    function Om() {
        return new C(S(
            "shared-calculator-error-invalid-double-inequality-variables"
        ))
    }

    function Cm() {
        return new C(S(
            "shared-calculator-error-mismatched-double-inequality", {
            example: "1 < y < 2"
        }))
    }

    function Rm() {
        return new C(S(
            "shared-calculator-error-complicated-double-inequality"
        ))
    }

    function Nm(e) {
        return e ? (e = X(e), new C(
            S("shared-calculator-error-equation-required-symbol", {
                lhs: e +
                    "="
            }))) : new C(S(
                "shared-calculator-error-equation-required"
            ))
    }

    function Am(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-variable-as-function", {
            dependency: e
        }))
    }

    function _m(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-distribution-as-function", {
            symbol: e
        }))
    }

    function SP(e) {
        return new C(S(
            "shared-calculator-error-invalid-table-header", {
            supplement: e
        }))
    }

    function ml(e) {
        return new C(S(
            "shared-calculator-error-invalid-table-entry", {
            supplement: e
        }))
    }

    function OP() {
        return new C(S(
            "shared-calculator-error-invalid-first-table-column", {
            most: "'y', 'r',",
            last: "''"
        }))
    }

    function OL() {
        return new C(S(
            "shared-calculator-error-invalid-dependent-first-table-column"
        ))
    }

    function CP(e) {
        return new C(S(
            "shared-calculator-error-invalid-regression-parameter", {
            symbol: X(e)
        }))
    }

    function RP() {
        return new C(S(
            "shared-calculator-error-optimization-error"
        ))
    }

    function sf(e) {
        return new C(S(
            "shared-calculator-error-non-list-double-reducer", {
            symbol: X(
                e),
            recommendation: X(
                e) +
                "([1,2,3], [3,2,1])"
        })).allowExport()
    }

    function NP(e) {
        return new C(S(
            "shared-calculator-error-non-list-parameterized-reducer", {
            symbol: X(
                e),
            recommendation: X(
                e) +
                "([1,2,3], 1)"
        })).allowExport()
    }

    function As(e) {
        return new C(S(
            "shared-calculator-error-method-requires-list", {
            symbol: X(
                e),
            recommendation: X(
                e) +
                "([1,2,3])"
        })).allowExport()
    }

    function CL(e, t) {
        return new C(S(
            "shared-calculator-error-variable-function-free-variable", {
            functionSymbol: e,
            variableSymbol: t
        })).allowExport()
    }

    function of() {
        return new C(S(
            "shared-calculator-error-non-arithmetic-range"
        )).allowExport()
    }

    function AP() {
        return new C(S(
            "shared-calculator-error-invalid-half-empty-range"
        ))
    }

    function _P() {
        return new C(S(
            "shared-calculator-error-sum-missing-bound"
        ))
    }

    function LP() {
        return new C(S(
            "shared-calculator-error-product-missing-bound"
        ))
    }

    function wP() {
        return new C(S(
            "shared-calculator-error-incorrect-sum-lower-bound"
        ))
    }

    function FP() {
        return new C(S(
            "shared-calculator-error-incorrect-product-lower-bound"
        ))
    }

    function VP(e) {
        return new C(S(
            "shared-calculator-error-bad-sum-bound-dependency", {
            symbol: X(e)
        }))
    }

    function BP(e) {
        return new C(S(
            "shared-calculator-error-bad-product-bound-dependency", {
            symbol: X(e)
        }))
    }

    function GP() {
        return new C(S(
            "shared-calculator-error-integral-missing-bound"
        ))
    }

    function kP() {
        return new C(S(
            "shared-calculator-error-integral-missing-differential"
        ))
    }

    function zP() {
        return new C(S(
            "shared-calculator-error-differential-with-superscript"
        ))
    }

    function HP() {
        return new C(S(
            "shared-calculator-error-sum-missing-body"
        ))
    }

    function UP() {
        return new C(S(
            "shared-calculator-error-product-missing-body"
        ))
    }

    function qP() {
        return new C(S(
            "shared-calculator-error-integral-missing-body"
        ))
    }

    function $P() {
        return new C(S(
            "shared-calculator-error-derivative-missing-body"
        ))
    }

    function YP(e, t) {
        return e = X(e), t = X(t),
            new C(S("shared-calculator-error-mismatched-braces", {
                symbol1: e,
                symbol2: t
            }))
    }

    function Lm(e) {
        return new C(S(
            "shared-calculator-error-shadowed-integration-variable", {
            symbol: X(e)
        }))
    }

    function XP(e) {
        return new C(S(
            "shared-calculator-error-bad-integral-bound-dependency", {
            symbol: X(e)
        }))
    }

    function ZP() {
        return new C(S(
            "shared-calculator-error-percent-missing-of"
        ))
    }

    function af(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-illegal-bin-width", {
            symbol: e
        }))
    }

    function yl(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-ttest-list-too-short", {
            symbol: e
        }))
    }

    function WP() {
        return new C(S(
            "shared-calculator-error-bad-sample-size"
        ))
    }

    function jP(e) {
        return new C(S(
            "shared-calculator-error-variable-seed", {
            symbol: X(e[
                0]
                .symbol
            )
        })).setDependencies(
            e.filter(t => t
                .scope ===
                "free").map(t =>
                    t.symbol))
            .allowExport()
    }

    function uf(e) {
        return new C(S(
            "shared-calculator-error-bad-symbol-context", {
            symbol: X(e)
        }))
    }

    function wm() {
        return new C(S(
            "shared-calculator-error-write-integral", {
            command: "integral",
            symbol: ""
        }))
    }

    function JP() {
        return new C(S(
            "shared-calculator-error-ans-undefined"
        ))
    }

    function cf(e) {
        return new C(S(
            "shared-calculator-error-variables-unsupported", {
            variable: X(
                e)
        }))
    }

    function Fm() {
        return new C(S(
            "shared-calculator-error-polygon-unsupported-in-3d"
        ))
    }

    function ms(e, t = !1) {
        return t && e ===
            "polygon" ? Fm() :
            new C(S("shared-calculator-error-function-unsupported", {
                symbol: X(e)
            }))
    }

    function QP() {
        return new C(S(
            "shared-calculator-error-logbase-unsupported"
        ))
    }

    function ic(e) {
        return new C(S(
            "shared-calculator-error-constant-unsupported", {
            symbol: X(e)
        }))
    }

    function Vm(e) {
        return new C(S(
            "shared-calculator-error-variable-unsupported", {
            symbol: X(e)
        }))
    }

    function Bm(e) {
        return new C(S(
            "shared-calculator-error-variable-invalid-function-name", {
            symbol: X(e)
        }))
    }

    function lf() {
        return new C(S(
            "shared-calculator-error-assignments-unsupported"
        ))
    }

    function pf() {
        return new C(S(
            "shared-calculator-error-function-definition-unsupported"
        ))
    }

    function ma() {
        return new C(S(
            "shared-calculator-error-equations-unsupported"
        ))
    }

    function sc() {
        return new C(S(
            "shared-calculator-error-inequalities-unsupported"
        ))
    }

    function oc() {
        return new C(S(
            "shared-calculator-error-regressions-unsupported"
        ))
    }

    function ac() {
        return new C(S(
            "shared-calculator-error-points-unsupported"
        ))
    }

    function ff() {
        return new C(S(
            "shared-calculator-error-feature-unavailable"
        ))
    }

    function Gm() {
        return new C(S(
            "basic-calculator-error-fractions-unavailable"
        ))
    }

    function RL() {
        return new C(S(
            "shared-calculator-error-non-square-determinant"
        ))
    }

    function NL() {
        return new C(S(
            "shared-calculator-error-non-square-trace"
        ))
    }

    function AL() {
        return new C(S(
            "shared-calculator-error-non-square-inverse"
        ))
    }

    function _L() {
        return new C(S(
            "shared-calculator-error-non-singular-inverse"
        ))
    }

    function LL(e) {
        return new C(S(
            "shared-calculator-error-clickable-object-assignment-not-defined", {
            symbol: e
        }))
    }

    function wL(e) {
        return new C(S(
            "shared-calculator-error-multiply-defined", {
            dependency: e
        }))
    }

    function FL() {
        return new C(S(
            "shared-calculator-error-clickable-object-assignment-not-identifier"
        ))
    }

    function VL() {
        return new C(S(
            "shared-calculator-error-clickable-object-invalid-expression"
        ))
    }

    function BL() {
        return new C(S(
            "shared-calculator-error-matrix-assignment"
        ))
    }

    function GL() {
        return new C(S(
            "shared-calculator-error-matrix-add-dimensions"
        ))
    }

    function kL() {
        return new C(S(
            "shared-calculator-error-matrix-subtract-dimensions"
        ))
    }

    function zL() {
        return new C(S(
            "shared-calculator-error-matrix-multiply-dimensions"
        ))
    }

    function HL() {
        return new C(S(
            "shared-calculator-error-matrix-fractional-power"
        ))
    }

    function UL() {
        return new C(S(
            "shared-calculator-error-matrix-power-dimensions"
        ))
    }

    function qL(e) {
        return new C(S(
            "shared-calculator-error-matrix-element-type-error", {
            arg: e[0]
        }))
    }

    function $L(e) {
        return new C(S(
            "shared-calculator-error-matrix-invalid-variable", {
            symbol: X(e)
        }))
    }

    function KP(e, t, n) {
        let r = "[1...10]";
        return n && !/[\\]/.test(
            n) && (r = `[${n}]`),
            new C(S("shared-calculator-error-list-comprehension-input-type-error", {
                identifier: e,
                actual: t,
                example: r
            })).allowExport()
    }

    function eT() {
        return new C(S(
            "shared-calculator-error-incorrect-list-comprehension-input"
        ))
    }

    function km(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-shadowed-list-comprehension-input", {
            symbol: e
        }))
    }

    function tT(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-bad-for-input-list-dependency", {
            symbol: e
        }))
    }

    function nT(e) {
        return e = X(e), new C(S(
            "shared-calculator-error-bad-for-interval-dependency", {
            symbol: e
        }))
    }

    function rT(e) {
        let t = e.filter(n => n
            .scope === "free")
            .map(n => n.symbol);
        return new C(S(
            "shared-calculator-error-variable-length-top-level-list", {
            symbol: X(t[
                0] ||
                "")
        })).setDependencies(
            t).allowExport()
    }

    function df(e) {
        return new C(S(
            "shared-calculator-error-variable-length-distribution-list", {
            symbol: e[0]
                .symbol
        })).setDependencies(
            e.filter(t => t
                .scope ===
                "free").map(t =>
                    t.symbol))
    }

    function iT(e) {
        return new C(S(
            "shared-calculator-error-variable-length-sum-body-depends-on-index", {
            symbol: e
        }))
    }

    function sT(e) {
        return new C(S(
            "shared-calculator-error-variable-length-product-body-depends-on-index", {
            symbol: e
        }))
    }

    function oT(e) {
        return new C(S(
            "shared-calculator-error-variable-length-integral-depends-on-integration-var", {
            symbol: e
        }))
    }

    function YL(e, t) {
        return new C(S(
            "shared-calculator-error-substitution-type-error", {
            actual: ne(
                e),
            expected: ne(
                t)
        }))
    }

    function mf() {
        return new C(S(
            "shared-calculator-error-substitution-invalid-assignments"
        ))
    }

    function yf(e) {
        return new C(S(
            "shared-calculator-error-substitution-local-lhs", {
            symbol: X(e)
        }))
    }

    function gl(e) {
        return new C(S(
            "shared-calculator-error-substitution-illegal-lhs", {
            symbol: X(e)
        }))
    }

    function hl(e) {
        return new C(S(
            "shared-calculator-error-substitution-function-lhs", {
            symbol: X(e)
        }))
    }

    function aT(e, t, n) {
        return new C(S(
            "shared-calculator-error-substitution-body-regression-parameter-dependency", {
            globalVariable: X(
                e),
            regressionParameter: X(
                t),
            operator: n
        }))
    }

    function XL() {
        return new C(S(
            "shared-calculator-error-substitution-body-action"
        ))
    }

    function zm() {
        return new C(S(
            "shared-calculator-error-substitution-nested"
        ))
    }

    function Ya(e) {
        return new C(S(
            "shared-calculator-error-substitution-ambiguous-comma", {
            operation: e
        }))
    }

    function uT(e) {
        return new C(S(
            "shared-calculator-error-substitution-duplicate-assignment", {
            symbol: X(e)
        }))
    }

    function gf(e) {
        return new C(S(
            "shared-calculator-error-substitution-recursion-shadow", {
            symbol: X(e)
        }))
    }

    function cT() {
        return new C(S(
            "shared-calculator-error-depends-on-deleted-geo-object"
        ))
    }

    function lT(e) {
        return new C(S(
            "shared-calculator-error-invalid-interval-comprehension-return-type", {
            type: ne(e)
        }))
    }

    function pT(e, t) {
        return new C(S(
            "shared-calculator-error-bad-interval-comprehension-arity", {
            type: ne(e),
            count: kp(t)
        }))
    }

    function bl(e) {
        return new C(S(
            "shared-calculator-error-invalid-interval-comprehension-invalid-bound", {
            identifier: e
        }))
    }

    function fT() {
        return new C(S(
            "shared-calculator-error-nested-interval-comprehension"
        ))
    }

    function Hm() {
        return new C(S(
            "shared-calculator-error-substitution-unsupported-interval"
        ))
    }

    function ZL(e, t) {
        let n = Rr[e[0]]
            .direction === -1 ?
            new ni([t[1], t[0]]) :
            new ni([t[0], t[1]]);
        switch (e.length) {
            case 0:
                throw new Error(
                    "Programming Error: ComparatorChain must have at least one comparator"
                );
            case 1:
                return n;
            case 2:
                return new hr([
                    new qr[
                        e[1]
                    ](t
                        .slice(
                            1
                        )
                    ),
                    n,
                    new Zt(
                        NaN)
                ]);
            default:
                return new hr([
                    new Xa(e
                        .slice(
                            1
                        ),
                        t
                            .slice(
                                1
                            )
                    ),
                    n,
                    new Zt(
                        NaN)
                ])
        }
    }
    var Xa = class extends j {
        constructor(n, r) {
            super(r);
            this.symbols =
                n;
            if (n.length <
                1)
                throw "Programming Error: ComparatorChain must have at least one comparator.";
            if (r.length !==
                n.length + 1
            )
                throw "Programming Error: ComparatorChain must have one more arg than symbols";
            if (n.includes(
                "=") &&
                !n.every(
                    i =>
                        i ===
                        "="))
                throw Eb();
            this._difference =
                ZL(n, r)
        }
        isInequality() {
            return !this
                .symbols
                .includes(
                    "=")
        }
    };
    var Um = class extends Tt {
        constructor(t) {
            super();
            let [n, r, i, s,
                o
            ] = t;
            this.args = t,
                this
                    ._symbol = i
                    ._symbol,
                this
                    ._operators = [
                    r, s
                ], this
                    ._expressions = [
                    n, o
                ];
            var a = Qu(Rr[r]
                .inclusive &&
                Rr[t[3]]
                    .inclusive,
                Rr[t[1]]
                    .direction
            );
            this._indicator =
                new qr[a]([
                    t[
                    0],
                    t[4]
                ]), this
                    .addDependency(
                        this
                            ._symbol
                    ), this
                        .mergeDependencies(
                            this
                                ._expressions[
                            0],
                            this
                                ._expressions[
                            1])
        }
        isInequality() {
            return !0
        }
        isShadeBetween() {
            return !0
        }
    };
    var Za = class extends j {
        constructor(t) {
            super(t, {
                skipRegisterDependencies:
                    !
                    0
            }), this
                ._index = t[
                0], this
                    .registerDependencies()
        }
        registerDependencies() {
            for (let t =
                1; t <=
                3; t++) this
                    .mergeDependenciesInScope(
                        this
                            .type, [
                        this
                            ._index
                            ._symbol
                    ], this
                        .args[t]
                    )
        }
    };
    var xl = class extends Za {
        constructor() {
            super(...
                arguments
            );
            this.in_place_operator =
                "+=";
            this.starting_value =
                0
        }
        evaluateConstant(n) {
            var r = 1 + Math
                .round(n[
                    1]) - Math
                        .round(n[
                            0]);
            return r <= 0 ?
                this
                    .starting_value :
                r * n[2]
        }
        update(n, r) {
            return n + r
        }
    };
    var Pl = class extends Za {
        constructor() {
            super(...
                arguments
            );
            this.in_place_operator =
                "*=";
            this.starting_value =
                1
        }
        evaluateConstant(n) {
            var r = 1 + Math
                .round(n[
                    1]) - Math
                        .round(n[
                            0]);
            return r <= 0 ?
                this
                    .starting_value :
                Math.pow(n[
                    2],
                    r)
        }
        update(n, r) {
            return n * r
        }
    };
    var Tl = class extends j {
        constructor(t) {
            super(t, {
                skipRegisterDependencies:
                    !
                    0
            }), this
                ._differential =
                t[0], this
                    .registerDependencies()
        }
        registerDependencies() {
            for (let t =
                1; t <=
                3; t++) this
                    .mergeDependenciesInScope(
                        this
                            .type, [
                        this
                            ._differential
                            ._symbol
                    ], this
                        .args[t]
                    )
        }
    };
    var Il = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                t[0]
                    ._symbol,
                this._lhs =
                t[0], this
                    ._rhs = t[1]
        }
    };
    var ya = class extends j {
        constructor(n, r, i, s,
            o = []) {
            super([n, r]
                .concat(
                    i
                ), {
                skipRegisterDependencies:
                    !
                    0
            });
            this.shouldCoerceToList =
                s;
            this.parameters =
                o;
            this._index = n,
                this._body =
                r, this
                    ._inputLists =
                i, this
                    .registerDependencies()
        }
        registerDependencies() {
            var n = [];
            n.push(this
                ._index
                ._symbol
            );
            for (let r of
                this
                    ._inputLists) {
                let i = r
                    ._symbol;
                this.addSubstitutionSymbol(
                    i),
                    n.push(
                        i)
            }
            for (let r of
                this
                    .parameters) {
                let i = r
                    .identifier
                    ._symbol;
                n.push(i),
                    this
                        .addDependency(
                            i)
            }
            for (let r of
                this
                    ._inputLists)
                this
                    .mergeDependenciesInScope(
                        this
                            .type,
                        n, r
                            .args[1]
                    );
            for (let r of
                this
                    .parameters)
                this
                    .mergeDependenciesInScope(
                        this
                            .type,
                        n, r
                            .bounds[
                    0]),
                    this
                        .mergeDependenciesInScope(
                            this
                                .type,
                            n, r
                                .bounds[
                        1]);
            this.mergeDependenciesInScope(
                this
                    .type,
                n, this
                ._body)
        }
    };
    var Wa = class extends cn {
        constructor(t, n) {
            super(t, n),
                this.seed =
                n[0]
        }
    };
    var El = class extends j {
        registerDependencies() {
            if (super
                .registerDependencies(),
                this.args[0]
                    .type ===
                "Identifier"
            ) {
                var t = this
                    .args[0]
                    ._symbol;
                Ha(t) &&
                    this
                        .addDependency(
                            "trigAngleMultiplier"
                        )
            }
        }
    };
    var Ml = class extends j {
        registerDependencies() {
            if (this
                .addDependency(
                    "factorial"
                ), super
                    .registerDependencies(),
                this.args[0]
                    .type ===
                "Identifier"
            ) {
                var t = this
                    .args[0]
                    ._symbol;
                Ha(t) &&
                    this
                        .addDependency(
                            "trigAngleMultiplier"
                        )
            }
        }
    };
    var uc = class extends j {
        constructor(t, n) {
            super(n), this
                .order = t
        }
    };
    var vl = class extends j { };
    var cc = class extends j {
        constructor(t, n) {
            super(n),
                t instanceof ze ?
                    this
                        ._symbol = t
                        ._symbol :
                    this
                        ._symbol =
                    new ze(t)
                        ._symbol,
                this
                    .addDependency(
                        this
                            ._symbol
                    )
        }
    };
    var Dl = class extends j {
        constructor(t) {
            super(t, {
                skipRegisterDependencies:
                    !
                    0
            }), this
                ._symbol =
                t[0]
                    ._symbol,
                this
                    ._expression =
                t[1], this
                    .registerDependencies()
        }
        registerDependencies() {
            this.addUpdateSymbol(
                this
                    ._symbol
            ), this
                .mergeDependencies(
                    this
                        ._expression
                )
        }
    };
    var Go = class extends j {
        constructor(t, n) {
            super([t]
                .concat(
                    n
                ), {
                skipRegisterDependencies:
                    !
                    0
            }), this
                ._body = t,
                this
                    ._assignments =
                n, this
                    .registerDependencies()
        }
        registerDependencies() {
            for (var t = [],
                n =
                    0; n <
                this
                    ._assignments
                    .length; n++
            ) {
                var r = this
                    ._assignments[
                    n],
                    i = r
                        ._symbol;
                this.addSubstitutionSymbol(
                    i),
                    t.push(
                        i);
                var s = r
                    .args[
                    1];
                this.mergeDependencies(
                    s),
                    this
                        .addSubstitutionDependencies(
                            s
                                .getDependencies()
                        )
            }
            this.mergeDependenciesInScope(
                this
                    .type,
                t, this
                ._body)
        }
    };
    var Sl = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                "histogram"
        }
    };
    var Ol = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                "dotplot"
        }
    };
    var Cl = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                "boxplot"
        }
    };
    var Rl = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                "ttest"
        }
    };
    var Nl = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                "ittest"
        }
    };
    var Al = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                "stats"
        }
    };
    var ko = class extends Tt {
        constructor(t, n) {
            super(), this
                .mergeDependencies(
                    t, n),
                this._lhs =
                t, this
                    ._rhs = n,
                this
                    ._difference =
                new ni([this
                    ._lhs,
                this
                    ._rhs
                ])
        }
        asComparator() {
            return new qr[
                "="]([
                    this
                        ._lhs,
                    this
                        ._rhs
                ])
        }
    };
    var ga = class extends Tt {
        constructor(t, n) {
            super(),
                t instanceof ze ?
                    this
                        ._symbol = t
                        ._symbol :
                    this
                        ._symbol =
                    t, this
                        .mergeDependencies(
                            n), this
                                ._expression =
                n, this
                    ._exports =
                this
                    .computeExports()
        }
        shouldExportAns() {
            return !0
        }
        computeExports() {
            for (var t =
                this
                    ._symbol,
                n = this
                    .getDependencies(),
                r =
                    0; r < n
                        .length; r++
            )
                if (n[r] ===
                    t)
                    return [];
            return [t]
        }
        isEquation(t, n) {
            let r = this
                ._symbol,
                i = r ===
                    "x" || r ===
                    "y",
                s = r ===
                    "r" || r ===
                    "z",
                o = r ===
                    "rho",
                a = n
                    .getDependencies(),
                u = this
                    .graphmodeDependencies(
                        t, n);
            return o || s ||
                i && a
                    .includes(
                        "z") ? u
                            .includes(
                                r) : a
                                    .includes(r)
        }
        asEquation() {
            var t = new ko(
                new ze(
                    this
                        ._symbol
                ),
                this
                    ._expression
            );
            return t
                .userData =
                this
                    .userData, t
                        .metaData =
                this
                    .metaData, t
        }
        shouldPromoteToSlider(
            t) {
            if (!this
                ._expression
                .isConstant ||
                this
                    ._expression
                    .is_mixed_number
            ) return !1;
            let n = this
                ._expression
                .asValue();
            return typeof n !=
                "number" ||
                !isFinite(
                    n) ? !1 : t
                        .isValidSlider(
                            this
                                ._symbol
                        )
        }
    };
    var qm = class extends Tt {
        constructor(t, n) {
            super(), this
                ._symbols =
                t.args.map(
                    r => r
                        ._symbol
                ), this
                    ._expression =
                n, this
                    ._concatenatedSymbol =
                this
                    ._symbols
                    .join(""),
                this
                    .mergeDependencies(
                        n)
        }
        asEquation() {
            let t = new ko(
                new Qi(
                    this
                        ._symbols
                        .map(
                            n =>
                                new ze(
                                    n
                                )
                        )
                ),
                this
                    ._expression
            );
            return t
                .userData =
                this
                    .userData, t
                        .metaData =
                this
                    .metaData, t
        }
    };
    var cr = class extends Tt {
        constructor(n, r, i,
            s) {
            super();
            this.recursionInfo =
                s;
            this
                .externalBaseCases = [];
            this.isFunction = !
                0;
            this._symbol = n
                ._symbol,
                this
                    ._argSymbols =
                r.map(
                    function (
                        o) {
                        return o
                            ._symbol
                    });
            for (let o of
                this
                    ._argSymbols)
                if (o ===
                    this
                        ._symbol
                ) throw jx(
                    o
                );
            this._exports = [
                this
                    ._symbol
            ], this
                ._expression =
                i, this
                    .mergeDependenciesInScope(
                        this
                            .type, [
                                this
                                    ._symbol
                            ]
                                .concat(
                                    this
                                        ._argSymbols
                                ),
                        this
                            ._expression, {
                        functionDefinitionSymbol: this
                            ._symbol
                    }), this
                        .combinedDependencies =
                super
                    .getDependencies()
        }
        getDependencies() {
            return this
                .combinedDependencies
        }
        setExternalBaseCases(
            n) {
            this.externalBaseCases = [
                ...n
            ], this
                .combinedDependencies = [
                    ...super
                        .getDependencies()
                ];
            for (let r of
                n) {
                let i = r
                    .getRef();
                i && this
                    .combinedDependencies
                    .push(i)
            }
        }
        getExternalBaseCases() {
            return this
                .externalBaseCases
        }
        getSliderVariables(n,
            r) {
            var i = this
                ._argSymbols;
            return super
                .getSliderVariables(
                    n, r)
                .filter(
                    function (
                        s) {
                        return i
                            .indexOf(
                                s
                            ) ===
                            -
                            1
                    })
        }
        asEquation() {
            var n = this
                ._argSymbols
                .map(
                    function (
                        i) {
                        return new ze(
                            i
                        )
                    }),
                r = new ko(
                    new cn(
                        new ze(
                            this
                                ._symbol
                        ),
                        n),
                    this
                        ._expression
                );
            return r
                .userData =
                this
                    .userData, r
                        .metaData =
                this
                    .metaData, r
        }
    };
    var ja = class extends Tt {
        constructor(t, n) {
            super(), this
                ._symbol = t
                    ._symbol,
                this
                    .mergeDependencies(
                        t, n),
                this._lhs =
                t, this
                    ._rhs = n
        }
        asComparator() {
            return new qr[
                "="]([
                    this
                        ._lhs,
                    this
                        ._rhs
                ])
        }
    };
    var $m = class extends Tt {
        constructor(n, r) {
            super();
            this.isRegression = !
                0;
            this._lhs = n,
                this
                    .isLhsSimple =
                n instanceof ze,
                this
                    ._logLhs =
                new cn("ln",
                    [n]),
                this._rhs =
                r, this
                    ._difference =
                new ni([n,
                    r]),
                this
                    ._logDifference =
                new ni([new cn(
                    "ln",
                    [
                        n]
                ),
                new cn(
                    "ln",
                    [
                        r]
                )
                ]), this
                    .mergeDependencies(
                        n, r)
        }
        exportTo(n, r, i) {
            if (!r
                .isError) {
                for (var s in
                    r
                        .parameters)
                    r
                        .parameters
                        .hasOwnProperty(
                            s
                        ) &&
                        (n.assignmentForbidden(
                            s
                        ) ||
                            (i[s] =
                                i[
                                    s] ?
                                    dl(
                                        s) :
                                    r
                                        .parameters[
                                    s
                                    ]
                            )
                        );
                n.assignmentForbidden(
                    r
                        .residualVariable
                ) ||
                    (i[r.residualVariable] =
                        r
                            .residuals
                    )
            }
        }
        getSliderVariables() {
            return []
        }
    };
    var Ym = class extends Tt {
        constructor(n, r) {
            super();
            this.isImage = !
                0;
            this.center = n
                .center,
                this
                    .radianAngle =
                n
                    .radianAngle,
                this.width =
                n.width,
                this
                    .height = n
                    .height,
                this
                    .opacity = n
                    .opacity,
                this
                    .moveStrategy =
                r, this
                    .mergeDependencies(
                        this
                            .center,
                        this
                            .radianAngle,
                        this
                            .width,
                        this
                            .height,
                        this
                            .opacity
                    )
        }
    };
    var Xm = class extends Tt {
        constructor(t) {
            super(), this
                .handler = t
                    .handler,
                this
                    .minStep = t
                    .minStep,
                this
                    .mergeDependencies(
                        this
                            .handler
                    ), this
                        .mergeDependencies(
                            this
                                .minStep
                        )
        }
    };
    var Zm = class extends ga {
        constructor(n, r) {
            super(new ze(n
                ._symbol
            ), n
                ._expression
            );
            this.isSlider = !
                0;
            this.setInputSpan(
                n
                    ._inputSpan
            ), this
                .sliderAssignment =
                n, this
                    .sliderMin =
                r.sliderMin,
                this
                    .sliderMax =
                r.sliderMax,
                this
                    .sliderSoftMin =
                r
                    .sliderSoftMin,
                this
                    .sliderSoftMax =
                r
                    .sliderSoftMax,
                this
                    .sliderStep =
                r
                    .sliderStep,
                this
                    .sliderIsPlayingOnce =
                r
                    .sliderIsPlayingOnce,
                this
                    .sliderMin &&
                this
                    .mergeDependencies(
                        this
                            .sliderMin
                    ), this
                        .sliderMax &&
                this
                    .mergeDependencies(
                        this
                            .sliderMax
                    ), this
                        .sliderStep &&
                this
                    .mergeDependencies(
                        this
                            .sliderStep
                    )
        }
        shouldPromoteToSlider(
            n) {
            return !1
        }
        asAssignment() {
            return new ga(
                this
                    ._symbol,
                this
                    ._expression
            )
        }
    };
    var lc = class extends j {
        constructor(n) {
            let r = new Zt(
                n);
            super([r]);
            this.value = n;
            this._constantNode =
                r
        }
        asValue() {
            return this
                ._constantNode
                .asValue()
        }
        asCompilerValue() {
            return this
                ._constantNode
                .asCompilerValue()
        }
    };
    var Wm = class extends Tt {
        constructor(n) {
            super();
            this.exportPenalty =
                1;
            this.isTable = !
                0;
            this.columns =
                n, this
                    .mergeDependencies
                    .apply(this,
                        n)
        }
        getExports(n) {
            let r = [];
            for (var i =
                0; i < this
                    .columns
                    .length; i++
            ) Array
                .prototype
                .push.apply(
                    r, this
                        .columns[
                        i]
                        .getExports(
                            n));
            return r
        }
        exportTo(n, r, i) {
            for (var s =
                0; s < this
                    .columns
                    .length; s++
            ) {
                var o = this
                    .columns[
                    s]
                    .getExports(
                        n);
                if (o
                    .length) {
                    var a =
                        o[
                        0];
                    n.assignmentForbidden(
                        a
                    ) ||
                        i[
                        a] ||
                        (r.isError ?
                            i[
                            a] =
                            r :
                            this
                                .columns[
                                s
                            ]
                                .exportTo(
                                    n,
                                    r
                                        .columns[
                                    s
                                    ],
                                    i
                                )
                        )
                }
            }
        }
        getAllIds() {
            return this
                .columns
                .map(
                    function (
                        n) {
                        return n
                            .header
                            .userData
                            .id
                    })
        }
    };

    function WL(e) {
        return e.isConstant ?
            new Zt(e
                .asCompilerValue()
            ) : new Zt(NaN)
    }
    var pc = class extends Tt {
        constructor(t, n) {
            super(), this
                .header = t,
                this
                    .values = n,
                this
                    .isIndependent = !
                1, this
                    .registerDependencies(),
                this
                    ._exports =
                this
                    .computeExports()
        }
        registerDependencies() {
            this.mergeDependencies(
                this
                    .header
            ), this
                .mergeDependencies
                .apply(this,
                    this
                        .values)
        }
        computeExports() {
            return this
                .header instanceof ze ?
                [this.header
                    ._symbol
                ] : []
        }
        _exportSymbolsTo(t, n,
            r) {
            if (t.length) {
                var i = t[
                    0];
                if (n
                    .isError
                ) r[i] =
                    n;
                else try {
                    r[i] =
                        new Vo(
                            n
                                .values
                                .map(
                                    WL
                                )
                        )
                } catch (
                s) {
                    if (
                        s instanceof Tt)
                        r[
                            i] =
                            s;
                    else throw s
                }
            }
        }
        exportTo(t, n, r) {
            var i = this
                .getLegalExports(
                    t);
            this._exportSymbolsTo(
                i, n, r)
        }
        exportToLocal(t, n, r) {
            this._exportSymbolsTo(
                this
                    .getExports(
                        t),
                n, r)
        }
    };
    var jm = class extends Tt {
        constructor(t, n, r,
            i) {
            super(), this
                ._symbol =
                t, this
                    ._expression =
                n, this
                    .otherVariableSolutionData =
                r, this
                    .mergeDependencies(
                        n), this
                            .branchMultiplier =
                i
        }
    };
    var Jm = class extends Tt {
        constructor(t, n, r, i,
            s) {
            super(), this
                .parameters =
                t, this
                    .residuals =
                n, this
                    .statistics =
                r, this
                    .model = i,
                this
                    .isModelValid =
                s
                    .isModelValid,
                this
                    .residualVariable =
                s
                    .residualVariable,
                this
                    .residualSuggestionId =
                s
                    .residualSuggestionId,
                this
                    .shouldSuggestLogMode =
                s
                    .shouldSuggestLogMode,
                this
                    .isLinear =
                s.isLinear,
                this
                    .parameterWarning =
                s
                    .parameterWarning,
                this
                    ._exports = [
                    this
                        .residualVariable
                ];
            for (var o in t)
                t
                    .hasOwnProperty(
                        o) &&
                    this
                        ._exports
                        .push(o);
            this.mergeDependencies(
                i)
        }
        getCompiledFunction() {
            return this
                .model
                .getCompiledFunction
                .apply(this
                    .model,
                    arguments
                )
        }
        getCompiledDerivative
            () {
            return this
                .model
                .getCompiledDerivative
                .apply(this
                    .model,
                    arguments
                )
        }
    };
    var fc = class extends j {
        constructor(n) {
            typeof n !=
                "string" &&
                (n = "" +
                    n);
            super([]);
            this.isString = !
                0;
            this._stringValue =
                n
        }
        asValue() {
            return this
                ._stringValue
        }
    };
    var dc = class extends j {
        constructor(t, n) {
            super(n), this
                .seed = n[
                0], this
                    .userSeed =
                n[1], this
                    .tag = t
        }
        asValue() {
            return this.seed
                .asValue() +
                "::" + this
                    .tag + this
                        .userSeed
                        .asValue()
        }
    };

    function Ja(e) {
        return typeof e !=
            "object" || !e ? !1 : e
                .type === "Action"
    }

    function ln(e, t) {
        let n = e.getInstruction(t);
        switch (n.type) {
            case 1:
                return ao(n.value);
            default:
                throw new Error(
                    `Unexpected opcode ${n.type}.`
                )
        }
    }

    function ao(e) {
        if (Array.isArray(e))
            return e.map(ao);
        switch (typeof e) {
            case "boolean":
            case "number":
            case "string":
                return e;
            case "object":
                if (Ja(e)) {
                    let t = {};
                    for (let n in e
                        .updateRules) {
                        let r = e
                            .updateRules[
                            n];
                        t[n] = {
                            value: ao(
                                r
                                    .value
                            ),
                            valueType: r
                                .valueType
                        }
                    }
                    return {
                        type: "Action",
                        updateRules: t
                    }
                } else return q(e);
            default:
                throw new Error(
                    "Unexpected value: " +
                    e)
        }
    }
    var Qa = [ge, Vt, T, R, V, Nt,
        Se, In, Nn, rt, Ut, Be,
        Ie, pe, ce, fe, Le, he,
        Ge, Ae, Ue, mn
    ],
        jL = new Set(Qa);

    function uo(e) {
        return jL.has(e)
    }

    function $r(e) {
        switch (e) {
            case T:
                return NaN;
            case R:
                return [NaN, NaN];
            case V:
                return [NaN, NaN,
                    NaN
                ];
            case Nt:
            case Se:
                return [
                    [NaN, NaN,
                        NaN
                    ],
                    [NaN, NaN,
                        NaN
                    ]
                ];
            case In:
                return [
                    [NaN, NaN,
                        NaN
                    ],
                    [NaN, NaN,
                        NaN
                    ],
                    [NaN, NaN,
                        NaN
                    ]
                ];
            case Nn:
                return [
                    [
                        [NaN,
                            NaN,
                            NaN
                        ],
                        [NaN,
                            NaN,
                            NaN
                        ],
                        [NaN,
                            NaN,
                            NaN
                        ]
                    ], NaN
                ];
            case Ut:
                return [NaN, NaN,
                    NaN
                ];
            case rt:
                return {
                    type: "Action",
                    updateRules: {}
                };
            case Ie:
            case Le:
            case fe:
                return [
                    [NaN, NaN],
                    [NaN, NaN]
                ];
            case he:
                return [
                    [NaN, NaN],
                    [NaN, NaN]
                ];
            case pe:
                return [
                    [NaN, NaN],
                    NaN
                ];
            case ce:
                return [
                    [NaN, NaN],
                    [NaN, NaN],
                    [NaN, NaN]
                ];
            case ge:
            case Vt:
                return !1;
            case Be:
                return [];
            case Ue:
                return [
                    [NaN, NaN],
                    [NaN, NaN],
                    !1
                ];
            case Ge:
            case Ae:
                return [
                    [NaN, NaN],
                    NaN, NaN,
                    NaN
                ];
            case mn:
                return [NaN, NaN];
            default:
                let t = e;
                throw new Error(
                    `${t} does not have a NaN type.`
                )
        }
    }

    function _v(e, t) {
        return _o($r(e), t)
    }

    function be(e) {
        return e.type <= 4
    }

    function Lv(e) {
        return !be(e)
    }

    function ri(e) {
        switch (e.type) {
            case 21:
            case 23:
            case 19:
            case 50:
            case 53:
                return !0;
            default:
                return !1
        }
    }

    function Ti(e) {
        switch (e.type) {
            case 20:
            case 22:
            case 24:
            case 51:
            case 54:
                return !0;
            default:
                return !1
        }
    }

    function Qm(e) {
        switch (e.type) {
            case 20:
            case 22:
            case 24:
            case 51:
                return !0;
            default:
                return !1
        }
    }

    function Yr(e, t) {
        let n = new Array(t);
        for (let i = 0; i < t; i++)
            n[i] = !1;
        n[t] = !0;
        let r = t;
        for (; r > 0;) {
            r = 0;
            for (let i = t; i >=
                0; i--) {
                if (!n[i]) continue;
                let s = e
                    .getInstruction(
                        i);
                if (!be(s))
                    for (let o of e
                        .getDirectDependencies(
                            s))
                        o > i && !n[
                            o] &&
                            o > r && (
                                r = o),
                            n[o] = !0
            }
        }
        return n
    }

    function wv(e, t) {
        let n = new Array(t);
        for (let i = 0; i < t; i++)
            n[i] = !1;
        n[t] = !0;
        let r = t;
        for (; r > 0;) {
            r = 0;
            for (let i = t; i >=
                0; i--) {
                if (!n[i]) continue;
                let s = e
                    .getInstruction(
                        i);
                if (!be(s))
                    if (s.type ===
                        33) n[s
                            .args[1]
                        ] = !0,
                            n[s.args[
                            2]] = !0;
                    else
                        for (let o of
                            e
                                .getDirectDependencies(
                                    s
                                ))
                            o > i &&
                                !n[o] &&
                                (r = o),
                                n[o] = !
                                0
            }
        }
        return n
    }

    function Fv(e, t) {
        let n = e.getReturnIndex(),
            r = new Array(n),
            i = new Array(n).fill(!
                1);
        for (let o = 0; o <=
            n; o++) {
            let a = e
                .getInstruction(o);
            ri(a) || Ti(a) || a
                .type === 48 || a
                    .type === 47 && e
                        .getInstruction(a
                            .args[0])
                        .type !== 22 || a
                            .type === 0 || a
                                .type === 55 ? r[
                                o] = 2 : r[o] = 0
        }
        r[n] === 0 && (r[n] = 1, i[
            n] = !0);
        let s = 0;
        for (let o = n; o >=
            0; o--) {
            if (!t[o]) continue;
            let a = e
                .getInstruction(o);
            if (a.type === 54 ? s++
                : a.type === 53 &&
                s--, be(a))
                continue;
            if (a.type === 19 || a
                .type === 20 || a
                    .type === 24 || a
                        .type === 54 || a
                            .type === 39 || a
                                .type === 55)
                for (let c of a
                    .args) {
                    let l = e
                        .getInstruction(
                            c);
                    r[c] === 0 && l
                        .type ===
                        1 && l
                            .valueType ===
                        T ? (r[c] =
                            1, i[
                            c] = !0
                    ) : (r[
                        c] =
                        2, i[
                        c] = !1)
                } else {
                for (let c of a
                    .args)
                    switch (r[
                    c]) {
                        case 0:
                            r[c] =
                                1,
                                i[
                                c] = !
                                0;
                            break;
                        case 1:
                        case 2:
                            r[c] =
                                2,
                                i[
                                c] = !
                                1;
                            break
                    }
                s > 0 && a
                    .type ===
                    33 && (r[
                        o] = 2,
                        i[o] = !
                        1)
            }
        }
        return i
    }

    function KL(e, t) {
        if (e.size !== t.size)
            return !1;
        for (let n of e)
            if (!t.has(n)) return !
                1;
        return !0
    }
    var Km = class {
        constructor(t, n, r) {
            this.chunk = t;
            this.referenced =
                n;
            this.shouldInline =
                r;
            this
                .thunkSets = [];
            this
                .thunkStarts = [];
            this
                .thunkEnds = [];
            this
                ._isThunkEnd = [];
            this
                .piecewiseReferencedCount = [];
            this
                .dependencyThunkNames = [];
            this
                .parentFunctionStart = [];
            let i = t
                .getReturnIndex();
            for (let a =
                0; a <= t
                    .instructionsLength(); a++
            ) this
                .thunkSets[
                a] =
                new Set;
            let s = t
                .argNames
                .length,
                o;
            for (let a =
                s; a <= t
                    .getReturnIndex(); a++
            ) {
                let u = t
                    .getInstruction(
                        a);
                this.parentFunctionStart[
                    a] =
                    o, u
                        .type ===
                        53 ? o =
                    a : u
                        .type ===
                    54 && (
                        o =
                        void 0
                    )
            }
            this.markThunkSets(
                s, i, [
                i],
                "always"
            ), this
                .markThunks(
                    s, i)
        }
        isThunkBegin(t) {
            return this
                .thunkStarts[
                t] === t
        }
        isThunkEnd(t) {
            return !!this
                ._isThunkEnd[
                t]
        }
        containingThunkName(t) {
            return this
                .thunkStarts[
                t]
        }
        thunkEnd(t) {
            return this
                .thunkEnds[
                t]
        }
        isEarlyReturningThunk(
            t) {
            let n = this
                .parentFunctionStart[
                t];
            return this
                .isThunkBegin(
                    t) &&
                n !== void 0
        }
        dependencyThunkNamesForPiecewiseBranch
            (t) {
            return this
                .dependencyThunkNames[
                t]
        }
        wantToInlineThunk(t) {
            let n = this
                .thunkSets[
                t];
            if (n !==
                "always" &&
                n.size === 1
            ) {
                for (let r of
                    n)
                    if (this
                        .piecewiseReferencedCount[
                        r
                    ] !==
                        1)
                        return !
                            1;
                return !0
            }
            return !1
        }
        printChunkWithThunkInfo
            () {
            for (let t =
                0; t <= this
                    .chunk
                    .getReturnIndex(); t++
            ) {
                let n = this
                    .thunkSets[
                    t],
                    r =
                        n ===
                            "always" ?
                            "always" :
                            `{${[...n].sort().join(",")}}`;
                if (this
                    .isThunkBegin(
                        t
                    ) &&
                    (r +=
                        " beginThunk"
                    ),
                    this
                        .isThunkEnd(
                            t))
                    r +=
                        " endThunk";
                else {
                    let i =
                        this
                            .containingThunkName(
                                t
                            );
                    i !==
                        void 0 &&
                        (r +=
                            ` start:${i}`
                        )
                }
                this.shouldInline[
                    t
                ] &&
                    (r +=
                        "	[inline]"
                    ),
                    this
                        .chunk
                        .comments[
                    t] =
                    r
            }
            return this
                .chunk
                .print(this
                    .chunk
                    .getReturnIndex()
                )
        }
        markThunkSets(t, n, r,
            i) {
            let {
                chunk: s,
                referenced: o,
                thunkSets: a,
                piecewiseReferencedCount: u
            } = this;
            for (let l of r)
                a[l] =
                    "always";

            function c(l,
                p) {
                let f = a[
                    l];
                if (f !==
                    "always"
                ) {
                    if (p ===
                        "always"
                    ) {
                        a[l] =
                            p;
                        return
                    }
                    for (let m of
                        p)
                        f
                            .add(
                                m
                            )
                }
            }
            for (let l =
                n; l >=
                t; l--) {
                if (!o[l])
                    continue;
                let p = s
                    .getInstruction(
                        l);
                if (be(p))
                    continue;
                let f = a[
                    l];
                if (Ti(p)) {
                    let m =
                        p
                            .args[
                        0
                        ];
                    this.markThunkSets(
                        m +
                        1,
                        l -
                        1,
                        p
                            .args
                            .slice(
                                1
                            ),
                        f
                    ),
                        l =
                        m +
                        1;
                    continue
                }
                for (let m =
                    0; m <
                    p.args
                        .length; m++
                ) {
                    let g =
                        p
                            .args[
                        m
                        ];
                    if (g <
                        t)
                        c(g,
                            i);
                    else if (
                        m >
                        0 &&
                        p
                            .type ===
                        33
                    ) {
                        let d =
                            a[
                            g];
                        d !==
                            "always" &&
                            d
                                .add(
                                    g
                                );
                        let y =
                            u[
                            g];
                        u[g] =
                            (y !=
                                null ?
                                y :
                                0
                            ) +
                            1
                    } else
                        c(g,
                            f)
                }
            }
        }
        markThunks(t, n) {
            var a, u;
            let {
                chunk: r,
                thunkSets: i
            } = this, s, o;
            for (let c =
                t; c <=
                n; c = o) {
                let l = r
                    .getInstruction(
                        c),
                    p = ew(
                        this
                            .chunk,
                        l),
                    f, m;
                if (p) {
                    let g =
                        c +
                        1,
                        d =
                            p
                                .innerEndIndex -
                            1;
                    this.markThunks(
                        g,
                        d
                    ),
                        m =
                        i[p
                            .innerEndIndex],
                        o =
                        p
                            .outerEndIndex +
                        1,
                        f =
                        this
                            .thunkDecision(
                                s,
                                c,
                                this
                                    .referenced[
                                p
                                    .innerEndIndex
                                ],
                                l
                                    .type ===
                                21 &&
                                this
                                    .shouldInline[
                                p
                                    .outerEndIndex
                                ],
                                m
                            )
                } else m =
                    i[c],
                    o = c +
                    1, f =
                    this
                        .thunkDecision(
                            s,
                            c,
                            this
                                .referenced[
                            c
                            ],
                            this
                                .shouldInline[
                            c
                            ],
                            m);
                if (s !==
                    void 0 &&
                    f
                        .shouldEndThunk &&
                    (this
                        .markEndThunk(
                            c -
                            1,
                            s
                        ),
                        s =
                        void 0
                    ), f
                        .shouldStartThunk &&
                    m !==
                    "always"
                ) {
                    for (let g of
                        m)
                        (u = (a =
                            this
                                .dependencyThunkNames
                        )[
                            g
                        ]) !=
                            null ||
                            (a[
                                g] = []),
                            this
                                .dependencyThunkNames[
                                g
                            ]
                                .push(
                                    c
                                );
                    s = {
                        start: c,
                        set: m
                    }
                }
                if (s !==
                    void 0 &&
                    (this
                        .thunkStarts[
                        c
                    ] =
                        s
                            .start,
                        p))
                    for (let g =
                        p
                            .innerEndIndex; g <=
                        p
                            .outerEndIndex; g++
                    )
                        this
                            .thunkStarts[
                            g
                        ] =
                            s
                                .start
            }
            s !== void 0 &&
                this
                    .markEndThunk(
                        n, s)
        }
        thunkDecision(t, n, r,
            i, s) {
            let o = this
                .chunk
                .getInstruction(
                    n);
            if (o.type ===
                33 && (i = !
                    1), i ||
                !r) return {
                    shouldEndThunk:
                        !1,
                    shouldStartThunk:
                        !1
                };
            if (s ===
                "always")
                return {
                    shouldEndThunk: t !==
                        void 0,
                    shouldStartThunk:
                        !1
                };
            let a = o
                .type ===
                1 || o
                    .type ===
                47,
                u = s.size >
                    0 && !a,
                c = t !==
                    void 0 && !
                    KL(s, t
                        .set);
            return {
                shouldEndThunk: c,
                shouldStartThunk: (
                    c ||
                    t ===
                    void 0
                ) &&
                    u
            }
        }
        markEndThunk(t, n) {
            let {
                referenced: r
            } = this;
            for (; t >= 0 &&
                !r[t];) t--;
            this._isThunkEnd[
                t] = !0,
                this
                    .thunkEnds[n
                    .start
                ] = t
        }
    };

    function ew(e, t) {
        if (ri(t)) {
            let n = t.endIndex,
                r = e
                    .getInstruction(n);
            if (r === void 0)
                return;
            if (Qm(r)) return {
                outerEndIndex: n +
                    r.args
                        .length - 1,
                innerEndIndex: n
            };
            if (r.type === 54)
                return {
                    outerEndIndex: n,
                    innerEndIndex: n
                }
        }
    }

    function eu(e, t) {
        return mc(e, [t], 0, e
            .instructionsLength() -
            1)
    }

    function mc(e, t, n, r) {
        let i = [];
        for (let o = n; o <= r; o++)
            i[o] = !1;
        for (let o of t) i[o] = !0;
        let s = Math.min(...t);
        for (let o = 0; o <=
            1; o++) {
            let a = !1;
            for (let u = s + 1; u <
                e
                    .instructionsLength(); u++
            ) {
                let c = e
                    .getInstruction(
                        u);
                if (be(c) || i[u])
                    continue;
                let l = !1;
                for (let p of e
                    .getDirectDependencies(
                        c))
                    if (i[p]) {
                        l = !0;
                        break
                    } if (i[u] = l,
                        l && c.type ===
                        20 && !i[c.args[
                        0]]) {
                    let p = c.args[
                        0],
                        f = c.args
                            .length - 1;
                    for (let m =
                        0; m <
                        f; m++) {
                        let g = c
                            .args[
                            1 +
                            m],
                            d = p +
                                1 + m;
                        i[g] && (i[
                            d] = !
                            0,
                            a = !
                            0)
                    }
                }
            }
            if (!a) break
        }
        return i
    }

    function ey(e) {
        for (let t = 0; t < e
            .argCoeffs.length; t++)
            if (q(e.argCoeffs[
                0]) !== 0) return !
                    1;
        return !0
    }
    var ty = De(0, 1),
        Vv = De(1, 1);

    function ny(e) {
        if (e.op === "&&") return {
            op: "||",
            values: e.values
                .map(ny)
        };
        if (e.op === "||") return {
            op: "&&",
            values: e.values
                .map(ny)
        };
        switch (e.condition) {
            case ">0":
                return {
                    op: "comparator",
                    value: ii
                        ._neg(e
                            .value),
                    condition:
                        ">=0"
                };
            case ">=0":
                return {
                    op: "comparator",
                    value: ii
                        ._neg(e
                            .value),
                    condition:
                        ">0"
                };
            case "=0":
                return {
                    op: "comparator",
                    value: e
                        .value,
                    condition:
                        "!=0"
                };
            case "!=0":
                return {
                    op: "comparator",
                    value: e
                        .value,
                    condition:
                        "=0"
                }
        }
    }

    function dT(e, t) {
        let n = [];
        return e.op === "&&" ? n
            .push(...e.values) : n
                .push(e), t.op ===
                    "&&" ? n.push(...t
                        .values) : n.push(
                            t), {
            op: "&&",
            values: n
        }
    }
    var ii;
    (c => {
        function e(l, p) {
            if (!(l ===
                void 0 ||
                p === void 0
            )) return t(
                l, p)
        }
        c.add = e;

        function t(l, p) {
            let f = [];
            for (let m = 0; m <
                l.argCoeffs
                    .length; m++) f
                        .push(us(l
                            .argCoeffs[
                            m],
                            p
                                .argCoeffs[
                            m]));
            return {
                argCoeffs: f,
                constantCoeff: us(
                    l
                        .constantCoeff,
                    p
                        .constantCoeff
                )
            }
        }
        c._add = t;

        function n(l, p) {
            if (!(l ===
                void 0 ||
                p === void 0
            )) return r(
                l, p)
        }
        c.sub = n;

        function r(l, p) {
            let f = [];
            for (let m = 0; m <
                l.argCoeffs
                    .length; m++) f
                        .push(ji(l
                            .argCoeffs[
                            m],
                            p
                                .argCoeffs[
                            m]));
            return {
                argCoeffs: f,
                constantCoeff: ji(
                    l
                        .constantCoeff,
                    p
                        .constantCoeff
                )
            }
        }
        c._sub = r;

        function i(l) {
            if (l !== void 0)
                return s(l)
        }
        c.neg = i;

        function s(l) {
            let p = [];
            for (let f = 0; f <
                l.argCoeffs
                    .length; f++) p
                        .push(hi(l
                            .argCoeffs[
                            f]));
            return {
                argCoeffs: p,
                constantCoeff: hi(
                    l
                        .constantCoeff
                )
            }
        }
        c._neg = s;

        function o(l, p) {
            if (l === void 0 ||
                p === void 0)
                return;
            let f = ey(l),
                m = ey(p);
            if (!f && !m)
                return;
            m || ([l, p] = [p,
                l]);
            let g = [];
            for (let d = 0; d <
                l.argCoeffs
                    .length; d++) g
                        .push(cs(l
                            .argCoeffs[
                            d],
                            p
                                .constantCoeff
                        ));
            return {
                argCoeffs: g,
                constantCoeff: cs(
                    l
                        .constantCoeff,
                    p
                        .constantCoeff
                )
            }
        }
        c.mul = o;

        function a(l, p) {
            if (l === void 0 ||
                p === void 0 ||
                !ey(p)) return;
            let m = [];
            for (let g = 0; g <
                l.argCoeffs
                    .length; g++) m
                        .push(Ji(l
                            .argCoeffs[
                            g],
                            p
                                .constantCoeff
                        ));
            return {
                argCoeffs: m,
                constantCoeff: Ji(
                    l
                        .constantCoeff,
                    p
                        .constantCoeff
                )
            }
        }
        c.div = a;

        function u(l, p) {
            if (!(l ===
                void 0 ||
                p ===
                void 0 || !
                ey(p)))
                return q(p
                    .constantCoeff
                ) ===
                    0 ? {
                    argCoeffs: new Array(
                        l
                            .argCoeffs
                            .length
                    )
                        .fill(
                            ty
                        ),
                    constantCoeff: Vv
                } : q(p
                    .constantCoeff
                ) ===
                    1 ? l :
                    void 0
        }
        c.pow = u
    })(ii || (ii = {}));
    var ry = class {
        constructor(t, n, r,
            i) {
            this.chunk = t;
            this
                .coefficientTable = [];
            this
                .conditionTable = [];
            this.ZERO_COEFFS =
                new Array(n
                    .length)
                    .fill(ty),
                this.mask =
                mc(t, n, r,
                    i);
            for (let s =
                0; s < n
                    .length; s++
            ) {
                let o = [];
                for (let a =
                    0; a <
                    n
                        .length; a++
                ) o
                    .push(
                        s ===
                            a ?
                            Vv :
                            ty);
                this.coefficientTable[
                    n[s]
                ] = {
                    argCoeffs: o,
                    constantCoeff: ty
                }
            }
        }
        coeffs(t) {
            let n = this
                .coefficientTable[
                t];
            if (n !==
                void 0)
                return n;
            let r, i = this
                .chunk
                .getInstruction(
                    t);
            return i
                .type ===
                1 && i
                    .valueType ===
                T ? r = {
                    argCoeffs: this
                        .ZERO_COEFFS,
                    constantCoeff: i
                        .value
                } : this
                    .mask[t] ?
                r = this
                    ._coeffs(
                        t) : r =
                void 0, this
                    .coefficientTable[
                t] = r,
                r
        }
        _coeffs(t) {
            let n = this
                .chunk
                .getInstruction(
                    t);
            switch (n
                .type) {
                case 8: {
                    let [i,
                        s
                    ] = n
                            .args;
                    return ii
                        .add(
                            this
                                .coeffs(
                                    i
                                ),
                            this
                                .coeffs(
                                    s
                                )
                        )
                }
                case 9: {
                    let [i,
                        s
                    ] = n
                            .args;
                    return ii
                        .sub(
                            this
                                .coeffs(
                                    i
                                ),
                            this
                                .coeffs(
                                    s
                                )
                        )
                }
                case 14: {
                    let i =
                        n
                            .args[
                        0
                        ];
                    return ii
                        .neg(
                            this
                                .coeffs(
                                    i
                                )
                        )
                }
                case 10: {
                    let [i,
                        s
                    ] = n
                            .args;
                    return ii
                        .mul(
                            this
                                .coeffs(
                                    i
                                ),
                            this
                                .coeffs(
                                    s
                                )
                        )
                }
                case 11: {
                    let [i,
                        s
                    ] = n
                            .args;
                    return ii
                        .div(
                            this
                                .coeffs(
                                    i
                                ),
                            this
                                .coeffs(
                                    s
                                )
                        )
                }
                case 12:
                case 13: {
                    let [i,
                        s
                    ] = n
                            .args;
                    return ii
                        .pow(
                            this
                                .coeffs(
                                    i
                                ),
                            this
                                .coeffs(
                                    s
                                )
                        )
                }
                case 26:
                case 28:
                case 27:
                case 29:
                case 33:
                case 0:
                case 23:
                case 2:
                case 1:
                case 25:
                case 32:
                case 31:
                case 15:
                case 17:
                case 16:
                case 18:
                case 38:
                case 39:
                case 40:
                case 41:
                case 37:
                case 42:
                case 21:
                case 22:
                case 19:
                case 20:
                case 24:
                case 48:
                case 47:
                case 3:
                case 44:
                case 49:
                case 50:
                case 51:
                case 4:
                case 53:
                case 54:
                case 55:
                    return;
                default:
                    let r =
                        n;
                    throw new Error(
                        `Unexpected opcode ${r.type}`
                    )
            }
        }
        condition(t) {
            let n = this
                .conditionTable[
                t];
            if (n !==
                void 0)
                return n;
            let r;
            return this
                .mask[t] ?
                r = this
                    ._condition(
                        t) : r =
                void 0, this
                    .conditionTable[
                t] = r,
                r
        }
        _condition(t) {
            let n = this
                .chunk
                .getInstruction(
                    t);
            switch (n
                .type) {
                case 26: {
                    let [i,
                        s
                    ] = n
                            .args,
                        o =
                            ii
                                .sub(
                                    this
                                        .coeffs(
                                            s
                                        ),
                                    this
                                        .coeffs(
                                            i
                                        )
                                );
                    return o ===
                        void 0 ?
                        void 0 :
                        {
                            op: "comparator",
                            value: o,
                            condition: ">0"
                        }
                }
                case 28: {
                    let [i,
                        s
                    ] = n
                            .args,
                        o =
                            ii
                                .sub(
                                    this
                                        .coeffs(
                                            s
                                        ),
                                    this
                                        .coeffs(
                                            i
                                        )
                                );
                    return o ===
                        void 0 ?
                        void 0 :
                        {
                            op: "comparator",
                            value: o,
                            condition: ">=0"
                        }
                }
                case 27: {
                    let [i,
                        s
                    ] = n
                            .args,
                        o =
                            ii
                                .sub(
                                    this
                                        .coeffs(
                                            i
                                        ),
                                    this
                                        .coeffs(
                                            s
                                        )
                                );
                    return o ===
                        void 0 ?
                        void 0 :
                        {
                            op: "comparator",
                            value: o,
                            condition: ">0"
                        }
                }
                case 29: {
                    let [i,
                        s
                    ] = n
                            .args,
                        o =
                            ii
                                .sub(
                                    this
                                        .coeffs(
                                            i
                                        ),
                                    this
                                        .coeffs(
                                            s
                                        )
                                );
                    return o ===
                        void 0 ?
                        void 0 :
                        {
                            op: "comparator",
                            value: o,
                            condition: ">=0"
                        }
                }
                case 25: {
                    let [i,
                        s
                    ] = n
                            .args,
                        o =
                            ii
                                .sub(
                                    this
                                        .coeffs(
                                            i
                                        ),
                                    this
                                        .coeffs(
                                            s
                                        )
                                );
                    return o ===
                        void 0 ?
                        void 0 :
                        {
                            op: "comparator",
                            value: o,
                            condition: "=0"
                        }
                }
                case 32: {
                    let i =
                        n
                            .args
                            .map(
                                s =>
                                    this
                                        .condition(
                                            s
                                        )
                            );
                    return i
                        .some(
                            s =>
                                s ===
                                void 0
                        ) ?
                        void 0 :
                        {
                            op: "&&",
                            values: i
                        }
                }
                case 31: {
                    let i =
                        n
                            .args
                            .map(
                                s =>
                                    this
                                        .condition(
                                            s
                                        )
                            );
                    return i
                        .some(
                            s =>
                                s ===
                                void 0
                        ) ?
                        void 0 :
                        {
                            op: "||",
                            values: i
                        }
                }
                case 8:
                case 9:
                case 14:
                case 10:
                case 11:
                case 12:
                case 13:
                case 33:
                case 0:
                case 23:
                case 2:
                case 1:
                case 15:
                case 17:
                case 16:
                case 18:
                case 38:
                case 39:
                case 40:
                case 41:
                case 37:
                case 42:
                case 21:
                case 22:
                case 19:
                case 20:
                case 24:
                case 48:
                case 47:
                case 3:
                case 44:
                case 49:
                case 50:
                case 51:
                case 4:
                case 53:
                case 54:
                case 55:
                    return;
                default:
                    let r =
                        n;
                    throw new Error(
                        `Unexpected opcode ${r.type}`
                    )
            }
        }
    };

    function Bv(e, t, n, r) {
        let i = e.getInstruction(n
            .args[0]);
        if (i.recursionGroup
            .length > 1) return [];
        let s = i.endIndex,
            o = e.getInstruction(s),
            a = new ry(e, r, t, s),
            u = [];
        for (let l = 1; l < o.args
            .length; l++) u[o.args[
                l]] = {
                op: "&&",
                values: []
            };
        for (let l = s - 1; l >
            t; l--) {
            let p = u[l];
            if (p === void 0)
                continue;
            let f = e
                .getInstruction(l);
            if (!be(f))
                if (f.type === 33) {
                    u[f.args[0]] =
                        p;
                    let m = a
                        .condition(f
                            .args[0]
                        );
                    m !== void 0 &&
                        (u[f.args[
                            1]] =
                            dT(p,
                                m), u[f
                                    .args[
                                2
                                ]
                                ] =
                            dT(p,
                                ny(
                                    m)
                            ))
                } else
                    for (let m of f
                        .args)
                        u[m] = p
        }
        let c = [];
        e: for (let l = s - 1; l >=
            t; l--) {
            let p = e
                .getInstruction(
                    l);
            if (p.type !== 55)
                continue;
            let f = e
                .getInstruction(
                    p.args[0]);
            if (l > f.endIndex)
                continue;
            let m = p.args
                .slice(1);
            if (m.length !== f
                .signature
                .argTypes.length
            ) throw new Error(
                "Programming error: Non-matching arg length"
            );
            let g = u[l];
            if (g !== void 0) {
                if (g.op ===
                    "&&" && g
                        .values
                        .length ===
                    0) throw new Error(
                        "Programming error: Recursive call unconditionally executed"
                    );
                for (let d =
                    0; d < m
                        .length; d++
                ) {
                    if (e
                        .getInstruction(
                            m[d]
                        )
                        .valueType !==
                        T)
                        continue e;
                    let y = a
                        .coeffs(
                            m[d]
                        );
                    if (y ===
                        void 0 ||
                        !tw(y,
                            d) ||
                        q(y.argCoeffs[
                            d
                        ]) <
                        -1)
                        continue e
                }
                c[l] = g
            }
        }
        return c
    }

    function tw(e, t) {
        for (let n = 0; n < e
            .argCoeffs.length; n++)
            if (n !== t && q(e
                .argCoeffs[n]
            ) !== 0)
                return !1;
        return !0
    }

    function Gv(e, t) {
        if (t.recursionGroup
            .length > 1) return !1;
        let n = t.endIndex,
            r = e.getInstruction(n);
        if (r.type !== 54)
            throw new Error(
                "Programming Error: end of BeginFunction is not EndFunction"
            );
        let [i, ...s] = r.args;
        if (s.length !== 1) return !
            1;
        let o = e.getInstruction(i);
        if (o.type !== 53)
            throw new Error(
                "Programming Error: start of EndFunction is not BeginFunction"
            );
        let a = o.args[0],
            u = {};
        u[s[0]] = !0;
        for (let c = n - 1; c >=
            i; c--) {
            let l = e
                .getInstruction(c);
            switch (l.type) {
                case 55:
                    if (!u[c])
                        return !1;
                    if (l.args[
                        0] !== a)
                        throw new Error(
                            "recursionGroup.length == 1 contradicted"
                        );
                    break;
                case 33:
                    u[c] && (u[l.args[
                        1
                    ]] = !
                        0, u[l
                            .args[
                        2
                        ]
                        ] = !
                        0);
                    break;
                default:
                    break
            }
        }
        return !0
    }

    function an(e) {
        return `_${e}`
    }

    function _l(e) {
        return `_${e}_thunk_computed`
    }

    function Ll(e) {
        return `_${e}_thunk_function`
    }

    function iy(e) {
        return `_${e}_next`
    }

    function mT(e, t) {
        return `_${e}_${t}`
    }

    function yT(e) {
        return `_${e}_inner`
    }

    function kv(e) {
        return `_${e}_cache`
    }

    function zv(e) {
        return `_${e}_key`
    }

    function sy(e) {
        return `_${e}_computationMetrics`
    }

    function Hv(e) {
        return `_${e}_out`
    }

    function Uv(e) {
        return `_${e}_computationMetrics`
    }

    function qv(e) {
        return `_${e}_cacheEntry`
    }

    function $v(e) {
        return `_${e}_args`
    }

    function hf(e, t) {
        return `_${e}_prev_${t}`
    }

    function Yv(e) {
        return `_${e}_computationDepth`
    }

    function Xv(e) {
        return `_${e}_computationCount`
    }
    var wl = class {
        constructor(t, n) {
            this.chunk = t;
            this.glsl = n;
            this
                .inlinedSource = [];
            this
                .inlinedThunks = [];
            this
                .recursiveFunctionInfo = [];
            this
                .isTailFunction = [];
            let r = t
                .getReturnIndex();
            this.referenced =
                Yr(t, r),
                this
                    ._shouldInline =
                Fv(t, this
                    .referenced
                ), !this
                    .glsl && t
                        .computeNeedsThunking() &&
                (this
                    .thunks =
                    new Km(
                        t,
                        this
                            .referenced,
                        this
                            ._shouldInline
                    ));
            for (let i =
                0; i <=
                r; i++) {
                let s = t
                    .getInstruction(
                        i);
                if (s
                    .type ===
                    4) {
                    if (!
                        this
                            .referenced[
                        i
                        ]
                    )
                        continue;
                    this.isTailFunction[
                        i
                    ] =
                        Gv(t,
                            s
                        ),
                        s
                            .recursionGroup =
                        s
                            .recursionGroup
                            .filter(
                                o =>
                                    this
                                        .referenced[
                                    o
                                    ]
                            )
                }
            }
        }
        isThunkBegin(t) {
            return !!this
                .thunks &&
                this.thunks
                    .isThunkBegin(
                        t)
        }
        isThunkEnd(t) {
            return !!this
                .thunks &&
                this.thunks
                    .isThunkEnd(
                        t)
        }
        isEarlyReturningThunk(
            t) {
            return !!this
                .thunks &&
                this.thunks
                    .isEarlyReturningThunk(
                        t) &&
                this
                    .inlinedThunks[
                t] ===
                void 0
        }
        thunkName(t) {
            var n;
            return (n = this
                .thunks
            ) ==
                null ?
                void 0 : n
                    .containingThunkName(
                        t)
        }
        thunkEnd(t) {
            return this
                .thunks
                .thunkEnd(t)
        }
        shouldInline(t) {
            return this
                ._shouldInline[
                t]
        }
        inlineSource(t, n) {
            this.inlinedSource[
                t] = n
        }
        wantToInlineThunk(t) {
            return !!this
                .thunks &&
                this.thunks
                    .wantToInlineThunk(
                        t)
        }
        inlineThunk(t, n) {
            this.inlinedThunks[
                t] = n
        }
        referenceArg(t) {
            let n = this
                .inlinedSource[
                t];
            return n !==
                void 0 ? n :
                an(t)
        }
        referencePiecewiseBranch
            (t) {
            var o;
            let n = this
                .referenceArg(
                    t),
                r = (o =
                    this
                        .thunks
                ) ==
                    null ?
                    void 0 : o
                        .dependencyThunkNamesForPiecewiseBranch(
                            t);
            if (!r || r
                .length ===
                0) return {
                    expression: n,
                    rawExpression: n,
                    thunkDependencies: []
                };
            let i = [],
                s = "";
            for (let a of
                r) {
                let u = this
                    .inlinedThunks[
                    a];
                if (u !==
                    void 0)
                    s && (
                        s +=
                        ","
                    ),
                        s += u;
                else {
                    let c =
                        _l(
                            a),
                        l =
                            Ll(
                                a),
                        p =
                            `${c}||${l}()`;
                    s && (s +=
                        ","
                    ),
                        s +=
                        `${p}`
                }
                i.push(a)
            }
            return {
                expression: "(" +
                    s +
                    "," +
                    n + ")",
                rawExpression: n,
                thunkDependencies: i
            }
        }
        enterFunction(t, n, r) {
            let i = t.args[
                0],
                s = this
                    .chunk
                    .getInstruction(
                        i),
                o = [];
            for (let u =
                0; u < s
                    .signature
                    .argTypes
                    .length; u++
            ) o.push(n +
                u + 1);
            let a = Bv(this
                .chunk,
                n, t, o);
            this.recursiveFunctionInfo
                .push({
                    fn: i,
                    argBlockvars: o,
                    reachConditions: a,
                    returnType: t
                        .valueType,
                    executionMode: r
                })
        }
        exitFunction() {
            this.recursiveFunctionInfo
                .pop()
        }
    };

    function Wv(e, t, n) {
        let r = "",
            i = (e
                .instructionsLength() -
                1).toString()
                .length,
            s = 0,
            o = !1,
            a = Yr(e, t);
        for (let u = 0; u < e
            .instructionsLength(); u++
        ) {
            let c = e
                .getInstruction(u),
                l = n.comments[u] ||
                    "";
            if (Ti(c) && (s -= 1), !
                a[u] && !n
                    .printUnreferencedInstructions ||
                c.type === 0) o || (
                    r += `${Zv(u, i)}: ${hT(2 * s)}...
`), o = !0;
            else {
                o = !1;
                let p =
                    `${Zv(u, i)}: ${hT(2 * s)}${yc(e, u)}`;
                l && (p += " "
                    .repeat(Math
                        .max(0,
                            36 -
                            p
                                .length
                        )),
                    p +=
                    `	# ${l}`),
                    r += p + `
`
            }
            ri(c) && (s += 1)
        }
        return r
    }

    function yc(e, t) {
        let n = e.getInstruction(t);
        switch (n.type) {
            case 0:
                return Ar(n.type);
            case 2:
                return `${Ar(n.type)} ${on(n.valueType)} ${e.argNames[t]}`;
            case 3:
                return `${Ar(n.type)} ${on(n.valueType)}`;
            case 1:
                return `${Ar(n.type)} ${on(n.valueType)} ${gT(n.value)}`;
            case 37:
            case 42:
                return `${Ar(n.type)} ${on(n.valueType)} ${n.symbol} ${n.args.join(" ")}`;
            case 44:
                return `${Ar(n.type)} ${on(n.valueType)} ${n.tag} ${n.args.join(" ")}`;
            case 48:
                return `${Ar(n.type)} ${on(n.valueType)} ${n.args.join(" ")}`;
            case 17:
            case 18:
                return `${Ar(n.type)} ${on(n.valueType)} (${n.index}) ${n.args.join(" ")}`;
            case 50:
                return `${Ar(n.type)} ${on(n.valueType)} ${n.args.join(" ")} (${n.callData.parameterSymbols.join(",")})`;
            case 4: {
                let i = n.signature
                    .argTypes.map(
                        s => on(s))
                    .join(", ");
                return `${Ar(n.type)} ${on(n.valueType)} ${n.symbol}(${i}) [group ${n.recursionGroup.join(" ")}]`
            }
            case 8:
            case 9:
            case 10:
            case 11:
            case 13:
            case 12:
            case 14:
            case 15:
            case 16:
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 32:
            case 31:
            case 33:
            case 38:
            case 39:
            case 40:
            case 41:
            case 47:
            case 49:
            case 51:
            case 53:
            case 54:
            case 55:
                return `${Ar(n.type)} ${on(n.valueType)} ${n.args.join(" ")}`;
            default:
                let r = n;
                throw new Error(
                    `Unexpected opcode ${r.type}`
                )
        }
    }

    function Ar(e) {
        switch (e) {
            case 0:
                return "Noop";
            case 1:
                return "Constant";
            case 8:
                return "Add";
            case 9:
                return "Subtract";
            case 10:
                return "Multiply";
            case 11:
                return "Divide";
            case 12:
                return "Exponent";
            case 13:
                return "RawExponent";
            case 14:
                return "Negative";
            case 15:
                return "OrderedPair";
            case 17:
                return "OrderedPairAccess";
            case 16:
                return "OrderedTriple";
            case 18:
                return "OrderedTripleAccess";
            case 19:
                return "BeginLoop";
            case 20:
                return "EndLoop";
            case 21:
                return "BeginIntegral";
            case 22:
                return "EndIntegral";
            case 23:
                return "BeginBroadcast";
            case 24:
                return "EndBroadcast";
            case 25:
                return "Equal";
            case 26:
                return "Less";
            case 27:
                return "Greater";
            case 28:
                return "LessEqual";
            case 29:
                return "GreaterEqual";
            case 31:
                return "Or";
            case 32:
                return "And";
            case 33:
                return "Piecewise";
            case 38:
                return "List";
            case 39:
                return "ListAccess";
            case 40:
                return "DeferredListAccess";
            case 41:
                return "InboundsListAccess";
            case 37:
                return "NativeFunction";
            case 42:
                return "Distribution";
            case 2:
                return "LoadArg";
            case 47:
                return "BlockVar";
            case 48:
                return "BroadcastResult";
            case 3:
                return "SymbolicVar";
            case 44:
                return "ExtendSeed";
            case 49:
                return "Action";
            case 50:
                return "BeginMap";
            case 51:
                return "EndMap";
            case 4:
                return "FunctionHeader";
            case 53:
                return "BeginFunction";
            case 54:
                return "EndFunction";
            case 55:
                return "FunctionCall";
            default:
                let t = e;
                throw new Error(
                    `Unexpected opcode ${t.type}`
                )
        }
    }

    function gT(e) {
        if (Array.isArray(e))
            return `[${e.map(gT).join(",")}]`;
        switch (typeof e) {
            case "string":
                return e;
            case "boolean":
            case "number":
                return e.toString();
            case "object":
                if (Ja(e)) {
                    let t = [];
                    for (let n in e
                        .updateRules)
                        t.push(
                            `"${n}": ${gT(e.updateRules[n].value)}`
                        );
                    return `{${t.join(", ")}}`
                } else
                    return `${e.n}/${e.d}`;
            default:
                throw new Error(
                    "Unexpected value: " +
                    e)
        }
    }

    function Zv(e, t) {
        let n = e.toString();
        return hT(t - n.length) + n
    }

    function hT(e) {
        let t = "";
        for (let n = 0; n < e; n++)
            t += " ";
        return t
    }

    function Jv(e, t, n, r) {
        let i = t.reachConditions[
            n];
        if (i !== void 0) return Qv(
            e, t, r, i)
    }

    function Qv(e, t, n, r) {
        let i = t.argBlockvars;
        if (r.op === "||" || r
            .op === "&&") {
            let s = [];
            for (let o of r
                .values) {
                let a = Qv(e, t, n,
                    o);
                if (a === void 0)
                    return;
                s.push(a)
            }
            return s.length === 0 ?
                r.op === "&&" ?
                    "true" : "false" :
                `(${s.join(r.op)})`
        }
        switch (r.condition) {
            case ">0":
            case ">=0": {
                let o =
                    `(${jv(e, r.value, i)}${r.condition})`,
                    a = bT(e, r
                        .value, i, n
                    );
                return `(${o}&&${a})`
            }
            case "!=0": {
                let s = jv(e, r
                    .value, i),
                    o = `(${s}>0)`,
                    a = bT(e, r
                        .value, i, n
                    ),
                    u = `(${s}<0)`,
                    c = bT(e, ii
                        ._neg(r
                            .value),
                        i, n);
                return `((${o}&&${a})||(${u}&&${c}))`
            }
            case "=0":
                return
        }
    }

    function bT(e, t, n, r) {
        let i = [];
        for (let s = 0; s < n
            .length; s++) {
            let o = q(t.argCoeffs[
                s]),
                a = e.referenceArg(
                    n[s]),
                u = e.referenceArg(
                    r[s]);
            o > 0 ? i.push(
                `${u}>=${a}`) :
                o < 0 && i.push(
                    `${u}<=${a}`)
        }
        return i.length === 0 ? !0 :
            `(${i.join("&&")})`
    }

    function jv(e, t, n) {
        let r = "";
        for (let i = 0; i < n
            .length; i++) {
            let s = e.printValue(t
                .argCoeffs[i], T
            ),
                o = e.referenceArg(
                    n[i]);
            r += `${s}*${o}+`
        }
        return r += e.printValue(t
            .constantCoeff, T),
            `(${r})`
    }
    var zt;
    (r => (r.Noop = 0, r.Inline = 1,
        r.Block = 2))(zt || (
            zt = {}));

    function xT(e) {
        switch (e.type) {
            case zt.Noop:
                return "";
            case zt.Inline:
                return e.source + `;
`;
            case zt.Block:
                return e.source
        }
    }

    function bt(e) {
        return e.type === 1
    }

    function Kv(e) {
        if (!bt(e)) throw new Error(
            `Programming error: expected constant instruction but found ${Ar(e.type)} instead.`
        )
    }
    var TT = class {
        constructor(t, n) {
            this.chunk = t;
            this.recursiveFunctionGroup =
                n;
            this
                .referencesFrom = {};
            this
                .referencesTo = {};
            this
                .baseCases = {};
            for (let c of
                Object
                    .values(
                        n))
                this
                    .referencesFrom[
                    c] = [],
                    this
                        .referencesTo[
                    c] = [],
                    this
                        .baseCases[
                    c] = [];
            let {
                dependsOnRecursiveCall: r,
                iterationParameterIndex: i,
                recursiveReferences: s
            } = sw(this
                .chunk,
                this
                    .recursiveFunctionGroup
            );
            for (let c of s)
                this
                    .referencesFrom[
                    c.from]
                    .push(c),
                    this
                        .referencesTo[
                        c.to]
                        .push(c);
            this.iterationParameterIndex =
                i;
            let {
                baseCases: o,
                isEveryBranchRecursiveOrBaseCase: a,
                isUnconditionallyRecursive: u
            } = iw(t, n, r,
                i);
            this.isEveryBranchRecursiveOrBaseCase =
                a, this
                    .isUnconditionallyRecursive =
                u;
            for (let c of o)
                this
                    .baseCases[c
                        .fn]
                    .push(c)
        }
        hasRecursiveReferences
            () {
            for (let t of
                Object
                    .values(
                        this
                            .referencesFrom
                    ))
                if (t
                    .length >
                    0)
                    return !
                        0;
            return !1
        }
        getBaseCasesForFunction(
            t) {
            return this
                .baseCases[
                t]
        }
        getReferencesFrom(t) {
            return this
                .referencesFrom[
                t]
        }
        getReferencesTo(t) {
            return this
                .referencesTo[
                t]
        }
        getAllReferences() {
            let t = [];
            for (let n of
                Object
                    .values(
                        this
                            .referencesFrom
                    )) t
                        .push(...n);
            return t
        }
    };

    function rw(e, t, n) {
        if (t === void 0) return;
        let r = e.getInstruction(n),
            i = e.getInstruction(r
                .args[0]);
        if (i.type !== 25) return;
        let [s, o] = i.args, a;
        if (s === t) a = o;
        else if (o === t) a = s;
        else return;
        let u = e.getInstruction(a);
        if (bt(u) && u.valueType ===
            T) return u.value
    }

    function iw(e, t, n, r) {
        let i = [],
            s = !0,
            o = !0;
        for (let a in t) {
            let u = t[a],
                l = e
                    .getInstruction(u)
                    .endIndex,
                f = e
                    .getInstruction(l)
                    .args[0],
                m = r !== void 0 ?
                    f + r + 1 : void 0,
                g = {
                    [l]: !0
                };
            for (let d = l; d >
                f; d--) {
                if (!g[d]) continue;
                let y = e
                    .getInstruction(
                        d);
                if (!be(y)) {
                    if (y.type ===
                        33) {
                        let h = y
                            .args[
                            1],
                            b = y
                                .args[
                                2];
                        if (!n[h] ||
                            !n[b]) {
                            s = !1;
                            let P =
                                rw(e,
                                    m,
                                    d
                                );
                            P !==
                                void 0 &&
                                !n[
                                h] ?
                                i
                                    .push({
                                        fn: u,
                                        argValue: P
                                    }) :
                                o = !
                                1
                        }
                    }
                    for (let h of y
                        .args)
                        g[h] = !0
                }
            }
        }
        return i.sort((a, u) => q(a
            .argValue) - q(u
                .argValue)), {
            baseCases: i,
            isUnconditionallyRecursive: s,
            isEveryBranchRecursiveOrBaseCase: o
        }
    }
    var PT = Symbol(
        "NON_ITERATIVE");

    function sw(e, t) {
        let n = new Set(Object
            .values(t)),
            r = {},
            i = [],
            s;
        for (let o in t) {
            let a = t[o],
                c = e
                    .getInstruction(a)
                    .endIndex,
                p = e
                    .getInstruction(c)
                    .args[0],
                f = Yr(e, c);
            for (let m = p; m <
                c; m++) {
                let g = e
                    .getInstruction(
                        m);
                if (!be(g) && f[
                    m]) {
                    if (g.type ===
                        55 && n.has(
                            g.args[
                            0])
                    ) {
                        r[m] = !0;
                        let d = IT(
                            e,
                            p, g
                        );
                        d ? (d.iterationParameterIndex !==
                            void 0 &&
                            (s !==
                                void 0 &&
                                s !==
                                d
                                    .iterationParameterIndex ?
                                s =
                                PT :
                                s =
                                d
                                    .iterationParameterIndex
                            ),
                            i
                                .push(
                                    d
                                        .ref
                                )
                        ) :
                            s = PT
                    }
                    for (let d of e
                        .getDirectDependencies(
                            g))
                        if (r[d]) {
                            r[m] = !
                                0;
                            break
                        }
                }
            }
        }
        return s === void 0 &&
            Object.values(t).every(
                o => e
                    .getInstruction(o)
                    .signature.argTypes
                    .length === 1) && (
                s = 0), {
            dependsOnRecursiveCall: r,
            iterationParameterIndex: s ===
                PT ? void 0 : s,
            recursiveReferences: i
        }
    }

    function IT(e, t, n) {
        let r = e.getInstruction(t),
            i, s;
        for (let o = 1; o < n.args
            .length; o++) {
            let a = n.args[o],
                u = e
                    .getInstruction(a),
                c, l;
            if (u.type === 9 &&
                i === void 0) {
                let m = e
                    .getInstruction(
                        u.args[1]);
                if (!(m.type ===
                    1 && m
                        .valueType ===
                    T)) return;
                l = q(m.value), c =
                    u.args[0]
            } else l = 0, c = a;
            let p = e
                .getInstruction(c);
            if (!(p.type === 47 && p
                .args[0] ===
                t && o === c - t
            ) || l !== Math
                .floor(l) || l < 0)
                return;
            if (i === void 0) s = l,
                l !== 0 && (i = o -
                    1);
            else if (l !== 0) return
        }
        if (s !== void 0) return {
            ref: {
                from: r.args[0],
                to: n.args[0],
                iterationParameterOffset: s
            },
            iterationParameterIndex: i
        }
    }

    function eD(e, t) {
        var c, l;
        let n = new TT(e, t),
            r = {};
        for (let p in n
            .recursiveFunctionGroup) {
            let f = n
                .recursiveFunctionGroup[
                p],
                m = n
                    .getBaseCasesForFunction(
                        f);
            if (m.length === 0)
                continue;
            let g = q(m[0]
                .argValue),
                d = 1;
            for (; d < m.length &&
                q(m[d].argValue) ===
                q(m[d - 1]
                    .argValue) + 1;)
                d++;
            let y = m.slice(d).map(
                h => q(h
                    .argValue));
            r[p] = {
                min: g,
                consecutiveCount: d,
                additional: y
            }
        }
        let i = {},
            s = -1 / 0,
            o = 1 / 0;
        if (n
            .iterationParameterIndex !==
            void 0 && n
                .isEveryBranchRecursiveOrBaseCase
        ) {
            let p = new Map;
            for (let f of Object
                .values(n
                    .recursiveFunctionGroup
                )) {
                let m = e
                    .getInstruction(
                        f).symbol,
                    g = -1 / 0;
                for (let d of n
                    .getReferencesTo(
                        f)) g =
                            Math.max(g, d
                                .iterationParameterOffset
                            );
                if (isFinite(g) && (
                    i[m] = g),
                    g > 0) {
                    let d = r[e
                        .getInstruction(
                            f)
                        .symbol
                    ],
                        y = (c =
                            d ==
                                null ?
                                void 0 :
                                d.min
                        ) !=
                            null ? c : -
                            1 / 0;
                    p.set(f, {
                        min: y +
                            g,
                        max: y +
                            ((l = d ==
                                null ?
                                void 0 :
                                d
                                    .consecutiveCount
                            ) !=
                                null ?
                                l :
                                0
                            )
                    })
                }
            }
            for (let {
                min: f,
                max: m
            }
                of p.values()) s =
                    Math.max(s, f), o =
                    Math.min(o, m)
        }
        let a = {};
        for (let p in n
            .recursiveFunctionGroup) {
            let f = n
                .recursiveFunctionGroup[
                p],
                m = e
                    .getInstruction(f);
            a[p] = m
                .parameterSymbols
        }
        let u = {};
        for (let p in n
            .recursiveFunctionGroup) {
            let f = n
                .recursiveFunctionGroup[
                p],
                m = e
                    .getInstruction(f);
            u[p] = m.signature
                .argTypes.map((g,
                    d) => d === n
                        .iterationParameterIndex &&
                        n
                            .isEveryBranchRecursiveOrBaseCase &&
                        !n
                            .isUnconditionallyRecursive ?
                        1 : 0)
        }
        if (n
            .iterationParameterIndex !==
            void 0 && isFinite(s) &&
            s <= o) {
            let p = ow(n);
            return {
                canIterate: !0,
                parameterSymbols: a,
                baseCaseInfo: r,
                maxRecursiveCallOffsets: i,
                iterationParameterIndex: n
                    .iterationParameterIndex,
                domainInfo: u,
                loopStart: s,
                order: p
            }
        } else return {
            canIterate: !1,
            parameterSymbols: a,
            baseCaseInfo: r,
            maxRecursiveCallOffsets: i,
            iterationParameterIndex: n
                .iterationParameterIndex,
            domainInfo: u
        }
    }

    function ow(e) {
        if (e
            .iterationParameterIndex ===
            void 0) throw J(
                "Programming error: no recursive parameter"
            );
        let n = Object.values(e
            .recursiveFunctionGroup
        ),
            r = new Map,
            i = new Map,
            s = u => {
                let c = new Set;
                for (let l of e
                    .getReferencesTo(
                        u)) l
                            .iterationParameterOffset ===
                            0 && c.add(l
                                .from);
                return [...c]
            };
        n.forEach(u => {
            let c = s(u);
            r.set(u, c);
            for (let l of c)
                i.set(l, (i
                    .get(
                        l
                    ) ||
                    0) +
                    1);
            i.has(u) || i
                .set(u, 0)
        });
        let o = [];
        i.forEach((u, c) => {
            u === 0 && o
                .push(c)
        });
        let a = [];
        for (; o.length > 0;) {
            let u = o.shift();
            a.push(u), (r.get(u) ||
                []).forEach(
                    l => {
                        let p = l,
                            f = i
                                .get(
                                    p) - 1;
                        i.set(p, f),
                            f ===
                            0 && o
                                .push(p)
                    })
        }
        if (a.length !== n.length)
            throw fb();
        return a
    }

    function oy(e, t) {
        let n;
        for (let o = t, a = 0; o >
            0; o--) {
            let u = e
                .getInstruction(o);
            if (u.type === 53 &&
                a === 0) {
                n = o;
                break
            }
            u.type === 54 && a++, u
                .type === 53 && a--
        }
        if (n === void 0) return !1;
        let r = e.getInstruction(t),
            i = e.getInstruction(r
                .args[0]),
            s = e.getInstruction(n)
                .args[0];
        return i.recursionGroup
            .includes(s)
    }

    function tD(e, t, n) {
        if (e.glsl) throw J(
            "GLSL function not implemented"
        );
        let {
            chunk: r,
            referenced: i
        } = e, s = t.args[0], o = r
            .getInstruction(s), a =
                o.signature.argTypes;
        if (e.isTailFunction[s])
            return {
                type: zt.Noop,
                nextIdx: o
                    .endIndex + 1
            };
        e.enterFunction(t, n, 0);
        let u = "";
        for (let c = 0; c < a
            .length; c++) {
            let l = n + c + 1;
            i[l] && (u += `${an(l)}=${mT(s, c)};
`)
        }
        return {
            type: zt.Block,
            source: aw(e, t, n, u),
            nextIdx: n + 1
        }
    }

    function aw(e, t, n, r) {
        let {
            chunk: i
        } = e, s = t.args[0], o = i
            .getInstruction(s), a =
                o.signature.argTypes,
            u = "";
        for (let m = 0; m < a
            .length; m++) m > 0 && (
                u += ","), u += mT(
                    s, m);
        let c = yT(s),
            l = kv(s),
            p = zv(s),
            f = sy(s);
        return `
    const ${p}=${a.length === 1 && o.signature.argTypes[0] === T ? "({fn, args}) => `${fn}: ${args[0]}`":"({fn, args}) => `${fn}: $ {JSON.stringify(args)}`"};

    const ${c}=((${l}, ${u}) => {
      ${Fl(e, n + 1, o.endIndex - 1)}
      const ${f} = {depth: 0, count: 0};
      const cache = ${l};
      ${r}
    `
    }

    function nD(e, t, n) {
        let r = n + 1,
            i = t.args[0],
            o = e.chunk
                .getInstruction(i).args[
                0];
        if (e.isTailFunction[o])
            throw J(
                "Unexpected tail recursive function");
        let a = uw(e, t),
            {
                referenced: u
            } = e;
        return u[n] && (a += `${an(n)}=${e.referenceArg(t.args[0])};
`), e.exitFunction(), {
            type: zt.Block,
            source: a,
            nextIdx: r
        }
    }

    function uw(e, t) {
        let n = t.args[0],
            r = e.chunk
                .getInstruction(n),
            i = r.args[0],
            s = Hv(i),
            o = sy(i),
            a = r.valueType;
        return `
${o}.count++;
${o}.depth++;
let ${s};
if ((${o}.depth > BuiltIn.RECURSIVE_DEPTH_LIMIT) || (${o}.count > BuiltIn.RECURSIVE_COMPUTATION_LIMIT)) {
  ${s}=BuiltIn.handleRecursionLimitExceeded(__meta, ${a});
} else {
  ${s}=${e.referenceArg(t.args[1])};
}
return BuiltIn.recursionSuccess(${s},${o});
});
`
    }

    function bf(e, t) {
        return `{ fn: ${e}, args: ${t} }`
    }

    function rD(e, t, n) {
        let r = n + 1,
            {
                chunk: i
            } = e,
            s = t.args[0],
            o = i.getInstruction(s),
            u = i.getInstruction(o
                .endIndex).args[0],
            c = t.args.slice(1).map(
                y => e.referenceArg(
                    y)),
            l = an(n),
            p = $v(n),
            f = Uv(n),
            m = qv(n),
            g = i.getInstruction(u),
            d = i.getInstruction(g
                .args[0]);
        if (oy(i, n)) {
            if (e
                .recursiveFunctionInfo
                .length < 1)
                throw J(
                    "Expected recursive function info");
            let y = e
                .recursiveFunctionInfo[
                e
                    .recursiveFunctionInfo
                    .length - 1],
                h = "",
                b = Jv(e, y, n, t
                    .args.slice(1));
            if (e.isTailFunction[
                s]) {
                let I = g.valueType;
                b && (h = `
if (${b}) {
            return BuiltIn.recursionDiverges(__meta, ${I});
          }`);
                let E = d.signature
                    .argTypes,
                    v = h + `
`;
                v += "looping=true";
                for (let O = 0; O <
                    E.length; O++) {
                    let A = iy(u +
                        O + 1);
                    v += `,
${A}=${c[O]}`
                }
                return h ? {
                    type: zt
                        .Block,
                    source: v + `;
`,
                    nextIdx: r
                } : {
                    type: zt
                        .Inline,
                    source: v,
                    nextIdx: r
                }
            } else if (y
                .executionMode === 1
            ) {
                let I = i
                    .getInstruction(
                        i
                            .getInstruction(
                                y.fn)
                            .endIndex),
                    E = IT(i, I
                        .args[0], t
                    );
                if (!E) throw J(
                    "Expected valid iteration reference"
                );
                let v = hf(E.ref.to,
                    E.ref
                        .iterationParameterOffset
                );
                return {
                    type: zt.Inline,
                    source: `${l}=${v}`,
                    nextIdx: r
                }
            }
            b && (h = `
if (${b}) {
          return BuiltIn.SYMBOL_DIVERGES;
        }`);
            let x = sy(y.fn),
                P = bf(s, p),
                M = `
      const ${p} = ([${c.join(",")}]);
      ${h}
      const ${m} = cache.get(BuiltIn.recursionCacheKey(${P}));
      if (${m} === undefined) {
        return BuiltIn.recursionMissingCacheEntry(${P});
      }
      ${l} = ${m}[0];
      const ${f} = ${m}[1];
      if (${f}.count > ${x}.count) {
        ${x}.count = ${f}.count;
      }
      if (${f}.depth > ${x}.depth) {
        ${x}.depth = ${f}.depth;
      }
    `;
            return {
                type: zt.Block,
                source: M,
                nextIdx: r
            }
        } else {
            let y =
                `{${d.recursionGroup.map(P => `${P}: ${yT(P)}`).join(",")}}`,
                h = e.chunk
                    .getRecursionStructure(
                        g.args[0]);
            if (e.isTailFunction[s])
                return cw(e, t, n);
            if (h.canIterate)
                return lw(e, t, n,
                    h, {
                    innerFunctionsMap: y
                });
            let b = bf(s,
                `[${c.join(",")}]`
            ),
                x = `${l}=BuiltIn.executeRecursiveFunction(
      __meta,
      ${y},
      ${g.valueType},
      ${b}
    )`;
            return {
                type: zt.Inline,
                source: x,
                nextIdx: r
            }
        }
    }
    var iD = Symbol(
        "UPDATED_IN_BODY");

    function sD(e) {
        let t = "";
        for (let n of e) {
            let r = "declare" in n ?
                `let ${n.declare}` :
                an(n.reference),
                i = n.initializeRHS;
            t += `${r}=${i};
`
        }
        return t
    }

    function oD(e) {
        let t = "",
            n = "";
        for (let r of e) {
            let i = "declare" in r ?
                r.declare : an(r
                    .reference);
            r.updateRHS !== iD && (
                t && (t += ",",
                    n += ","),
                t += `${i}`,
                n +=
                `${r.updateRHS}`
            )
        }
        return `[${t}]=[${n}]`
    }

    function cw(e, t, n) {
        let r = t.args[0],
            i = e.chunk
                .getInstruction(r),
            s = e.chunk
                .getInstruction(i
                    .endIndex),
            o = s.args[0],
            a = e.chunk
                .getInstruction(o),
            u = a.valueType,
            c = an(n),
            l = [];
        e.enterFunction(a, o, 2);
        let p = ay(e, o, i.endIndex)
            .source;
        e.exitFunction();
        let f = Yv(n),
            m = Xv(n);
        l.push({
            declare: f,
            initializeRHS: "0",
            updateRHS: `${f}+1`
        }, {
            declare: m,
            initializeRHS: "0",
            updateRHS: `${m}+1`
        });
        for (let d = 1; d < t.args
            .length; d++) {
            let y = o + d;
            if (!e.referenced[y])
                continue;
            let h = iy(y);
            l.push({
                reference: y,
                initializeRHS: e
                    .referenceArg(
                        t
                            .args[
                        d
                        ]
                    ),
                updateRHS: h
            }, {
                declare: h,
                initializeRHS: void 0,
                updateRHS: iD
            })
        }
        let g = `${c}=(() => {
    ${Fl(e, o + 1, i.endIndex - 1)}

    let looping = true;
    ${sD(l)}
    while (looping) {
      looping = false;

      ${p}

      if (looping) {
        ${oD(l)}
      }

      if ((${f} > BuiltIn.RECURSIVE_DEPTH_LIMIT) || (${m} > BuiltIn.RECURSIVE_COMPUTATION_LIMIT)) {
        return BuiltIn.handleRecursionLimitExceeded(__meta, ${u});
      };
    }

    return ${e.referenceArg(s.args[1])}
  })()`;
        return {
            type: zt.Inline,
            source: g,
            nextIdx: n + 1
        }
    }

    function lw(e, t, n, r, i) {
        let s = t.args[0],
            o = e.chunk
                .getInstruction(s),
            a = e.chunk
                .getInstruction(o
                    .endIndex),
            u = a.args[0],
            c = an(n),
            l = [],
            p = "",
            f, {
                iterationParameterIndex: m,
                loopStart: g,
                order: d
            } = r,
            y = r
                .maxRecursiveCallOffsets,
            h = u + m + 1,
            b = an(h),
            x = t.args[m + 1],
            P = `(${g})`,
            M = e.chunk
                .getInstruction(x),
            I = (M.type === 39 || M
                .type === 41) && e
                    .chunk.getInstruction(M
                        .args[1]).type ===
                23 ? M.args[0] : void 0,
            E =
                `(${e.referenceArg(x)})-${P}`,
            v, O;
        if (I !== void 0) {
            let z = e.referenceArg(
                I);
            v = `BuiltIn.listMax(
      (${z}).filter(
        x => isFinite(x) &&
        Math.floor(x - ${P}) === (x - ${P})
      )
    )`, O = `BuiltIn.getBroadcastTargetElements(${z}).has(${b})`
        } else v =
            `(${e.referenceArg(x)})`,
            O = "false";
        l.push({
            reference: h,
            initializeRHS: `(${P})`,
            updateRHS: `${b}+1`
        }), f = "";
        for (let z of d) {
            let G = e.chunk
                .getInstruction(z),
                $ = G.endIndex,
                w = e.chunk
                    .getInstruction($),
                Y = w.args[0],
                de = e.chunk
                    .getInstruction(Y);
            for (let ie = 1; ie < t
                .args.length; ie++
            ) {
                let Z = Y + ie;
                if (!e.referenced[
                    Z]) continue;
                let Re = an(Z);
                ie === m + 1 ? f += `${Re}=${e.referenceArg(h)};
` : p += `${Re}=${e.referenceArg(t.args[ie])};
`
            }
            p += Fl(e, Y + 1, G
                .endIndex - 1);
            let re = y[G.symbol];
            if (re !== void 0)
                for (let ie =
                    1; ie <=
                    re; ie++) {
                    let Z = hf(z,
                        ie),
                        Re = ie ===
                            1 ? e
                                .referenceArg(
                                    w.args[
                                    1]
                                ) : hf(
                                    z, ie -
                                1),
                        Ne = t.args
                            .slice(1)
                            .map((Q,
                                U) =>
                                U ===
                                    m ? g -
                                ie : e
                                    .referenceArg(
                                        Q)),
                        Te = bf(z,
                            `[${Ne.join(",")}]`
                        ),
                        Me = `BuiltIn.executeRecursiveFunction(
            __meta,
            ${i.innerFunctionsMap},
            ${de.valueType},
            ${Te}
          )`,
                        ve = `(
          broadcastOutputMap
            ? (broadcastOutputMap[BuiltIn.recursionCacheKey(${Te})] = ${Me})
            : ${Me}
        )`;
                    l.push({
                        declare: Z,
                        initializeRHS: ve,
                        updateRHS: Re
                    })
                }
            e.enterFunction(de, Y,
                1), f += ay(e,
                    Y, G.endIndex)
                    .source, e
                        .exitFunction(),
                f += `const ${hf(z, 0)}=${e.referenceArg(w.args[1])};
`
        }
        let A = t.args.slice(1).map(
            z => e.referenceArg(
                z)),
            N = t.args.slice(1).map(
                (z, G) => G === m ?
                    b : e.referenceArg(
                        z)),
            L = `${c}=(() => {
    ${p}
    const broadcastOutputMap = ${I !== void 0 ? "__meta.iterativeRecursionOutputs" : "undefined"};

    ${sD(l)}

    const outerStackFrame = ${bf(s, `[${A.join(",")}]`)};

    if (broadcastOutputMap) {
        const cacheEntry = broadcastOutputMap[BuiltIn.recursionCacheKey(outerStackFrame)];
        if (cacheEntry !== undefined) {
          return cacheEntry;
        }
      }


    const targetLoopSteps = ${E}
    if (targetLoopSteps < 0 || Math.floor(targetLoopSteps) !== targetLoopSteps) {
      return BuiltIn.executeRecursiveFunction(
        __meta,
        ${i.innerFunctionsMap},
        ${o.valueType},
        outerStackFrame
      );
    }

    const loopEnd = ${v};

    let result;
    while (true) {
      ${f}

      result = ${e.referenceArg(a.args[1])};

      if (broadcastOutputMap && ${O}) {
        const key = BuiltIn.recursionCacheKey(${bf(s, `[${N.join(",")}]`)});
        broadcastOutputMap[key] = result;
      }

      if (${b} < loopEnd) {
        ${oD(l)}
      } else {
        break;
      }
    }

    ${I === void 0 ? "return result;" : `const cached = broadcastOutputMap[BuiltIn.recursionCacheKey(outerStackFrame)];
          if (cached === undefined) {
            return BuiltIn.recursionDiverges(__meta, ${o.valueType});
          }
          return cached;
          `}
  })()`;
        return {
            type: zt.Inline,
            source: L,
            nextIdx: n + 1
        }
    }

    function uy(e) {
        let {
            chunk: t
        } = e, n = Fl(e, t.argNames
            .length, t
                .instructionsLength() -
        1), r = 0;
        for (; r < t
            .instructionsLength();
        ) {
            let i = t
                .getInstruction(r),
                s = ET(e, i, r);
            n += xT(s), r = s
                .nextIdx
        }
        return n +=
            `return ${e.referenceArg(t.getReturnIndex())};`,
            n
    }

    function pw(e, t) {
        let {
            chunk: n
        } = e, r = [], i = e
            .thunkName(t), s = e
                .thunkEnd(i), o = _l(i),
            a = Ll(i), u = "", c = !
                1, l = !1;
        e.wantToInlineThunk(i) || (
            l = !0);
        let p = t;
        for (; p <= s;) {
            let f = n
                .getInstruction(p),
                m = p === t ? aD(e,
                    f, p) : ET(e, f,
                        p);
            switch (m.type) {
                case zt.Noop:
                    break;
                case zt.Inline:
                    c && (u += `,
`), u += m.source, c = !0;
                    break;
                case zt.Block:
                    c && (u += `;
`), c = !1, u += m.source, l = !0;
                    break
            }
            r.push(u), p = m.nextIdx
        }
        if (u === "" && (u = "0",
            l = !1), l) {
            let f = `${o}=false;${a}=()=>{
${o}=true;

      ${u}${c ? ";" : ""}
    };
`;
            return {
                type: zt.Block,
                source: f,
                nextIdx: p
            }
        } else return e.inlineThunk(
            i, u), {
            type: zt.Noop,
            nextIdx: p
        }
    }

    function ET(e, t, n) {
        return e.isThunkBegin(n) ?
            pw(e, n) : aD(e, t, n)
    }

    function aD(e, t, n) {
        let r = n + 1;
        if (!e.referenced[n])
            return {
                type: zt.Noop,
                nextIdx: r
            };
        switch (t.type) {
            case 0:
            case 47:
            case 48:
            case 22:
            case 49:
            case 4:
                return {
                    type: zt.Noop,
                    nextIdx: r
                };
            case 21:
                if (e.glsl)
                    throw ux();
                return dw(e, t, n);
            case 2:
                return e
                    .inlineSource(n,
                        e.chunk
                            .argNames[n]
                    ), {
                    type: zt
                        .Noop,
                    nextIdx: r
                };
            case 23:
                return {
                    type: zt.Block,
                    source: mw(
                        e, t, n
                    ),
                    nextIdx: r
                };
            case 24:
                return {
                    type: zt.Block,
                    source: yw(
                        e, t, n
                    ),
                    nextIdx: r
                };
            case 19:
                return {
                    type: zt.Block,
                    source: gw(
                        e, t, n
                    ),
                    nextIdx: r
                };
            case 20:
                return {
                    type: zt.Block,
                    source: hw(
                        e, t, n
                    ),
                    nextIdx: r
                };
            case 50:
                return {
                    type: zt.Block,
                    source: bw(
                        e, t, n
                    ),
                    nextIdx: r
                };
            case 51:
                return {
                    type: zt.Block,
                    source: xw(
                        e, t, n
                    ),
                    nextIdx: r
                };
            case 53:
                return tD(e, t, n);
            case 54:
                return nD(e, t, n);
            case 33: {
                let i = e
                    .referenceArg(t
                        .args[0]),
                    s = e
                        .referencePiecewiseBranch(
                            t.args[1]),
                    o = e
                        .referencePiecewiseBranch(
                            t.args[2]);
                if (!(s.thunkDependencies
                    .some(p => e
                        .isEarlyReturningThunk(
                            p)
                    ) || o
                        .thunkDependencies
                        .some(p => e
                            .isEarlyReturningThunk(
                                p))
                )) {
                    let p = e
                        .emitTernary(
                            i, s
                            .expression,
                            o
                                .expression,
                            t);
                    return e
                        .shouldInline(
                            n) ? (e
                                .inlineSource(
                                    n,
                                    `(${p})`
                                ), {
                                type: zt
                                    .Noop,
                                nextIdx: r
                            }) : {
                        type: zt
                            .Inline,
                        source: `${an(n)}=${p}`,
                        nextIdx: r
                    }
                }
                let u = an(n),
                    c = p => {
                        if (p
                            .length ===
                            0)
                            return "";
                        let f = "";
                        for (let m of
                            p) {
                            let g =
                                e
                                    .inlinedThunks[
                                m
                                ];
                            if (g !==
                                void 0
                            ) {
                                let d =
                                    `(${g},void 0)`;
                                f !==
                                    "" ?
                                    f =
                                    `(${f}||${d})` :
                                    f =
                                    d
                            } else {
                                let d =
                                    _l(
                                        m),
                                    y =
                                        Ll(
                                            m);
                                f !==
                                    "" &&
                                    (f +=
                                        "||"
                                    ),
                                    f +=
                                    `(${d} ? undefined : ${y}())`
                            }
                        }
                        return f =
                            "const earlyReturn =" +
                            f, f += `;
if (earlyReturn !== undefined) return earlyReturn;
`, f
                    },
                    l = `if (${i}) {
          ${c(s.thunkDependencies)}${u} = ${s.rawExpression};
        } else {
          ${c(o.thunkDependencies)}${u} = ${o.rawExpression};
        }`;
                return {
                    type: zt.Block,
                    source: l,
                    nextIdx: r
                }
            }
            case 55:
                return rD(e, t, n);
            default: {
                let i = Pw(e, t);
                return e
                    .shouldInline(
                        n) ? (e
                            .inlineSource(
                                n,
                                `(${i})`
                            ), {
                            type: zt
                                .Noop,
                            nextIdx: r
                        }) : {
                    type: zt
                        .Inline,
                    source: `${an(n)}=${i}`,
                    nextIdx: r
                }
            }
        }
    }

    function ay(e, t, n) {
        let {
            chunk: r,
            referenced: i
        } = e, s = "", o = t + 1;
        for (; o < n;) {
            if (!i[o]) {
                o = o + 1;
                continue
            }
            let a = r
                .getInstruction(o),
                u = ET(e, a, o);
            s += xT(u), o = u
                .nextIdx
        }
        return {
            type: zt.Block,
            source: s,
            nextIdx: o
        }
    }

    function fw(e, t, n) {
        let {
            endIndex: r
        } = t, {
            chunk: i
        } = e, s = `function(${an(n)}) {
`, o = n + 1, a = r - 1;
        s += Fl(e, o, a), s += ay(e,
            n, r).source;
        let u = i.getInstruction(r);
        return s += `return ${e.referenceArg(u.args[1])};
}`, s
    }

    function dw(e, t, n) {
        let r = "BuiltIn.quad(";
        r += fw(e, t, n), r +=
            `,${e.referenceArg(t.args[0])},${e.referenceArg(t.args[1])})`;
        let {
            endIndex: i
        } = t, s = i + 1;
        return e.shouldInline(s) ? (
            e.inlineSource(s,
                r), {
                type: zt.Noop,
                nextIdx: t
                    .endIndex
            }) : {
            type: zt.Inline,
            source: `${an(i + 1)}=${r}`,
            nextIdx: t.endIndex
        }
    }

    function Fl(e, t, n) {
        let {
            chunk: r,
            referenced: i
        } = e, s = "", o = !1;
        for (let a = t; a <=
            n; a++) {
            if (!e.glsl && e
                .isThunkBegin(a)) {
                let c = e.thunkName(
                    a);
                s += `${o ? "," : "var "}${_l(c)}`,
                    s +=
                    `,${Ll(c)}`,
                    o = !0
            }
            let u = r
                .getInstruction(a);
            if (!(u.type === 0 || u
                .type === 24 ||
                u.type === 20 ||
                !i[a])) {
                if (u.type === 21) {
                    let {
                        endIndex: c
                    } = u;
                    a = c, e
                        .shouldInline(
                            c + 1
                        ) &&
                        a++;
                    continue
                }
                if (!e.shouldInline(
                    a) && (s +=
                        e
                            .emitVarDeclaration(
                                a, o),
                        o = !0, u
                            .type === 53
                    )) {
                    let {
                        endIndex: c
                    } = u;
                    a = c - 1;
                    continue
                }
            }
        }
        return o && (s += `;
`), s
    }

    function mw(e, t, n) {
        let {
            glsl: r,
            chunk: i,
            referenced: s
        } = e, o = an(n), a = i
            .getInstruction(t
                .endIndex), u = e
                    .referenceArg(t.args[
                        0]), c = "";
        for (let p = 1; p < a.args
            .length; p++) {
            let f = t.endIndex + p;
            if (!s[f] || i
                .getInstruction(f)
                .type !== 48)
                continue;
            let g = an(f);
            r || (c += `${g}=[];
`)
        }
        return r || (c += `if(${u}>${1e4}) throw ErrorMsg.maxListSize();
`), c += `for(${o}=1${r ? ".0" : ""};${o}<=${u};${o}++){
`, c
    }

    function yw(e, t, n) {
        let {
            glsl: r,
            chunk: i,
            referenced: s
        } = e, o = "";
        for (let a = 1; a < t.args
            .length; a++) {
            let u = n + a;
            if (u >= i
                .instructionsLength() ||
                !s[u] || i
                    .getInstruction(u)
                    .type !== 48)
                continue;
            let c = an(n + a),
                l = e.referenceArg(t
                    .args[a]);
            if (r) {
                let p = e
                    .referenceArg(t
                        .args[0]);
                o += `${c}[int(${p})-1]=${l};
`
            } else o += `${c}.push(${l});
`
        }
        return o += `}
`, o
    }

    function gw(e, t, n) {
        let {
            chunk: r,
            referenced: i
        } = e, s = an(n);
        e.beforeBeginLoop(t);
        let o =
            `${e.referenceArg(t.args[0])}`,
            a =
                `${e.referenceArg(t.args[1])}`,
            u = `if(${o}>${a}){
`;
        for (let c = 2; c < t.args
            .length; c++) {
            let l = t.endIndex + c -
                1;
            if (l >= r
                .instructionsLength() ||
                !i[l] || r
                    .getInstruction(l)
                    .type !== 47)
                continue;
            let p = an(l);
            u += `${p}=${e.referenceArg(t.args[c])};
`
        }
        u += e.checkFiniteBounds(t,
            o, a), u += `}else{
`;
        for (let c = 2; c < t.args
            .length; c++) {
            let l = n + c - 1;
            if (!i[l] || r
                .getInstruction(l)
                .type !== 47)
                continue;
            let p = an(l);
            u += `${p}=${e.referenceArg(t.args[c])};
`
        }
        return u += `${s}=${o};
`, u += "while (true) {", u
    }

    function hw(e, t, n) {
        let {
            chunk: r,
            referenced: i
        } = e, s = r.getInstruction(
            t.args[0]), o =
                `${e.referenceArg(s.args[1])}`,
            a = an(t.args[0]), u =
                `${a}++;`;
        u += `if (${a}<=${o}) {
`;
        let c = {};
        for (let l = 1; l < t.args
            .length; l++) {
            let p = t.args[0] + l;
            if (!i[p] || r
                .getInstruction(p)
                .type !== 47)
                continue;
            let f = an(p),
                m = e.referenceArg(t
                    .args[l]);
            c[f] = m
        }
        for (let l in c) {
            let p = c[l];
            c[p] && (u += `const _next_${l}=${p};
`, c[l] = `_next_${l}`)
        }
        for (let l in c) {
            let p = c[l];
            u += `${l}=${p};
`
        }
        u += `} else {
`;
        for (let l = 1; l < t.args
            .length; l++) {
            let p = n + l;
            if (p >= r
                .instructionsLength() ||
                !i[p] || r
                    .getInstruction(p)
                    .type !== 47)
                continue;
            let f = an(p);
            u += `${f}=${e.referenceArg(t.args[l])};
`
        }
        return u += `break;
`, u += `}
}
`, u += `}
`, u
    }

    function bw(e, t, n) {
        let {
            glsl: r
        } = e;
        if (r) throw J(
            "GLSL map not implemented yet"
        );
        let i = an(t.endIndex + 1),
            s = [];
        for (let a = 0; a < t
            .callData
            .parameterSymbols
            .length; a++) {
            let u = an(n + a + 1);
            s.push(u)
        }
        let o = s.join(",");
        return `${i}=(${o}) => {
`
    }

    function xw(e, t, n) {
        let r =
            `return ${e.referenceArg(t.args[1])}`;
        return r += `}
`, r
    }

    function Pw(e, t) {
        switch (t.type) {
            case 1:
                return e
                    .emitConstant(
                        t);
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 31:
            case 32:
                return e.emitBinary(
                    t, e
                        .referenceArg(
                            t.args[
                            0]),
                    e
                        .referenceArg(
                            t.args[
                            1]));
            case 14: {
                let r = e
                    .referenceArg(t
                        .args[0]);
                return e.emitNeg(r)
            }
            case 15:
                return e.emitVec2(e
                    .referenceArg(
                        t.args[
                        0]),
                    e
                        .referenceArg(
                            t.args[
                            1]));
            case 16:
                return e.emitVec3(e
                    .referenceArg(
                        t.args[
                        0]),
                    e
                        .referenceArg(
                            t.args[
                            1]),
                    e
                        .referenceArg(
                            t.args[
                            2]));
            case 17:
            case 18:
                return e
                    .emitVecAccess(e
                        .referenceArg(
                            t.args[
                            0]),
                        t.index);
            case 38:
                return e.emitList(t
                    .args.map(
                        r => e
                            .referenceArg(
                                r)),
                    t);
            case 40:
            case 42:
            case 3:
                throw new Error(
                    `Programming Error: expect ${Ar(t.type)} to be removed before emitting code.`
                );
            case 39: {
                let r = t.valueType;
                return e
                    .emitListAccess(
                        e
                            .referenceArg(
                                t.args[
                                0]),
                        e
                            .referenceArg(
                                t.args[
                                1]),
                        e
                            .printValue(
                                $r(r), r
                            ), t)
            }
            case 41:
                return e
                    .emitInboundsListAccess(
                        e
                            .referenceArg(
                                t.args[
                                0]),
                        e
                            .referenceArg(
                                t.args[
                                1])
                    );
            case 37:
                return e
                    .emitNativeFunction(
                        t.args.map(
                            r => e
                                .referenceArg(
                                    r)),
                        t);
            case 44:
                return e
                    .emitExtendSeed(
                        e
                            .referenceArg(
                                t.args[
                                0]),
                        e
                            .referenceArg(
                                t.args[
                                1]),
                        t.tag);
            case 2:
            case 0:
            case 21:
            case 22:
            case 19:
            case 20:
            case 23:
            case 24:
            case 47:
            case 48:
            case 49:
            case 50:
            case 51:
            case 53:
            case 54:
            case 33:
            case 55:
            case 4:
                throw new Error(
                    `Unexpected opcode ${t.type}`
                );
            default:
                let n = t;
                throw new Error(
                    `Unexpected opcode ${n.type}`
                )
        }
    }

    function cy(e) {
        let t = new MT(e),
            n = uy(t);
        return t.finish(n)
    }
    var MT = class extends wl {
        constructor(n) {
            super(n, !1);
            this.constants = []
        }
        finish(n) {
            return {
                source: n,
                constants: this
                    .constants
            }
        }
        printValue(n) {
            return uD(n)
        }
        beforeBeginLoop() { }
        checkFiniteBounds(n, r,
            i) {
            let s = `}else if(!isFinite(${i}-${r})){
`;
            for (let o =
                2; o < n
                    .args
                    .length; o++
            ) {
                let a = n
                    .endIndex +
                    o - 1;
                if (a >=
                    this
                        .chunk
                        .instructionsLength() ||
                    !this
                        .referenced[
                    a])
                    continue;
                let u = this
                    .chunk
                    .getInstruction(
                        a);
                if (u
                    .type !==
                    47)
                    continue;
                let c = an(
                    a);
                uo(u.valueType) ?
                    s += `${c}=${this.printValue($r(u.valueType))};
` : s += `throw new Error('Cannot set ${c} of type ${on(u.valueType)} to NaN value');
`
            }
            return s
        }
        emitConstant(n) {
            return n
                .valueType ===
                T || n
                    .valueType ===
                ge || n
                    .valueType ===
                R || n
                    .valueType ===
                V ? this
                    .printValue(
                        n.value
                    ) : (
                this
                    .constants
                    .push(
                        ao(n
                            .value)
                    ),
                `_C[${this.constants.length - 1}]`
            )
        }
        emitNeg(n) {
            return `-${n}`
        }
        emitTernary(n, r, i) {
            return `${n}?${r}:${i}`
        }
        emitVec2(n, r) {
            return `[${n},${r}]`
        }
        emitVec3(n, r, i) {
            return `[${n},${r},${i}]`
        }
        emitVecAccess(n, r) {
            return `${n}[${r - 1}]`
        }
        emitBinary(n, r, i) {
            switch (n
                .type) {
                case 8:
                    return `${r}+${i}`;
                case 9:
                    return `${r}-${i}`;
                case 10:
                    return `${r}*${i}`;
                case 11:
                    return `${r}/${i}`;
                case 12:
                    return `BuiltIn.pow(${r},${i})`;
                case 13:
                    return `Math.pow(${r},${i})`;
                case 25:
                    return `${r}===${i}`;
                case 26:
                    return `${r}<${i}`;
                case 28:
                    return `${r}<=${i}`;
                case 27:
                    return `${r}>${i}`;
                case 29:
                    return `${r}>=${i}`;
                case 31:
                    return `${r}||${i}`;
                case 32:
                    return `${r}&&${i}`;
                default:
                    throw new Error(
                        "Programming Error: invalid binary opcode."
                    )
            }
        }
        emitList(n) {
            return `[${n.join(",")}]`
        }
        emitListAccess(n, r,
            i) {
            let s =
                `${n}.length`,
                o =
                    `Math.floor(${r})`;
            return `(${o}>=1&&${o}<=${s})?${n}[${o}-1]:${i}`
        }
        emitInboundsListAccess(
            n, r) {
            return `${n}[${r}-1]`
        }
        emitNativeFunction(n,
            r) {
            let i = bn[r
                .symbol];
            return `${i.module}.${i.symbol}(${n.join(",")})`
        }
        emitExtendSeed(n, r,
            i) {
            return `${n}+'::${i}'+${r}`
        }
        emitVarDeclaration(n,
            r) {
            let i = r ?
                "," :
                "var ";
            return i += an(
                n), i
        }
        emitFunctionCall(n, r,
            i, s) {
            return `${n}(${r}, ${i}, ${s.join(",")})`
        }
    };

    function uD(e) {
        if (Array.isArray(e))
            return `[${e.map(uD).join(",")}]`;
        switch (typeof e) {
            case "boolean":
            case "number":
                return e.toString();
            case "string":
                return `${JSON.stringify(e)}`;
            case "object":
                if (Ja(e))
                    throw new Error(
                        "Action values cannot be compiled"
                    );
                return q(e)
                    .toString();
            default:
                throw new Error(
                    "Unexpected value: " +
                    e)
        }
    }
    var fo = {};
    No(fo, {
        LruCache: () => ql,
        RECURSIVE_COMPUTATION_LIMIT: () =>
            y1,
        RECURSIVE_DEPTH_LIMIT: () =>
            Lf,
        RecursiveFunctionResult: () =>
            m1,
        SYMBOL_DIVERGES: () =>
            d1,
        TerminationStatus: () =>
            g1,
        acosh: () => c1,
        acot: () => pF,
        acoth: () => xF,
        acsc: () => fF,
        acsch: () => bF,
        addTangentAngle: () =>
            GV,
        addTangentArc: () =>
            BV,
        addTangentCircle: () =>
            VV,
        addTangentLine: () =>
            wV,
        addTangentRay: () =>
            FV,
        addTangentSegment: () =>
            hI,
        addTangentSegmentThreeD: () =>
            LV,
        angleMarkerMultiplier: () =>
            vV,
        angleMarkerRawDelta: () =>
            MV,
        arc: () => IV,
        arcArcIntersection: () =>
            XV,
        arcCenter: () => jl,
        arcCircleIntersection: () =>
            YV,
        arcGlider: () => Z1,
        arcLineIntersection: () =>
            Q1,
        arcOmega: () => Jl,
        argMax: () => YF,
        argMin: () => $F,
        asec: () => dF,
        asech: () => hF,
        asinh: () => l1,
        atanh: () => p1,
        basePointFromVector: () =>
            mV,
        basePointFromVectorThreeD: () =>
            hV,
        bernoulliTable: () =>
            T1,
        binomSample: () =>
            AF,
        binomcdf: () => LF,
        binompdf: () => Fy,
        center: () => PV,
        chooseNonIncidentPoint: () =>
            UV,
        circle: () => xV,
        circleArcIntersection: () =>
            $V,
        circleCircleIntersection: () =>
            Af,
        circleGlider: () =>
            zV,
        circleLineIntersection: () =>
            TI,
        clamp: () => rr,
        common_log: () =>
            oF,
        composeTransformation: () =>
            oB,
        corr: () => By,
        cos: () => xn,
        cosh: () => o1,
        cot: () => lF,
        cotDerivative: () =>
            I1,
        coth: () => gF,
        cov: () => ZF,
        covp: () => G1,
        csc: () => cF,
        csch: () => yF,
        dilation: () => rB,
        directedAngleMarker: () =>
            Y1,
        directedCoterminalAngle: () =>
            X1,
        distance: () => Xl,
        distanceThreeD: () =>
            QF,
        elementsAt: () =>
            hB,
        erf: () => VF,
        erfcx: () => Ta,
        executeRecursiveFunction: () =>
            jw,
        expm1: () => qw,
        factorial: () => $o,
        frequency: () => PB,
        gcd: () => tI,
        getArcDetails: () =>
            Gy,
        getBroadcastTargetElements: () =>
            Xw,
        getRecursiveDepthLimit: () =>
            Yw,
        handleRecursionLimitExceeded: () =>
            b1,
        hsv: () => KF,
        hypot: () => po,
        identity: () => bV,
        invBinom: () => R1,
        invNorm: () => aI,
        invPoisson: () =>
            C1,
        invT: () => N1,
        invUniform: () =>
            GF,
        invertTransformation: () =>
            aB,
        isDegenerateArc: () =>
            yI,
        itscore: () => _1,
        ittest: () => cI,
        lcm: () => P1,
        line: () => pV,
        lineArcIntersection: () =>
            J1,
        lineCircleIntersection: () =>
            PI,
        lineGlider: () =>
            bI,
        lineLineIntersection: () =>
            j1,
        listGCD: () => Kw,
        listLCM: () => eF,
        listLength: () =>
            kF,
        listMax: () => w1,
        listMin: () => L1,
        log: () => sF,
        log1p: () => _f,
        log_base: () => M1,
        lowerQuantileIndex: () =>
            HF,
        lowerQuartileIndex: () =>
            qF,
        mad: () => XF,
        mathVector: () =>
            U1,
        mathVectorThreeD: () =>
            q1,
        md5Spyable: () =>
            s1,
        mean: () => Xo,
        median: () => V1,
        mod: () => x1,
        nCr: () => ou,
        nPr: () => Dy,
        normalSample: () =>
            RF,
        normalcdf: () => OF,
        normalpdf: () => rI,
        nthroot: () => aF,
        parallel: () => JV,
        perpendicular: () =>
            QV,
        pointDet: () => tS,
        pointDot: () => KV,
        pointPerp: () => eB,
        poissonSample: () =>
            _F,
        poissoncdf: () =>
            wF,
        poissonpdf: () =>
            Yl,
        polyGamma: () => E1,
        polygon: () => eV,
        polygonArea: () =>
            dI,
        polygonEdges: () =>
            sV,
        polygonGlider: () =>
            HV,
        polygonInteriorDirectedAngles: () =>
            lV,
        polygonInteriorUndirectedAngles: () =>
            cV,
        polygonPerimeter: () =>
            oV,
        pow: () => f1,
        quad: () => JF,
        quantile: () => F1,
        quartile: () => Ic,
        quartileIndex: () =>
            Vy,
        radius: () => TV,
        random: () => iI,
        randomPerm: () =>
            sI,
        rank: () => JT,
        ray: () => fV,
        rayGlider: () => QT,
        recursionCacheKey: () =>
            WT,
        recursionDiverges: () =>
            h1,
        recursionMissingCacheEntry: () =>
            Ww,
        recursionSuccess: () =>
            Zw,
        reflection: () =>
            sB,
        restriction: () =>
            EB,
        restrictionToBoolean: () =>
            MB,
        rgb: () => k1,
        rotation: () => iB,
        scaleTangentAngle: () =>
            _V,
        scaleTangentArc: () =>
            AV,
        scaleTangentCircle: () =>
            NV,
        scaleTangentLine: () =>
            CV,
        scaleTangentRay: () =>
            RV,
        scaleTangentSegment: () =>
            gI,
        sec: () => uF,
        sech: () => mF,
        segment: () => mI,
        segmentGlider: () =>
            xI,
        segmentThreeD: () =>
            tV,
        segmentThreeDGlider: () =>
            kV,
        select: () => gB,
        shuffle: () => CF,
        sign: () => eI,
        sin: () => Kt,
        sinh: () => a1,
        sortPerm: () => Ec,
        spearman: () => WF,
        sphere: () => rV,
        sqrtxsqm1: () => Qw,
        sqrtxsqp1: () => Jw,
        stats: () => lI,
        stdev: () => Sy,
        stdevp: () => jF,
        supplementAngle: () =>
            SV,
        tSample: () => NF,
        tan: () => D1,
        tanh: () => u1,
        tcdf: () => My,
        testingOnlySetRecursiveDepthLimit: () =>
            nI,
        toFraction: () =>
            $w,
        tone: () => xB,
        total: () => TF,
        tpdf: () => wy,
        transformAngleMarker: () =>
            yB,
        transformArc: () =>
            dB,
        transformCircle: () =>
            fB,
        transformLine: () =>
            cB,
        transformPoint: () =>
            Yo,
        transformPolygon: () =>
            mB,
        transformRay: () =>
            lB,
        transformSegment: () =>
            ky,
        transformVector: () =>
            pB,
        transformation: () =>
            tB,
        translation: () =>
            nB,
        triangle: () => nV,
        tscore: () => A1,
        ttest: () => uI,
        undirectedAngleMarker: () =>
            EV,
        undirectedCoterminalAngle: () =>
            DV,
        uniformSample: () =>
            au,
        uniformcdf: () =>
            FF,
        uniformpdf: () =>
            oI,
        uniquePerm: () =>
            bB,
        upperQuantileIndex: () =>
            zF,
        upperQuartileIndex: () =>
            UF,
        validateRangeLength: () =>
            pI,
        validateSampleCount: () =>
            fI,
        variance: () => B1,
        varp: () => wf,
        vector: () => H1,
        vectorDisplacementAsPoint: () =>
            dV,
        vectorThreeD: () =>
            yV,
        vectorThreeDDisplacementAsPoint: () =>
            gV,
        vertices: () => iV,
        volume: () => TB
    });
    var cD = function () {
        "use strict";

        function e(d, y) {
            var h = (d &
                65535) + (y &
                    65535),
                b = (d >> 16) +
                    (y >> 16) + (
                        h >> 16);
            return b << 16 | h &
                65535
        }

        function t(d, y) {
            return d << y |
                d >>> 32 - y
        }

        function n(d, y, h, b,
            x, P) {
            return e(t(e(e(y,
                d),
                e(b,
                    P)
            ),
                x), h)
        }

        function r(d, y, h, b,
            x, P, M) {
            return n(y & h | ~
                y & b, d, y,
                x, P, M)
        }

        function i(d, y, h, b,
            x, P, M) {
            return n(y & b | h &
                ~b, d, y, x,
                P, M)
        }

        function s(d, y, h, b,
            x, P, M) {
            return n(y ^ h ^ b,
                d, y, x, P,
                M)
        }

        function o(d, y, h, b,
            x, P, M) {
            return n(h ^ (y | ~
                b), d,
                y, x, P, M)
        }

        function a(d, y) {
            d[y >> 5] |= 128 <<
                y % 32, d[(y +
                    64 >>>
                    9 << 4
                ) + 14
                ] = y;
            var h, b, x, P, M,
                I = 1732584193,
                E = -271733879,
                v = -1732584194,
                O = 271733878;
            for (h = 0; h < d
                .length; h += 16
            ) b = I, x = E,
                P = v, M = O,
                I = r(I, E, v,
                    O, d[h], 7,
                    -680876936),
                O = r(O, I, E,
                    v, d[h + 1],
                    12, -
                389564586),
                v = r(v, O, I,
                    E, d[h + 2],
                    17,
                    606105819),
                E = r(E, v, O,
                    I, d[h + 3],
                    22, -
                1044525330),
                I = r(I, E, v,
                    O, d[h + 4],
                    7, -
                176418897),
                O = r(O, I, E,
                    v, d[h + 5],
                    12,
                    1200080426),
                v = r(v, O, I,
                    E, d[h + 6],
                    17, -
                1473231341),
                E = r(E, v, O,
                    I, d[h + 7],
                    22, -
                45705983),
                I = r(I, E, v,
                    O, d[h + 8],
                    7,
                    1770035416),
                O = r(O, I, E,
                    v, d[h + 9],
                    12, -
                1958414417),
                v = r(v, O, I,
                    E, d[h +
                    10], 17, -
                42063), E =
                r(E, v, O, I, d[
                    h + 11],
                    22, -
                1990404162),
                I = r(I, E, v,
                    O, d[h +
                    12], 7,
                    1804603682),
                O = r(O, I, E,
                    v, d[h +
                    13], 12, -
                40341101),
                v = r(v, O, I,
                    E, d[h +
                    14], 17, -
                1502002290),
                E = r(E, v, O,
                    I, d[h +
                    15], 22,
                    1236535329),
                I = i(I, E, v,
                    O, d[h + 1],
                    5, -
                165796510),
                O = i(O, I, E,
                    v, d[h + 6],
                    9, -
                1069501632),
                v = i(v, O, I,
                    E, d[h +
                    11], 14,
                    643717713),
                E = i(E, v, O,
                    I, d[h], 20,
                    -373897302),
                I = i(I, E, v,
                    O, d[h + 5],
                    5, -
                701558691),
                O = i(O, I, E,
                    v, d[h +
                    10], 9,
                    38016083),
                v = i(v, O, I,
                    E, d[h +
                    15], 14, -
                660478335),
                E = i(E, v, O,
                    I, d[h + 4],
                    20, -
                405537848),
                I = i(I, E, v,
                    O, d[h + 9],
                    5, 568446438
                ), O = i(O,
                    I, E, v, d[
                h + 14],
                    9, -
                1019803690),
                v = i(v, O, I,
                    E, d[h + 3],
                    14, -
                187363961),
                E = i(E, v, O,
                    I, d[h + 8],
                    20,
                    1163531501),
                I = i(I, E, v,
                    O, d[h +
                    13], 5, -
                1444681467),
                O = i(O, I, E,
                    v, d[h + 2],
                    9, -51403784
                ), v = i(v,
                    O, I, E, d[
                h + 7],
                    14,
                    1735328473),
                E = i(E, v, O,
                    I, d[h +
                    12], 20, -
                1926607734),
                I = s(I, E, v,
                    O, d[h + 5],
                    4, -378558),
                O = s(O, I, E,
                    v, d[h + 8],
                    11, -
                2022574463),
                v = s(v, O, I,
                    E, d[h +
                    11], 16,
                    1839030562),
                E = s(E, v, O,
                    I, d[h +
                    14], 23, -
                35309556),
                I = s(I, E, v,
                    O, d[h + 1],
                    4, -
                1530992060),
                O = s(O, I, E,
                    v, d[h + 4],
                    11,
                    1272893353),
                v = s(v, O, I,
                    E, d[h + 7],
                    16, -
                155497632),
                E = s(E, v, O,
                    I, d[h +
                    10], 23, -
                1094730640),
                I = s(I, E, v,
                    O, d[h +
                    13], 4,
                    681279174),
                O = s(O, I, E,
                    v, d[h], 11,
                    -358537222),
                v = s(v, O, I,
                    E, d[h + 3],
                    16, -
                722521979),
                E = s(E, v, O,
                    I, d[h + 6],
                    23, 76029189
                ), I = s(I,
                    E, v, O, d[
                h + 9],
                    4, -
                640364487),
                O = s(O, I, E,
                    v, d[h +
                    12], 11, -
                421815835),
                v = s(v, O, I,
                    E, d[h +
                    15], 16,
                    530742520),
                E = s(E, v, O,
                    I, d[h + 2],
                    23, -
                995338651),
                I = o(I, E, v,
                    O, d[h], 6,
                    -198630844),
                O = o(O, I, E,
                    v, d[h + 7],
                    10,
                    1126891415),
                v = o(v, O, I,
                    E, d[h +
                    14], 15, -
                1416354905),
                E = o(E, v, O,
                    I, d[h + 5],
                    21, -
                57434055),
                I = o(I, E, v,
                    O, d[h +
                    12], 6,
                    1700485571),
                O = o(O, I, E,
                    v, d[h + 3],
                    10, -
                1894986606),
                v = o(v, O, I,
                    E, d[h +
                    10], 15, -
                1051523),
                E = o(E, v, O,
                    I, d[h + 1],
                    21, -
                2054922799),
                I = o(I, E, v,
                    O, d[h + 8],
                    6,
                    1873313359),
                O = o(O, I, E,
                    v, d[h +
                    15], 10, -
                30611744),
                v = o(v, O, I,
                    E, d[h + 6],
                    15, -
                1560198380),
                E = o(E, v, O,
                    I, d[h +
                    13], 21,
                    1309151649),
                I = o(I, E, v,
                    O, d[h + 4],
                    6, -
                145523070),
                O = o(O, I, E,
                    v, d[h +
                    11], 10, -
                1120210379),
                v = o(v, O, I,
                    E, d[h + 2],
                    15,
                    718787259),
                E = o(E, v, O,
                    I, d[h + 9],
                    21, -
                343485551),
                I = e(I, b), E =
                e(E, x), v = e(
                    v, P), O =
                e(O, M);
            return [I, E, v, O]
        }

        function u(d) {
            var y, h = "",
                b = d.length *
                    32;
            for (y = 0; y <
                b; y += 8) h +=
                    String
                        .fromCharCode(d[
                            y >> 5
                        ] >>>
                            y % 32 & 255
                        );
            return h
        }

        function c(d) {
            var y, h = [];
            for (h[(d.length >>
                2) - 1] =
                void 0, y =
                0; y < h
                    .length; y += 1)
                h[y] = 0;
            var b = d.length *
                8;
            for (y = 0; y <
                b; y += 8) h[
                    y >> 5] |= (
                        d
                            .charCodeAt(
                                y / 8) &
                        255) << y %
                    32;
            return h
        }

        function l(d) {
            return u(a(c(d), d
                .length *
                8))
        }

        function p(d) {
            var y =
                "0123456789abcdef",
                h = "",
                b, x;
            for (x = 0; x < d
                .length; x += 1)
                b = d
                    .charCodeAt(x),
                    h += y.charAt(
                        b >>> 4 & 15
                    ) + y
                        .charAt(b & 15);
            return h
        }

        function f(d) {
            return unescape(
                encodeURIComponent(
                    d))
        }

        function m(d) {
            return l(f(d))
        }

        function g(d) {
            return p(m(d))
        }
        return g
    }();

    function ha(e, t, n) {
        e.prototype = t.prototype =
            n, n.constructor = e
    }

    function tu(e, t) {
        var n = Object.create(e
            .prototype);
        for (var r in t) n[r] = t[
            r];
        return n
    }

    function Ho() { }
    var nu = .7,
        bc = 1 / nu,
        Vl = "\\s*([+-]?\\d+)\\s*",
        xf =
            "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
        zo =
            "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
        Tw = /^#([0-9a-f]{3,8})$/,
        Iw = new RegExp(
            `^rgb\\(${Vl},${Vl},${Vl}\\)$`
        ),
        Ew = new RegExp(
            `^rgb\\(${zo},${zo},${zo}\\)$`
        ),
        Mw = new RegExp(
            `^rgba\\(${Vl},${Vl},${Vl},${xf}\\)$`
        ),
        vw = new RegExp(
            `^rgba\\(${zo},${zo},${zo},${xf}\\)$`
        ),
        Dw = new RegExp(
            `^hsl\\(${xf},${zo},${zo}\\)$`
        ),
        Sw = new RegExp(
            `^hsla\\(${xf},${zo},${zo},${xf}\\)$`
        ),
        lD = {
            aliceblue: 15792383,
            antiquewhite: 16444375,
            aqua: 65535,
            aquamarine: 8388564,
            azure: 15794175,
            beige: 16119260,
            bisque: 16770244,
            black: 0,
            blanchedalmond: 16772045,
            blue: 255,
            blueviolet: 9055202,
            brown: 10824234,
            burlywood: 14596231,
            cadetblue: 6266528,
            chartreuse: 8388352,
            chocolate: 13789470,
            coral: 16744272,
            cornflowerblue: 6591981,
            cornsilk: 16775388,
            crimson: 14423100,
            cyan: 65535,
            darkblue: 139,
            darkcyan: 35723,
            darkgoldenrod: 12092939,
            darkgray: 11119017,
            darkgreen: 25600,
            darkgrey: 11119017,
            darkkhaki: 12433259,
            darkmagenta: 9109643,
            darkolivegreen: 5597999,
            darkorange: 16747520,
            darkorchid: 10040012,
            darkred: 9109504,
            darksalmon: 15308410,
            darkseagreen: 9419919,
            darkslateblue: 4734347,
            darkslategray: 3100495,
            darkslategrey: 3100495,
            darkturquoise: 52945,
            darkviolet: 9699539,
            deeppink: 16716947,
            deepskyblue: 49151,
            dimgray: 6908265,
            dimgrey: 6908265,
            dodgerblue: 2003199,
            firebrick: 11674146,
            floralwhite: 16775920,
            forestgreen: 2263842,
            fuchsia: 16711935,
            gainsboro: 14474460,
            ghostwhite: 16316671,
            gold: 16766720,
            goldenrod: 14329120,
            gray: 8421504,
            green: 32768,
            greenyellow: 11403055,
            grey: 8421504,
            honeydew: 15794160,
            hotpink: 16738740,
            indianred: 13458524,
            indigo: 4915330,
            ivory: 16777200,
            khaki: 15787660,
            lavender: 15132410,
            lavenderblush: 16773365,
            lawngreen: 8190976,
            lemonchiffon: 16775885,
            lightblue: 11393254,
            lightcoral: 15761536,
            lightcyan: 14745599,
            lightgoldenrodyellow: 16448210,
            lightgray: 13882323,
            lightgreen: 9498256,
            lightgrey: 13882323,
            lightpink: 16758465,
            lightsalmon: 16752762,
            lightseagreen: 2142890,
            lightskyblue: 8900346,
            lightslategray: 7833753,
            lightslategrey: 7833753,
            lightsteelblue: 11584734,
            lightyellow: 16777184,
            lime: 65280,
            limegreen: 3329330,
            linen: 16445670,
            magenta: 16711935,
            maroon: 8388608,
            mediumaquamarine: 6737322,
            mediumblue: 205,
            mediumorchid: 12211667,
            mediumpurple: 9662683,
            mediumseagreen: 3978097,
            mediumslateblue: 8087790,
            mediumspringgreen: 64154,
            mediumturquoise: 4772300,
            mediumvioletred: 13047173,
            midnightblue: 1644912,
            mintcream: 16121850,
            mistyrose: 16770273,
            moccasin: 16770229,
            navajowhite: 16768685,
            navy: 128,
            oldlace: 16643558,
            olive: 8421376,
            olivedrab: 7048739,
            orange: 16753920,
            orangered: 16729344,
            orchid: 14315734,
            palegoldenrod: 15657130,
            palegreen: 10025880,
            paleturquoise: 11529966,
            palevioletred: 14381203,
            papayawhip: 16773077,
            peachpuff: 16767673,
            peru: 13468991,
            pink: 16761035,
            plum: 14524637,
            powderblue: 11591910,
            purple: 8388736,
            rebeccapurple: 6697881,
            red: 16711680,
            rosybrown: 12357519,
            royalblue: 4286945,
            saddlebrown: 9127187,
            salmon: 16416882,
            sandybrown: 16032864,
            seagreen: 3050327,
            seashell: 16774638,
            sienna: 10506797,
            silver: 12632256,
            skyblue: 8900331,
            slateblue: 6970061,
            slategray: 7372944,
            slategrey: 7372944,
            snow: 16775930,
            springgreen: 65407,
            steelblue: 4620980,
            tan: 13808780,
            teal: 32896,
            thistle: 14204888,
            tomato: 16737095,
            turquoise: 4251856,
            violet: 15631086,
            wheat: 16113331,
            white: 16777215,
            whitesmoke: 16119285,
            yellow: 16776960,
            yellowgreen: 10145074
        };
    ha(Ho, Pf, {
        copy(e) {
            return Object
                .assign(
                    new this
                        .constructor,
                    this, e)
        },
        displayable() {
            return this
                .rgb()
                .displayable()
        },
        hex: pD,
        formatHex: pD,
        formatHex8: Ow,
        formatHsl: Cw,
        formatRgb: fD,
        toString: fD
    });

    function pD() {
        return this.rgb()
            .formatHex()
    }

    function Ow() {
        return this.rgb()
            .formatHex8()
    }

    function Cw() {
        return bD(this).formatHsl()
    }

    function fD() {
        return this.rgb()
            .formatRgb()
    }

    function Pf(e) {
        var t, n;
        return e = (e + "").trim()
            .toLowerCase(), (t = Tw
                .exec(e)) ? (n = t[
                    1].length, t =
                    parseInt(t[1], 16),
                    n === 6 ? dD(t) :
                        n === 3 ? new br(
                            t >> 8 & 15 |
                            t >> 4 & 240,
                            t >> 4 & 15 |
                            t & 240, (t &
                                15) << 4 |
                        t & 15, 1) :
                            n === 8 ? ly(t >>
                                24 & 255, t >>
                                16 & 255, t >>
                                8 & 255, (t &
                                    255) / 255
                            ) : n === 4 ?
                                ly(t >> 12 & 15 |
                                    t >> 8 & 240,
                                    t >> 8 & 15 |
                                    t >> 4 & 240,
                                    t >> 4 & 15 |
                                    t & 240, ((t &
                                        15) <<
                                        4 | t & 15
                                    ) / 255) :
                                null) : (t = Iw
                                    .exec(e)) ? new br(
                                        t[1], t[2], t[3], 1
                                    ) : (t = Ew.exec(
                                        e)) ? new br(t[1] *
                                            255 / 100, t[2] *
                                            255 / 100, t[3] *
                                            255 / 100, 1) : (t =
                                                Mw.exec(e)) ? ly(t[
                                                    1], t[2], t[3],
                                                    t[4]) : (t = vw
                                                        .exec(e)) ? ly(t[
                                                            1] * 255 / 100, t[
                                                            2] * 255 / 100, t[
                                                            3] * 255 / 100, t[4]
                                                        ) : (t = Dw.exec(
                                                            e)) ? gD(t[1], t[2] /
                                                                100, t[3] / 100, 1
                                                            ) : (t = Sw.exec(
                                                                e)) ? gD(t[1], t[2] /
                                                                    100, t[3] / 100, t[
                                                                4]) : lD
                                                                    .hasOwnProperty(e) ? dD(
                                                                        lD[e]) : e ===
                                                                            "transparent" ? new br(
                                                                                NaN, NaN, NaN, 0) :
                null
    }

    function dD(e) {
        return new br(e >> 16 & 255,
            e >> 8 & 255, e &
        255, 1)
    }

    function ly(e, t, n, r) {
        return r <= 0 && (e = t =
            n = NaN), new br(e,
                t, n, r)
    }

    function Tf(e) {
        return e instanceof Ho || (
            e = Pf(e)), e ? (e =
                e.rgb(), new br(e.r,
                    e.g, e.b, e
                    .opacity)) :
                new br
    }

    function xc(e, t, n, r) {
        return arguments.length ===
            1 ? Tf(e) : new br(e, t,
                n, r == null ? 1 : r
            )
    }

    function br(e, t, n, r) {
        this.r = +e, this.g = +t,
            this.b = +n, this
                .opacity = +r
    }
    ha(br, xc, tu(Ho, {
        brighter(e) {
            return e =
                e ==
                    null ?
                    bc :
                    Math
                        .pow(bc,
                            e),
                new br(
                    this
                        .r *
                    e,
                    this
                        .g *
                    e,
                    this
                        .b *
                    e,
                    this
                        .opacity
                )
        },
        darker(e) {
            return e =
                e ==
                    null ?
                    nu :
                    Math
                        .pow(nu,
                            e),
                new br(
                    this
                        .r *
                    e,
                    this
                        .g *
                    e,
                    this
                        .b *
                    e,
                    this
                        .opacity
                )
        },
        rgb() {
            return this
        },
        clamp() {
            return new br(
                hc(this
                    .r
                ),
                hc(this
                    .g
                ),
                hc(this
                    .b
                ),
                fy(this
                    .opacity
                )
            )
        },
        displayable() {
            return -
                .5 <=
                this
                    .r &&
                this.r <
                255.5 &&
                -.5 <=
                this
                    .g &&
                this.g <
                255.5 &&
                -.5 <=
                this
                    .b &&
                this.b <
                255.5 &&
                0 <=
                this
                    .opacity &&
                this
                    .opacity <=
                1
        },
        hex: mD,
        formatHex: mD,
        formatHex8: Rw,
        formatRgb: yD,
        toString: yD
    }));

    function mD() {
        return `#${gc(this.r)}${gc(this.g)}${gc(this.b)}`
    }

    function Rw() {
        return `#${gc(this.r)}${gc(this.g)}${gc(this.b)}${gc((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`
    }

    function yD() {
        let e = fy(this.opacity);
        return `${e === 1 ? "rgb(" : "rgba("}${hc(this.r)}, ${hc(this.g)}, ${hc(this.b)}${e === 1 ? ")" : `, ${e})`}`
    }

    function fy(e) {
        return isNaN(e) ? 1 : Math
            .max(0, Math.min(1, e))
    }

    function hc(e) {
        return Math.max(0, Math.min(
            255, Math.round(
                e) || 0))
    }

    function gc(e) {
        return e = hc(e), (e < 16 ?
            "0" : "") + e
                .toString(16)
    }

    function gD(e, t, n, r) {
        return r <= 0 ? e = t = n =
            NaN : n <= 0 || n >= 1 ?
            e = t = NaN : t <= 0 &&
            (e = NaN), new co(e, t,
                n, r)
    }

    function bD(e) {
        if (e instanceof co)
            return new co(e.h, e.s,
                e.l, e.opacity);
        if (e instanceof Ho || (e =
            Pf(e)), !e)
            return new co;
        if (e instanceof co)
            return e;
        e = e.rgb();
        var t = e.r / 255,
            n = e.g / 255,
            r = e.b / 255,
            i = Math.min(t, n, r),
            s = Math.max(t, n, r),
            o = NaN,
            a = s - i,
            u = (s + i) / 2;
        return a ? (t === s ? o = (
            n - r) / a + (
                n < r) * 6 :
            n === s ? o = (r -
                t) / a + 2 : o =
            (t - n) / a + 4,
            a /= u < .5 ? s +
                i : 2 - s - i, o *=
            60) : a = u > 0 &&
                u < 1 ? 0 : o, new co(o,
                    a, u, e.opacity)
    }

    function dy(e, t, n, r) {
        return arguments.length ===
            1 ? bD(e) : new co(e, t,
                n, r == null ? 1 : r
            )
    }

    function co(e, t, n, r) {
        this.h = +e, this.s = +t,
            this.l = +n, this
                .opacity = +r
    }
    ha(co, dy, tu(Ho, {
        brighter(e) {
            return e =
                e ==
                    null ?
                    bc :
                    Math
                        .pow(bc,
                            e),
                new co(
                    this
                        .h,
                    this
                        .s,
                    this
                        .l *
                    e,
                    this
                        .opacity
                )
        },
        darker(e) {
            return e =
                e ==
                    null ?
                    nu :
                    Math
                        .pow(nu,
                            e),
                new co(
                    this
                        .h,
                    this
                        .s,
                    this
                        .l *
                    e,
                    this
                        .opacity
                )
        },
        rgb() {
            var e = this
                .h %
                360 + (
                    this
                        .h <
                    0) *
                360,
                t =
                    isNaN(
                        e) ||
                        isNaN(
                            this
                                .s
                        ) ?
                        0 : this
                            .s,
                n = this
                    .l,
                r = n +
                    (n < .5 ?
                        n :
                        1 -
                        n) *
                    t,
                i = 2 *
                    n - r;
            return new br(
                vT(e >=
                    240 ?
                    e -
                    240 :
                    e +
                    120,
                    i,
                    r
                ),
                vT(e,
                    i,
                    r
                ),
                vT(e <
                    120 ?
                    e +
                    240 :
                    e -
                    120,
                    i,
                    r
                ),
                this
                    .opacity
            )
        },
        clamp() {
            return new co(
                hD(this
                    .h
                ),
                py(this
                    .s
                ),
                py(this
                    .l
                ),
                fy(this
                    .opacity
                )
            )
        },
        displayable() {
            return (0 <=
                this
                    .s &&
                this
                    .s <=
                1 ||
                isNaN(
                    this
                        .s
                )
            ) &&
                0 <=
                this
                    .l &&
                this
                    .l <=
                1 &&
                0 <=
                this
                    .opacity &&
                this
                    .opacity <=
                1
        },
        formatHsl() {
            let e = fy(
                this
                    .opacity
            );
            return `${e === 1 ? "hsl(" : "hsla("}${hD(this.h)}, ${py(this.s) * 100}%, ${py(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`
        }
    }));

    function hD(e) {
        return e = (e || 0) % 360,
            e < 0 ? e + 360 : e
    }

    function py(e) {
        return Math.max(0, Math.min(
            1, e || 0))
    }

    function vT(e, t, n) {
        return (e < 60 ? t + (n -
            t) * e / 60 : e <
                180 ? n : e < 240 ?
            t + (n - t) * (240 -
                e) / 60 : t) *
            255
    }
    var my = Math.PI / 180,
        yy = 180 / Math.PI;
    var gy = 18,
        xD = .96422,
        PD = 1,
        TD = .82521,
        ID = 4 / 29,
        Bl = 6 / 29,
        ED = 3 * Bl * Bl,
        Nw = Bl * Bl * Bl;

    function MD(e) {
        if (e instanceof Uo)
            return new Uo(e.l, e.a,
                e.b, e.opacity);
        if (e instanceof ba)
            return DD(e);
        e instanceof br || (e = Tf(
            e));
        var t = CT(e.r),
            n = CT(e.g),
            r = CT(e.b),
            i = DT((.2225045 * t +
                .7168786 * n +
                .0606169 * r) /
                PD),
            s, o;
        return t === n && n === r ?
            s = o = i : (s = DT((
                .4360747 *
                t +
                .3850649 *
                n +
                .1430804 * r
            ) / xD), o = DT(
                (.0139322 * t +
                    .0971045 *
                    n +
                    .7141733 * r
                ) / TD)),
            new Uo(116 * i - 16,
                500 * (s - i), 200 *
            (i - o), e.opacity)
    }

    function RT(e, t, n, r) {
        return arguments.length ===
            1 ? MD(e) : new Uo(e, t,
                n, r == null ? 1 : r
            )
    }

    function Uo(e, t, n, r) {
        this.l = +e, this.a = +t,
            this.b = +n, this
                .opacity = +r
    }
    ha(Uo, RT, tu(Ho, {
        brighter(e) {
            return new Uo(
                this
                    .l +
                gy *
                (e ==
                    null ?
                    1 :
                    e
                ),
                this
                    .a,
                this
                    .b,
                this
                    .opacity
            )
        },
        darker(e) {
            return new Uo(
                this
                    .l -
                gy *
                (e ==
                    null ?
                    1 :
                    e
                ),
                this
                    .a,
                this
                    .b,
                this
                    .opacity
            )
        },
        rgb() {
            var e = (
                this
                    .l +
                16
            ) /
                116,
                t =
                    isNaN(
                        this
                            .a
                    ) ?
                        e : e +
                        this.a /
                        500,
                n =
                    isNaN(
                        this
                            .b
                    ) ?
                        e : e -
                        this.b /
                        200;
            return t =
                xD * ST(
                    t),
                e = PD *
                ST(e),
                n = TD *
                ST(n),
                new br(
                    OT(3.1338561 *
                        t -
                        1.6168667 *
                        e -
                        .4906146 *
                        n
                    ),
                    OT(-.9787684 *
                        t +
                        1.9161415 *
                        e +
                        .033454 *
                        n
                    ),
                    OT(.0719453 *
                        t -
                        .2289914 *
                        e +
                        1.4052427 *
                        n
                    ),
                    this
                        .opacity
                )
        }
    }));

    function DT(e) {
        return e > Nw ? Math.pow(e,
            1 / 3) : e / ED + ID
    }

    function ST(e) {
        return e > Bl ? e * e * e :
            ED * (e - ID)
    }

    function OT(e) {
        return 255 * (e <=
            .0031308 ? 12.92 *
        e : 1.055 * Math
            .pow(e, 1 / 2.4) -
        .055)
    }

    function CT(e) {
        return (e /= 255) <=
            .04045 ? e / 12.92 :
            Math.pow((e + .055) /
                1.055, 2.4)
    }

    function Aw(e) {
        if (e instanceof ba)
            return new ba(e.h, e.c,
                e.l, e.opacity);
        if (e instanceof Uo || (e =
            MD(e)), e.a === 0 &&
            e.b === 0)
            return new ba(NaN, 0 < e
                .l && e.l <
                100 ? 0 : NaN, e
                .l, e.opacity);
        var t = Math.atan2(e.b, e
            .a) * yy;
        return new ba(t < 0 ? t +
            360 : t, Math.sqrt(e
                .a * e.a + e.b *
                e.b), e.l, e
            .opacity)
    }

    function vD(e, t, n, r) {
        return arguments.length ===
            1 ? Aw(e) : new ba(e, t,
                n, r == null ? 1 : r
            )
    }

    function ba(e, t, n, r) {
        this.h = +e, this.c = +t,
            this.l = +n, this
                .opacity = +r
    }

    function DD(e) {
        if (isNaN(e.h))
            return new Uo(e.l, 0, 0,
                e.opacity);
        var t = e.h * my;
        return new Uo(e.l, Math.cos(
            t) * e.c, Math
                .sin(t) * e.c, e
            .opacity)
    }
    ha(ba, vD, tu(Ho, {
        brighter(e) {
            return new ba(
                this
                    .h,
                this
                    .c,
                this
                    .l +
                gy *
                (e ==
                    null ?
                    1 :
                    e
                ),
                this
                    .opacity
            )
        },
        darker(e) {
            return new ba(
                this
                    .h,
                this
                    .c,
                this
                    .l -
                gy *
                (e ==
                    null ?
                    1 :
                    e
                ),
                this
                    .opacity
            )
        },
        rgb() {
            return DD(
                this
            )
                .rgb()
        }
    }));
    var RD = -.14861,
        NT = 1.78277,
        AT = -.29227,
        hy = -.90649,
        If = 1.97294,
        SD = If * hy,
        OD = If * NT,
        CD = NT * AT - hy * RD;

    function _w(e) {
        if (e instanceof Pc)
            return new Pc(e.h, e.s,
                e.l, e.opacity);
        e instanceof br || (e = Tf(
            e));
        var t = e.r / 255,
            n = e.g / 255,
            r = e.b / 255,
            i = (CD * r + SD * t -
                OD * n) / (CD + SD -
                    OD),
            s = r - i,
            o = (If * (n - i) - AT *
                s) / hy,
            a = Math.sqrt(o * o +
                s * s) / (If * i * (
                    1 - i)),
            u = a ? Math.atan2(o,
                s) * yy - 120 : NaN;
        return new Pc(u < 0 ? u +
            360 : u, a, i, e
            .opacity)
    }

    function _T(e, t, n, r) {
        return arguments.length ===
            1 ? _w(e) : new Pc(e, t,
                n, r == null ? 1 : r
            )
    }

    function Pc(e, t, n, r) {
        this.h = +e, this.s = +t,
            this.l = +n, this
                .opacity = +r
    }
    ha(Pc, _T, tu(Ho, {
        brighter(e) {
            return e =
                e ==
                    null ?
                    bc :
                    Math
                        .pow(bc,
                            e),
                new Pc(
                    this
                        .h,
                    this
                        .s,
                    this
                        .l *
                    e,
                    this
                        .opacity
                )
        },
        darker(e) {
            return e =
                e ==
                    null ?
                    nu :
                    Math
                        .pow(nu,
                            e),
                new Pc(
                    this
                        .h,
                    this
                        .s,
                    this
                        .l *
                    e,
                    this
                        .opacity
                )
        },
        rgb() {
            var e =
                isNaN(
                    this
                        .h
                ) ?
                    0 : (
                        this
                            .h +
                        120
                    ) *
                    my,
                t = +
                    this.l,
                n =
                    isNaN(
                        this
                            .s
                    ) ?
                        0 : this
                            .s * t *
                        (1 - t),
                r = Math
                    .cos(e),
                i = Math
                    .sin(e);
            return new br(
                255 *
                (t + n *
                    (RD *
                        r +
                        NT *
                        i
                    )
                ),
                255 *
                (t + n *
                    (AT *
                        r +
                        hy *
                        i
                    )
                ),
                255 *
                (t + n *
                    (If *
                        r
                    )
                ),
                this
                    .opacity
            )
        }
    }));

    function ys(e, t, n) {
        return e > 0 == t > 0 ?
            n === 1 ? t : e + n * (
                t - e) : e * (1 -
                    n) + t * n
    }

    function Jn(e, t, n) {
        return [ys(e[0], t[0], n),
        ys(e[1], t[1], n)
        ]
    }

    function gs(e, t, n) {
        return [ys(e[0], t[0], n),
        ys(e[1], t[1], n),
        ys(e[2], t[2], n)
        ]
    }

    function Ef(e, t) {
        return [e[0] + t[0], e[1] +
            t[1]
        ]
    }

    function ND(e, t) {
        return [e[0] - t[0], e[1] -
            t[1]
        ]
    }

    function LT(e, t) {
        return [e[0] - t[0], e[1] -
            t[1], e[2] - t[2]
        ]
    }

    function wT(e, t) {
        return e[0] * t[0] + e[1] *
            t[1] + e[2] * t[2]
    }

    function xa(e, t) {
        return Gl(LT(e, t))
    }

    function by(e, t, n) {
        return [ys(e[0], t[0], n[
            0]), ys(e[1], t[1],
                n[1])
        ]
    }

    function AD(e, t) {
        return [e[0] * t, e[1] * t]
    }

    function Gl(e) {
        let [t, n, r] = e;
        return t * t + n * n + r * r
    }

    function kl(e, t) {
        let n = e[1] * t[2] - e[2] *
            t[1],
            r = e[2] * t[0] - e[0] *
                t[2],
            i = e[0] * t[1] - e[1] *
                t[0],
            s = Math.sqrt(n * n +
                r * r + i * i);
        return [n / s, r / s, i / s]
    }

    function zl(e, t, n) {
        e = Math.fround(e), t = Math
            .fround(t), n = Math
                .fround(n);
        let r = Math.fround(e * e +
            t * t + n * n);
        return isFinite(r) && r != 0
    }

    function qo([e, t, n]) {
        return isFinite(e) &&
            isFinite(t) && isFinite(
                n)
    }

    function Ki(e, t) {
        let n;
        e > t && (n = e, e = t, t =
            n);
        let r = e > 0,
            i = t > 0,
            s = Math.abs(e) > .01,
            o = Math.abs(t) > .01;
        if (s || o) return pa(e, t);
        if (e === 0) return t * Math
            .abs(t);
        if (t === 0) return e * Math
            .abs(e);
        if (r !== i) return 0;
        let a = r ? Math.sqrt(e *
            t) : -Math.sqrt(e * t);
        return a >= e && t >= a ?
            a : pa(e, t)
    }

    function kT(e, t, n, r, i) {
        if (!(isNaN(t) || isNaN(
            r) || t < 0 == r < 0
        ))
            for (; ;) {
                let s = Ki(e, n),
                    o = i(s);
                if (!isFinite(o))
                    return;
                if (s === e || s ===
                    n) return Math
                        .abs(t) <=
                        Math.abs(
                            r) ? [e,
                        t] : [n, r];
                if (o === 0)
                    return vf(e, t,
                        s, o, n,
                        r, i);
                t < 0 != o < 0 ? (
                    n = s, r = o
                ) : (e = s,
                    t = o)
            }
    }

    function HD(e, t, n, r, i) {
        if (!(FT(t) || FT(r)) && VT(
            t, r))
            for (; ;) {
                let s = Ki(e, n),
                    o = i(s);
                if (FT(o)) return;
                if (s === e || s ===
                    n) return s;
                if (VT(t, o)) n = s,
                    r = o;
                else if (VT(o, r))
                    e = s, t = o;
                else return
            }
    }

    function FT(e) {
        for (let t of e)
            if (isNaN(t)) return !0;
        return !1
    }

    function VT(e, t) {
        for (let n = 0; n < e
            .length; n++)
            if (!Lw(e[n], t[n]))
                return !1;
        return !0
    }

    function Lw(e, t) {
        return e <= 0 && t >= 0 ||
            e >= 0 && t <= 0
    }

    function vf(e, t, n, r, i, s,
        o) {
        let a;
        if (!isFinite(r)) return;
        isFinite(t) || (a = si(e, t,
            n, r, o), a !==
            void 0 && (e = a,
                t = o(e))),
            isFinite(s) || (a = si(
                n, r, i, s, o),
                a !== void 0 && (i =
                    a, s = o(a)));
        let u, c;
        t === r ? u = [e, t] : u =
            _D(e, t, n, r, o, r),
            s === r ? c = [i, s] :
                c = _D(n, r, i, s, o,
                    r);
        let l;
        return u && c && (l = Ki(u[
            0], c[0])), l !==
                void 0 ? [l, o(l)] :
                void 0
    }

    function si(e, t, n, r, i) {
        if (isFinite(t) !==
            isFinite(r))
            for (; ;) {
                let s = Ki(e, n),
                    o = i(s);
                if (s === e || s ===
                    n) return isFinite(
                        t) ? e :
                        n;
                isFinite(o) !==
                    isFinite(t) ? (
                    n = s, r = o
                ) : (e = s,
                    t = o)
            }
    }

    function xy(e, t, n, r, i) {
        if (qo(t) !== qo(r))
            for (; ;) {
                let s = Ki(e, n),
                    o = i(s);
                if (s === e || s ===
                    n) return qo(
                        t) ? e : n;
                qo(o) !== qo(t) ? (
                    n = s, r = o
                ) : (e = s,
                    t = o)
            }
    }

    function _D(e, t, n, r, i, s) {
        if (t === s != (r === s))
            for (; ;) {
                let o = Ki(e, n),
                    a = i(o);
                if (o === e || o ===
                    n) return t ===
                        s ? [e, t] :
                        [n, r];
                a === s != (t ===
                    s) ? (n = o, r =
                        a) : (e = o,
                            t = a)
            }
    }

    function UD(e, t, n, r, i, s,
        o) {
        if (e < n && n < i &&
            isFinite(t) && isFinite(
                r) && isFinite(s) &&
            t !== r && r !== s &&
            r > t == r > s)
            for (; ;) {
                let a = Ki(e, n),
                    u = o(a),
                    c = Ki(n, i),
                    l = o(c);
                if (!isFinite(u) ||
                    !isFinite(l))
                    return;
                if (a === e || a ===
                    n || c === n ||
                    c === i)
                    return u > r ==
                        r > t ? [a,
                        u
                    ] : l > r ==
                        r > t ? [c,
                        l
                    ] : [n, r];
                if (u === r || l ===
                    r) return vf(e,
                        t, n, r,
                        i, s, o);
                r > t && u > t &&
                    u > r || r <
                    t && u < t &&
                    u < r ? (i = n,
                        s = r, n =
                        a, r = u) :
                    r > t && l >
                        r && l > s ||
                        r < t && l <
                        r && l < s ? (
                        e = n, t =
                        r, n = c,
                        r = l) : (
                        e = a, t =
                        u, i = c,
                        s = l)
            }
    }

    function hs([e, t], [n, r]) {
        return (n - e) * (n - e) + (
            r - t) * (r - t)
    }

    function LD(e, t, n, r, i, s) {
        let o = s(e),
            a = s(t),
            u = s(n),
            c = hs(o, r),
            l = hs(a, r),
            p = hs(u, r);
        if (!(t <= e || n <= t) && !
            (!isFinite(c) || !
                isFinite(l) || !
                isFinite(p)) && !(
                    l >= c || l >= p))
            for (; ;) {
                if (Math.abs(u[0] -
                    o[0]) < i &&
                    Math.abs(u[1] -
                        o[1]) < i)
                    return [e, n];
                let f = Ki(e, t),
                    m = s(f),
                    g = hs(m, r),
                    d = Ki(t, n),
                    y = s(d),
                    h = hs(y, r);
                if (!isFinite(g) ||
                    !isFinite(h))
                    return;
                if (f === e || f ===
                    t || d === t ||
                    d === n)
                    return g < l &&
                        g < h ? [f,
                        f
                    ] : h < g &&
                        h < l ? [d,
                        d
                    ] : [t, t];
                if ((g === l ||
                    h === l) &&
                    (t = .5 * (f +
                        t), a =
                        s(t), l =
                        hs(a, r),
                        g === l ||
                        h === l))
                    return [e, n];
                g < l && g < h ? ([
                    n, t
                ] = [t, f],
                    [u, a] = [a,
                        m
                    ], [p,
                        l] = [l, g]
                ) : h < g &&
                    h < l ? ([e,
                        t] = [t, d],
                        [o, a] = [a,
                            y
                        ], [c,
                            l] = [l, h]
                ) : ([e,
                    n] = [f, d],
                    [o, u] = [m,
                        y
                    ], [c,
                        p] = [g, h])
            }
    }

    function wD(e, t, n) {
        return t === void 0 && (
            t = -1 / 0), n ===
            void 0 && (n = 1 / 0),
            Math.min(n, Math.max(t,
                e))
    }

    function BT(e, t, n, r, i, s) {
        let o;
        if (r !== void 0 && i !==
            void 0) {
            let p = .5 * (r + i);
            o = n + .01 * (n < p ?
                i - r : r - i)
        } else o = Math.abs(n) > 1 ?
            n * 1.00001 : n + 1e-5;
        let a = e(n),
            u = e(o),
            c = hs(a, t),
            l = hs(u, t);
        if (!(!isFinite(c) || !
            isFinite(l))) {
            if (c === l) return [n,
                o
            ];
            for (l > c && ([n,
                o] = [o, n], [a,
                    u
                ] = [u, a], [c,
                    l
                ] = [l, c]
            ); isFinite(
                n) && isFinite(o) &&
                n !== o;) {
                if (i !== void 0 &&
                    o > i) return [
                        i, i
                    ];
                if (r !== void 0 &&
                    o < r) return [
                        r, r
                    ];
                let p = n + 3 * (o -
                    n),
                    f = e(p),
                    m = hs(f, t);
                if (!isFinite(m))
                    return [n, o];
                if (m === l)
                    return [n, o];
                if (m > l) {
                    let g = o > n ?
                        LD(n, o, p,
                            t, s, e
                        ) : LD(
                            p, o, n,
                            t, s, e
                        );
                    return g && [wD(
                        g[
                        0],
                        r, i
                    ),
                    wD(g[1],
                        r, i
                    )
                    ]
                } [n, c, o, l] = [o,
                    l, p, m
                ]
            }
            return [n, o]
        }
    }

    function FD(e, t, n, r) {
        return n ? r ? Math.min(hs(
            e(r[0]), t), hs(
                e(r[1]), t)) < Math
                    .min(hs(e(n[0]), t), hs(
                        e(n[1]), t)) : !1 :
            !0
    }

    function C4(e, t, n, r, i, s) {
        let o = BT(e, t, n, r, i,
            s);
        if (r !== void 0) {
            let a = BT(e, t, r, r,
                i, s);
            FD(e, t, o, a) && (o =
                a)
        }
        if (i !== void 0) {
            let a = BT(e, t, i, r,
                i, s);
            FD(e, t, o, a) && (o =
                a)
        }
        return o
    }

    function VD(e, t, n, r, i, s, o,
        a) {
        let u = Math.abs(r - t),
            c = Math.abs(s - r),
            l = Math.abs(a - s);
        return u > c && u > l ? [e,
            n
        ] : l > c && l > u ? [i,
            o
        ] : [n, i]
    }

    function Hl(e, t, n, r, i, s, o,
        a = 0) {
        if (!((n - e) * (i - n) <=
            0) && !(!isFinite(
                e) || !isFinite(
                    n) || !isFinite(i)
            ) && !(!isFinite(
                t) || !isFinite(s))
        ) {
            if (!isFinite(r)) {
                let u = si(e, t, n,
                    r, o),
                    c = si(n, r, i,
                        s, o);
                return u ===
                    void 0 || c ===
                    void 0 ?
                    void 0 : [u, c]
            }
            if (!(Math.abs(r - ((i -
                n) *
                t + (n -
                    e) *
                s) / (
                    i - e)) < a))
                for (; ;) {
                    let u = Ki(e,
                        n),
                        c = o(u),
                        l = Ki(n,
                            i),
                        p = o(l),
                        f = Math
                            .abs(c - pa(
                                t, r
                            )),
                        m = Math
                            .abs(r - pa(
                                c, p
                            )),
                        g = Math
                            .abs(p - pa(
                                r, s
                            ));
                    if (f <= a &&
                        m <= a &&
                        g <= a)
                        return;
                    if (!isFinite(
                        c)) {
                        let d = si(
                            e,
                            t,
                            u,
                            c, o
                        ),
                            y = si(
                                u,
                                c,
                                i,
                                s, o
                            );
                        return d ===
                            void 0 ||
                            y ===
                            void 0 ?
                            void 0 :
                            [d, y]
                    }
                    if (!isFinite(
                        p)) {
                        let d = si(
                            e,
                            t,
                            l,
                            p, o
                        ),
                            y = si(
                                l,
                                p,
                                i,
                                s, o
                            );
                        return d ===
                            void 0 ||
                            y ===
                            void 0 ?
                            void 0 :
                            [d, y]
                    }
                    if ((u === e ||
                        u === n
                    ) && (
                            l ===
                            n ||
                            l === i)
                    ) return Math
                        .abs(r -
                            t) >
                        Math
                            .abs(s -
                                r) ?
                        [e, n] :
                        [n, i];
                    if (u === e ||
                        u === n)
                        return VD(e,
                            t,
                            n,
                            r,
                            l,
                            p,
                            i, s
                        );
                    if (l === n ||
                        l === i)
                        return VD(e,
                            t,
                            u,
                            c,
                            n,
                            r,
                            i, s
                        );
                    f > g && f >=
                        m ? (i = n,
                            s = r,
                            n = u,
                            r = c) :
                        g > f &&
                            g >= m ? (
                            e = n,
                            t = r,
                            n = l,
                            r = p) :
                            (e = u, t =
                                c, i =
                                l, s = p
                            )
                }
        }
    }
    var Pa = (Math.sqrt(5) - 1) / 2;

    function Mf(e, t) {
        return e > 0 == t > 0 ? e +
            Pa * (t - e) : (1 -
                Pa) * e + Pa * t
    }

    function ru(e, t) {
        let n;
        e > t && (n = e, e = t, t =
            n);
        let r = e > 0,
            i = t > 0,
            s = Math.abs(e) > .01,
            o = Math.abs(t) > .01;
        if (s || o) return Mf(e, t);
        if (e === 0) return t * Math
            .abs(t);
        if (t === 0) return e * Math
            .abs(e);
        if (r !== i) return 0;
        let a = r ? Math.sqrt(e *
            t) : -Math.sqrt(e * t);
        return a >= e && t >= a ?
            a : Mf(e, t)
    }

    function qD(e, t, n, r, i, s) {
        if (!isFinite(e) || !
            isFinite(n) || !
            isFinite(t) || !
            isFinite(r)) return;
        e > n && ([e, t, n, r] = [n,
            r, e, t
        ]);
        let o = ru(e, n),
            a = i(o);
        if (Math.abs(a - Mf(t,
            r)) <= s) return;
        let u = ru(e, o),
            c = i(u);
        for (; ;) {
            let l = Math.abs(c - Mf(
                t, a)),
                p = Math.abs(a - Mf(
                    r, c));
            if (l <= s && p <= s)
                return;
            if (l > p) {
                if (n = o, r = a,
                    o = u, a = c,
                    u = ru(e, o),
                    c = i(u), u ===
                    e || u === o)
                    return GD(e, t,
                        o, a, n,
                        r);
                if (!isFinite(c))
                    return BD(e, t,
                        u, c, n,
                        r, i)
            } else {
                if (e = u, t = c,
                    u = o, c = a,
                    o = ru(n, o),
                    a = i(o), o ===
                    n || o === u)
                    return GD(e, t,
                        u, c, n,
                        r);
                if (!isFinite(a))
                    return BD(e, t,
                        o, a, n,
                        r, i)
            }
        }
    }

    function BD(e, t, n, r, i, s,
        o) {
        let a = si(e, t, n, r, o),
            u = si(n, r, i, s, o);
        if (!(a === void 0 || u ===
            void 0)) return [a,
                u
            ]
    }

    function GD(e, t, n, r, i, s) {
        return Math.abs(r - t) >
            Math.abs(s - r) ? [e,
            n] : [n, i]
    }

    function GT(e, t, n) {
        let r = e[0] * (1 - Pa) + t[
            0] * Pa - n[0],
            i = e[1] * (1 - Pa) + t[
                1] * Pa - n[1],
            s = e[2] * (1 - Pa) + t[
                2] * Pa - n[2];
        return r * r + i * i + s * s
    }

    function Py(e, t, n, r, i, s, o,
        a) {
        if (!isFinite(e) || !
            isFinite(n) || !qo(t) ||
            !qo(r)) return;
        e > n && ([e, t, n, r] = [n,
            r, e, t
        ]);
        let u = ru(e, n),
            c = i(u),
            l = s * s;
        if (GT(t, r, c) <= l)
            return;
        let p = ru(e, u),
            f = i(p);
        for (; ;) {
            let m = GT(t, c, f),
                g = GT(r, f, c);
            if (m <= l && g <= l)
                return n - e < a ?
                    p : void 0;
            if (m > g) {
                if (n = u, r = c,
                    u = p, c = f,
                    p = ru(e, u),
                    f = i(p), p ===
                    e || u - p <= o)
                    return zD(e, t,
                        u, c, n,
                        r);
                if (!qo(f))
                    return kD(e, t,
                        p, f, n,
                        r, i)
            } else {
                if (e = p, t = f,
                    p = u, f = c,
                    u = ru(n, u),
                    c = i(u), u ===
                    n || u - p <= o)
                    return zD(e, t,
                        p, f, n,
                        r);
                if (!qo(c))
                    return kD(e, t,
                        u, c, n,
                        r, i)
            }
        }
    }

    function kD(e, t, n, r, i, s,
        o) {
        let a = xy(e, t, n, r, o),
            u = xy(n, r, i, s, o);
        if (!(a === void 0 || u ===
            void 0)) return [a,
                u
            ]
    }

    function zD(e, t, n, r, i, s) {
        return xa(r, t) > xa(s, r) ?
            [e, n] : [n, i]
    }
    var Fw = Hl,
        Ty = si,
        Vw = 3.154019550531224,
        $D = Math.pow(2, -13),
        iu = $D * $D,
        YD = iu * iu,
        zT = iu,
        UT = 32,
        lo = [],
        su = [];

    function Bw(e, t) {
        for (var n = UT; n >
            0; n--) {
            var r = Vw / UT * n,
                i = Math.sinh(r),
                s = Math.cosh(Math
                    .PI / 2 * i),
                o = 1 / (Math.exp(
                    Math.PI /
                    2 * i) * s),
                a = Math.cosh(r) / (
                    s * s);
            e.push(o), t.push(a)
        }
    }
    Bw(lo, su);
    var WD = 0;
    for (Iy = 0; Iy < su
        .length; Iy++) WD += su[Iy];
    var Iy, Ey = 1 / (1 + 2 * WD);

    function Ii(e, t, n) {
        return .5 * (t * (2 - n) +
            e * n)
    }

    function Gw(e, t, n) {
        var r = .5 * (t + n),
            i = Fw(t, e(t), r, e(r),
                n, e(n), e);
        return i ? .5 * (i[0] + i[
            1]) : r
    }

    function Df(e, t, n, r, i) {
        return {
            x1: e,
            x2: t,
            value: n,
            error: r,
            minerror: i
        }
    }

    function XD(e, t, n) {
        var r = Math.abs(e(Ii(t, n,
            iu))),
            i = Math.abs(e(Ii(t, n,
                2 * iu))),
            s = Math.abs(e(Ii(t, n,
                4 * iu)));
        return r < iu || i < iu ? !
            1 : r > 1.95 * i && i >
            1.95 * s
    }

    function HT(e, t, n) {
        var r = Ii(n, t, lo[0]),
            i = Ii(t, n, lo[0]),
            s = e(r),
            o = e(i),
            a = Ii(t, n, 1),
            u = e(a),
            c, l;
        if (isFinite(u) && !
            isFinite(s)) {
            if (c = Ty(r, s, a, u,
                e), Math.abs((
                    c - t) / (
                        n - t)) > zT)
                return Df(t, n, NaN,
                    NaN, NaN);
            t = c, s = e(t)
        }
        if (isFinite(u) && !
            isFinite(o)) {
            if (l = Ty(a, u, i, o,
                e), Math.abs((
                    l - n) / (
                        n - t)) > zT)
                return Df(t, n, NaN,
                    NaN, NaN);
            n = l, o = e(n)
        }
        if (isFinite(s) && isFinite(
            o) && !isFinite(
                u)) {
            if (c = Ty(r, s, a, u,
                e), l = Ty(a, u,
                    i, o, e), Math
                        .abs((l - c) / (n -
                            t)) > zT)
                return Df(t, n, NaN,
                    NaN, NaN);
            u = .5 * (c + l)
        }
        if (XD(e, t, n) || XD(e, n,
            t)) return Df(t, n,
                NaN, NaN, NaN);
        for (var p = u, f = 0, m =
            0, g = 0, d = 0, y =
                0, h = 0, b = 0; b <
            UT; b += 4) y = e(Ii(t,
                n, lo[b])), h = e(
                    Ii(n, t, lo[b])),
                d = Math.max(d, Math
                    .abs(y), Math.abs(h)
                ), f += su[b] * (y +
                    h), y = e(Ii(t, n,
                        lo[b + 1])), h = e(
                            Ii(n, t, lo[b + 1])
                        ), d = Math.max(d,
                            Math.abs(y), Math
                                .abs(h)), g += su[
                                b + 1] * (y + h),
                y = e(Ii(t, n, lo[b +
                    2])), h = e(Ii(n, t,
                        lo[b + 2])), d =
                Math.max(d, Math.abs(y),
                    Math.abs(h)), m +=
                su[b + 2] * (y + h), y =
                e(Ii(t, n, lo[b + 3])),
                h = e(Ii(n, t, lo[b +
                    3])), d = Math.max(
                        d, Math.abs(y), Math
                            .abs(h)), g += su[
                            b + 3] * (y + h);
        var x = p + f,
            P = x + m,
            M = P + g,
            I = Math.abs(m - x),
            E = Math.abs(g - P),
            v = Ey * (n - t) * M,
            O = Ey * Math.abs(n -
                t) * d * su[0],
            A;
        return I === 0 ? A = Ey *
            Math.abs(n - t) * E :
            A = Ey * Math.abs(n -
                t) * E * (E / I) * (E /
                    I), A = Math.max(A,
                        O), Df(t, n, v, A,
                            O)
    }

    function ZD(e) {
        for (var t = -1 / 0, n = -
            1 / 0, r = -1, i =
                0, s = 0; s < e
                    .length; s++) {
            var o = e[s];
            i += o.value, o.error >
                t && (t = o.error,
                    r = s), o
                        .minerror > n && (
                    n = o.minerror)
        }
        return {
            maxerror: t,
            maxminerror: n,
            maxindex: r,
            totalvalue: i
        }
    }

    function Sf(e, t, n, r = 32) {
        if (isNaN(t) || isNaN(n))
            return NaN;
        var i = 1;
        if (t > n) {
            var s = t;
            t = n, n = s, i = -1
        }
        if (t === 1 / 0 && n === 1 /
            0) return NaN;
        if (t === -1 / 0 && n === -
            1 / 0) return NaN;
        if (t === -1 / 0 && n ===
            1 / 0) return i * Sf(
                function (f) {
                    return e(f /
                        ((1 +
                            f) *
                            (1 -
                                f)
                        )
                    ) *
                        (1 + f *
                            f) /
                        ((1 +
                            f) *
                            (1 +
                                f) *
                            (1 -
                                f) *
                            (1 -
                                f)
                        )
                }, -1, 1, r);
        if (t === -1 / 0) return i *
            Sf(function (f) {
                return -e(
                    n -
                    f /
                    (1 -
                        f)
                ) /
                    ((1 -
                        f) *
                        (1 -
                            f)
                    )
            }, 1, 0, r);
        if (n === 1 / 0) return i *
            Sf(function (f) {
                return e(t +
                    f /
                    (1 -
                        f)
                ) /
                    ((1 -
                        f) *
                        (1 -
                            f)
                    )
            }, 0, 1, r);
        for (var o = [HT(e, t, n)],
            a = ZD(o), u =
                1; u < r && !(Math
                    .abs(a.maxerror / a
                        .totalvalue) <=
                    32 * YD || a
                        .maxerror <= 32 *
                    YD || a.maxerror <=
                    32 * a
                        .maxminerror || !
                    isFinite(a
                        .maxerror) || !
                    isFinite(a
                        .maxminerror)
                ); u++) {
            var c = o[o.length - 1];
            o[o.length - 1] = o[a
                .maxindex], o[a
                    .maxindex] = c;
            var l = o.pop(),
                p = Gw(e, Ii(l.x2, l
                    .x1, .125),
                    Ii(l.x1, l.x2,
                        .125));
            o.push(HT(e, l.x1, p)),
                o.push(HT(e, p, l
                    .x2)), a = ZD(o)
        }
        return !isFinite(a
            .maxerror) || !isFinite(
                a.maxminerror) ?
            NaN : Math.abs(a
                .totalvalue) <= 10 *
                a.maxminerror ? 0 : i *
            a.totalvalue
    }
    var Of = class {
        constructor(t) {
            this.comparator =
                t;
            this._data = []
        }
        size() {
            return this
                ._data
                .length
        }
        queue(t) {
            let n = this
                ._data
                .length;
            for (this._data
                .push(
                    t); n > 0;
            ) {
                let r = n -
                    1 >>> 1;
                if (this
                    .comparator(
                        this
                            ._data[
                        n
                        ],
                        this
                            ._data[
                        r
                        ]
                    ) <
                    0) {
                    let i =
                        this
                            ._data[
                        r
                        ];
                    this._data[
                        r
                    ] =
                        this
                            ._data[
                        n
                        ],
                        this
                            ._data[
                        n
                        ] =
                        i,
                        n =
                        r
                } else break
            }
        }
        dequeue() {
            let t = this
                ._data[0],
                n = this
                    ._data
                    .pop();
            if (this._data
                .length >
                0 && n !==
                void 0) {
                this._data[
                    0] =
                    n;
                let r = 0,
                    i = this
                        ._data
                        .length -
                        1;
                for (; ;) {
                    let s =
                        (r <<
                            1
                        ) +
                        1,
                        o =
                            s +
                            1,
                        a =
                            r;
                    if (s <=
                        i &&
                        this
                            .comparator(
                                this
                                    ._data[
                                s
                                ],
                                this
                                    ._data[
                                a
                                ]
                            ) <
                        0 &&
                        (a =
                            s),
                        o <=
                        i &&
                        this
                            .comparator(
                                this
                                    ._data[
                                o
                                ],
                                this
                                    ._data[
                                a
                                ]
                            ) <
                        0 &&
                        (a =
                            o),
                        a !==
                        r) {
                        let u =
                            this
                                ._data[
                            a
                            ];
                        this._data[
                            a
                        ] =
                            this
                                ._data[
                            r
                            ],
                            this
                                ._data[
                            r
                            ] =
                            u,
                            r =
                            a
                    } else
                        break
                }
            }
            return t
        }
        peek() {
            return this
                ._data[0]
        }
        clear() {
            this._data
                .length = 0
        }
    };

    function zw(e, t) {
        let n = e.start[1] - e.end[
            1],
            r = e.end[0] - e.start[
                0],
            i = t.start[1] - t.end[
                1],
            s = t.end[0] - t.start[
                0],
            o = n * e.end[0] + r * e
                .end[1],
            a = i * t.end[0] + s * t
                .end[1],
            u = n * s - i * r;
        if (u !== 0) return (n * a -
            i * o) / u
    }

    function Hw(e, t, n) {
        if (n.xSlope >= t.xSlope)
            return;
        if (t.scanlineX === n
            .scanlineX) return e;
        let r = t.start[1] > t.end[
            1] ? t.start : t
            .end,
            i = n.start[1] > n.end[
                1] ? n.start : n
                .end,
            s = r[1];
        if (i[1] < r[1]) {
            if (s = i[1], qT(s, t) <
                i[0]) return
        } else if (r[1] < i[1]) {
            let a = qT(s, n);
            if (r[0] < a) return
        } else if (r[0] < i[0])
            return;
        let o = zw(t, n);
        if (o !== void 0)
            return Math.max(Math
                .min(o, s), e)
    }

    function qT(e, t) {
        let n = t.end[0],
            r = t.start[0],
            i = t.end[1],
            s = t.start[1];
        if (i === e) return n;
        if (s === e) return r;
        {
            let o = (e - i) / (s -
                i),
                a = (1 - o) * n +
                    o * r;
            if (n < r) {
                if (a <= n)
                    return n;
                if (r <= a) return r
            } else {
                if (a <= r)
                    return r;
                if (n <= a) return n
            }
            return a
        }
    }

    function $T(e) {
        let t = 0,
            n = 0,
            r = !1,
            i = 0;
        for (let {
            scanlineX: s,
            isClockwise: o
        }
            of e) o ? i += 1 : i -=
                1, i !== 0 && !r ? (
                    r = !0, n = s) :
                    i === 0 && r && (r = !1,
                        t += s - n);
        return t
    }
    var Cf = class {
        constructor(t) {
            this.scanlineY = -
                1 / 0;
            let n = 1;
            this.activeEdges = [],
                this
                    .events =
                new Of(
                    function (
                        r, i
                    ) {
                        return r
                            .y -
                            i
                                .y
                    }), this
                        .scanlineY = -
                        1 / 0, this
                            .polygonLength =
                t.length -
                1;
            for (let r = t
                .length -
                1; r >=
                1; r--) {
                let i = t[
                    r],
                    s = t[
                        r -
                        1],
                    o = {
                        id: n++,
                        index: r -
                            1,
                        end: i,
                        start: s,
                        scanlineX: 0,
                        xSlope: 1 /
                            0,
                        isClockwise: s[
                            1
                        ] >
                            i[
                            1],
                        skipIntersectionWith: {}
                    };
                s[1] > i[
                    1] ? (
                    this
                        .events
                        .queue({
                            type: "+",
                            y: i[
                                1],
                            edge: o
                        }),
                    this
                        .events
                        .queue({
                            type: "-",
                            y: s[
                                1],
                            edge: o
                        }),
                    o
                        .xSlope =
                    (s[0] -
                        i[
                        0]
                    ) /
                    (s[1] -
                        i[
                        1]
                    ),
                    o
                        .scanlineX =
                    i[0]
                ) :
                    i[1] >
                        s[1] ? (
                        this
                            .events
                            .queue({
                                type: "+",
                                y: s[
                                    1],
                                edge: o
                            }),
                        this
                            .events
                            .queue({
                                type: "-",
                                y: i[
                                    1],
                                edge: o
                            }),
                        o
                            .xSlope =
                        (i[0] -
                            s[
                            0]
                        ) /
                        (i[1] -
                            s[
                            1]
                        ),
                        o
                            .scanlineX =
                        s[0]
                    ) :
                        this
                            .events
                            .queue({
                                type: "h",
                                y: s[
                                    1],
                                edge: o
                            })
            }
        }
        nextScanline() {
            var s;
            let t, n = this
                .events
                .peek();
            if (!n) return;
            if (n.y <= this
                .scanlineY)
                throw new Error(
                    "Programming error: expected next event to begin a new scanline"
                );
            this.scanlineY =
                n.y, this
                    .updateActiveEdgeScanlineIntersections();
            let r = $T(this
                .activeEdges
            ),
                i = [];
            for (; t = this
                .events
                .dequeue();)
                if (t
                    .type ===
                    "x" ?
                    this
                        .swapActiveEdges(
                            t) :
                    t
                        .type ===
                        "+" ?
                        this
                            .insertActiveEdge(
                                t) :
                        t
                            .type ===
                        "-" &&
                        this
                            .removeActiveEdge(
                                t),
                    i.push(
                        t),
                    ((s = this
                        .events
                        .peek()
                    ) ==
                        null ?
                        void 0 :
                        s.y
                    ) !==
                    this
                        .scanlineY
                )
                    return {
                        y: this
                            .scanlineY,
                        activeEdges: this
                            .activeEdges,
                        lengthBeforeProcessingEvents: r,
                        events: i
                    }
        }
        updateActiveEdgeScanlineIntersections
            () {
            let t = -1 / 0;
            for (let n of
                this
                    .activeEdges) {
                let r = qT(
                    this
                        .scanlineY,
                    n);
                r < t ? r =
                    t : t =
                r, n
                    .scanlineX =
                    r
            }
        }
        insertActiveEdge(t) {
            let n = this
                .activeEdges,
                r = t.edge,
                i = t.y,
                {
                    xSlope: s,
                    scanlineX: o
                } = r;
            for (var a =
                0; a < n
                    .length; a++
            ) {
                let u = n[
                    a];
                if (o < u
                    .scanlineX ||
                    o === u
                        .scanlineX &&
                    s <= u
                        .xSlope)
                    break
            }
            n.splice(a, 0,
                r), this
                    .checkIntersection(
                        i, n[a -
                        1],
                        r), this
                            .checkIntersection(
                                i, r, n[
                            a +
                            1])
        }
        checkIntersection(t, n,
            r) {
            if (!n || !r ||
                n.index ===
                (r.index +
                    1) %
                this
                    .polygonLength ||
                r.index ===
                (n.index +
                    1) %
                this
                    .polygonLength
            ) return;
            if (n.id < r
                .id) {
                if (n
                    .skipIntersectionWith[
                    r.id
                ])
                    return
            } else if (r
                .skipIntersectionWith[
                n.id])
                return;
            let i = Hw(t, n,
                r);
            if (i ===
                void 0)
                return;
            n.id < r.id ? n
                .skipIntersectionWith[
                r.id
            ] = !0 :
                r
                    .skipIntersectionWith[
                n.id
                ] = !0;
            let s = {
                type: "x",
                y: i,
                edge1: n,
                edge2: r
            };
            this.events
                .queue(s)
        }
        removeActiveEdge(t) {
            let n = this
                .activeEdges,
                r = t.edge,
                i = t.y,
                s = n
                    .indexOf(r);
            n.splice(s, 1),
                this
                    .checkIntersection(
                        i, n[s -
                        1],
                        n[s])
        }
        swapActiveEdges(t) {
            let n = this
                .activeEdges,
                r = t.edge1,
                i = t.edge2,
                s = t.y,
                o = n
                    .indexOf(r),
                a = o + 1;
            o === -1 || n[
                a] !== i ? r
                    .id < i.id ?
                delete r
                    .skipIntersectionWith[
                i.id] :
                delete i
                    .skipIntersectionWith[
                r.id] :
                (n[o] = i,
                    n[a] =
                    r, this
                        .checkIntersection(
                            s,
                            n[o -
                            1
                            ],
                            i),
                    this
                        .checkIntersection(
                            s,
                            r,
                            n[a +
                            1
                            ]
                        ))
        }
        static debugEvent(t) {
            let n =
                `y=${t.y} `;
            return n += t
                .type ===
                "x" ?
                `[x ${t.edge1.index}/${t.edge2.index}]` :
                `[${t.type} ${t.edge.index}] (${t.edge.end})-(${t.edge.start})`,
                n
        }
        debugState() {
            return `y=${this.scanlineY}
${this.activeEdges.map(t => `[${t.index}] ${t.scanlineX}`)}`
        }
    };

    function Uw(e) {
        let t = e.slice(0, 2),
            n = e.slice(-2);
        return t[0] !== n[0] || t[
            1] !== n[1] ? [...e, ...
                t
        ] : e
    }

    function L4(e, t) {
        if (!e) return !1;
        let n = Uw(e),
            [r, i] = t,
            s = 0;
        for (var o = n.length -
            1; o >= 3; o -= 2) {
            let a = n[o - 3],
                u = n[o - 2],
                c = n[o - 1],
                l = n[o];
            u > i != l > i && r < (
                c - a) * (i -
                    u) / (l - u) + a &&
                (u > l ? s += 1 :
                    u < l && (s -=
                        1))
        }
        return s !== 0
    }

    function JD(e) {
        if (e.length < 4 || e[0][
            0] !== e[e.length - 1][
            0] || e[0][1] !== e[
            e.length - 1][1])
            return 0;
        let t = new Cf(e),
            n, r = 0,
            i;
        for (; i = t
            .nextScanline();) {
            let s = i
                .lengthBeforeProcessingEvents;
            n && (r += .5 * (i.y - n
                .y) * (s + n
                    .length)), n = {
                        y: i.y,
                        length: $T(i
                            .activeEdges
                        )
                    }
        }
        return r
    }

    function QD(e) {
        if (!e.length) return [];
        if (e[0][0] !== e[e.length -
            1][0] || e[0][1] !==
            e[e.length - 1][1])
            throw new Error(
                "Programming error: expected last point to be a duplicate of the first point."
            );
        for (let f = 0; f < e
            .length - 1; f++)
            if (e[f][0] === e[f + 1]
            [0] && e[f][1] ===
                e[f + 1][1])
                throw new Error(
                    `Programming error: unexpected duplicate point at ${f + 1}`
                );
        let t = new Cf(e),
            n = e.slice(0, -1).map(
                () => 0),
            r;
        for (; r = t
            .nextScanline();)
            for (let f of r
                .events) {
                let m = {};
                if (f.type ===
                    "h") {
                    let g = f.edge;
                    m[g.index] = {
                        xMin: Math
                            .min(
                                g
                                    .end[
                                0
                                ],
                                g
                                    .start[
                                0
                                ]
                            ),
                        xMax: Math
                            .max(
                                g
                                    .end[
                                0
                                ],
                                g
                                    .start[
                                0
                                ]
                            ),
                        dx: g
                            .end[
                            0
                        ] -
                            g
                                .start[
                            0
                            ]
                    }
                } else if (f
                    .type === "x") {
                    let g = f.edge1,
                        d = f.edge2,
                        y = jD([g
                            .start,
                        g
                            .end
                        ], [d
                            .start,
                        d
                            .end
                        ]),
                        h = y > 0 ?
                            -1 : y < 0 ?
                                1 : 0;
                    n[g.index] += h,
                        n[d
                            .index] -= h
                }
                for (let g of r
                    .activeEdges) {
                    let d = g.end[
                        1] - g
                            .start[1];
                    for (let y in
                        m) {
                        let {
                            xMin: h,
                            xMax: b,
                            dx: x
                        } = m[y];
                        if (h < g
                            .scanlineX &&
                            g
                                .scanlineX <
                            b) {
                            let P =
                                x *
                                d,
                                M =
                                    P >
                                        0 ?
                                        -1 :
                                        P <
                                            0 ?
                                            1 :
                                            0;
                            n[y] +=
                                M,
                                n[g
                                    .index] -=
                                M
                        }
                    }
                }
            }
        let i = e.slice(0, -1).map(
            () => 0),
            s = e[0][1],
            o = 0;
        for (let f = 1; f < e
            .length; f++) e[f][1] <
                s && (s = e[f][1], o =
                    f);
        let a = e.length - 1,
            u = o > 0 ? o - 1 : a -
                1,
            c = (o + 1) % a,
            p = jD([e[u], e[o]], [e[
                o], e[c]]) > 0 ? 1 :
                0;
        i[o] = p > 0 ? -1 : 1;
        for (let f = 0; f < a -
            1; f++) {
            let m = (o + f) % a;
            p += n[m], i[(m + 1) %
                a] = p > 0 ? -
                    1 : 1
        }
        return i
    }

    function jD(e, t) {
        let n = e[1][0] - e[0][0],
            r = e[1][1] - e[0][1],
            i = t[1][0] - t[0][0],
            s = t[1][1] - t[0][1];
        return n * s - r * i
    }
    var s1 = {
        spy: cD
    },
        {
            cosh: o1,
            sinh: a1,
            tanh: u1,
            acosh: c1,
            asinh: l1,
            atanh: p1,
            expm1: qw,
            log1p: _f,
            sign: eI,
            hypot: po
        } = Math,
        $w = la,
        tI = qu,
        f1 = $u,
        d1 = Symbol("DIVERGES"),
        m1 = (n => (n[n.SUCCESS =
            0] = "SUCCESS", n[n
                .MISSING_CACHE_ENTRY =
            1] =
            "MISSING_CACHE_ENTRY",
            n))(m1 || {}),
        Ny = class Ny {
            constructor(t = Ny
                .defaultLimit, n
            ) {
                this.limit = t;
                this.computeSize =
                    n;
                this.currentSize =
                    0;
                this.cache =
                    new Map
            }
            get(t) {
                let n = this
                    .cache.get(
                        t);
                return n && (
                    this
                        .cache
                        .delete(
                            t),
                    this
                        .cache
                        .set(t,
                            n)),
                    n == null ?
                        void 0 : n
                            .value
            }
            set(t, n) {
                let r = this
                    .computeSize ?
                    this
                        .computeSize(
                            n) : 1;
                if (this
                    .currentSize +
                    r >= this
                        .limit) {
                    let i = this
                        .cache
                        .keys()
                        .next()
                        .value;
                    this.cache
                        .delete(
                            i)
                }
                this.cache.set(
                    t, {
                    size: r,
                    value: n
                })
            }
        };
    Ny.defaultLimit = 1e5;
    var ql = Ny,
        Lf = 1e4,
        y1 = Lf * 2;

    function Yw() {
        return Lf
    }

    function nI(e) {
        Lf = e
    }
    var g1 = (n => (n[n
        .DoesNotTerminate =
        0] =
        "DoesNotTerminate",
        n[n.DepthLimitExceeded =
        1] =
        "DepthLimitExceeded",
        n))(g1 || {});

    function h1(e, t) {
        if (uo(t)) return e
            .recursionTerminationStatus =
            0, $r(t);
        throw db()
    }

    function b1(e, t) {
        if (uo(t)) return e
            .recursionTerminationStatus =
            1, $r(t);
        throw mb()
    }
    var KD = new WeakMap;

    function Xw(e) {
        let t = KD.get(e);
        return t || (t = new Set(e),
            KD.set(e, t)), t
    }

    function WT(e) {
        return `${e.fn}:${JSON.stringify(e.args)}`
    }

    function Zw(e, t) {
        return {
            status: 0,
            result: [e, t]
        }
    }

    function Ww(e) {
        return {
            status: 1,
            stackFrame: e
        }
    }

    function jw(e, t, n, r) {
        let i = e
            .recursiveFunctionCache ||
            new ql,
            s = [];
        s.push(r);
        let o = 0;
        for (; s.length > 0;) {
            if (s.length > Lf || o++
                > y1) return b1(e,
                    n);
            let a = s.pop(),
                {
                    fn: u,
                    args: c
                } = a,
                l = t[u](i, ...c);
            if (l === d1) return h1(
                e, n);
            if ((l == null ?
                void 0 : l
                    .status) === 1)
                s.push({
                    fn: u,
                    args: c
                }), s.push(l
                    .stackFrame);
            else {
                let p = WT(a);
                i.set(p, l.result)
            }
        }
        return i.get(WT(r))[0]
    }
    var Jw = function (e) {
        let t = e * e;
        return 1 + t === 1 ? 1 :
            1 + t === t ? Math
                .abs(e) : Math.sqrt(
                    t + 1)
    },
        Qw = function (e) {
            let t = e * e;
            return t < 1 ? NaN : t -
                1 === t ? Math.abs(
                    e) : Math.sqrt(
                        t - 1)
        };

    function rr(e, t, n) {
        return Math.max(t, Math.min(
            n, e))
    }

    function x1(e, t) {
        let n = e % t;
        return e * t < 0 && n !==
            0 ? n + t : n
    }

    function P1(e, t) {
        e = Math.round(e), t = Math
            .round(t);
        let n = tI(e, t);
        return Math.abs(e / n * t)
    }

    function Kw(e) {
        if (e.length === 0)
            return NaN;
        let t = e[0];
        for (let n = 1; n < e
            .length; n++) t = tI(t,
                e[n]);
        return t
    }

    function eF(e) {
        if (e.length === 0)
            return NaN;
        let t = e[0];
        for (let n = 1; n < e
            .length; n++) t = P1(t,
                e[n]);
        return t
    }

    function ou(e, t) {
        if (isNaN(e)) return e;
        if (isNaN(t)) return t;
        if (!isFinite(e) && !
            isFinite(t)) return NaN;
        if (t === 0 || e === t)
            return 1;
        if (e === 0) return bs(t);
        let n = isFinite(e) && e ===
            Math.round(e),
            r = isFinite(t) && t ===
                Math.round(t);
        if (e < 0 && t < 0 && e -
            t < 0) return n && r ?
                0 : bs(e - t) * bs(
                    t) / (bs(e) *
                        ou(-e, -t));
        if (e < 0 && t > 0 && e -
            t < 0) return n && r ?
                Math.pow(-1, t) *
                ou(t - e - 1, t) :
                bs(e - t) / bs(e) *
                ou(-(e - t), t);
        if (e < 0 && t < 0 && e -
            t > 0) return n && r ?
                Math.pow(-1, e -
                    t) * ou(-t - 1, e -
                        t) : bs(t) / bs(
                            e) * ou(-t, -e);
        if (e > 0 && t < 0 && e -
            t > 0) {
            let a = Math.abs(e) >
                Math.abs(t) ? -t :
                e;
            return bs(t) / ou(e - t,
                a)
        }
        if (e > 0 && t > 0 && e -
            t < 0) return bs(e -
                t) / ou(t, e);
        if (e < 0 || t < 0 || e -
            t < 0 || e < 15 && t <
            15 && e - t < 15)
            return Dy(e, t) / $o(t);
        let i = es(e) - es(t) - es(
            e - t) - (e - t) *
            _f(-t / e),
            s = Math.sqrt(e / (2 *
                Math.PI * t * (
                    e - t))) * Math
                        .pow(e / t, t) * Math
                            .exp(i);
        return n && r && e > 0 &&
            t > 0 && e - t > 0 ?
            Math.round(s) : s
    }

    function Dy(e, t) {
        if (isNaN(e)) return e;
        if (isNaN(t)) return t;
        if (!isFinite(e) && !
            isFinite(t)) return NaN;
        if (t === 0) return 1;
        if (e === 0) return 1 / $o(-
            t);
        if (e === t) return $o(e);
        let n = isFinite(e) && e ===
            Math.round(e),
            r = isFinite(t) && t ===
                Math.round(t);
        if (e < 0 && e - t < 0)
            return n && r ? Math
                .pow(-1, t) * Dy(t -
                    e - 1, t) : bs(
                        e - t) / bs(e) *
            Dy(-(e - t), t);
        if (e < 0 || e - t < 0 ||
            e < 15 && e - t < 15)
            return $o(e) / $o(e -
                t);
        let i = es(e) - es(e - t) -
            (e - t) * _f(-t / e),
            s = Math.sqrt(e / (e -
                t)) * Ay(e, t) *
                Math.exp(i);
        return n && r && e > 0 &&
            t > 0 && e - t > 0 ?
            Math.round(s) : s
    }

    function $o(e) {
        if (e === -1 / 0)
            return NaN;
        let t = Math.round(e) === e;
        if (e < 0) return t ? 1 /
            0 : 1 / (bs(e) * e1(
                -e));
        let n = e1(e);
        return t ? Math.round(n) : n
    }

    function e1(e) {
        return e > 171 ? 1 / 0 : e <
            14 ? tF(e) : iF(e)
    }

    function tF(e) {
        let t = 4.077131788261185,
            n = 7.024675027156382,
            r = 6.657107767450176,
            i = 3.766266976716022,
            s = 1.2792371666711133,
            o = .24304596436338005,
            a = .020049769312165774,
            u = 4.154347453162709,
            c = 7.270007565107539,
            l = 6.97805297331391,
            p = 3.989651532924167,
            f = 1.367176195613119,
            m = .26175627691546965,
            g = .021742722739397567,
            d = 1 + e * (t + e * (
                n + e * (r + e *
                    (i + e * (
                        s +
                        e *
                        (o + e *
                            a
                        )
                    ))))),
            y = 1 + e * (u + e * (
                c + e * (l + e *
                    (p + e * (
                        f +
                        e *
                        (m + e *
                            g
                        )
                    ))))),
            h = e + 1,
            b = 1 - (h - e);
        return Ay(h, e) * Math.sqrt(
            h + (2 * e + 1) * b
        ) * (d / y)
    }
    var nF = Math.pow(2, 27) + 1;

    function rF(e) {
        let t = nF * e;
        return t - (t - e)
    }
    var YT = .3678794428706169,
        XT = -16991745912462731e-25;

    function Ay(e, t) {
        let n = rF(e),
            r = e - n,
            i = e * (YT + XT);
        if (i === 0) return Math
            .pow(e / Math.E, t);
        let s = n * YT - i + n *
            XT + r * YT + r * XT;
        return Math.pow(i, t) * (1 +
            t * (s / i))
    }

    function iF(e) {
        return Ay(e, e) * Math.sqrt(
            2 * Math.PI * e) *
            Math.exp(S1(e))
    }
    var T1 = [1 / 6, -1 / 30, 1 /
        42, -1 / 30, 5 / 66, -
        691 / 2730, 7 / 6, -
        3617 / 510, 43867 / 798,
    -174611 / 330, 854513 /
    138, -236364091 / 2730,
    8553103 / 6, -
    23749461029 / 870
    ];

    function I1(e, t) {
        if (e !== Math.floor(e))
            return NaN;
        if (e < 0) return NaN;
        if (e === 0) return 1 / D1(
            t);
        let n = Kt(t);
        if (e === 1) return -1 / (
            n * n);
        let r = xn(t);
        if (e === 2) return 2 * r /
            (n * n * n);
        let i = [0, 2],
            s = [];
        for (let a = 3; a <=
            e; a++) {
            s = [];
            for (let u = 0; u <
                a; u++) {
                let c = 0,
                    l = 0;
                u > 0 && (c = (a -
                    u + 1) *
                    i[u - 1]),
                    u + 2 < a && (
                        l = (u +
                            1) * i[u +
                            1]), s
                                .push(-(c + l))
            }
            i = s
        }
        let o = 0;
        for (let a = e - 1; a >=
            0; a--) o = s[a] + r *
                o;
        return o / Math.pow(n, e +
            1)
    }

    function E1(e, t) {
        if (e < 0) return NaN;
        if (e !== Math.floor(e))
            return NaN;
        let n = e % 2 === 0 ? -1 :
            1;
        if (t < 0) return -n * E1(e,
            1 - t) - Math
                .pow(Math.PI, e +
                    1) * I1(e, Math.PI *
                        t);
        let r = $o(e),
            i = 0,
            s = Math.pow(t, -(e +
                1));
        for (; t < 10;) i += s, t++,
            s = Math.pow(t, -(e +
                1));
        i += e === 0 ? -Math.log(
            t) : s * t / e, i +=
            .5 * s;
        let o = T1,
            a = e + 1,
            u = 2,
            c = s * t * a / u,
            l = 1 / (t * t);
        for (let p = 1; p <=
            14; p++) c *= l, i +=
                c * o[p - 1], a++, u++,
                c *= a / u, a++, u++,
                c *= a / u;
        return r * n * i
    }

    function sF(e) {
        let t = Math.log(e);
        return Math.exp(Math.round(
            t)) === e ? Math
                .round(t) : t
    }

    function M1(e, t) {
        if (t === 0) return NaN;
        let n;
        return t === Math.E ? n =
            Math.log(e) : t === 2 &&
                Math.log2 ? n = Math
                    .log2(e) : t === 10 &&
                        Math.log10 ? n = Math
                            .log10(e) : n = Math
                                .log(e) / Math.log(t),
            Math.pow(t, Math.round(
                n)) === e ? Math
                    .round(n) : n
    }

    function oF(e) {
        return M1(e, 10)
    }

    function aF(e, t) {
        return f1(e, 1 / t)
    }
    var v1 = 1 / Math.PI;

    function _y(e) {
        return e > 1e12 ? !1 : Math
            .round(v1 * e) * Math
                .PI === e
    }

    function Ly(e) {
        if (e > 1e12) return !1;
        let t = Math.round(2 * v1 *
            e);
        return t % 2 === 1 && t *
            Math.PI === 2 * e
    }

    function Kt(e) {
        return _y(Math.abs(e)) ? 0 :
            Math.sin(e)
    }

    function xn(e) {
        return Ly(Math.abs(e)) ? 0 :
            Math.cos(e)
    }

    function D1(e) {
        let t = Math.abs(e);
        return _y(t) ? 0 : Ly(t) ?
            1 / 0 : Math.tan(e)
    }

    function uF(e) {
        return Ly(Math.abs(e)) ? 1 /
            0 : 1 / Math.cos(e)
    }

    function cF(e) {
        return _y(Math.abs(e)) ? 1 /
            0 : 1 / Math.sin(e)
    }

    function lF(e) {
        let t = Math.abs(e);
        return _y(t) ? 1 / 0 : Ly(
            t) ? 0 : 1 / Math.tan(e)
    }

    function pF(e) {
        return e > 0 ? Math.atan(1 /
            e) : Math.PI / 2 -
        Math.atan(e)
    }

    function fF(e) {
        return Math.asin(1 / e)
    }

    function dF(e) {
        return Math.acos(1 / e)
    }

    function mF(e) {
        return 1 / o1(e)
    }

    function yF(e) {
        return 1 / a1(e)
    }

    function gF(e) {
        return 1 / u1(e)
    }

    function hF(e) {
        return c1(1 / e)
    }

    function bF(e) {
        return l1(1 / e)
    }

    function xF(e) {
        return p1(1 / e)
    }

    function PF(e) {
        if (e === 0 || isNaN(e))
            return e;
        if (!isFinite(e))
            return NaN;
        if (e === Math.floor(e))
            return e > 0 ? 0 : -0;
        let t = Math.round(2 * e),
            n = -.5 * t + e,
            r = t & 2 ? -1 : 1,
            i = t & 1 ? Math.cos(
                Math.PI * n) : Math
                    .sin(Math.PI * n);
        return r * i
    }

    function bs(e) {
        return e === 1 / 0 || e ===
            -1 / 0 ? 0 : e === 0 ?
            1 : PF(e) / (Math.PI *
                e)
    }

    function Xo(e) {
        let t = 0;
        for (let n = 0; n < e
            .length; n++) t += e[n];
        return t / e.length
    }

    function TF(e) {
        let t = 0;
        for (let n = 0; n < e
            .length; n++) t += e[n];
        return t
    }

    function jT(e) {
        return e > 50 ? Math.exp(
            .5 * ((1 - e) * _f(-
                1 / (e - 1)
            ) - 1) + es(
                .5 * (e - 1)) -
            es(.5 * (e - 2))) *
            Math.sqrt((1 - 1 / e) /
                (2 * Math.PI)) : e /
                (e + 1) * $o((e + 1) /
                    2) / ($o(e / 2) *
                        Math.sqrt(e * Math
                            .PI))
    }

    function $l(e, t, n = e - t) {
        if (Math.abs(n) < .1 * (e +
            t)) {
            let r = n / (e + t),
                i = n * n / (e + t),
                s = 2 * e * r;
            for (let o = 1; o <
                10; o++) {
                s *= r * r;
                let a = i + s / (2 *
                    o + 1);
                if (a == i)
                    return a;
                i = a
            }
        }
        return e * Math.log(e / t) +
            t - e
    }
    var IF = [0, .08106146679532726,
        .0413406959554093,
        .02767792568499834,
        .020790672103765093,
        .016644691189821193,
        .013876128823070748,
        .01189670994589177,
        .010411265261972096,
        .009255462182712733,
        .00833056343336287,
        .007573675487951841,
        .00694284010720953,
        .006408994188004207,
        .0059513701127588475,
        .005554733551962801
    ];

    function es(e) {
        return e > 15 ? S1(e) : e <
            0 ? NaN : e === Math
                .floor(e) ? IF[e] : Math
                    .log($o(e) / (Ay(e, e) *
                        Math.sqrt(2 *
                            Math.PI * e)
                    ))
    }

    function S1(e) {
        let t = .08333333333333333,
            n = .002777777777777778,
            r =
                .0007936507936507937,
            i =
                .0005952380952380953,
            s =
                .0008417508417508417,
            o = e * e;
        return (t - (n - (r - (i -
            s / o) /
            o) / o) / o) / e
    }

    function wy(e, t) {
        return t <= 0 ? NaN : jT(
            t) * Math.pow(1 + e *
                e / t, -((t + 1) /
                    2))
    }

    function Tc(e, t) {
        if (t > 0) return 1 - Tc(e,
            -t);
        if (t === -1 / 0) return 0;
        if (t === 0) return .5;
        if (e >= 40 && t > -1)
            return .5 + jT(e) * EF(
                e, t);
        if (t / e < -1e3) {
            let r = t * t;
            return jT(e) * Math.pow(
                e, .5 * (e - 1)
            ) * Math.pow(
                Math.abs(t), -e
            ) * (1 - e * e *
                (e + 1) * (1 / (
                    2 + e) +
                    e * (e +
                        3) / (4 * (
                            4 +
                            e) *
                            r)) / (
                    2 * r))
        }
        let n = Math.sqrt(t * t +
            e);
        return MF((t + n) / (2 * n),
            e / 2, e / 2)
    }

    function EF(e, t) {
        let n = t * t / e,
            r = t,
            i = r;
        for (let s = 1; s <=
            15; s++) r *= -(2 * s -
                1) / (2 * s + 1) * (
                    .5 * (e + 1) + s - 1
                ) / s * n, i += r;
        return i
    }

    function My(e, t, n) {
        return n <= 0 ? NaN : e ===
            -1 / 0 ? Tc(n, t) : e >
                0 && t > 0 ? Tc(n, -e) -
        Tc(n, -t) : Tc(n, t) -
        Tc(n, e)
    }

    function MF(e, t, n) {
        if (e < 0 || e > 1)
            throw new RangeError(
                "First argument must be between 0 and 1."
            );
        if (t === 1 && n === 1)
            return e;
        if (e === 0) return 0;
        if (e === 1) return 1;
        if (t === 0) return 1;
        if (n === 0) return 0;
        {
            let r = es(t + n) - es(
                t) - es(n) - $l(
                    t, (t + n) * e
                ) - $l(n, (t +
                    n) * (1 -
                        e), (t + n) *
                        e - t),
                i = Math.exp(r) *
                    Math.sqrt(t * n / (
                        2 * Math
                            .PI * (t +
                                n)));
            return e < (t + 1) / (
                t + n + 2) ? i *
                t1(e, t, n) / t :
                1 - i * t1(1 - e, n,
                    t) / n
        }
    }

    function t1(e, t, n) {
        let r = Math.pow(2, -52),
            i = 1e-300,
            s = t + n,
            o = t + 1,
            a = t - 1,
            u = 1,
            c = 1 - s * e / o;
        Math.abs(c) < i && (c = i),
            c = 1 / c;
        let l = c;
        for (let p = 1; p <=
            100; p++) {
            let f = 2 * p,
                m = p * (n - p) *
                    e / ((a + f) * (t +
                        f));
            c = 1 + m * c, Math.abs(
                c) < i && (c =
                    i), u = 1 + m /
                    u, Math.abs(u) <
                    i && (u = i), c =
                1 / c, l *= c * u,
                m = -(t + p) * (s +
                    p) * e / ((t +
                        f) * (o +
                            f)), c = 1 + m *
                            c, Math.abs(c) <
                            i && (c = i), u =
                1 + m / u, Math.abs(
                    u) < i && (u =
                        i), c = 1 / c;
            let g = c * u;
            if (l *= g, Math.abs(g -
                1) <= r)
                return l
        }
        return l
    }

    function vF(e, t) {
        let n = Math.pow(2, -52),
            r = 1e-300,
            i = 1,
            s = e,
            o = i / s,
            a = i / r,
            u = 1 / s,
            c = 2,
            l = 0,
            p = s,
            f = -(e - 1),
            m = 0;
        do f -= 1, p += 1, u = u *
            f * t + p, u === 0 && (
                u = r), a = p + f *
                t / a, a === 0 && (a =
                    r), u = 1 / u, l =
            a * u, o = o * l, m +=
            1, p += 1, u = u * m *
            t + p, u === 0 && (u =
                r), a = p + m * t /
                a, a === 0 && (a = r),
            u = 1 / u, l = a * u,
            o *= l, c += 2; while (
            c < 100 && Math.abs(l -
                1) > n);
        return o
    }

    function DF(e, t) {
        let n = Math.pow(2, -52),
            r = 1e-300,
            i = 1,
            s = t + 1 - e,
            o = i / s,
            a = i / r,
            u = 1 / s,
            c = 2,
            l = 0,
            p = s;
        do {
            let f = -(c - 1) * (c -
                e - 1);
            p += 2, u = u * f + p,
                u === 0 && (u = r),
                a = p + f / a, a ===
                0 && (a = r), u =
                1 / u, l = a * u,
                o *= l, c += 1
        } while (c < 100 && Math
            .abs(l - 1) > n);
        return o
    }

    function SF(e, t) {
        let n = t / e,
            r = eI(t - e) * Math
                .sqrt(2 * $l(1, n)),
            i = [1, -
                .3333333333333333,
                .08333333333333333,
                -
                .014814814814814815,
                .0011574074074074073,
                .0003527336860670194,
                -
                .0001787551440329218,
                3919263178522438e-20,
                -
                2185448510679992e-21,
                -
                185406221071516e-20,
                8296711340953087e-22,
                -
                17665952736826078e-23,
                6707853543401498e-24,
                10261809784240309e-24,
                -
                4382036018453353e-24,
                914769958223679e-24,
                -
                25514193994946248e-27,
                -
                5830772132550426e-26,
                24361948020667415e-27,
                -
                50276692801141755e-28,
                11004392031956135e-29,
                3371763262400985e-28,
                -
                1392388722418162e-28,
                28534893807047445e-30,
                -
                5139111834242572e-31,
                -
                19752288294349442e-31,
                8099521156704561e-31
            ],
            s = i.length - 2,
            o = 0,
            a = 0,
            u = 0,
            c = 0;
        for (; s >= 0; s--) u = (s +
            2) * o / e + i[s +
            1], c = r * c + u,
            o = a, a = u;
        if (c = e / (e + o) * c, t <
            e) {
            let l = Math.exp(-.5 *
                e * r * r) * (
                    .5 * Ta(-r *
                        Math.sqrt(
                            e / 2)
                    ) - c / Math
                        .sqrt(2 * Math
                            .PI * e));
            return isFinite(l) ? 1 -
                l : 1
        } else {
            let l = Math.exp(-.5 *
                e * r * r) * (
                    .5 * Ta(r * Math
                        .sqrt(e / 2)
                    ) + c / Math
                        .sqrt(2 * Math
                            .PI * e));
            return isFinite(l) ? l :
                0
        }
    }

    function n1(e, t, n) {
        return (e - t) / (Math
            .SQRT2 * Math.abs(n)
        )
    }

    function Rf(e) {
        return e < 0 ? .5 * Math
            .exp(-e * e) * Ta(-e) :
            1 - .5 * Math.exp(-e *
                e) * Ta(e)
    }

    function OF(e, t, n, r) {
        let i = n1(t, n, r);
        if (e === -1 / 0) return Rf(
            i);
        let s = n1(e, n, r);
        return s > 0 && i > 0 ? Rf(-
            s) - Rf(-i) : Rf(
                i) - Rf(s)
    }

    function rI(e, t, n) {
        return 1 / Math.sqrt(2 *
            Math.PI * n * n) *
            Math.exp(-(e - t) * (e -
                t) / (2 * n *
                    n))
    }

    function iI(e) {
        let t = s1.spy(e),
            n = parseInt(t.slice(0,
                8), 16) & 2097151,
            r = parseInt(t.slice(8,
                16), 16);
        return (n * 4294967296 +
            r) / 9007199254740992
    }

    function O1(e, t) {
        for (let n = t.length -
            1; n > 0; n--) {
            let r = e + "::sc" + n,
                i = Math.floor(iI(
                    r) * (n + 1)),
                s = t[n];
            t[n] = t[i], t[i] = s
        }
    }

    function CF(e, t) {
        let n = t.slice();
        return O1(e, n), n
    }

    function sI(e, t) {
        let n = [];
        for (let r = 0; r < t; r++)
            n.push(r);
        return O1(e, n), n
    }

    function au(e, t, n) {
        return iI(e) * (n - t) + t
    }

    function RF(e, t, n) {
        let r = 0,
            i, s, o, a;
        do i = e + "::sc" + r, r +=
            1, s = au(i, 0, 1) * 2 -
            1, i = e + "::sc" + r,
            r += 1, o = au(i, 0,
                1) * 2 - 1, a = s * s +
                o * o; while (a >= 1 ||
            a === 0);
        let u = Math.sqrt(-2 * Math
            .log(a) / a);
        return t + n * s * u
    }

    function NF(e, t) {
        if (t <= 0) return NaN;
        let n = 0,
            r, i, s, o;
        do r = e + "::sc" + n, n +=
            1, i = au(r, 0, 1) * 2 -
            1, r = e + "::sc" + n,
            n += 1, s = au(r, 0,
                1) * 2 - 1, o = i * i +
                s * s; while (o > 1);
        let a = i * i / o,
            u = t * (Math.pow(o, -
                2 / t) - 1);
        return r = e + "::sc" + n,
            n += 1, (au(r, 0, 1) <
                .5 ? -1 : 1) * Math
                    .sqrt(a * u)
    }

    function AF(e, t, n) {
        return t = rr(Math.round(t),
            0, 1 / 0), t === 1 /
                0 ? NaN : (n = rr(n, 0,
                    1), R1(au(e, 0,
                        1), t, n))
    }

    function _F(e, t) {
        return t < 0 ? NaN : C1(au(
            e, 0, 1), t)
    }

    function vy(e, t, n) {
        return e >= t ? 1 : e < 0 ?
            0 : e < Math.floor((t +
                1) * n) ? r1(e, t,
                    n) : 1 - r1(t - e -
                        1, t, 1 - n)
    }

    function r1(e, t, n) {
        let r = (1 - n) / n,
            i = Fy(e, t, n),
            s = i;
        for (; e > 0 && (i *= e / (
            t - e + 1) * r,
            s + i !== s); e--)
            s += i;
        return s
    }

    function LF(e, t, n, r) {
        return n = rr(Math.round(n),
            0, 1 / 0), n === 1 /
                0 ? NaN : (r = rr(r, 0,
                    1), t < 0 ? 0 :
                        (e = Math.ceil(e),
                            t = Math.floor(
                                t), e === -
                                    1 / 0 ? vy(t, n,
                                        r) : vy(t,
                                            n, r) - vy(
                                                e - 1, n, r)
                        ))
    }

    function Fy(e, t, n) {
        if (e = Math.round(e), t =
            rr(Math.round(t), 0, 1 /
                0), t === 1 / 0)
            return NaN;
        if (n = rr(n, 0, 1), e <
            0 || e > t) return 0;
        if (n === 0) return e ===
            0 ? 1 : 0;
        if (n === 1) return e ===
            t ? 1 : 0;
        if (e === 0) return Math
            .exp(t * _f(-n));
        if (e === t) return Math
            .pow(n, t);
        let r = es(t) - es(e) - es(
            t - e) - $l(e, t *
                n) - $l(t - e, t * (
                    1 - n), t * n -
                e);
        return Math.exp(r) * Math
            .sqrt(t / (2 * Math.PI *
                e * (t - e)))
    }

    function Yl(e, t) {
        return t < 0 ? NaN : (e =
            Math.round(e), e <
                0 ? 0 : t === 0 ?
                e === 0 ? 1 : 0 :
                e === 0 ? Math.exp(-
                    t) : Math.exp(-
                        es(e) - $l(e, t)
                    ) / Math.sqrt(
                        2 * Math.PI * e)
        )
    }

    function Nf(e, t) {
        if (isNaN(e) || isNaN(t))
            return NaN;
        if (e === 1 / 0) return 1;
        if (e = Math.floor(e), e <
            0) return 0;
        if (t === 0) return 1;
        if (e + 1 > 12 && 2.35 * (
            e + 1) > t && .3 * (
                e + 1) < t)
            return SF(e + 1, t);
        if (e + 1 >= t) {
            let n = vF(e + 1, t);
            return isFinite(n) ? 1 -
                t * Yl(e, t) * n : 1
        } else {
            let n = DF(e + 1, t);
            return isFinite(n) ? t *
                Yl(e, t) * n : 0
        }
    }

    function wF(e, t, n) {
        return n < 0 ? NaN : (e =
            Math.ceil(e), t =
            Math.floor(t), t <
                0 ? 0 : e === -1 /
                    0 ? Nf(t, n) : Nf(t,
                        n) - Nf(e - 1,
                            n))
    }

    function oI(e, t, n) {
        return n <= t ? NaN : e <
            t || e > n ? 0 : 1 / (
                n - t)
    }

    function i1(e, t, n) {
        return n <= t ? NaN : e <
            t ? 0 : e > n ? 1 : (e -
                t) / (n - t)
    }

    function FF(e, t, n, r) {
        return i1(t, n, r) - i1(e,
            n, r)
    }

    function VF(e) {
        let t = -e * e;
        return t < -750 ? e >= 0 ?
            1 : -1 : e >= .065 ? 1 -
                Math.exp(t) * Ta(e) :
            e <= -.065 ? Math.exp(
                t) * Ta(-e) - 1 : e * (
                    1.1283791670955126 +
                    t * (
                        .37612638903183754 +
                        t * (
                            .11283791670955126 +
                            t * (
                                .026866170645131252 +
                                t *
                                .005223977625442188
                            ))))
    }

    function Ta(e) {
        let t = .9999999999999999,
            n = 2.224574423459406,
            r = 2.444115549920689,
            i = 1.7057986861852539,
            s = .8257463703357973,
            o = .28647031042892007,
            a = .07124513844341643,
            u = .012296749268608364,
            c = .001347817214557592,
            l =
                7263959403471071e-20,
            p = 1,
            f = 3.352953590554884,
            m = 5.227518529742423,
            g = 5.003720878235473,
            d = 3.266590890998987,
            y = 1.5255421920765353,
            h = .5185887413188858,
            b = .12747319185915415,
            x = .02185979575963238,
            P =
                .0023889438122503674,
            M =
                .00012875032817508128;
        if (e < 0) return e < -6.1 ?
            2 * Math.exp(e *
                e) : 2 * Math.exp(
                    e * e) - Ta(-e);
        if (e > 50) {
            let I =
                .5641895835477563,
                E = e * e;
            return e > 5e7 ? I / e :
                I * (E * (E + 4.5) +
                    2) / (e * (E * (
                        E + 5) +
                        3.75))
        } else {
            let I = t + e * (n + e *
                (r + e * (i +
                    e * (s +
                        e *
                        (o + e *
                            (a + e *
                                (u + e *
                                    (c + e *
                                        l
                                    )
                                )
                            )
                        )
                    )))),
                E = p + e * (f + e *
                    (m + e * (g +
                        e * (d +
                            e *
                            (y + e *
                                (h + e *
                                    (b + e *
                                        (x + e *
                                            (P + e *
                                                M
                                            )
                                        )
                                    )
                                )
                            )
                        ))));
            return I / E
        }
    }

    function aI(e) {
        let t = -39.6968302866538,
            n = 220.946098424521,
            r = -275.928510446969,
            i = 138.357751867269,
            s = -30.6647980661472,
            o = 2.50662827745924,
            a = -54.4760987982241,
            u = 161.585836858041,
            c = -155.698979859887,
            l = 66.8013118877197,
            p = -13.2806815528857,
            f = -.00778489400243029,
            m = -.322396458041136,
            g = -2.40075827716184,
            d = -2.54973253934373,
            y = 4.37466414146497,
            h = 2.93816398269878,
            b = .00778469570904146,
            x = .32246712907004,
            P = 2.445134137143,
            M = 3.75440866190742,
            I = .02425,
            E, v, O;
        return e > .5 ? -aI(1 - e) :
            e === .5 ? 0 : e < 0 ?
                NaN : e === 0 ? -1 / 0 :
                    (e < I ? (E = Math.sqrt(
                        -2 * Math
                            .log(e)),
                        O = (((((f * E + m) *
                            E +
                            g
                        ) *
                            E +
                            d) *
                            E + y) *
                            E + h) / (((
                                (b * E +
                                    x
                                ) *
                                E +
                                P) *
                                E + M) *
                                E + 1)) : (
                        E = e - .5, v =
                        E * E, O = (((((t * v +
                            n
                        ) *
                            v +
                            r
                        ) *
                            v +
                            i) *
                            v + s) *
                            v + o) * E /
                        (((((a * v + u) *
                            v +
                            c
                        ) *
                            v +
                            l) *
                            v + p) *
                            v + 1)), O -
                        Math.sqrt(2 * Math
                            .PI) * (.5 * Ta(
                                -O / Math
                                    .SQRT2) -
                                Math.exp(.5 *
                                    O * O) * e))
    }

    function C1(e, t) {
        if (t < 0 || e < 0 || e > 1)
            return NaN;
        if (t === 0 || e === 0)
            return 0;
        if (e === 1) return 1 / 0;
        let n = -1,
            r = Math.ceil(t);
        for (; Nf(r, t) < e;) r =
            2 * r;
        let i = Math.floor(n + (r -
            n) / 2);
        for (; n < i && i < r;) Nf(
            i, t) < e ? n = i :
            r = i, i = Math.floor(
                n + (r - n) / 2);
        return r
    }

    function R1(e, t, n) {
        if (t !== Math.round(t))
            return NaN;
        if (n < 0 || n > 1)
            return NaN;
        if (e < 0 || e > 1)
            return NaN;
        if (e === 0) return 0;
        if (e === 1) return t;
        if (t === 0) return 0;
        if (n === 1) return t;
        if (n === 0) return 0;
        let r = -1,
            i = t,
            s = Math.floor(r + (i -
                r) / 2);
        for (; r < s && s < i;) vy(
            s, t, n) < e ? r =
        s : i = s, s = Math
            .floor(r + (i - r) / 2);
        return i
    }

    function N1(e, t) {
        if (isNaN(t) || t <= 0 ||
            e < 0 || e > 1)
            return NaN;
        if (e === 0) return -1 / 0;
        if (e === 1) return 1 / 0;
        if (t === 1 || t === 2 ||
            t === 4) return ZT(t,
                e);
        let n, r;
        if (e === .5) return 0;
        if (e > .5) n = t > 1 ? aI(
            e) : ZT(1, e), r =
            t > 1 ? ZT(1, e) : Math
                .pow(wy(0, t) * Math
                    .pow(t, (t - 1) /
                        2) / (1 - e), 1 / t
                );
        else return -N1(1 - e, t);
        return BF(t, e, n, r)
    }

    function ZT(e, t) {
        let n = 4 * t * (1 - t);
        switch (e) {
            case 1:
                return Math.tan(Math
                    .PI * (t -
                        .5));
            case 2:
                return 2 * (t -
                    .5) * Math.sqrt(
                        2 / n);
            case 4:
                let r = Math.cos(
                    Math.acos(
                        Math
                            .sqrt(n)
                    ) / 3) /
                    Math.sqrt(n);
                return eI(t - .5) *
                    2 * Math.sqrt(
                        r - 1);
            default:
                throw new Error(
                    "_invTSimple() must be called with 1, 2, or 4 df."
                )
        }
    }

    function BF(e, t, n, r) {
        if (!isFinite(n) || !
            isFinite(r)) return NaN;
        let i = n,
            s = r;
        for (; ;) {
            let o = Ki(i, s),
                a = Tc(e, o);
            if (o === i || o === s)
                return a > t ? i :
                    s;
            a < t ? i = o : s = o
        }
    }

    function GF(e, t, n) {
        return e < 0 || e > 1 ||
            n <= t ? NaN : e === 0 ?
            t : e === 1 ? n : t +
                e * (n - t)
    }

    function A1(e, t) {
        let n = Sy(e);
        return (Xo(e) - t) * Math
            .sqrt(e.length) / n
    }

    function _1(e, t) {
        let n = e.length,
            r = Xo(e),
            i = Sy(e),
            s = t.length,
            o = Xo(t),
            a = Sy(t),
            u = Math.sqrt(((n - 1) *
                i * i + (s -
                    1) * a * a) / (
                    n + s - 2));
        return (r - o) / (u * Math
            .sqrt(1 / n + 1 / s)
        )
    }

    function Ul(e, t, n) {
        return n < 0 ? My(-1 / 0, e,
            t) : n > 0 ? My(-1 /
                0, -e, t) : 2 * My(-
                    1 / 0, -Math.abs(e),
                    t)
    }

    function uI(e, t) {
        arguments.length === 1 && (
            t = 0);
        let n = A1(e, t),
            r = e.length - 1;
        return {
            lessThan: Ul(n, r, -1),
            greaterThan: Ul(n, r,
                1),
            notEqual: Ul(n, r, 0)
        }
    }

    function cI(e, t) {
        let n = _1(e, t),
            r = e.length + t
                .length - 2;
        return {
            lessThan: Ul(n, r, -1),
            greaterThan: Ul(n, r,
                1),
            notEqual: Ul(n, r, 0)
        }
    }

    function lI(e) {
        return {
            min: L1(e),
            q1: Ic(e, 1),
            median: V1(e),
            q3: Ic(e, 3),
            max: w1(e)
        }
    }

    function kF(e) {
        return e.length
    }

    function L1(e) {
        if (e.length < 1)
            return NaN;
        let t = e[0];
        if (isNaN(t)) return NaN;
        for (let n = 1; n < e
            .length; n++) {
            if (isNaN(e[n]))
                return NaN;
            e[n] < t && (t = e[n])
        }
        return t
    }

    function w1(e) {
        if (e.length < 1)
            return NaN;
        let t = e[0];
        if (isNaN(t)) return NaN;
        for (let n = 1; n < e
            .length; n++) {
            if (isNaN(e[n]))
                return NaN;
            e[n] >= t && (t = e[n])
        }
        return t
    }

    function F1(e, t) {
        if (!isFinite(t) || t < 0 ||
            t > 1) return NaN;
        if (e.some(isNaN))
            return NaN;
        if (e.length === 0)
            return NaN;
        let n = e.length,
            r = Ec(e),
            i = t * (n - 1);
        return Math.floor(i) === i ?
            e[r[i]] : (Math.ceil(
                i) - i) * e[r[Math
                    .floor(i)]] + (i -
                        Math.floor(i)) * e[
            r[Math.ceil(i)]]
    }

    function Ic(e, t) {
        if (!isFinite(t) || t < 0 ||
            t > 4) return NaN;
        if (e.some(isNaN))
            return NaN;
        let n = Ec(e),
            r = Vy(e, t),
            i = Math.floor(r),
            s = Math.ceil(r);
        return (e[n[i]] + e[n[s]]) /
            2
    }

    function Ec(e) {
        let t = e.length,
            n = [];
        for (let r = 0; r < t; r++)
            n.push(r);
        return n.sort(function (r,
            i) {
            return q(ji(e[
                r],
                e[i]
            ))
        }), n
    }

    function Vy(e, t) {
        t = Math.round(t);
        let n = e.length,
            r = n % 2 === 1,
            i;
        return n === 1 ? 0 : (t ===
            0 && (i = 0), t ===
            2 && (i = (n - 1) /
                2), t === 4 && (
                    i = n - 1),
            t === 1 && (i = r ?
                (n + 1) / 4 -
                1 : (n + 2) /
                4 - 1), t ===
                3 && (i = r ? (3 *
                    n + 3) / 4 -
                    1 : (3 * n +
                        2) / 4 - 1),
            i === void 0 ? NaN :
                i)
    }

    function zF(e, t) {
        return Ec(e)[Math.ceil(t * (
            e.length - 1
        ))] + 1
    }

    function HF(e, t) {
        return Ec(e)[Math.floor(t *
            (e.length - 1))] + 1
    }

    function UF(e, t) {
        return Ec(e)[Math.ceil(Vy(e,
            t))] + 1
    }

    function qF(e, t) {
        return Ec(e)[Math.floor(Vy(
            e, t))] + 1
    }

    function V1(e) {
        return F1(e, .5)
    }

    function $F(e) {
        if (e.length < 1) return 0;
        let t = e[0];
        if (isNaN(t)) return 0;
        let n = 0;
        for (let r = 1; r < e
            .length; r++) {
            if (isNaN(e[r]))
                return 0;
            e[r] < t && (n = r, t =
                e[r])
        }
        return n + 1
    }

    function YF(e) {
        if (e.length < 1) return 0;
        let t = e[0];
        if (isNaN(t)) return 0;
        let n = 0;
        for (let r = 1; r < e
            .length; r++)
            if (e[r] >= t) {
                if (isNaN(e[r]))
                    return 0;
                n = r, t = e[r]
            } return n + 1
    }

    function wf(e) {
        let t = Xo(e),
            n = 0;
        for (let r = 0; r < e
            .length; r++) {
            let i = e[r] - t;
            n += i * i
        }
        return n / e.length
    }

    function XF(e) {
        let t = Xo(e),
            n = 0;
        for (let r = 0; r < e
            .length; r++) n += Math
                .abs(e[r] - t);
        return n / e.length
    }

    function B1(e) {
        let t = e.length;
        return wf(e) * t / (t - 1)
    }

    function G1(e, t) {
        let n = Math.min(e.length, t
            .length);
        e.length !== n && (e = e
            .slice(0, n)), t
                .length !== n && (t = t
                    .slice(0, n));
        let r = Xo(e),
            i = Xo(t),
            s = 0;
        for (let o = 0; o < n; o++)
            s += (e[o] - r) * (t[
                o] - i);
        return s / n
    }

    function ZF(e, t) {
        let n = Math.min(e.length, t
            .length);
        return G1(e, t) * n / (n -
            1)
    }

    function By(e, t) {
        let n = Math.min(e.length, t
            .length);
        e.length !== n && (e = e
            .slice(0, n)), t
                .length !== n && (t = t
                    .slice(0, n));
        let r = Xo(e),
            i = Xo(t),
            s = 0,
            o = 0,
            a = 0;
        for (let u = 0; u <
            n; u++) {
            let c = e[u] - r,
                l = t[u] - i;
            s += c * c, o += l * l,
                a += c * l
        }
        return a / Math.sqrt(s * o)
    }

    function pI(e, t, n, r) {
        let i = e[0];
        for (let o = 2; o < e
            .length; o++) {
            let a = q(Ji(ji(e[o],
                i), n));
            if (!Li(a, o, 10))
                return 0
        }
        let s = q(r);
        for (let o = 0; o < t
            .length - 1; o++) {
            let a = q(Ji(ji(t[o],
                i), n));
            if (!Li(a, s - t
                .length + o, 10
            )) return 0
        }
        return !isFinite(s) || s < e
            .length || s < t
                .length ? 0 : s
    }

    function fI(e) {
        return e < 0 || !isFinite(
            e) ? 0 : e
    }

    function JT(e) {
        let t = e.length;
        if (t === 0) return [];
        let n = [],
            r = [];
        for (let a = 0; a < t; a++)
            r.push([e[a], a]);
        r.sort(function (a, u) {
            let c = a[0],
                l = u[0];
            return c === 1 /
                0 && l ===
                1 / 0 ||
                c === -1 /
                0 && l === -
                1 / 0 ? 0 :
                c - l
        });
        let i = 0,
            s = 1,
            o = 1;
        for (; i < t;) {
            let a = i;
            for (; a < t - 1 && r[a]
            [0] === r[a + 1][0];
            ) a += 1;
            o = a - i + 1;
            let u;
            for (a = 0; a < o; a++)
                u = r[i + a][1], n[
                    u] = isNaN(e[
                        u]) ? NaN : s + .5 *
                        (o - 1);
            s += o, i += o
        }
        return n
    }

    function WF(e, t) {
        let n = Math.min(e.length, t
            .length);
        return e.length !== n && (
            e = e.slice(0, n)),
            t.length !== n && (t = t
                .slice(0, n)), By(
                    JT(e), JT(t))
    }

    function Sy(e) {
        return Math.sqrt(B1(e))
    }

    function jF(e) {
        return Math.sqrt(wf(e))
    }
    var JF = Sf;

    function Xl(e, t) {
        return po(t[0] - e[0], t[
            1] - e[1])
    }

    function QF(e, t) {
        return po(t[0] - e[0], po(t[
            1] - e[1],
            t[2] - e[2]))
    }

    function k1(e, t, n) {
        return [rr(Math.round(e), 0,
            255), rr(Math
                .round(t), 0,
                255), rr(Math
                    .round(n), 0,
                    255)]
    }

    function KF(e, t, n) {
        isFinite(e) || (e = 0), t =
            rr(t, 0, 1), n = rr(n,
                0, 1);
        let r = n * (1 - t / 2);
        r === 0 || r === 1 ? t = 0 :
            t = (n - r) / Math.min(
                r, 1 - r);
        let {
            r: i,
            g: s,
            b: o
        } = dy(e, t, r).rgb();
        return k1(i, s, o)
    }

    function eV(e) {
        return e
    }

    function tV(e, t) {
        return [e, t]
    }

    function nV(e, t, n) {
        return [e, t, n]
    }

    function rV(e, t) {
        return [e, t]
    }

    function iV(e) {
        return e
    }

    function sV(e) {
        let t = [];
        if (e.length === 0)
            return [];
        for (let n = 0; n < e
            .length - 1; n++) t
                .push([e[n], e[n + 1]]);
        return t.push([e[e.length -
            1], e[0]]), t
    }

    function dI(e) {
        if (e.length == 0) return 0;
        let t = [...e, e[0]];
        return JD(t)
    }

    function oV(e) {
        let t = 0;
        for (let n = 0; n < e
            .length - 1; n++) {
            let [r, i] = e[n], [s,
                o] = e[n + 1];
            t += as(s - r, o - i)
        }
        if (e.length > 1) {
            let [n, r] = e[e
                .length - 1], [
                    i, s
                ] = e[0];
            t += as(i - n, s - r)
        }
        return t
    }

    function aV(e) {
        let t = !1;
        for (let n = 0; n < e
            .length; n++) {
            let r = (n + 1) % e
                .length;
            e[n][0] === e[r][0] &&
                e[n][1] === e[r][
                1] && (t = !0)
        }
        return t ? e.filter((n,
            r) => {
            let i = e[r ===
                0 ? e
                    .length -
            1 : r -
            1];
            return n[0] !==
                i[0] || n[
                1] !== i[1]
        }) : e
    }

    function uV(e) {
        let [t, n, r, i] = e;
        return [t, r >= 0 ? n : n +
            r, r >= 0 ? r : -r,
            i
        ]
    }

    function z1(e, t, n) {
        if (e.length === 0)
            return [];
        e = aV(e);
        let r = QD([...e, e[0]]),
            i = [];
        for (let s = 0; s < e
            .length; s++) {
            let o = e[s > 0 ? s -
                1 : e.length - 1
            ],
                a = e[s],
                u = e[s < e.length -
                    1 ? s + 1 : 0],
                c = r[s] === 1,
                l = OV(o, a, u, c ?
                    "counterclockwise" :
                    "clockwise", n);
            i.push(t ? l : uV(l))
        }
        return i
    }

    function cV(e, t) {
        return z1(e, !1, t)
    }

    function lV(e, t) {
        return z1(e, !0, t)
    }

    function mI(e, t) {
        return [e, t]
    }
    var pV = mI,
        fV = mI;

    function H1(e, t) {
        let n = [t[0] - e[0], t[1] -
            e[1]
        ],
            r = [e[0], e[1]];
        return U1(n, r)
    }

    function U1(e, t) {
        return [e, t]
    }

    function dV(e) {
        return e[0]
    }

    function mV(e) {
        return e[1]
    }

    function yV(e, t) {
        let n = [t[0] - e[0], t[1] -
            e[1], t[2] - e[2]
        ],
            r = [e[0], e[1], e[2]];
        return q1(n, r)
    }

    function q1(e, t) {
        return [e, t]
    }

    function gV(e) {
        return e[0]
    }

    function hV(e) {
        return e[1]
    }

    function bV(e) {
        return e
    }

    function xV(e, t) {
        return [e, t]
    }

    function PV(e) {
        return e[0]
    }

    function TV(e) {
        return e[1]
    }

    function IV(e, t, n) {
        return [e, t, n]
    }

    function jl([e, t, n]) {
        let [r, i] = e, [s, o] = t,
            [a, u] = n, c = s * s + o *
                o, l = (r * r + i * i -
                    c) / 2, p = (c - a *
                        a - u * u) / 2, f =
                (r - s) * (o - u) - (s -
                    a) * (i - o);
        f = 1 / f;
        let m = (l * (o - u) - p * (
            i - o)) * f,
            g = ((r - s) * p - (s -
                a) * l) * f;
        return [m, g]
    }

    function Jl(e) {
        let [
            [t, n],
            [r, i],
            [s, o]
        ] = e, a = r - t, u = i - n,
            c = s - r, l = o - i;
        return 2 * Math.atan2(a *
            l - c * u, a * c +
        u * l)
    }

    function yI(e) {
        let t = Math.abs(Jl(e));
        return t < 1e-9 || t > 2 *
            Math.PI - 1e-9
    }

    function $1(e) {
        return Math.abs(e) === Math
            .PI ? Math.PI : x1(e +
                Math.PI, 2 * Math.PI
            ) - Math.PI
    }

    function Y1(e, t, n, r) {
        return [e, $1(t), n, r]
    }

    function EV([e, t, n, r]) {
        return [e, t, n, r]
    }

    function MV(e) {
        return e[2]
    }

    function vV(e) {
        return e[3]
    }

    function X1(e) {
        let [t, n, r, i] = e, s =
            Math.PI * 2, o = r ===
                0 ? s : r > 0 ? r - s :
                r + s;
        return [t, n, o, i]
    }

    function DV(e) {
        let [t, n, r, i] = X1(e);
        return [t, n, r, i]
    }

    function SV(e) {
        let [t, n, r, i] = e, s =
            r >= 0 ? Math.PI - r : -
                Math.PI - r;
        return [t, $1(n + r), s, i]
    }

    function OV(e, t, n, r, i) {
        let s = e[0] - t[0],
            o = e[1] - t[1],
            a = n[0] - t[0],
            u = n[1] - t[1],
            c = Math.atan2(o, s),
            l = Math.atan2(s * u -
                o * a, s * a + o * u
            ),
            p = 2 * Math.PI;
        return r === "clockwise" ?
            l -= l < 0 ? 0 : p :
            r ===
            "counterclockwise" && (
                l += l < 0 ? p : 0),
            Y1(t, c, l, i)
    }

    function gI(e, t) {
        let [
            [n, r],
            [i, s]
        ] = e;
        return [
            [t * n, t * r],
            [t * i, t * s]
        ]
    }
    var CV = gI,
        RV = gI;

    function NV(e, t) {
        let [
            [n, r], i
        ] = e;
        return [
            [t * n, t * r], t *
            i
        ]
    }

    function AV(e, t) {
        let [
            [n, r],
            [i, s],
            [o, a]
        ] = e;
        return [
            [t * n, t * r],
            [t * i, t * s],
            [t * o, t * a]
        ]
    }

    function _V(e, t) {
        let [
            [n, r], i, s, o
        ] = e;
        return [
            [t * n, t * r], t *
            i, t * s, o
        ]
    }

    function hI(e, t) {
        let [
            [n, r],
            [i, s]
        ] = e, [
            [o, a],
            [u, c]
        ] = t;
        return [
            [n + o, r + a],
            [i + u, s + c]
        ]
    }

    function LV(e, t) {
        let [
            [n, r, i],
            [s, o, a]
        ] = e, [
            [u, c, l],
            [p, f, m]
        ] = t;
        return [
            [n + u, r + c, i +
                l],
            [s + p, o + f, a +
                m]
        ]
    }
    var wV = hI,
        FV = hI;

    function VV(e, t) {
        let [
            [n, r], i
        ] = e, [
            [s, o], a
        ] = t;
        return [
            [n + s, r + o], i +
            a
        ]
    }

    function BV(e, t) {
        let [
            [n, r],
            [i, s],
            [o, a]
        ] = e, [
            [u, c],
            [l, p],
            [f, m]
        ] = t;
        return [
            [n + u, r + c],
            [i + l, s + p],
            [o + f, a + m]
        ]
    }

    function GV(e, t) {
        let [
            [n, r], i, s, o
        ] = e, [
            [a, u], c, l
        ] = t;
        return [
            [n + a, r + u], i +
            c, s + l, o
        ]
    }

    function bI(e, t) {
        let [
            [n, r],
            [i, s]
        ] = e;
        return [(1 - t) * n + t * i,
        (1 - t) * r + t * s
        ]
    }

    function xI(e, t) {
        return bI(e, rr(t, 0, 1))
    }

    function kV(e, t) {
        t = rr(t, 0, 1);
        let [
            [n, r, i],
            [s, o, a]
        ] = e;
        return [(1 - t) * n + t * s,
        (1 - t) * r + t * o,
        (1 - t) * i + t * a
        ]
    }

    function QT(e, t) {
        return bI(e, rr(t, 0, 1 /
            0))
    }

    function zV(e, t) {
        let [
            [n, r], i
        ] = e, s = Math.min(1, Math
            .max(0, t));
        return [n + i * Math.cos(2 *
            Math.PI * s),
        r + i * Math.sin(2 *
            Math.PI * s)
        ]
    }

    function Z1(e, t) {
        let n = Gy(e);
        if (!n) return [NaN, NaN];
        if (n.type === "segment")
            return xI([e[0], e[2]],
                t);
        if (n.type === "rays")
            return t <= 0 ? QT([n
                .start1, n
                .end1
            ], -t) : t >= 1 ?
                QT([n.start2, n
                    .end2], t -
                1) : [NaN, NaN];
        t = Math.min(1, Math.max(0,
            t));
        let r = jl(e),
            i = Jl(e),
            s = Math.atan2(e[0][1] -
                r[1], e[0][0] - r[0]
            ),
            o = Xl(r, e[0]),
            a = s + t * i;
        return [r[0] + o * Math.cos(
            a), r[1] + o *
            Math.sin(a)
        ]
    }

    function HV(e, t) {
        if (isNaN(t)) return [NaN,
            NaN
        ];
        if (t < 0 || t >= e.length)
            return e[0];
        let n = Math.floor(t);
        return xI([e[n], e[(n + 1) %
            e.length]], t -
        n)
    }

    function Gy(e) {
        let [t, n, r] = e, [
            [i, s],
            [o, a],
            [u, c]
        ] = [t, n, r];
        if (isNaN(i) || isNaN(s) ||
            isNaN(o) || isNaN(a) ||
            isNaN(u) || isNaN(c))
            return;
        let l = jl([t, n, r]),
            p = Xl(l, t);
        if (isFinite(p) && !yI([t,
            n, r
        ])) {
            let f = Math.atan2(t[
                1] - l[1], t[
                0] - l[0]),
                m = f + Jl([t, n,
                    r]);
            return {
                type: "arc",
                center: l,
                radius: p,
                startAngle: f,
                endAngle: m
            }
        } else {
            let f = Rs(o, a, 0, i,
                s, 0, u, c, 0);
            return f < 0 || f > 1 ?
                {
                    type: "rays",
                    start1: [i, s],
                    end1: [i + (i -
                        u),
                    s + (s -
                        c)
                    ],
                    start2: [u, c],
                    end2: [u + (u -
                        i),
                    c + (c -
                        s)
                    ]
                } : {
                    type: "segment",
                    start: [i, s],
                    end: [u, c]
                }
        }
    }

    function UV(e, t, n) {
        let i = Xl(e, t);
        if (i > 1e-9) return t;
        let s = Xl(e, n);
        return s > 1e-9 ? n : isNaN(
            i) && isNaN(s) ? [
            NaN, NaN
        ] : e
    }

    function Af(e, t) {
        let [
            [n, r], i
        ] = e, [
            [s, o], a
        ] = t, u = po(s - n, o - r),
            c = i + a, l = i - a,
            p = u * u, f = Math
                .sqrt((u + c) * (-u +
                    c) * (u - l) * (u +
                        l)) / 4, m = i *
                            i, g = a * a;
        return [(s + n) / 2 + (s -
            n) * (m - g) / (
                2 * p) + -2 * (
                    o - r) * f / p,
        (o + r) / 2 + (o -
            r) * (m - g) / (
            2 * p) + 2 * (
                s - n) * f / p
        ]
    }

    function W1(e, t, n) {
        let [
            [r, i], s
        ] = e, [
            [o, a],
            [u, c]
        ] = t, l = o - r, p = u - r,
            f = a - i, m = c - i,
            g = p - l, d = m - f,
            y = g * g + d * d, h =
                l * m - p * f, b = s *
                    s * y - h * h;
        if (b < 0) return [NaN,
            NaN];
        let x = Math.sqrt(b);
        return x < 0 ? [NaN, NaN] :
            [r + (h * d + n * g *
                x) / y, i + (-h *
                    g + n * d * x) /
                y
            ]
    }

    function qV(e, t) {
        let [
            [n, r],
            [i, s]
        ] = e, [
            [o, a],
            [u, c]
        ] = t, l = s - r, p = n - i,
            f = c - a, m = o - u,
            g = l * n + p * r, d =
                f * o + m * a, y = l *
                    m - f * p;
        return y === 0 ? [NaN,
            NaN] : [(m * g - p *
                d) / y, (l * d - f *
                    g) / y
        ]
    }

    function PI(e, t, n = 0) {
        let r = W1(t, e, -1);
        return Wl(r, e, n, !0) ? r :
            [NaN, NaN]
    }

    function TI(e, t, n = 0) {
        let r = W1(e, t, 1);
        return Wl(r, t, n, !1) ? r :
            [NaN, NaN]
    }

    function j1(e, t, n = 0) {
        let r = qV(e, t);
        return !Wl(r, e, n, !0) || !
            Wl(r, t, n, !1) ? [NaN,
            NaN
        ] : r
    }

    function $V(e, t, n = 0) {
        let r = K1(t, e, n, -1);
        return Zl(r, t, n, !1) ? r :
            [NaN, NaN]
    }

    function J1(e, t, n = 0) {
        let r = eS(t, e, n, -1);
        return !Wl(r, e, n, !0) || !
            Zl(r, t, n, !1) ? [NaN,
            NaN
        ] : r
    }

    function YV(e, t, n = 0) {
        let r = K1(e, t, n, 1);
        return Zl(r, e, n, !0) ? r :
            [NaN, NaN]
    }

    function Q1(e, t, n = 0) {
        let r = eS(e, t, n, 1);
        return !Zl(r, e, n, !0) || !
            Wl(r, t, n, !1) ? [NaN,
            NaN
        ] : r
    }

    function XV(e, t, n = 0) {
        let r = ZV(e, t, n);
        return !Zl(r, e, n, !0) || !
            Zl(r, t, n, !1) ? [NaN,
            NaN
        ] : r
    }

    function ZV(e, t, n) {
        let r = Cy(e);
        if (Ry(r)) return J1(r, t,
            n);
        let i = Cy(t);
        return Ry(i) ? Q1(e, i, n) :
            II(() => Af(r, i), () =>
                Af(i, r), s => EI(-
                    1, Oy(e, s), Oy(
                        t, s)))
    }

    function K1(e, t, n, r) {
        let i = Cy(e);
        return Ry(i) ? r > 0 ? TI(t,
            i, n) : PI(i, t,
                n) : II(() => Af(i, t),
                    () => Af(t, i), s =>
                    EI(r, Oy(e, s), WV(
                        t, s)))
    }

    function eS(e, t, n, r) {
        let i = Cy(e);
        return Ry(i) ? j1(i, t, n) :
            II(() => TI(i, t, n),
                () => PI(t, i, n), s =>
                EI(r, Oy(e, s), jV(
                    t)))
    }

    function II(e, t, n) {
        let r = e();
        if (n(r)) return r;
        let i = t();
        return n(i) ? i : [NaN, NaN]
    }

    function EI(e, t, n) {
        return e * tS(t, n) > 0
    }

    function Oy(e, [t, n]) {
        let [r, i] = jl(e);
        return Jl(e) > 0 ? [i - n,
        t - r
        ] : [n - i, r - t]
    }

    function WV([
        [e, t]
    ], [n, r]) {
        return [t - r, n - e]
    }

    function jV([
        [e, t],
        [n, r]
    ]) {
        return [n - e, r - t]
    }

    function Cy(e) {
        let t = jl(e),
            n = Xl(t, Z1(e, 0));
        return isFinite(n) && !yI(
            e) ? [t, n] : [e[0], e[
                2]]
    }

    function Ry(e) {
        return Array.isArray(e[1])
    }

    function Zl([e, t], n, r, i) {
        let [s, o] = jl(n);
        return (i ? (r & 3) === 0 :
            (r & 12) === 0) ||
            Ld(Math.atan2(t - o, e -
                s), Math.atan2(
                    n[0][1] - o, n[
                    0][0] - s),
                Jl(n))
    }

    function Wl([e, t], [
        [n, r],
        [i, s]
    ], o, a) {
        let u = Rs(e, t, 0, n, r, 0,
            i, s, 0),
            [c, l] = a ? [(o &
                1) === 0, (o &
                    2) === 0
            ] : [(o & 4) === 0, (o &
                8) === 0];
        return !isNaN(u) && (u >=
            0 || c) && (u <=
                1 || l)
    }

    function JV(e, t) {
        let [
            [n, r],
            [i, s]
        ] = e, [o, a] = t;
        return [
            [o, a],
            [o + (i - n), a + (
                s - r)]
        ]
    }

    function QV(e, t) {
        let [
            [n, r],
            [i, s]
        ] = e, [o, a] = t;
        return [
            [o, a],
            [o + (s - r), a - (
                i - n)]
        ]
    }

    function tS(e, t) {
        let [n, r] = e, [i, s] = t;
        return n * s - i * r
    }

    function KV(e, t) {
        let [n, r] = e, [i, s] = t;
        return n * i + r * s
    }

    function eB(e) {
        let [t, n] = e;
        return [-n, t]
    }

    function tB(e, t, n) {
        return [e, t, n]
    }

    function nB(e) {
        return [
            [1, 0], e, !1
        ]
    }

    function rB(e, t) {
        let [n, r] = e;
        return [
            [t, 0],
            [(1 - t) * n, (1 -
                t) * r], !1
        ]
    }

    function iB(e, t) {
        let [n, r] = e, i = Math
            .cos(t), s = Math.sin(
                t);
        return [
            [i, s],
            [n * (1 - i) + r *
                s, r * (1 - i) -
            n * s
            ], !1
        ]
    }

    function sB(e) {
        let [
            [t, n],
            [r, i]
        ] = e, s = r - t, o = i - n,
            a = s * s + o * o;
        return [
            [(s * s - o * o) /
                a, 2 * s * o / a
            ],
            [(1 - (s * s - o *
                o) / a) *
                t - 2 * s * o /
                a * n, (1 + (s *
                    s - o *
                    o) / a) *
                n - 2 * s * o /
                a * t
            ], !0
        ]
    }

    function oB(e, t) {
        let [
            [n, r],
            [i, s], o
        ] = e, [
            [a, u],
            [c, l], p
        ] = t;
        return o && (u = -u, l = -l,
            p = !p), [
                [a * n - u * r, a *
                    r + u * n
                ],
                [i + n * c - r * l,
                s + n * l + r *
                c
                ], p
            ]
    }

    function aB(e) {
        let [
            [t, n],
            [r, i], s
        ] = e, o = t * t + n * n,
            a = t / o, u = -n / o,
            c = -(t / o * r + n /
                o * i), l = -(t /
                    o * i - n / o * r);
        return s && (u = -u, l = -
            l), [
                [a, u],
                [c, l], s
            ]
    }

    function Yo(e, t) {
        let [
            [n, r],
            [i, s], o
        ] = e, [a, u] = t;
        return o && (u = -u), [n *
            a - r * u + i, n *
            u + r * a + s
        ]
    }

    function uB(e, t) {
        let [n, r, i] = e;
        return i ? -t : t
    }

    function ky(e, t) {
        let [n, r] = t;
        return [Yo(e, n), Yo(e, r)]
    }
    var cB = ky,
        lB = ky;

    function pB(e, t) {
        let [n, r] = t, i = [r, [r[
            0] + n[0],
        r[1] + n[1]
        ]], s = ky(e, i);
        return H1(s[0], s[1])
    }

    function fB(e, t) {
        let [n, r] = t, [
            [i, s]
        ] = e;
        return [Yo(e, n), po(i, s) *
            r
        ]
    }

    function dB(e, t) {
        let [n, r, i] = t;
        return [Yo(e, n), Yo(e, r),
        Yo(e, i)
        ]
    }

    function mB(e, t) {
        let n = [];
        for (let r of t) n.push(Yo(
            e, r));
        return n
    }

    function yB(e, t) {
        let [n, r, i] = t, s = Yo(e,
            n), [o, a, u] = e, [
                c, l
            ] = Yo([o, [0, 0], u], [
                Math.cos(r),
                Math.sin(r)
            ]), p = Math.atan2(l,
                c), f = uB(e, i);
        return [s, p, f, t[3]]
    }

    function gB(e, t) {
        let n = [];
        for (let r = 0; r < Math
            .min(e.length, t
                .length); r++) t[r] && n
                    .push(e[r]);
        return n
    }

    function hB(e, t) {
        let n = [];
        for (let r of t) n.push(e[
            r]);
        return n
    }

    function bB(e) {
        let t = [],
            n = {};
        for (let r = 0; r < e
            .length; r++) {
            let i = e[r],
                s = KT(i);
            n.hasOwnProperty(s) || (
                n[s] = !0, t
                    .push(r))
        }
        return t
    }

    function xB(e, t) {
        return [e, t]
    }

    function PB(e) {
        return e[0]
    }

    function TB(e) {
        return e[1]
    }

    function KT(e) {
        if (Array.isArray(e))
            return `[${e.map(KT).join(",")}]`;
        switch (typeof e) {
            case "string":
                return e;
            case "boolean":
            case "number":
                return e.toString();
            case "object":
                if (IB(e)) {
                    let n = [];
                    for (let r in e
                        .updateRules)
                        n.push(
                            `"${r}": ${KT(e.updateRules[r].value)}`
                        );
                    return `{${n.join(",")}}`
                } else return q(e)
                    .toString();
            default:
                return e
        }
    }

    function IB(e) {
        return typeof e !=
            "object" || !e ? !1 : e
                .type === "Action"
    }

    function EB(e) {
        return e
    }

    function MB(e) {
        return e
    }

    function Xr(e) {
        if (!mo(e)) throw new Error(
            "Programming error: expected an array but found " +
            typeof e)
    }

    function mo(e) {
        return Array.isArray(e)
    }

    function nS(e) {
        if (mo(e))
            for (let {
                compiled: t
            }
                of e) t && MI(t)
    }

    function Y4(e) {
        if (mo(e))
            for (let {
                compiled: t
            }
                of e) t && vB(t)
    }

    function MI(e) {
        delete e.fn
    }

    function vB(e) {
        e.fn = Ff(e.args, e.source,
            e.constants, e
            .executionMetadata)
    }

    function Ff(e, t, n, r) {
        let s = `var fn = (function(${e.join(",")}){"use strict"; ${t}});
fn.__meta = __meta;
return fn;
`;
        return new Function(
            "BuiltIn",
            "ErrorMsg", "_C",
            "__meta", s)(fo, nn,
                n, r)
    }

    function rS(e) {
        let t = e.getInstruction(e
            .getReturnIndex());
        if (t.type !== 47)
            throw new Error(
                `Expected BlockVar, got ${t.type}`
            );
        let n = e.getInstruction(t
            .args[0]);
        if (n.type !== 51)
            throw new Error(
                `Expected EndMap, got ${n.type}`
            );
        let r = W(t.valueType) ? ke(
            t.valueType) : t
            .valueType,
            i = e.getInstruction(n
                .args[0]);
        if (i.type !== 50)
            throw new Error(
                `Expected BeginMap, got ${i.type}`
            );
        let s = [];
        for (let p of i.args) {
            let f = e
                .getInstruction(p);
            if (!bt(f) || f
                .valueType !== T)
                throw J(
                    "Programming error: interval bounds must be constant numbers");
            s.push(q(f.value))
        }
        let o, a;
        r === Wn || r === jn ? (
            o = ["t"], a = {
                type: "1d",
                min: s[0],
                max: s[1]
            }) : (o = ["u",
                "v"], a = {
                    type: "2d",
                    uMin: s[0],
                    uMax: s[1],
                    vMin: s[2],
                    vMax: s[3]
                });
        let u = cy(e),
            c = `
  const mapFn = (function() {
    "use strict";
    ${u.source}
  })();
  return mapFn(${o.join(",")});
`,
            l = {};
        return {
            args: o,
            source: c,
            constants: u.constants,
            executionMetadata: l,
            fn: Ff(o, c, u
                .constants, l),
            domain: a
        }
    }

    function oi(e, t) {
        let n = [],
            r = [];
        for (let i = 0; i < t; i++)
            r.push(!1);
        r.push(!0);
        for (let i = t; i >=
            0; i--) {
            if (!r[i]) continue;
            let s = e
                .getInstruction(i);
            if (s.type === 2) n
                .push({
                    symbol: e
                        .argNames[
                        i],
                    scope: "free"
                });
            else if (ri(s)) switch (
                s.type) {
                    case 21:
                        n.push({
                            symbol: s
                                .callData
                                .indexSymbol,
                            scope: "integral"
                        });
                        break;
                    case 19:
                        n.push({
                            symbol: s
                                .callData
                                .indexSymbol,
                            scope: s
                                .callData
                                .type
                        });
                        break;
                    case 23:
                        if (s
                            .listComprehensionCallData
                        )
                            for (let a of
                                s
                                    .listComprehensionCallData
                                    .inputListSymbols)
                                n
                                    .push({
                                        symbol: a,
                                        scope: "comprehension"
                                    });
                        break;
                    case 50:
                        for (let a of
                            s
                                .callData
                                .parameterSymbols)
                            n.push({
                                symbol: a,
                                scope: "map"
                            });
                        break;
                    case 53: {
                        let a = e
                            .getInstruction(
                                s
                                    .args[
                                0
                                ]
                            );
                        for (let u of
                            a
                                .parameterSymbols)
                            n.push({
                                symbol: u,
                                scope: "recursive-function"
                            });
                        break
                    }
                    default:
                        let o = s;
                        throw new Error(
                            `Programming Error: unexpected loop instruction ${o.type}`
                        )
                } else s.type ===
                    3 && s.symbol &&
                    n.push({
                        symbol: s
                            .symbol,
                        scope: "symbolic-var"
                    });
            if (!be(s))
                for (let o of e
                    .getDirectDependencies(
                        s)) r[
                            o] = !0
        }
        return n.reverse()
    }

    function iS(e) {
        if (e.isConstant()) return;
        let t = [];
        for (let s = 0; s < e
            .getReturnIndex(); s++)
            e.getInstruction(s)
                .type === 44 && t.push(
                    s);
        if (t.length === 0) return;
        let n = Yr(e, e
            .getReturnIndex()),
            r = [];
        for (let s = 0; s < e
            .argNames.length; s++)
            n[s] && r.push(s);
        let i = mc(e, r, 0, e
            .getReturnIndex());
        for (let s of t)
            if (n[s] && i[s])
                throw jP(oi(e, s))
    }

    function DB(e) {
        for (var t = 0; t < this
            .length; t++) e(this
                .elementAt(t), t)
    }

    function SB(e) {
        for (var t = [], n = 0; n <
            this.length; n++) t
                .push(e(this.elementAt(
                    n), n));
        return t
    }
    var pn = class e extends Tt {
        constructor(n) {
            super();
            this.isError = !
                1;
            this.eachElement =
                DB;
            this.mapElements =
                SB;
            if (n
                .getError())
                throw new Error(
                    "Programming error: IRExpression should not be constructed with an error chunk"
                );
            if (this
                ._chunk = n,
                this
                    .valueType =
                n
                    .getReturnType(),
                this
                    .addDependencies(
                        n
                            .getLiveArgNames()
                    ), this
                        .isList = W(
                            this
                                .valueType
                        ), this
                            .isList && (
                    this
                        .length =
                    this
                        ._chunk
                        .getConstantListLength(),
                    this
                        .length ===
                    void 0))
                throw rT(n
                    .getListLengthDependencies()
                );
            iS(n);
            var r = n
                .isConstant();
            this.isConstant =
                r && (this
                    .valueType ===
                    T ||
                    this
                        .valueType ===
                    ge),
                this
                    .isTypedConstant =
                r, this
                    .isEmptyAction =
                r && this
                    .valueType ===
                rt && Object
                    .keys(n
                        .asValue()
                        .updateRules
                    )
                    .length ===
                0
        }
        shouldExportAns() {
            return !0
        }
        getCompiledFunction(n) {
            return ca(this
                .valueType
            ) ? rS(
                this
                    ._chunk
            ) : this
                ._chunk
                .getCompiledFunction(
                    n)
        }
        getRestrictedFunctionForGLSL
            (n, r) {
            return this
                ._chunk
                .getRestrictedFunctionForGLSL(
                    n, r)
        }
        polynomialOrder(n) {
            return this
                ._chunk
                .polynomialOrder(
                    n, {
                    allowRestriction:
                        !
                        0,
                    allowClosedBlockReferences:
                        !
                        1
                })
        }
        getPolynomialCoefficients
            (n) {
            for (var r =
                this
                    ._chunk
                    .getPolynomialCoefficients(
                        n),
                i = r
                    .chunk,
                s = r
                    .coefficients,
                o = [],
                a =
                    0; a < s
                        .length; a++
            ) {
                var u = i
                    .copy();
                u.setReturnIndex(
                    s[a]
                ), u
                    .fuseBroadcast(),
                    o.push(
                        new e(
                            u
                        )
                    )
            }
            return o
        }
        takeDerivative(n) {
            var r = this
                ._chunk
                .copy()
                .takeDerivative(
                    n)
                .fuseBroadcast();
            return new e(r)
        }
        gradient(n) {
            var r = this
                ._chunk
                .copy()
                .gradient(n)
                .fuseBroadcast();
            return new e(r)
        }
        toImplicitBool() {
            let n = this
                ._chunk
                .copy();
            return n
                .GreaterEqual(
                    [n.getReturnIndex(),
                    n
                        .Constant(
                            0
                        )
                    ]), n
                        .fuseBroadcast(),
                new e(n)
        }
        interpretWithParameters(
            n) {
            let r, i = this
                ._chunk
                .argNames;
            if (n.length ===
                i.length)
                r = n;
            else {
                r = [];
                let s = this
                    .getDependencies();
                for (let o =
                    0,
                    a =
                        0; o <
                    i
                        .length; o++
                ) s[
                    a] ===
                    i[o] ? (
                    r
                        .push(
                            n[
                            a]
                        ),
                    a +=
                    1) :
                    r.push(
                        void 0
                    )
            }
            return this
                ._chunk
                .interpretWithParameters(
                    r)
        }
        substituteConstantArguments
            (n) {
            return new e(
                this
                    ._chunk
                    .substituteConstantArguments(
                        n))
        }
        boundDomain(n) {
            return this
                ._chunk
                .boundDomain(
                    n)
        }
        asValue() {
            if (this._chunk
                .isConstant()
            ) return this
                ._chunk
                .asValue();
            if (this
                .isList) {
                for (var n = [],
                    r =
                        ao($r(ke(this
                            .valueType
                        ))),
                    i =
                        0; i <
                    this
                        .length; i++
                ) n
                    .push(
                        r);
                return n
            } else return ao(
                $r(this
                    .valueType
                )
            )
        }
        asTypedValue() {
            return {
                valueType: this
                    .valueType,
                value: this
                    .asValue()
            }
        }
        asCompilerValue() {
            return this
                ._chunk
                .asCompilerValue()
        }
        isNaN() {
            return typeof this
                .asValue() ==
                "number" &&
                isNaN(this
                    .asValue()
                )
        }
        getEvaluationInfo() {
            return this
                ._chunk
                .isConstant() &&
                this
                    .getDependencies()
                    .length ===
                0 && (oe(
                    this
                        .valueType,
                    T
                ) ||
                    oe(this
                        .valueType,
                        ge)
                ) ? [{
                    val: this
                        .asValue()
                }] : !1
        }
        findLinearSubset(n) {
            return this
                ._chunk
                .findLinearSubset(
                    n)
        }
        deriveRegressionRestrictions
            () {
            var n = this
                ._chunk
                .deriveRegressionRestrictions();
            return n ===
                this
                    ._chunk ?
                this :
                new e(n)
        }
        getCursorContext() {
            return this
                ._chunk
                .getCursorContext()
        }
        getRecursiveFunctionMetadata
            () {
            let n = this
                ._chunk
                .getInstruction(
                    this
                        ._chunk
                        .getReturnIndex()
                );
            if (n.type ===
                55) return this
                    ._chunk
                    .getRecursiveFunctionMetadata(
                        n
                            .args[
                        0
                        ]
                    )
        }
    };
    var Ql = class extends j { };
    var Kl = class extends j { };
    var uu = class extends j { };
    var ep = class extends j { };
    var tp = class extends j { };
    var cu = class extends j { };
    var np = class extends j { };
    var rp = class extends j { };
    var ip = class extends j { };
    var zy = class extends cu { };
    var wi = class e extends Tt {
        constructor(n, r, i, s,
            o) {
            super();
            this.specifiedArg =
                i;
            this.rhs = s;
            this.originalNode =
                o;
            if (this
                ._symbol =
                n, this
                    ._argSymbols =
                r.map(
                    function (
                        a) {
                        return a
                            ._symbol
                    }), this
                        ._expression =
                s, this
                    .userData =
                o.userData,
                this
                    .metaData =
                o.metaData,
                this
                    ._inputSpan =
                o
                    ._inputSpan,
                this
                    .mergeDependenciesInScope(
                        "FunctionDefinition",
                        this
                            ._argSymbols,
                        this
                            ._expression, {
                        functionDefinitionSymbol: this
                            ._symbol
                    }), i
                    .valid) {
                let a = i
                    .functionDefArgSymbols
                    .slice();
                a[i.argIndex] =
                    i
                        .argValue
                        .toString(),
                    this
                        .ref =
                    `_base_case:${n}:${a.join(",")}`,
                    this
                        ._exports = [
                        this
                            .ref
                    ]
            } else {
                let a = this
                    ._exports
                    .find(
                        u =>
                            u
                                .indexOf(
                                    "idref"
                                ) !==
                            -1);
                a && (this
                    .ref =
                    a)
            }
        }
        static fromCallAssignment
            (n, r) {
            let i = r._lhs;
            if (!(
                i instanceof cn))
                return;
            let s = n[i
                ._symbol
            ];
            if (!s || !(
                s instanceof cr
            ))
                return;
            if (i.args
                .length !==
                s
                    ._argSymbols
                    .length)
                return new e(
                    s
                        ._symbol,
                    [], {
                    valid:
                        !
                        1,
                    error: yb(
                        s
                            ._symbol,
                        s
                            ._argSymbols
                            .length
                    )
                }, r
                    ._rhs,
                    r);
            let o, a = [];
            for (let u =
                0; u < i
                    .args
                    .length; u++
            ) {
                let c = i
                    .args[
                    u];
                if (
                    c instanceof Zt) {
                    if (o) {
                        o = {
                            valid:
                                !
                                1,
                            error: Hp()
                        };
                        break
                    }
                    o = {
                        valid:
                            !
                            0,
                        argIndex: u,
                        functionDefArgSymbols: s
                            ._argSymbols,
                        argValue: c
                            .asValue(),
                        argSymbol: s
                            ._argSymbols[
                            u
                        ]
                    }
                } else if (
                    c instanceof ze
                )
                    if (c
                        ._symbol !==
                        s
                            ._argSymbols[
                        u
                        ]
                    ) {
                        o = {
                            valid:
                                !
                                1,
                            error: sm()
                        };
                        break
                    } else a
                        .push(
                            c
                        );
                else {
                    o = {
                        valid:
                            !
                            1,
                        error: sm()
                    };
                    break
                }
            }
            if (o) return new e(
                s
                    ._symbol,
                a,
                o, r
                ._rhs,
                r)
        }
        getRef() {
            return this.ref
        }
    };

    function ae(e, t) {
        let n = Av(e);
        return n.prototype.type = t,
            n
    }
    var OB = {
        Base: ae(Tt, "Base"),
        Expression: ae(j,
            "Expression"),
        Error: ae(C, "Error"),
        Constant: ae(Zt,
            "Constant"),
        MixedNumber: ae(Qd,
            "MixedNumber"),
        Identifier: ae(ze,
            "Identifier"),
        Ans: ae(Kd, "Ans"),
        List: ae(Vo, "List"),
        Range: ae(ol, "Range"),
        ListAccess: ae(Ua,
            "ListAccess"),
        DotAccess: ae(xi,
            "DotAccess"),
        Construction: ae(ju,
            "Construction"),
        ParenSeq: ae(Qi,
            "ParenSeq"),
        MovablePoint: ae(em,
            "MovablePoint"),
        NamedCoordinateAccess: ae(
            Ju,
            "NamedCoordinateAccess"
        ),
        BareSeq: ae(qa,
            "BareSeq"),
        Norm: ae(al, "Norm"),
        BaseComparator: ae(Ns,
            "BaseComparator"
        ),
        ComparatorChain: ae(Xa,
            "ComparatorChain"
        ),
        DoubleInequality: ae(Um,
            "DoubleInequality"
        ),
        RepeatedOperator: ae(Za,
            "RepeatedOperator"
        ),
        Sum: ae(xl, "Sum"),
        Product: ae(Pl,
            "Product"),
        Integral: ae(Tl,
            "Integral"),
        AssignmentExpression: ae(
            Il,
            "AssignmentExpression"
        ),
        ListComprehension: ae(
            ya,
            "ListComprehension"
        ),
        FunctionCall: ae(cn,
            "FunctionCall"),
        RecursiveFunctionBaseCase: ae(
            wi,
            "RecursiveFunctionBaseCase"
        ),
        SeededFunctionCall: ae(
            Wa,
            "SeededFunctionCall"
        ),
        FunctionExponent: ae(El,
            "FunctionExponent"
        ),
        FunctionFactorial: ae(
            Ml,
            "FunctionFactorial"
        ),
        Prime: ae(uc, "Prime"),
        Piecewise: ae(hr,
            "Piecewise"),
        Restriction: ae(vl,
            "Restriction"),
        Derivative: ae(cc,
            "Derivative"),
        UpdateRule: ae(Dl,
            "UpdateRule"),
        Substitution: ae(Go,
            "Substitution"),
        Histogram: ae(Sl,
            "Histogram"),
        DotPlot: ae(Ol,
            "DotPlot"),
        BoxPlot: ae(Cl,
            "BoxPlot"),
        TTest: ae(Rl, "TTest"),
        IndependentTTest: ae(Nl,
            "IndependentTTest"
        ),
        Stats: ae(Al, "Stats"),
        Assignment: ae(ga,
            "Assignment"),
        CoordinateEquation: ae(
            qm,
            "CoordinateEquation"
        ),
        FunctionDefinition: ae(
            cr,
            "FunctionDefinition"
        ),
        CallAssignment: ae(ja,
            "CallAssignment"
        ),
        Equation: ae(ko,
            "Equation"),
        Regression: ae($m,
            "Regression"),
        Image: ae(Ym, "Image"),
        Ticker: ae(Xm,
            "Ticker"),
        Slider: ae(Zm,
            "Slider"),
        RegressionParameter: ae(
            lc,
            "RegressionParameter"
        ),
        Table: ae(Wm, "Table"),
        TableColumn: ae(pc,
            "TableColumn"),
        SolvedEquation: ae(jm,
            "SolvedEquation"
        ),
        OptimizedRegression: ae(
            Jm,
            "OptimizedRegression"
        ),
        Seed: ae(fc, "Seed"),
        ExtendSeed: ae(dc,
            "ExtendSeed"),
        IRExpression: ae(pn,
            "IRExpression"),
        Add: ae(Ql, "Add"),
        Subtract: ae(ni,
            "Subtract"),
        Multiply: ae(Kl,
            "Multiply"),
        DotMultiply: ae(uu,
            "DotMultiply"),
        CrossMultiply: ae(ep,
            "CrossMultiply"
        ),
        Divide: ae(tp,
            "Divide"),
        Exponent: ae(cu,
            "Exponent"),
        Negative: ae(np,
            "Negative"),
        Or: ae(rp, "Or"),
        PercentOf: ae(ip,
            "PercentOf"),
        RawExponent: ae(zy,
            "RawExponent"),
        Comparator: {
            "<": ae(qr["<"],
                "Comparator['<']"
            ),
            ">": ae(qr[">"],
                "Comparator['>']"
            ),
            "<=": ae(qr["<="],
                "Comparator['<=']"
            ),
            ">=": ae(qr[">="],
                "Comparator['>=']"
            ),
            "=": ae(qr["="],
                "Comparator['=']"
            )
        }
    },
        D = OB;
    var lr = {
        xmin: -5,
        xmax: 5,
        ymin: -5,
        ymax: 5,
        zmin: -5,
        zmax: 5
    };

    function DI(e, t) {
        let n = Math.round(1e6 *
            e) / 1e6;
        return Math.abs(n - e) < t ?
            n : e
    }

    function a6(e) {
        let t = !0,
            n = !0,
            r = !0;
        return e.hardMin !==
            void 0 && e.target < e
                .hardMin && (t = !1), e
                    .hardMax !== void 0 && e
                        .target > e.hardMax && (
                n = !1), e.step &&
                Hy({
                    target: e
                        .target,
                    step: e.step,
                    hardMin: t ? e
                        .hardMin :
                        void 0,
                    hardMax: n ? e
                        .hardMax :
                        void 0
                }) !== e.target && (
                r = !1), {
            min: t,
            max: n,
            step: r
        }
    }

    function Hy(e) {
        let {
            target: t,
            hardMin: n,
            hardMax: r,
            step: i
        } = e, s = 1e-10;
        if (n !== void 0 && r !==
            void 0 && (s = Math.min(
                s, Math.abs(r -
                    n) / 1e3)), i &&
            (s = Math.min(s, i /
                10)), n !==
                void 0 && (n = DI(n,
                    s)), r !== void 0 && (
                        r = DI(r, s)), e
                            .forceSliderToMax &&
                        r !== void 0 && (t = r),
            n > r || t <= n)
            return n;
        if (t >= r) return r;
        if (i) {
            let u = n !== void 0 ?
                n : 0;
            var o = Math.round((t -
                u) / i);
            t = i * o + u
        }
        let a = DI(t, s);
        return (i || n === a ||
            r === a) && (t = a),
            t <= n ? n : t >= r ?
                r : t
    }

    function sS(e) {
        let {
            storedMax: t,
            sliderValue: n,
            hardMin: r,
            step: i
        } = e, s = e.is3d ? lr
            .xmax : 10;
        if (t > s && (s = t), n >
            s && (s = n), r > s && (
                s = r), i) {
            let o = Hy({
                target: s,
                hardMin: r,
                hardMax: void 0,
                step: i
            });
            o >= s ? s = o : s = o +
                i
        }
        return s
    }
    var OI = D.Constant,
        RB = D.Identifier;
    D.Base.prototype
        .tryGetConcreteTree =
        function (e, t, n = {}) {
            var r;
            try {
                r = this
                    .getConcreteTree(
                        e, t, n)
            } catch (i) {
                i instanceof D
                    .Base ? r = i :
                    r = J(i)
            }
            return r
        };
    D.Base.prototype
        .getConcreteTree = function (
            e, t, n = {}) {
            var i;
            var r = this
                .buildIRExpression(
                    e, t, {
                    selection: (
                        i =
                        this
                            .parseOptions
                    ) ==
                        null ?
                        void 0 :
                        i
                            .selection,
                    coerceToNumber: n
                        .coerceToNumber
                });
            if (r.isError) throw r;
            return r
        };
    D.DoubleInequality.prototype
        .getConcreteTree = function (
            e, t) {
            return new this
                .constructor([new D
                    .Piecewise([
                        this
                            ._indicator,
                        this
                            ._expressions[
                        0
                        ],
                        new OI(
                            NaN
                        )
                    ])
                    .getConcreteTree(
                        e, t),
                this
                    ._operators[
                0],
                new RB(this
                    ._symbol
                ), this
                    ._operators[
                1],
                new D
                    .Piecewise([
                        this
                            ._indicator,
                        this
                            ._expressions[
                        1
                        ],
                        new OI(
                            NaN
                        )
                    ])
                    .getConcreteTree(
                        e, t)
                ])
        };
    D.Error.prototype
        .getConcreteTree = function (
            e, t) {
            return this
        };

    function Vf(e, t) {
        return e.isError ? e : t
            .indexOf(e
                .valueType) === -1 ?
            Up() : e
    }
    D.Image.prototype
        .getConcreteTree = function (
            e, t) {
            var n = this.center
                .tryGetConcreteTree(
                    e, t),
                r = this.radianAngle
                    .tryGetConcreteTree(
                        e, t),
                i = this.width
                    .tryGetConcreteTree(
                        e, t),
                s = this.height
                    .tryGetConcreteTree(
                        e, t),
                o = this.opacity
                    .tryGetConcreteTree(
                        e, t),
                a = [R, Pt, We],
                u = [T, se, We];
            return n = Vf(n, a), r =
                Vf(r, u), i = Vf(i,
                    u), s = Vf(s,
                        u), o = Vf(o, u),
                new D.Image({
                    center: n,
                    radianAngle: r,
                    width: i,
                    height: s,
                    opacity: o
                }, this
                    .moveStrategy)
        };
    D.Ticker.prototype
        .getConcreteTree = function (
            e, t) {
            var n = this.handler
                .tryGetConcreteTree(
                    e, t);
            !n.isError && n
                .valueType !== rt &&
                (n = jp(ne(n
                    .valueType)));
            var r = n
                .getDependencies()
                .filter(function (
                    i) {
                    return !(e
                        .graphingEnabled() &&
                        e
                            .validActionVariable(
                                i
                            )
                    )
                });
            return r.length && (n =
                tn(e.sliderVariables(
                    r))
                    .setDependencies(
                        r)), new D
                            .Ticker({
                                handler: n,
                                minStep: this
                                    .minStep
                                    .tryGetConcreteTree(
                                        e, t
                                    )
                            })
        };

    function SI(e, t, n) {
        if (!t) {
            n.valids[e] = !0;
            return
        }
        var r = t.getDependencies();
        if (t.isError) n.errors[
            e] = !0;
        else if (r.length > 0) {
            n.errors[e] = !0;
            for (var i = 0; i < r
                .length; i++) r[
                    i] === n
                        .exportedSymbol ? n
                            .errors.cycle = !0 :
                    n.missingVars.push(
                        r[i])
        } else n.values[e] = +t
            .asValue();
        n.valids[e] = isFinite(n
            .values[e]), n
                .valids[e] || (n.values[
                    e] = void 0)
    }

    function Uy(e) {
        return e && e.valueType ===
            se && e.length === 1 &&
            e.args ? e.args[0] : e
    }
    D.Slider.prototype
        .getConcreteTree = function (
            e, t) {
            var n = this._expression
                .getConcreteTree(e,
                    t),
                r = Uy(this
                    .sliderMin &&
                    this.sliderMin
                        .tryGetConcreteTree(
                            e, t)),
                i = Uy(this
                    .sliderMax &&
                    this.sliderMax
                        .tryGetConcreteTree(
                            e, t)),
                s = Uy(this
                    .sliderStep &&
                    this.sliderStep
                        .tryGetConcreteTree(
                            e, t)),
                o = {
                    exportedSymbol: this
                        ._symbol,
                    errors: {},
                    values: {},
                    valids: {},
                    missingVars: [],
                    errMsg: void 0
                };
            if (SI("min", r, o), SI(
                "max", i, o),
                SI("step", s, o),
                s && o.valids
                    .step && (o.values
                        .step === 0 ?
                        delete o.values
                            .step : o.values
                                .step = Math
                                    .abs(o.values
                                        .step)), o
                                            .errors.cycle ? n =
                tP(o
                    .exportedSymbol) : (
                    o.errors.min ||
                        !o.valids.min ?
                        o.errMsg =
                        nP() : o.errors
                            .max || !o
                                .valids.max ? o
                                    .errMsg = rP() :
                            (o.errors
                                .step || !o
                                    .valids.step
                            ) && (o
                                .errMsg =
                                sP()), o
                                    .values.min > o
                                        .values.max && (
                        o.valids
                            .min = !1, o
                                .valids
                                .max = !1, o
                                    .errMsg || (
                            o
                                .errMsg =
                            iP()))),
                n.isConstant) {
                var a = t
                    .initialEvaluation &&
                    t
                        .initialEvaluation
                        .asValue(),
                    u = a && this
                        .sliderIsPlayingOnce,
                    c = o.values
                        .max,
                    l = +n
                        .asValue(),
                    p = o.values
                        .min,
                    f = o.values
                        .step;
                if (u && !isFinite(
                    c)) {
                    var m = Uy(this
                        .sliderSoftMax &&
                        this
                            .sliderSoftMax
                            .tryGetConcreteTree(
                                e, t
                            ));
                    m && (c = sS({
                        storedMax: +m
                            .asValue(),
                        sliderValue: l,
                        step: f,
                        hardMin: p,
                        is3d: e
                            .is3dProduct()
                    }))
                }
                var g = Hy({
                    target: l,
                    hardMin: p,
                    hardMax: c,
                    step: f,
                    forceSliderToMax:
                        !!u
                }),
                    d = Yu(g
                        .toString()
                    ),
                    y = isFinite(q(
                        d)) ? d : g;
                n = new OI(y)
                    .getConcreteTree(
                        e, t)
            }
            return n.sliderInfo = o,
                n
        };

    function oS(e, t) {
        if (!t[this._symbol])
            throw ms(this._symbol);
        var n = this.args.map(
            function (i) {
                return i
                    .getConcreteTree(
                        e, t)
            });
        if (n.length > 0) {
            if (n.length === 1 && n
                .push(new D
                    .Constant(1)
                    .getConcreteTree(
                        e, t)), n[1]
                            .getDependencies()
                    .length) throw af(
                        this._symbol
                    )
                        .setDependencies(
                            n[1]
                                .getDependencies()
                        );
            if (n[1].valueType !==
                T) throw af(this
                    ._symbol);
            var r = n[1].asValue();
            if (!isFinite(r) || r <=
                0) throw af(this
                    ._symbol)
        }
        return this.typeCheck(e, n),
            new this.constructor(n)
    }
    D.Histogram.prototype
        .getConcreteTree = oS;
    D.DotPlot.prototype
        .getConcreteTree = oS;
    D.BoxPlot.prototype
        .getConcreteTree = function (
            e, t) {
            if (!t[this._symbol])
                throw ms(this
                    ._symbol);
            var n = this.args.map(
                function (r) {
                    return r
                        .getConcreteTree(
                            e, t
                        )
                });
            return this.typeCheck(e,
                n), n.length ===
                    1 && (n[0]
                        .valueType ===
                        se || n[0]
                            .valueType ===
                        We) ? new this
                            .constructor(n) : J(
                                "Failed to copmile BoxPlot"
                            )
        };

    function CI(e, t) {
        if (!t[this._symbol])
            throw ms(this._symbol);
        var n = this.args.map(
            function (r) {
                return r
                    .getConcreteTree(
                        e, t)
            });
        return this.typeCheck(e, n),
            new this.constructor(n)
    }
    D.TTest.prototype
        .getConcreteTree = CI;
    D.IndependentTTest.prototype
        .getConcreteTree = CI;
    D.Stats.prototype
        .getConcreteTree = CI;
    D.Table.prototype
        .getConcreteTree = function (
            e, t) {
            for (var n = [], r =
                Object.create(
                    t), i = 0; i <
                this.columns
                    .length; i++) {
                var s = this
                    .columns[i]
                    .getConcreteTree(
                        e, r);
                s.isIndependent &&
                    this.columns[i]
                        .exportToLocal(
                            e, s, r), n
                                .push(s)
            }
            return new this
                .constructor(n)
        };
    D.TableColumn.prototype
        .getConcreteTree = function (
            e, t) {
            var u;
            var n = this.header
                .getConcreteTree(e,
                    t),
                r, i, s = this
                    .header instanceof D
                        .Identifier && !t[
                        this.header
                            ._symbol];
            if (s) {
                r = [];
                for (var o = 0; o <
                    this.values
                        .length; o++) {
                    if (this.values[
                        o]
                        .tableError()
                    ) {
                        r.push(ml(this
                            .values[
                            o
                        ]
                            .tableError()
                        ));
                        continue
                    }
                    var a = this
                        .values[o]
                        .tryGetConcreteTree(
                            e, t);
                    a.isError ? r
                        .push(a) : a
                            .tableError() ?
                        r.push(ml(a
                            .tableError()
                        )) : a
                            .valueType ===
                            T ? r.push(
                                a) : r
                                    .push(Zb([ne(a
                                        .valueType)]))
                }
                return i = new this
                    .constructor(n,
                        r), i
                            .isIndependent = !
                    0, i
            } else return n.isList ?
                r = n
                    .mapElements(
                        function (
                            c) {
                            return c
                        }) : r = [],
                !n.isError && n
                    .valueType !==
                T && n
                    .valueType !==
                se && n
                    .valueType !==
                We && (n = Xb([
                    ne((u = n
                        .valueType
                    ) !=
                        null ?
                        u :
                        Ht
                    )
                ])), i =
                new this
                    .constructor(n,
                        r), i
        };

    function Bf(e, t, n) {
        return {
            symbolMap: e,
            symbolNodeMap: t,
            maxIndex: n
        }
    }

    function qy(e, t) {
        return e.symbolMap[t]
    }

    function aS(e, t) {
        return e.symbolNodeMap[t]
    }

    function xr(e, t, n, r) {
        e.symbolNodeMap[t] = r, e
            .symbolMap[t] = n, e
                .maxIndex = Math.max(e
                    .maxIndex, n)
    }

    function ts(e) {
        return Bf(Object.create(e
            .symbolMap),
            Object.create(e
                .symbolNodeMap),
            e.maxIndex)
    }

    function $y(e, t, n) {
        let r = e.getInstruction(n);
        if (!be(r)) {
            for (let o of r.args)
                if (!bt(e
                    .getInstruction(
                        o)))
                    return !0
        }
        if (t < n) return !bt(e
            .getInstruction(
                t));
        let i = [!0];
        for (let o = n + 1; o <=
            t; o++) i.push(!1);
        let s = [t];
        for (; s.length;) {
            let o = s.pop();
            if (i[o - n]) continue;
            i[o - n] = !0;
            let a = e
                .getInstruction(o);
            if (!be(a))
                for (let u of a
                    .args) {
                    let c = e
                        .getInstruction(
                            u);
                    if (u < n) {
                        let l = e
                            .getInstruction(
                                u);
                        if (l
                            .type ===
                            4)
                            continue;
                        if (!bt(l))
                            return !
                                0
                    } else {
                        if (e
                            .getInstruction(
                                u)
                            .type ===
                            50)
                            return !
                                0;
                        if (c
                            .type ===
                            3)
                            return !
                                0;
                        i[u - n] ||
                            s.push(
                                u)
                    }
                }
        }
        return !1
    }

    function yo(e, t, n) {
        let r = zn(e, t);
        if (r === void 0)
            throw new Error(
                `${n}
Non-constant instruction: "${yc(e, _r(e, t))}"`);
        return r
    }

    function zn(e, t) {
        let n = Mc(e, t, void 0,
            void 0);
        if (!(n < 0)) return n
    }

    function Mc(e, t, n, r) {
        var a;
        let i = n && n[t];
        if (i) return i;
        let s = e.getInstruction(t),
            o;
        switch (s.type) {
            case 38:
                o = s.args.length;
                break;
            case 1:
                o = s.value.length;
                break;
            case 48: {
                o = (a = s
                    .constantLength
                ) != null ?
                    a : -1;
                break
            }
        }
        return o === void 0 && (n =
            n || {}, o = NB(e,
                s, n, r ||
            new Set)), n &&
            (n[t] = o), o
    }

    function NB(e, t, n, r) {
        switch (t.type) {
            case 33: {
                let i = Mc(e, t
                    .args[1], n,
                    r),
                    s = Mc(e, t
                        .args[2], n,
                        r);
                return i === s ? i :
                    -1
            }
            case 37:
                switch (t.symbol) {
                    case "elementsAt":
                        return Mc(e,
                            t
                                .args[
                            1
                            ],
                            n, r
                        );
                    case "sortPerm":
                        return Mc(e,
                            t
                                .args[
                            0
                            ],
                            n, r
                        );
                    case "shuffle":
                        return Mc(e,
                            t
                                .args[
                            1
                            ],
                            n, r
                        );
                    default:
                        return -1
                }
            case 55: {
                if (r && r.has(t
                    .args[0]))
                    return -1;
                r.add(t.args[0]);
                let i = e
                    .dereferenceFunctionHeader(
                        t.args[0]);
                if (i !== void 0) {
                    let s = e
                        .getInstruction(
                            i);
                    return Mc(e, s
                        .args[
                        1], n, r
                    )
                }
                return -1
            }
            default: {
                if (W(t.valueType))
                    return -1;
                throw new Error(
                    `Programming Error: cannot find the list length of ${Ar(t.type)} ${ne(t.valueType)}.`
                )
            }
        }
    }

    function _r(e, t) {
        let n = e.getInstruction(t);
        if (!W(n.valueType))
            throw new Error(
                `Programming Error: cannot find the list length of ${e.printInstruction(t)}`
            );
        switch (n.type) {
            case 38:
                return e.Constant(n
                    .args.length
                );
            case 1:
                return e.Constant(n
                    .value
                    .length);
            case 48: {
                let r = e
                    .getInstruction(
                        n.args[0]);
                return e
                    .getInstruction(
                        r.args[0])
                    .args[0]
            }
            case 37:
                switch (n.symbol) {
                    case "elementsAt":
                        return _r(e,
                            n
                                .args[
                            1
                            ]
                        );
                    case "sortPerm":
                        return _r(e,
                            n
                                .args[
                            0
                            ]
                        );
                    case "shuffle":
                        return _r(e,
                            n
                                .args[
                            1
                            ]
                        )
                }
        }
        return e
            .SyntheticNativeFunction(
                "count", [t])
    }

    function Gf(e, t) {
        let n = [];
        for (let o of t) W(e
            .getInstruction(o)
            .valueType) && n
                .push(o);
        if (n.length === 0) return;
        if (n.length === 1)
            return _r(e, n[0]);
        let r = [];
        for (let o of n) r.push(zn(
            e, o));
        let i, s = 1 / 0;
        for (let o = 0; o < r
            .length; o++) {
            let a = n[o],
                u = r[o];
            if (u === void 0)
                return e
                    .SyntheticNativeFunction(
                        "min", [e
                            .List(n
                                .map(
                                    c =>
                                        _r(e,
                                            c
                                        )
                                )
                            )
                    ]);
            u < s && (i = a, s = u)
        }
        return i !== void 0 ? _r(e,
            i) : e.Constant(s)
    }

    function Yy(e, t) {
        if (W(e)) {
            let n = ke(e);
            for (let r = 0; r < t
                .length; r++)
                if (Pr(n, t[r]))
                    return !0;
            return !1
        }
        return Pr(e, t)
    }

    function Pr(e, t) {
        switch (e) {
            case T:
                return Wi(t);
            case Vt:
                return t;
            case R: {
                let [n, r] = t;
                return Wi(n) || Wi(
                    r)
            }
            case V: {
                let [n, r, i] = t;
                return Wi(n) || Wi(
                    r) || Wi(i)
            }
            case Ut: {
                let [n, r, i] = t;
                return Wi(n) || Wi(
                    r) || Wi(i)
            }
            case Be: {
                for (let n of t)
                    if (Pr(R, n))
                        return !0;
                return !1
            }
            case Nn: {
                let [n, r] = t;
                return Pr(V, n) ||
                    Pr(T, r)
            }
            case In: {
                let [n, r, i] = t;
                return Pr(V, n) ||
                    Pr(V, r) || Pr(
                        V, i)
            }
            case Nt:
            case Se: {
                let [n, r] = t;
                return Pr(V, n) ||
                    Pr(V, r)
            }
            case Ie:
            case fe:
            case Le:
            case he: {
                let [n, r] = t;
                return Pr(R, n) ||
                    Pr(R, r)
            }
            case pe: {
                let [n, r] = t;
                return Pr(R, n) ||
                    Pr(T, r)
            }
            case ce: {
                let [n, r, i] = t;
                return Pr(R, n) ||
                    Pr(R, r) || Pr(
                        R, i)
            }
            case Ge:
            case Ae: {
                let [n, r, i] = t;
                return Pr(R, n) ||
                    Pr(T, r) || Pr(
                        T, i)
            }
            case rt:
                return Object.keys(t
                    .updateRules
                ).length ===
                    0;
            case ge:
            case St:
            case ot:
            case Ue:
            case Wn:
            case jn:
            case sr:
            case or:
                return !1;
            case mn: {
                let [n, r] = t;
                return Wi(n) || Wi(
                    r)
            }
            default:
                throw new Error(
                    "Type cannot contain a NaN value: " +
                    ne(e) + ".")
        }
    }

    function RI(e, t, n) {
        let r;
        return Xy(t) ? r = AI(t,
            n) : r = lS(t, n), e
                .ConstantOfType(t, r)
    }

    function NI(e) {
        return Xy(e) || cS(e)
    }

    function Xy(e) {
        switch (e) {
            case We:
            case se:
            case Ln:
            case Hr:
            case Pt:
            case Tn:
            case Fn:
            case Vn:
            case Gn:
            case kn:
            case Bn:
            case Rn:
            case gn:
            case hn:
            case Kn:
            case nr:
            case tr:
            case yr:
            case er:
            case Zn:
            case Ur:
            case mr:
                return !0;
            default:
                return !1
        }
    }

    function cS(e) {
        switch (e) {
            case T:
            case ge:
            case Vt:
            case R:
            case Ie:
            case pe:
            case ce:
            case Le:
            case he:
            case fe:
            case Be:
            case Ge:
            case Ae:
            case V:
            case Se:
            case In:
            case Nn:
            case Nt:
            case Ut:
            case mn:
            case Ue:
            case rt:
            case ot:
                return !0;
            default:
                return !1
        }
    }

    function AI(e, t) {
        if (e === We) return [];
        let n = ke(e);
        if (!cS(n)) throw new Error(
            `Programming error: unexpected element type ${on(n)} for list type ${on(e)}.`
        );
        let r = [];
        for (let i = 0; i < t
            .length; i++) {
            let s = lS(n, t[i]);
            r.push(s)
        }
        return r
    }

    function lS(e, t) {
        if (e === T) return De(t,
            1);
        if (e === R) {
            let [n, r] = t;
            return [De(n, 1), De(r,
                1)]
        } else if (e === V) {
            let [n, r, i] = t;
            return [De(n, 1), De(r,
                1), De(i,
                    1)]
        } else return t
    }

    function _I(e, t) {
        return us(e, t)
    }

    function LI(e, t) {
        return ji(e, t)
    }

    function wI(e, t) {
        return cs(e, t)
    }

    function FI(e, t) {
        return Ji(e, t)
    }

    function kf(e, t) {
        return q(e) === Math.E ?
            Math.exp(q(t)) : Uh(e,
                t)
    }
    var AB = kf;

    function VI(e) {
        return hi(e)
    }

    function _B(e, t) {
        return [e, t]
    }

    function LB(e, t) {
        return t[e - 1]
    }

    function wB(e, t, n) {
        return [e, t, n]
    }

    function FB(e, t) {
        return t[e - 1]
    }

    function BI(e, t) {
        return q(e) === q(t)
    }

    function GI(e, t) {
        return q(e) < q(t)
    }

    function kI(e, t) {
        return q(e) > q(t)
    }

    function zI(e, t) {
        return q(e) <= q(t)
    }

    function HI(e, t) {
        return q(e) >= q(t)
    }

    function fS(e, t) {
        return e || t
    }

    function dS(e, t) {
        return e && t
    }

    function VB(e, t, n) {
        let r = Math.floor(q(n)) -
            1;
        return !isFinite(r) || r <
            0 || r >= t.length ? $r(
                e) : t[r]
    }

    function UI(e, t, n) {
        return En(n) && (n = q(n)),
            `${t}::${e}${n}`
    }

    function qI(e, t) {
        switch (e) {
            case "mod":
                return UM(t[0], t[
                    1]);
            case "abs":
                return zM(t[0]);
            case "sqrt":
                return HM(t[0]);
            case "nthroot":
                return wd(t[0], t[
                    1]);
            case "total":
                return qM(t[0]);
            case "count":
                return t[0].length;
            case "validateRangeLength": {
                let n = t[0],
                    r = t[1],
                    i = t[2],
                    s = t[3],
                    o = pI(n, r, i,
                        s);
                if (o === 0)
                    throw of();
                return o
            }
            case "validateSampleCount": {
                let n = ao(t[0]),
                    r = fI(n);
                if (r === 0 && n !==
                    0) throw WP();
                return r
            }
            case "select":
            case "elementsAt":
            case "uniquePerm":
            case "sortPerm": {
                let n = bn[e];
                return fo[n.symbol]
                    .apply(null, t)
            }
            default: {
                let n = bn[e];
                return (n.module ===
                    "Math" ?
                    Math : fo)[n
                        .symbol]
                    .apply(null, ao(
                        t))
            }
        }
    }

    function mS(e, t) {
        let n = Array(t + 1);
        return nt(e, t, n)
    }

    function yS(e, t, n) {
        let r = Array(t + 1);
        for (let i = 0; i < n
            .length; i++) r[i] = n[
                i];
        return nt(e, t, r)
    }

    function gS(e, t, n) {
        if (t.constantLength)
            return t.constantLength;
        let r = t.args[0],
            s = e.getInstruction(r)
                .args[0],
            o = e.getInstruction(s);
        return q(nt(e, o.args[0],
            n))
    }

    function hS(e, t, n, r) {
        let i = e.getInstruction(t),
            s = gS(e, i, r);
        if (!isFinite(n) || n < 0 ||
            n >= s) return $r(ke(i
                .valueType));
        let o = i.args[0],
            a = t - o,
            u = e.getInstruction(o),
            c = u.args[0],
            l = u.args[a];
        r[c] = n + 1;
        let p = nt(e, l, r);
        for (let f = c; f <= o; f++)
            r[f] = void 0;
        return p
    }

    function BB(e, t, n) {
        let r = e.getInstruction(t),
            i = r.args[0],
            s = e.getInstruction(i)
                .args[0];
        if (kB(e, s + 1, i - 1) &&
            Xy(r.valueType)) {
            let u = e.copy(),
                c = sp(u);
            return AI(r.valueType,
                c)
        }
        let o = gS(e, r, n),
            a = [];
        for (let u = o - 1; u >=
            0; u--) a[u] = hS(e, t,
                u, n);
        return a
    }

    function bS(e, t, n) {
        let r = nt(e, t.args[1], n),
            i = t.args[0],
            s = e.getInstruction(i);
        if (s.type === 48)
            return hS(e, i, q(r) -
                1, n);
        if (s.type === 33) {
            let o = nt(e, s.args[0],
                n);
            return bS(e, {
                ...t,
                args: [o ? s
                    .args[
                    1
                ] :
                    s
                        .args[
                    2
                    ],
                t
                    .args[
                1
                ]
                ]
            }, n)
        } else {
            let o = nt(e, t.args[0],
                n);
            return VB(t.valueType,
                o, r)
        }
    }

    function nt(e, t, n) {
        let r = n[t];
        if (r !== void 0) return r;
        let i = GB(e, t, n);
        return typeof i ==
            "number" && i === Math
                .floor(i) && (i = De(i,
                    1)), n[t] = i, i
    }

    function GB(e, t, n) {
        let r = e.getInstruction(t);
        switch (r.type) {
            case 1:
                return r.value;
            case 8:
                return _I(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 9:
                return LI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 10:
                return wI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 11:
                return FI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 12:
                return kf(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 13:
                return AB(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 14:
                return VI(nt(e, r
                    .args[
                    0], n));
            case 15:
                return _B(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 16:
                return wB(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n),
                    nt(e, r
                        .args[
                        2], n));
            case 17:
                return LB(r.index,
                    nt(e, r
                        .args[
                        0], n));
            case 18:
                return FB(r.index,
                    nt(e, r
                        .args[
                        0], n));
            case 25:
                return BI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 26:
                return GI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 27:
                return kI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 28:
                return zI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 29:
                return HI(nt(e, r
                    .args[
                    0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 31:
                return nt(e, r.args[
                    0], n) ||
                    nt(e, r.args[1],
                        n);
            case 32:
                return nt(e, r.args[
                    0], n) &&
                    nt(e, r.args[1],
                        n);
            case 44:
                return UI(r.tag, nt(
                    e, r
                        .args[
                0], n),
                    nt(e, r
                        .args[
                        1], n));
            case 33:
                return nt(e, r.args[
                    0], n) ? nt(
                        e, r.args[
                    1], n) : nt(
                        e, r.args[
                    2], n);
            case 37: {
                let s = [];
                for (let o of r
                    .args) s.push(
                        nt(e, o, n));
                return qI(r.symbol,
                    s)
            }
            case 38: {
                let s = [];
                for (let o of r
                    .args) s.push(
                        nt(e, o, n));
                return s
            }
            case 39:
            case 40:
            case 41:
                return bS(e, r, n);
            case 48:
                return BB(e, t, n);
            case 47: {
                let s = r.args[0],
                    o = t - s,
                    u = e
                        .getInstruction(
                            s).args[o],
                    c = pS(e, {
                        endIndex: s,
                        returnIndex: u,
                        resultIndex: t
                    }, n);
                return sp(c)
            }
            case 55: {
                let s = r.args[0],
                    a = e
                        .getInstruction(
                            s).endIndex,
                    c = e
                        .getInstruction(
                            a).args[0],
                    l = pS(e, {
                        endIndex: a,
                        returnIndex: c,
                        resultIndex: t
                    }, n);
                return sp(l)
            }
            case 19:
            case 20:
            case 21:
            case 22:
            case 23:
            case 24:
            case 42:
            case 0:
            case 2:
            case 3:
            case 49:
            case 50:
            case 51:
            case 4:
            case 53:
            case 54:
                throw new Error(
                    `Programming Error: cannot interpret opcode ${r.type}`
                );
            default:
                let i = r;
                throw new Error(
                    `Programming Error: unexpected opcode ${i.type}`
                )
        }
    }

    function pS(e, t, n) {
        let r = t.endIndex,
            i = t.returnIndex,
            s = t.resultIndex,
            o = e.getInstruction(r)
                .args[0],
            a = [];
        a[i] = !0;
        let u = i;
        e.getInstruction(s).type ===
            55 && (a[s] = !0, u =
                s);
        for (let m = u; m >=
            o; m--) {
            if (!a[m]) continue;
            let g = e
                .getInstruction(m);
            if (!be(g))
                for (let d of g
                    .args) d < o ||
                        d > r ? nt(e, d,
                            n) : a[
                            d] = !0
        }
        let l = e.copy();
        l.truncate(o);
        for (let m = 0; m <
            o; m++) {
            let g = n[m],
                d = e
                    .getInstruction(m);
            if (g !== void 0) {
                let y = d.valueType;
                l.replaceInstructionWithConstant(
                    m, {
                    type: 1,
                    valueType: y,
                    value: g
                })
            }
        }
        l.reopenAllBlocks();
        let p = [];
        for (let m = o; m <
            s; m++) {
            let g = e
                .getInstruction(m);
            if (be(g)) p.push(l
                .copyInstruction(
                    g));
            else {
                let d = [];
                for (let y of g
                    .args) d.push(
                        y < o ? y :
                            p[y - o]);
                g.type === 40 ? p
                    .push(l
                        .InboundsListAccess(
                            d)) : p
                                .push(l
                                    .copyInstructionWithArgs(
                                        g, d))
            }
        }
        l.Noop();
        let f = e.getInstruction(s);
        if (f.type === 47) l
            .replaceInstructionWithBlockVarOrFunctionCall(
                l
                    .getReturnIndex(), {
                type: 47,
                valueType: f
                    .valueType,
                args: [r < o ?
                    r : p[
                    r -
                    o]
                ]
            });
        else if (f.type === 55) l
            .replaceInstructionWithBlockVarOrFunctionCall(
                l
                    .getReturnIndex(), {
                type: 55,
                valueType: f
                    .valueType,
                args: f.args
                    .map(m =>
                        m < o ?
                            m : p[
                            m -
                            o])
            });
        else throw new Error(
            `Programming error: unexpected opcode ${Ar(f.type)}`
        );
        return l
    }

    function kB(e, t, n) {
        let r = [];
        for (let s = 0; s <= t; s++)
            r.push(!1);
        let i = [];
        for (let s = t + 1; s <=
            n; s++) i.push(s);
        for (; i.length;) {
            let s = i.pop();
            if (r[s]) continue;
            r[s] = !0;
            let o = e
                .getInstruction(s);
            if (o.type === 55)
                return !0;
            if (!be(o))
                for (let a of o
                    .args) r[a] || i
                        .push(a)
        }
        return !1
    }

    function sp(e) {
        let t = e
            .getCompiledFunction();
        return t.executionMetadata
            .recursiveFunctionCache =
            new ql, t
                .executionMetadata
                .iterativeRecursionOutputs = {},
            t.fn()
    }

    function Tr(e, t) {
        let n = e.getInstruction(t);
        if (n.type !== 48) return t;
        let r = n.args[0],
            i = e.getInstruction(r),
            s = i.args[0],
            o = !1;
        for (let u = s + 1; u <
            r; u++) {
            let c = e
                .getInstruction(u);
            if (c.type === 40 && c
                .args[1] === s) {
                o = !0;
                break
            }
        }
        if (!o) return t;
        let a = [];
        for (let u = s; u <= r + i
            .args.length - 1; u++) {
            let c = e
                .getInstruction(u);
            if (be(c)) a.push(e
                .copyInstruction(
                    c));
            else {
                let l = [];
                for (let p of c
                    .args) l.push(
                        p >= s ? a[
                            p - s] :
                            p);
                c.type === 40 ? a
                    .push(e
                        .InboundsListAccess(
                            l)) : a
                                .push(e
                                    .copyInstructionWithArgs(
                                        c, l))
            }
        }
        return e.getReturnIndex()
    }

    function zf(e, t, n) {
        let r = e.getInstruction(t);
        if (W(r.valueType)) {
            let i = zn(e, t);
            if (n = Math.floor(n),
                isNaN(n) || n < 0 ||
                i !== void 0 && n >=
                i) {
                let s = ke(r
                    .valueType);
                return e.NanOfType(
                    s)
            }
            return r.type === 38 ? r
                .args[n] : r
                    .type === 1 && W(r
                        .valueType) ? e
                            .ConstantOfType(ke(r
                                .valueType),
                                r.value[n]) :
                i !== void 0 ? e
                    .InboundsListAccess(
                        [t, e.Constant(
                            n + 1)]) : e
                                .ListAccess([t, e
                                    .Constant(
                                        n + 1)
                                ])
        } else {
            if (r.valueType === R)
                return isNaN(n) ||
                    n < 0 || n > 2 ?
                    e.Constant(
                        NaN) : r
                            .type === 15 ? r
                                .args[n] : r
                                    .type === 1 ? e
                                        .Constant(r
                                            .value[n]) :
                        e
                            .OrderedPairAccess(
                                n + 1, [t]);
            if (r.valueType === V)
                return isNaN(n) ||
                    n < 0 || n > 3 ?
                    e.Constant(
                        NaN) : r
                            .type === 16 ? r
                                .args[n] : r
                                    .type === 1 ? e
                                        .Constant(r
                                            .value[n]) :
                        e
                            .OrderedTripleAccess(
                                n + 1, [t]);
            throw new Error(
                `Cannot access elements of ${ne(r.valueType)}`
            )
        }
    }

    function Zy(e, t, n) {
        let r = e.getInstruction(t);
        if (n.length === 0) return e
            .ConstantOfType(r
                .valueType, []);
        if (r.type === 1 && W(r
            .valueType)) {
            let i = [],
                s = ke(r.valueType);
            for (let o of n) {
                let a = Math.floor(
                    o);
                isNaN(a) || a < 0 ||
                    a >= yo(e, t,
                        "Programming error: expected Constant list instruction to have constant length."
                    ) ? i.push(
                        $r(s)) : i
                            .push(r.value[
                                a])
            }
            return e.ConstantOfType(
                r.valueType, i)
        } else if (r.type === 38) {
            let i = [];
            for (let s of n) {
                let o = Math.floor(
                    s);
                if (isNaN(o) || o <
                    0 || o >= yo(e,
                        t,
                        "Programming error: expected List instruction to have constant length."
                    )) {
                    let a = ke(r
                        .valueType
                    );
                    i.push(e.NanOfType(
                        a))
                } else i.push(r
                    .args[o])
            }
            return e.List(i)
        } else {
            let i = [],
                s = !0,
                o = zn(e, t);
            for (let u of n) {
                let c = Math.floor(
                    u);
                i.push(e.Constant(
                    c + 1)), (
                        isNaN(c) ||
                        c < 0 ||
                        o ===
                        void 0 ||
                        c >= o) && (
                        s = !1)
            }
            let a = [t, e.List(i)];
            return s ? e
                .InboundsListAccess(
                    a) : e
                        .ListAccess(a)
        }
    }

    function TS(e) {
        if (e.instructionsLength() -
            1 !== e.getReturnIndex()
        ) throw new Error(
            "Programming Error: only the final instruction in a chunk can be constant collapsed"
        );
        let t = e.getInstruction(e
            .getReturnIndex());
        if (be(t)) return e
            .getReturnIndex();
        switch (t.type) {
            case 8: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e.Constant(
                            _I(r.value,
                                i
                                    .value
                            ))
                ) : r
                    .type === 1 &&
                    q(r.value) ===
                    0 ? (e
                        .popInstruction(),
                        t.args[1]) :
                    i.type === 1 &&
                        q(i.value) ===
                        0 ? (e
                            .popInstruction(),
                            t.args[0]) :
                        e
                            .getReturnIndex()
            }
            case 9: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e.Constant(
                            LI(r.value,
                                i
                                    .value
                            ))
                ) : r
                    .type === 1 &&
                    q(r.value) ===
                    0 ? (e
                        .popInstruction(),
                        e.Negative([
                            t
                                .args[
                            1
                            ]
                        ])) : i
                            .type === 1 &&
                            q(i.value) ===
                            0 ? (e
                                .popInstruction(),
                                t.args[0]) :
                    e
                        .getReturnIndex()
            }
            case 10: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e.Constant(
                            wI(r.value,
                                i
                                    .value
                            ))
                ) : r
                    .type === 1 &&
                    q(r.value) ===
                    1 ? (e
                        .popInstruction(),
                        t.args[1]) :
                    i.type === 1 &&
                        q(i.value) ===
                        1 ? (e
                            .popInstruction(),
                            t.args[0]) :
                        e
                            .getReturnIndex()
            }
            case 11: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e.Constant(
                            FI(r.value,
                                i
                                    .value
                            ))
                ) : i
                    .type === 1 &&
                    q(i.value) ===
                    1 ? (e
                        .popInstruction(),
                        t.args[0]) :
                    e
                        .getReturnIndex()
            }
            case 12: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                if (r.type === 1 &&
                    i.type === 1)
                    return e
                        .popInstruction(),
                        e.Constant(
                            kf(r.value,
                                i
                                    .value
                            ));
                if (r.type === 1 &&
                    r.valueType ===
                    T) {
                    let s = q(r
                        .value);
                    if (s === Math
                        .E) return e
                            .popInstruction(),
                            e
                                .SyntheticNativeFunction(
                                    "exp",
                                    [t.args[
                                        1]]
                                );
                    if (s > 0)
                        return e
                            .popInstruction(),
                            e
                                .RawExponent(
                                    t
                                        .args
                                )
                }
                if (i.type === 1 &&
                    i.valueType ===
                    T) {
                    let s = q(i
                        .value);
                    if (s === 1)
                        return e
                            .popInstruction(),
                            t.args[
                            0];
                    if (s === Math
                        .floor(s))
                        return e
                            .popInstruction(),
                            e
                                .RawExponent(
                                    t
                                        .args
                                );
                    if (En(i
                        .value)) {
                        let {
                            n: o,
                            d: a
                        } = i.value;
                        if (a %
                            2 === 1
                        ) {
                            e
                                .popInstruction();
                            let u =
                                e
                                    .RawExponent(
                                        [e.SyntheticNativeFunction(
                                            "abs",
                                            [t.args[
                                                0]]
                                        ),
                                        t
                                            .args[
                                        1
                                        ]
                                        ]
                                    );
                            return o %
                                2 ===
                                0 ?
                                u :
                                e
                                    .Multiply(
                                        [e.SyntheticNativeFunction(
                                            "sign",
                                            [t.args[
                                                0]]
                                        ),
                                            u
                                        ]
                                    )
                        }
                    }
                }
                return e
                    .getReturnIndex()
            }
            case 13: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e.Constant(
                            kf(r.value,
                                i
                                    .value
                            ))
                ) : i
                    .type === 1 &&
                    q(i.value) ===
                    1 ? (e
                        .popInstruction(),
                        t.args[0]) :
                    e
                        .getReturnIndex()
            }
            case 14: {
                let r = e
                    .getInstruction(
                        t.args[0]);
                return r.type ===
                    1 ? (e
                        .popInstruction(),
                        e.Constant(
                            VI(r
                                .value)
                        )) : e
                            .getReturnIndex()
            }
            case 25: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                ge, BI(r
                                    .value,
                                    i
                                        .value
                                ))
                ) : e
                    .getReturnIndex()
            }
            case 26: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                ge, GI(r
                                    .value,
                                    i
                                        .value
                                ))
                ) : e
                    .getReturnIndex()
            }
            case 27: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                ge, kI(r
                                    .value,
                                    i
                                        .value
                                ))
                ) : e
                    .getReturnIndex()
            }
            case 28: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                ge, zI(r
                                    .value,
                                    i
                                        .value
                                ))
                ) : e
                    .getReturnIndex()
            }
            case 29: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                ge, HI(r
                                    .value,
                                    i
                                        .value
                                ))
                ) : e
                    .getReturnIndex()
            }
            case 31: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                ge, fS(r
                                    .value,
                                    i
                                        .value
                                ))
                ) : r
                    .type === 1 ? (e
                        .popInstruction(),
                        r.value ? t
                            .args[0] : t
                                .args[1]) :
                    i.type === 1 ? (
                        e
                            .popInstruction(),
                        i.value ? t
                            .args[1] : t
                                .args[0]) :
                        e
                            .getReturnIndex()
            }
            case 32: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && i.type ===
                    1 ? (e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                ge, dS(r
                                    .value,
                                    i
                                        .value
                                ))
                ) : r
                    .type === 1 ? (e
                        .popInstruction(),
                        r.value ? t
                            .args[1] : t
                                .args[0]) :
                    i.type === 1 ? (
                        e
                            .popInstruction(),
                        i.value ? t
                            .args[0] : t
                                .args[1]) :
                        e
                            .getReturnIndex()
            }
            case 33: {
                let r = e
                    .getInstruction(
                        t.args[0]);
                return r.type ===
                    1 ? (e
                        .popInstruction(),
                        r.value ? t
                            .args[1] : t
                                .args[2]) :
                    e
                        .getReturnIndex()
            }
            case 17: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = t.index;
                return r.type ===
                    15 ? (e
                        .popInstruction(),
                        r.args[i -
                        1]) : r
                            .type === 1 && r
                                .valueType ===
                            R ? (e
                                .popInstruction(),
                                e.Constant(r
                                    .value[
                                    i -
                                    1])
                ) : e
                    .getReturnIndex()
            }
            case 18: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = t.index;
                return r.type ===
                    16 ? (e
                        .popInstruction(),
                        r.args[i -
                        1]) : r
                            .type === 1 && r
                                .valueType ===
                            V ? (e
                                .popInstruction(),
                                e.Constant(r
                                    .value[
                                    i -
                                    1])
                ) : e
                    .getReturnIndex()
            }
            case 38: {
                if (xS(e, t.args)) {
                    e
                        .popInstruction();
                    let r = [];
                    for (let i of t
                        .args) r
                            .push(e
                                .getInstruction(
                                    i)
                                .value);
                    return e
                        .ConstantOfType(
                            t
                                .valueType,
                            r)
                }
                return e
                    .getReturnIndex()
            }
            case 39:
            case 41: {
                let r = t.args[0],
                    i = e
                        .getInstruction(
                            r),
                    s = e
                        .getInstruction(
                            t.args[1]);
                if (i.type === 33 &&
                    s.type === 1) {
                    let o = t
                        .type ===
                        39 ? e
                            .ListAccess(
                                [i.args[
                                    1],
                                t
                                    .args[
                                1
                                ]
                                ]) : e
                                    .InboundsListAccess(
                                        [i.args[
                                            1],
                                        t
                                            .args[
                                        1
                                        ]
                                        ]),
                        a = t
                            .type ===
                            39 ? e
                                .ListAccess(
                                    [i.args[
                                        2],
                                    t
                                        .args[
                                    1
                                    ]
                                    ]) : e
                                        .InboundsListAccess(
                                            [i.args[
                                                2],
                                            t
                                                .args[
                                            1
                                            ]
                                            ]);
                    return e
                        .Piecewise([
                            i
                                .args[
                            0
                            ],
                            o, a
                        ])
                }
                if (i.type === 48) {
                    e
                        .popInstruction();
                    let o = i.args[
                        0],
                        a = r - o,
                        u = e
                            .getInstruction(
                                o),
                        c = u.args[
                            0],
                        l, p;
                    if (t.type ===
                        41) l = t
                            .args[1];
                    else {
                        let m = zn(
                            e, r
                        );
                        if (s
                            .type ===
                            1 && s
                                .valueType ===
                            T &&
                            m !==
                            void 0
                        ) {
                            let g =
                                q(s
                                    .value),
                                d =
                                    Math
                                        .floor(
                                            g
                                        );
                            if (d <
                                1 ||
                                d >
                                m)
                                return e
                                    .NanOfType(
                                        t
                                            .valueType
                                    );
                            l = g ===
                                d ?
                                t
                                    .args[
                                1
                                ] :
                                e
                                    .Constant(
                                        d
                                    )
                        } else {
                            let g =
                                e
                                    .Constant(
                                        1
                                    ),
                                y =
                                    e
                                        .getInstruction(
                                            c
                                        )
                                        .args[
                                    0
                                    ],
                                h =
                                    e
                                        .SyntheticNativeFunction(
                                            "floor",
                                            [t.args[
                                                1]]
                                        ),
                                b =
                                    e
                                        .GreaterEqual(
                                            [h,
                                                g]
                                        ),
                                x =
                                    e
                                        .LessEqual(
                                            [h,
                                                y]
                                        );
                            l = e
                                .Piecewise(
                                    [b, e
                                        .Piecewise(
                                            [x, h,
                                                y
                                            ]
                                        ),
                                        g
                                    ]
                                ),
                                p = {
                                    one: g,
                                    lengthIndex: y,
                                    roundedIndex: h,
                                    greaterEqualIndex: b,
                                    lessEqualIndex: x
                                }
                        }
                    }
                    if (u.args[a] <
                        c) return u
                            .args[a];
                    let f = [l];
                    for (let m = c +
                        1; m <=
                        u.args[
                        a]; m++) {
                        let g = e
                            .getInstruction(
                                m);
                        if (be(g)) f
                            .push(e
                                .copyInstruction(
                                    g
                                )
                            );
                        else {
                            let
                                d = [];
                            for (let y of
                                g
                                    .args)
                                d
                                    .push(
                                        y >=
                                            c ?
                                            f[y -
                                            c
                                            ] :
                                            y
                                    );
                            g.type ===
                                40 ?
                                f
                                    .push(
                                        e
                                            .InboundsListAccess(
                                                d
                                            )
                                    ) :
                                f
                                    .push(
                                        e
                                            .copyInstructionWithArgs(
                                                g,
                                                d
                                            )
                                    )
                        }
                    }
                    if (p) {
                        let {
                            greaterEqualIndex: m,
                            lessEqualIndex: g,
                            lengthIndex: d,
                            one: y
                        } = p, h =
                                ke(i
                                    .valueType),
                            b = e
                                .NanOfType(
                                    h),
                            x = f[f
                                .length -
                                1],
                            P = e
                                .And([e.And([m,
                                    g]),
                                e
                                    .GreaterEqual(
                                        [d,
                                            y]
                                    )
                                ]);
                        return e
                            .Piecewise(
                                [P, x,
                                    b
                                ])
                    } else return f[
                        f
                            .length -
                        1]
                } else if (s
                    .type === 1 && s
                        .valueType === T
                )
                    if (i.type ===
                        38) {
                        e
                            .popInstruction();
                        let o = Math
                            .floor(
                                q(s
                                    .value)
                            ) -
                            1;
                        return isNaN(
                            o
                        ) ||
                            o < 0 ||
                            o >= i
                                .args
                                .length ?
                            e
                                .NanOfType(
                                    t
                                        .valueType
                                ) :
                            i.args[
                            o]
                    } else if (i
                        .type === 1) {
                        e
                            .popInstruction();
                        let o = Math
                            .floor(q(s
                                .value
                            )) - 1;
                        return isNaN(
                            o) || o <
                            0 || o >= i
                                .value
                                .length ? e
                                    .NanOfType(t
                                        .valueType
                                    ) : e
                                        .ConstantOfType(
                                            ke(i
                                                .valueType),
                                            i.value[
                                            o])
                    } else return e
                        .getReturnIndex();
                else return e
                    .getReturnIndex()
            }
            case 47: {
                let r = e
                    .getInstruction(
                        t.args[0]);
                if (!Ti(r) || $y(e,
                    e
                        .getReturnIndex(),
                    r.args[0]))
                    return e
                        .getReturnIndex();
                if (NI(t
                    .valueType)) {
                    let i = e
                        .copy(),
                        s = sp(i);
                    return e
                        .popInstruction(),
                        RI(e, t
                            .valueType,
                            s)
                } else throw new Error(
                    `Constant collapsing a block with return type ${ne(t.valueType)} is not implemented.`
                )
            }
            case 55: {
                let r = e
                    .dereferenceFunctionHeader(
                        t.args[0]);
                if (r === void 0 ||
                    !xS(e, t.args
                        .slice(1)
                    ) || $y(e,
                        r, t.args[0]
                    )) return e
                        .getReturnIndex();
                if (NI(t
                    .valueType)) {
                    let i = e
                        .copy(),
                        s = sp(i);
                    return e
                        .popInstruction(),
                        RI(e, t
                            .valueType,
                            s)
                } else throw new Error(
                    `Constant collapsing a function call with return type ${ne(t.valueType)} is not implemented.`
                )
            }
            case 37:
                switch (t.symbol) {
                    case "nthroot": {
                        let r = PS(
                            e, t
                            .args
                        );
                        if (r !==
                            void 0)
                            return e
                                .Constant(
                                    wd(r[
                                        0],
                                        r[
                                        1]
                                    )
                                );
                        {
                            let i =
                                e
                                    .getInstruction(
                                        t
                                            .args[
                                        1
                                        ]
                                    );
                            if (i
                                .type ===
                                1 &&
                                i
                                    .valueType ===
                                T)
                                return e
                                    .Exponent(
                                        [t.args[
                                            0],
                                        e
                                            .Constant(
                                                _p(i
                                                    .value)
                                            )
                                        ]
                                    )
                        }
                        return e
                            .getReturnIndex()
                    }
                    case "count": {
                        let r = zn(
                            e, t
                                .args[
                        0
                        ]
                        );
                        return r !==
                            void 0 ?
                            (e.popInstruction(),
                                e
                                    .Constant(
                                        r
                                    )
                            ) :
                            e
                                .getReturnIndex()
                    }
                    case "select": {
                        let r = zn(
                            e, t
                                .args[
                        0
                        ]
                        );
                        if (r !==
                            void 0 &&
                            bt(e.getInstruction(
                                t
                                    .args[
                                1
                                ]
                            ))
                        ) {
                            e
                                .popInstruction();
                            let i =
                                ln(e,
                                    t
                                        .args[
                                    1
                                    ]
                                ),
                                s = [];
                            for (let o =
                                0; o <
                                Math
                                    .min(
                                        r,
                                        i
                                            .length
                                    ); o++
                            ) i[
                                o] &&
                                s
                                    .push(
                                        o
                                    );
                            return Zy(
                                e,
                                t
                                    .args[
                                0
                                ],
                                s
                            )
                        } else
                            return e
                                .getReturnIndex()
                    }
                    case "shuffle": {
                        let r = t
                            .args[
                            0],
                            i = t
                                .args[
                                1],
                            s = zn(
                                e, i
                            );
                        if (s !==
                            void 0 &&
                            bt(e.getInstruction(
                                r
                            ))
                        ) {
                            e
                                .popInstruction();
                            let o =
                                sI(ln(e,
                                    r),
                                    s
                                );
                            return Zy(
                                e,
                                i,
                                o
                            )
                        } else
                            return e
                                .getReturnIndex()
                    }
                    case "elementsAt": {
                        let r = t
                            .args[
                            0],
                            i = t
                                .args[
                                1];
                        if (bt(e.getInstruction(
                            i
                        ))) {
                            e
                                .popInstruction();
                            let s =
                                ln(e,
                                    i
                                );
                            return Zy(
                                e,
                                r,
                                s
                            )
                        }
                        return e
                            .getReturnIndex()
                    }
                    case "restrictionToBoolean": {
                        let r = e
                            .getInstruction(
                                t
                                    .args[
                                0
                                ]
                            );
                        return bt(
                            r) ? (e
                                .popInstruction(),
                                e
                                    .ConstantOfType(
                                        ge,
                                        r
                                            .value
                                    )
                        ) :
                            r
                                .type ===
                                37 && r
                                    .symbol ===
                                "restriction" ?
                                (e.popInstruction(),
                                    r
                                        .args[
                                    0
                                    ]
                                ) :
                                e
                                    .getReturnIndex()
                    }
                    default: {
                        let r = PS(
                            e, t
                            .args
                        );
                        return r ===
                            void 0 ?
                            e
                                .getReturnIndex() :
                            (e.popInstruction(),
                                e
                                    .ConstantOfType(
                                        t
                                            .valueType,
                                        qI(t.symbol,
                                            r
                                        )
                                    )
                            )
                    }
                }
            case 44: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return bt(r) && bt(
                    i) ? e
                        .ConstantOfType(
                            ot, UI(t
                                .tag,
                                ln(e, t
                                    .args[
                                    0
                                ]
                                ),
                                ln(e, t
                                    .args[
                                    1
                                ]
                                ))
                        ) : e
                            .getReturnIndex()
            }
            case 15: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]);
                return r.type ===
                    1 && r
                        .valueType ===
                    T && i.type ===
                    1 && i
                        .valueType ===
                    T ? e
                        .ConstantOfType(
                            R, [r.value,
                            i.value
                        ]) : e
                            .getReturnIndex()
            }
            case 16: {
                let r = e
                    .getInstruction(
                        t.args[0]),
                    i = e
                        .getInstruction(
                            t.args[1]),
                    s = e
                        .getInstruction(
                            t.args[2]);
                return r.type ===
                    1 && r
                        .valueType ===
                    T && i.type ===
                    1 && i
                        .valueType ===
                    T && s.type ===
                    1 && s
                        .valueType ===
                    T ? e
                        .ConstantOfType(
                            V, [r.value,
                            i.value,
                            s.value
                        ]) : e
                            .getReturnIndex()
            }
            case 48: {
                let r = e
                    .getReturnIndex(),
                    i = zn(e, r);
                if (i !== void 0 &&
                    i === 0)
                    return e
                        .popInstruction(),
                        e
                            .ConstantOfType(
                                t
                                    .valueType,
                                []);
                let s = t.args[0],
                    o = e
                        .getInstruction(
                            s),
                    a = o.args[0],
                    u = r - s,
                    c = o.args[u];
                if (!$y(e, c, a)) {
                    if (t
                        .valueType ===
                        wn) {
                        if (i ==
                            null)
                            throw df(
                                oi(e,
                                    r
                                )
                            );
                        let f = [];
                        for (let m =
                            0; m <
                            i; m++
                        ) {
                            let g =
                                e
                                    .InboundsListAccess(
                                        [r, e
                                            .Constant(
                                                m +
                                                1
                                            )
                                        ]
                                    );
                            f.push(
                                g)
                        }
                        return e
                            .List(f)
                    }
                    let p = mS(e,
                        r);
                    e.popInstruction(),
                        e
                            .ConstantOfType(
                                t
                                    .valueType,
                                p)
                }
                return r
            }
            case 49: {
                for (let i of t
                    .args)
                    if (!bt(e
                        .getInstruction(
                            i)))
                        return e
                            .getReturnIndex();
                e.popInstruction();
                let r = {};
                for (let i = 0; i <
                    t.symbols
                        .length; i++) {
                    let s = t
                        .symbols[i],
                        o = e
                            .getInstruction(
                                t.args[
                                i]);
                    if (o.type ===
                        48 && (o = e
                            .getInstruction(
                                Tr(e,
                                    t
                                        .args[
                                    i
                                    ]
                                )
                            )),
                        o.type !== 1
                    ) throw new Error(
                        "Expected instruction to be constant"
                    );
                    let {
                        valueType: a,
                        value: u
                    } = o;
                    Yy(a, u) || (r[
                        s] = {
                        value: u,
                        valueType: a
                    })
                }
                return e
                    .ConstantOfType(
                        rt, {
                        type: "Action",
                        updateRules: r
                    })
            }
            case 20:
            case 22:
            case 23:
            case 24:
            case 40:
            case 42:
            case 21:
            case 19:
            case 50:
            case 51:
            case 53:
            case 54:
                return e
                    .getReturnIndex();
            default:
                let n = t;
                throw new Error(
                    `Unexpected opcode ${n.type}`
                )
        }
    }

    function xS(e, t) {
        for (let n of t) {
            let r = e
                .getInstruction(n);
            if (!bt(r)) return !1
        }
        return !0
    }

    function PS(e, t) {
        let n = [];
        for (let r of t) {
            let i = e
                .getInstruction(r);
            if (bt(i)) n.push(i
                .value);
            else return
        }
        return n
    }
    var IS = {
        segment: !0,
        ray: !0,
        vector: !0,
        line: !0,
        circle: !0,
        arc: !0,
        polygon: !0,
        glider: !0,
        midpoint: !0,
        intersection: !0,
        strictintersection: !0,
        perpendicular: !0,
        parallel: !0,
        translate: !0,
        rotate: !0,
        dilate: !0,
        reflect: !0,
        apply: !0,
        segments: !0,
        vertices: !0,
        angle: !0,
        angles: !0,
        directedangle: !0,
        directedangles: !0,
        clockwise: !0,
        counterclockwise: !0,
        reflex: !0,
        start: !0,
        end: !0
    };

    function HB(e) {
        return e !== void 0 && e in
            IS
    }

    function $I(e) {
        return HB(e) ? e ===
            "rotate" || e ===
            "dilate" || e ===
            "translate" || e ===
            "reflect" ? !0 : !1 : !1
    }

    function Wy(e) {
        if (e.type ===
            "ListAccess" && e.list
                .type ===
            "Identifier" && e.index
                .type === "Constant")
            return [e.list._symbol,
            e.index
                .asValue()
            ];
        if (e.type === "Identifier")
            return [e._symbol,
            void 0
            ]
    }

    function jy(e) {
        let t = {},
            n = e;
        if ((n instanceof ga ||
            n instanceof cr) &&
            (t.identifier = n
                ._symbol, n = n
                    ._expression),
            n instanceof Ua && n
                .index instanceof Zt &&
            (t.listAccess = n.index
                .asValue(), n = n
                    .list), t
                        .identifier &&
            n instanceof ze) {
            let r = n._symbol,
                i = t.listAccess;
            t.assignmentRhsReference = [
                r, i
            ]
        }
        if (n instanceof cn) {
            let r = n._symbol,
                i = n.args[
                    0] instanceof ze ? n
                        .args[0]._symbol :
                    void 0;
            if ($I(r) &&
                e instanceof cr &&
                i && e._argSymbols
                    .some(s => s === i))
                t.tree = {
                    symbol: r,
                    parents: n.args
                        .slice(1)
                        .map(Wy)
                };
            else if (IS[r]) t
                .tree = {
                symbol: r,
                parents: n.args
                    .map(Wy)
            };
            else {
                let s = [n._symbol,
                void 0
                ];
                t.tree = {
                    symbol: "apply",
                    parents: [s,
                        ...n
                            .args
                            .map(
                                Wy
                            )
                    ]
                }
            }
        } else if (
            n instanceof xi) {
            let r = n.args.map(Wy);
            r.length === 2 && r[
                1] && r[1][0] ===
                "segments" ? t
                    .tree = {
                symbol: "segment",
                parents: [r[0]]
            } : r.length ===
                2 && r[1] && r[1][
                0] === "start" ? t
                    .tree = {
                symbol: "start",
                parents: [r[0]]
            } : r.length ===
            2 && r[1] && r[1][
            0] === "end" && (t
                .tree = {
                symbol: "end",
                parents: [r[
                    0]]
            })
        }
        return t
    }

    function Hf(e) {
        if (e.length === 0)
            return We;
        let t = e[0];
        if (t !== T && zr(t, T)) {
            let n = !1,
                r = !0;
            for (let i of e)
                if (i === T && (
                    n = !0), !
                    zr(i, T)) {
                    r = !1;
                    break
                } n && r && (t = T)
        }
        return ei(t) ? ar(t) : sn
    }
    var vc = _s([
        [T, T]
    ]),
        UB = _s([
            [{
                meta: "union",
                types: Zi
            }, {
                meta: "union",
                types: [ge,
                    T
                ]
            }]
        ]),
        YI = {
            Negative: _s([
                [T],
                [R],
                [he],
                [Se],
                [V]
            ]),
            Add: _s([
                [T, T],
                [R, R],
                [he, he],
                [Se, Se],
                [V, V]
            ]),
            Subtract: _s([
                [T, T],
                [R, R],
                [he, he],
                [Se, Se],
                [V, V]
            ]),
            Multiply: _s([
                [T, T],
                [R, T],
                [T, R],
                [T, he],
                [T, Se],
                [he, T],
                [Se, T],
                [V, T],
                [T, V],
                [Vt, {
                    meta: "union",
                    types: Qa
                }],
                [{
                    meta: "union",
                    types: Qa
                }, Vt]
            ]),
            DotMultiply: _s([
                [T, T],
                [R, T],
                [T, R],
                [he, he],
                [Se, Se],
                [T, he],
                [he, T],
                [T, Se],
                [Se, T],
                [V, T],
                [T, V],
                [V, V],
                [Vt, {
                    meta: "union",
                    types: Qa
                }],
                [{
                    meta: "union",
                    types: Qa
                }, Vt]
            ]),
            CrossMultiply: _s([
                [T, T],
                [R, T],
                [T, R],
                [he, T],
                [T, he],
                [Se, T],
                [T, Se],
                [Se, Se],
                [V, V],
                [Vt, {
                    meta: "union",
                    types: Qa
                }],
                [{
                    meta: "union",
                    types: Qa
                }, Vt]
            ]),
            Divide: _s([
                [T, T],
                [R, T],
                [he, T],
                [Se, T],
                [V, T]
            ]),
            Exponent: vc,
            "Comparator['=']": vc,
            "Comparator['>']": vc,
            "Comparator['<']": vc,
            "Comparator['>=']": vc,
            "Comparator['<=']": vc,
            ComparatorChain: _s([{
                type: "variadic",
                initial: [
                    T,
                    T
                ],
                rest: T
            }]),
            PercentOf: vc,
            NamedCoordinateAccess: _s(
                [
                    [R],
                    [V]
                ]),
            Norm: _s([
                [T],
                [R],
                [V],
                [he],
                [Se]
            ]),
            ListAccess: UB
        };

    function _s(e) {
        return e.map(ti)
    }

    function Jy(e, t, n) {
        if (t instanceof Vo) {
            let r = n.filter(s =>
                s !== void 0);
            if (r.length === 0)
                return;
            let i = Hf(r);
            return W(i) && i !==
                sn ? Ia([{
                    type: "variadic",
                    initial: [],
                    rest: ke(
                        i
                    )
                }], n) : []
        } else if (
            t instanceof cn ||
            t instanceof Wa ||
            t instanceof xi) {
            let r =
                t instanceof xi ? t
                    .args[1]._symbol : t
                    ._symbol;
            if (!r) return;
            let i = Vp(r);
            return i ? Ia(i, n) :
                void 0
        } else if (
            t instanceof hr) {
            let [r, i, s] = n, o =
                i !== void 0 &&
                    s !== void 0 ? ua(i,
                        s) : void 0;
            !o && s === T && t.args[
                2
            ] instanceof Zt &&
                t.args[2].isNaN() &&
                (s = void 0);
            let a;
            if (o !== void 0) a = o;
            else if (i !== void 0)
                a = i;
            else if (s !== void 0)
                a = s;
            else return;
            return W(a) && (a = ke(
                a)), Ia([ti([ge,
                    a, a
                ])], [n[0], i,
                    s])
        } else if (e
            .is3dProduct() &&
            t instanceof uu) {
            let r = [...YI
                .DotMultiply,
            ti([R, R])
            ];
            return Ia(r, n)
        } else if (
            t instanceof Qi) {
            let r = [{
                type: "variadic",
                initial: [
                    rt],
                rest: rt
            }, ti([T, T])];
            return e
                .is3dProduct() && r
                    .push(ti([T, T,
                        T])), Ia(r, n)
        } else if (
            t instanceof qa) {
            let r = [{
                type: "variadic",
                initial: [
                    rt],
                rest: rt
            }],
                i = n.filter(s =>
                    s !== void 0 &&
                    s !== T);
            if (i.length > 0) {
                let s = Hf(i);
                W(s) && s !== sn &&
                    r.push({
                        type: "variadic",
                        initial: [],
                        rest: ke(
                            s
                        )
                    })
            }
            return Ia(r, n)
        } else if (t.type in YI && n
            .some(r => r !== void 0)
        ) {
            let r = YI[t.type];
            return r ? Ia(r, n) :
                void 0
        }
    }

    function Ia(e, t) {
        let n = [];
        for (let r of e) Array
            .isArray(r) && r
                .length < t.length || t
                    .every((i, s) => {
                        if (i ===
                            void 0)
                            return !0;
                        let o = Uu(r,
                            s);
                        return o ===
                            void 0 ? !
                        1 : Hh(i, o)
                    }) && n.push(r);
        return n
    }

    function ES(e, t, n, r, i) {
        var h, b, x, P;
        if (!sl(t) && !il(t) || $I(
            t)) return;
        let s, o = !1,
            a = !1,
            u = 0,
            c = [],
            l = [],
            p = r.map(M => e
                .getInstruction(M)
                .valueType),
            f = sl(t) ? oo[t] :
                void 0;
        if (f && (o = f.isSeeded,
            s = void 0, c.push(
                ...f
                    .argumentTypes),
            u = (b = (h = f
                .defaultArguments
            ) == null ?
                void 0 : h
                    .length) !=
                null ? b : 0, l =
            Qy(c, p, u), a = f
                .allowDotCall),
            t === "mean" && l
                .length === 0 && p
                    .length > 0 && oe(p[0],
                        St)) c = [
                            [St]
                        ], u = 0, l = [], a = !0;
        else if (il(t) && l
            .length === 0 && !(f !=
                null && f
                    .fallthroughUnlessDistribution &&
                p.length > 0 && oe(
                    p[0], St))) {
            let M = bn[t];
            s = M.tag, c.push(...rb(
                t)), u = (P = (
                    x = M
                        .defaultArguments
                ) == null ?
                    void 0 : x
                        .length) !=
                    null ? P : 0, l =
                Qy(c, p, u), a =
                a || M.allowDotCall
        }
        let m = Math.min(...c.map(
            Ga)),
            g = Math.max(...c.map(
                Cp)),
            d = r,
            y = r;
        if (o && (y = d = r.slice(
            1), m -= 1, g -= 1),
            i) {
            if (!a) throw Wp(n);
            let M = e
                .getInstruction(d[
                    0]).valueType;
            if (!W(M) && M !== Nt &&
                M !== Se && M !==
                St && M !== mn && (
                    M === R || !Sp(
                        M)))
                throw Lb(n, ne(M));
            n = "." + n, y = d
                .slice(1), m -= 1,
                g -= 1
        }
        if (!(l.length > 0))
            throw qB(e, {
                symbol: t,
                errorSymbol: n,
                providedArgs: y,
                argsWithoutSeed: d,
                isDotCall: i,
                minArity: m,
                maxArity: g,
                defaultArgumentCount: u,
                builtInTag: s
            })
    }

    function qB(e, {
        symbol: t,
        errorSymbol: n,
        providedArgs: r,
        argsWithoutSeed: i,
        isDotCall: s,
        minArity: o,
        maxArity: a,
        defaultArgumentCount: u,
        builtInTag: c
    }) {
        if (c === "doubleReducer" &&
            r.length === 2) {
            if (!W(e.getInstruction(
                r[0])
                .valueType) || !
                W(e.getInstruction(
                    r[1])
                    .valueType))
                throw sf(t)
        } else if (c ===
            "parameterizedReducer" &&
            r.length === 2 && !W(e
                .getInstruction(r[
                    0]).valueType))
            throw NP(t);
        if (t === "logbase" && r
            .length !== 2)
            return ds("log", 1, r
                .length - 1);
        if (t === "random")
            return hx();
        if (r.length < o || r
            .length > a) {
            let {
                dotMinArityExampleArgs: p,
                dotMaxArityExampleArgs: f,
                minArityExampleArgs: m,
                maxArityExampleArgs: g
            } = $B(t), d, y;
            if (r.length < o ? (y =
                o - u, s && p ?
                    d = n + p : m &&
                    (d = n + m)) : (
                y = a, s && f ?
                    d = n + f : g &&
                    (d = n + g)),
                c === "reducer" && r
                    .length === 0)
                return Tx(n);
            if (c ===
                "doubleReducer")
                return ef(n);
            if (c ===
                "parameterizedReducer"
            ) return Px(n);
            if (c === "color")
                return xx(n);
            if (sl(t)) switch (t) {
                case "pdf":
                    return s ?
                        ds(n, y,
                            r
                                .length,
                            d) :
                        dx();
                case "cdf":
                    return s ?
                        ds(n, y,
                            r
                                .length,
                            d) :
                        r
                            .length <
                            o ?
                            mx() : yx();
                case "tdist":
                    return gx();
                case "length":
                case "round":
                case "midpoint":
                case "segment":
                case "vector":
                case "distance":
                case "circle":
                case "center":
                case "radius":
                case "glider":
                case "intersection":
                case "strictintersection":
                case "parallel":
                case "perpendicular":
                case "start":
                case "end":
                case "angle":
                case "directedangle":
                case "angles":
                case "directedangles":
                case "apply":
                case "translate":
                case "reflect":
                case "dilate":
                case "rotate":
                case "normaldist":
                case "poissondist":
                case "binomialdist":
                case "uniformdist":
                case "total":
                case "mean":
                case "median":
                case "stdev":
                case "var":
                case "quantile":
                case "sort":
                case "shuffle":
                case "join":
                case "unique":
                case "polygon":
                case "coterminal":
                    return ds(n,
                        y, r
                        .length,
                        d);
                case "points":
                case "lines":
                case "circles":
                case "polygons":
                case "rays":
                case "vectors":
                case "arcs":
                    throw Nr(n);
                case "histogram":
                case "dotplot":
                case "boxplot":
                case "ttest":
                case "ittest":
                case "stats":
                case "det":
                case "inv":
                case "transpose":
                case "rref":
                case "trace":
                    throw J(
                        `Unexpected arity error for ${t}`);
                default:
                    let h = t;
                    throw new Error(
                        `Unexpected compiler function ${h}`
                    )
            }
            return ds(n, y, r
                .length, d)
        }
        if (t === "polygon" && r
            .length === 2 && e
                .getInstruction(r[0])
                .valueType === T && e
                    .getInstruction(r[1])
                    .valueType === T)
            return Kp();
        let l = [];
        for (let p = 0; p < i
            .length; p++) {
            let f = i[p],
                m = c !== void 0 &&
                    c !==
                    "doubleReducer" &&
                    c !==
                    "never-broadcast" &&
                    !(c ===
                        "parameterizedReducer" &&
                        p === 0) &&
                    t !== "polygon",
                g = e
                    .getInstruction(f)
                    .valueType;
            W(g) && m && (g = ke(
                g)), l.push(ne(g))
        }
        return Pi(n, l)
    }

    function $B(e) {
        return sl(e) ? oo[e] : il(
            e) ? bn[e] : {}
    }

    function Qy(e, t, n) {
        return Ia(e, t).filter(r =>
            t.length + n >= Ga(
                r))
    }

    function Zo(e, t) {
        let n = [];
        for (let r of t) n.push(ne(e
            .getInstruction(
                r).valueType
        ));
        return n
    }

    function Dc(e, t) {
        let n = [];
        for (let r of t) {
            let i = e
                .getInstruction(r)
                .valueType,
                s = W(i) ? ke(i) :
                    i;
            n.push(ne(s))
        }
        return n
    }

    function Je(e, t, n) {
        return oe(e.getInstruction(
            t).valueType, n)
    }

    function lu(e, t, n, r) {
        var c, l;
        let i = n.type;
        if (i === "FunctionCall" ||
            i ===
            "SeededFunctionCall" ||
            i === "DotAccess") {
            let p, f;
            if (n instanceof xi && (
                n.args[
                1] instanceof ze ||
                n.args[
                1] instanceof cn
            )) p = n.args[1]
                ._symbol, f = (c = n
                    .args[1]
                    ._errorSymbol
                ) != null ? c :
                    p;
            else if (
                n instanceof cn ||
                n instanceof Wa) p =
                    n._symbol, f = (l =
                        n._errorSymbol
                    ) != null ? l :
                        p;
            else return;
            if (p === "polygon" && t
                .is3dPolicy())
                throw Fm();
            ES(e, p, f, r,
                n instanceof xi);
            return
        }
        let s = r.map(p => e
            .getInstruction(p)
            .valueType),
            o = Jy(t, n, s);
        if (!o) return;
        let a = Math.min(...o.map(
            Ga));
        if (o.length > 0 && r
            .length >= a) return;
        let u = YB(i, s);
        switch (i) {
            case "Add":
                throw bb(u);
            case "Subtract":
                throw xb(u);
            case "CrossMultiply":
                throw t
                    .is3dProduct() &&
                    s.length ===
                    2 && (oe(s[0],
                        R) &&
                        oe(s[1],
                            R) || oe(s[
                                0],
                                T) &&
                        oe(s[1],
                            V) || oe(s[
                                0],
                                V) &&
                        oe(s[1], T)
                    ) ? $p(u) :
                    qp(u);
            case "DotMultiply":
                throw qp(u);
            case "Multiply": {
                if (t
                    .is3dProduct() && s
                        .length === 2) {
                    if (oe(s[0],
                        V) && oe(s[
                            1],
                            V))
                        throw Xp(u);
                    if (oe(s[0],
                        R) && oe(s[
                            1],
                            R))
                        throw Yp(u)
                }
                throw qp(u)
            }
            case "Divide":
                throw Pb(u);
            case "Exponent":
                throw Tb(u);
            case "Negative":
                throw Ib(u);
            case "Comparator['=']":
            case "Comparator['>']":
            case "Comparator['<']":
            case "Comparator['>=']":
            case "Comparator['<=']":
            case "ComparatorChain":
                throw vb(u);
            case "Or":
                throw Sb(u);
            case "Piecewise":
                throw oe(s[0], ge) ?
                    Yb([ne(e.getInstruction(
                        r[
                        1]
                    )
                        .valueType
                    ),
                    ne(e.getInstruction(
                        r[
                        2]
                    )
                        .valueType
                    )
                    ]) : lm(u);
            case "Restriction":
                throw lm(u);
            case "List": {
                MS(e, r);
                break
            }
            case "ListAccess":
                throw Zp(u);
            case "Norm":
                throw Pi("abs", u);
            case "ParenSeq": {
                let p = s.indexOf(
                    rt) !== -1,
                    f = s.some(g =>
                        g !== rt);
                if (p && f)
                    throw dm([ne(s[
                        0]),
                    ne(s[
                        1])
                    ]);
                if (s.length !==
                    2 && (!t
                        .is3dProduct() ||
                        s.length !==
                        3)) {
                    let g = t
                        .is3dPolicy() ?
                        3 : 2;
                    throw Mx(g)
                }
                let m = s.find(g =>
                    !oe(g, T));
                throw m !== void 0 ?
                    Ob(ne(m)) : J(
                        "Unexpected error type checking ParenSeq"
                    )
            }
            case "BareSeq": {
                if (s.length < 2)
                    throw Nr(",");
                let p = s[0],
                    f = s.find(m =>
                        m !== p);
                if (f) throw dm([ne(
                    p),
                ne(
                    f)
                ]);
                if (p === T) throw r
                    .length ===
                    2 ? Ix() :
                    Ex();
                MS(e, r);
                break
            }
            case "Ans":
            case "Constant":
            case "Assignment":
            case "RecursiveFunctionBaseCase":
            case "MixedNumber":
            case "Identifier":
            case "Construction":
            case "Range":
            case "NamedCoordinateAccess":
            case "Sum":
            case "Product":
            case "Integral":
            case "ListComprehension":
            case "FunctionExponent":
            case "FunctionFactorial":
            case "Prime":
            case "Derivative":
            case "UpdateRule":
            case "Substitution":
            case "CoordinateEquation":
            case "FunctionDefinition":
            case "Slider":
            case "RegressionParameter":
            case "Seed":
            case "ExtendSeed":
            case "PercentOf":
                return;
            default: {
                let p = i;
                throw new Error(
                    `Unexpected node type: ${p}`
                )
            }
        }
    }

    function MS(e, t) {
        if (t.length === 0) return;
        let n = e.getInstruction(t[
            0]).valueType;
        if (!ei(n)) throw ec([ne(
            n)]);
        for (let r of t) {
            let i = e
                .getInstruction(r)
                .valueType;
            if (!ei(i)) throw ec([
                ne(i)
            ]);
            if (i !== n) throw Jp()
        }
    }

    function YB(e, t) {
        let n = r => W(r) ? ke(r) :
            r;
        switch (e) {
            case "Add":
            case "Subtract":
            case "Multiply":
            case "Divide":
            case "Exponent":
            case "Negative":
            case "Comparator['<']":
            case "Comparator['>']":
            case "Comparator['=']":
            case "Comparator['<=']":
            case "Comparator['>=']":
            case "NamedCoordinateAccess":
                return t.map(n).map(
                    ne);
            case "ComparatorChain": {
                let r = t.map(n);
                for (let i = 0; i <
                    r.length; i++)
                    if (!zr(r[i],
                        T)) return i ===
                            0 ? [ne(r[
                                i]),
                            ne(r[i +
                                1])
                        ] : [ne(r[i -
                            1
                        ]),
                        ne(r[
                            i])
                        ];
                return r.map(ne)
            }
            case "ListAccess":
            case "Constant":
            case "MixedNumber":
            case "Identifier":
            case "Ans":
            case "List":
            case "Range":
            case "Construction":
            case "ParenSeq":
            case "BareSeq":
            case "Norm":
            case "Sum":
            case "Product":
            case "Integral":
            case "ListComprehension":
            case "FunctionExponent":
            case "FunctionFactorial":
            case "Prime":
            case "Piecewise":
            case "Restriction":
            case "Derivative":
            case "UpdateRule":
            case "Substitution":
            case "Assignment":
            case "RecursiveFunctionBaseCase":
            case "CoordinateEquation":
            case "FunctionDefinition":
            case "Slider":
            case "RegressionParameter":
            case "Seed":
            case "ExtendSeed":
            case "DotMultiply":
            case "CrossMultiply":
            case "Or":
            case "PercentOf":
                return t.map(ne);
            default: {
                let r = e;
                throw new Error(
                    `Unexpected node type: ${r}`
                )
            }
        }
    }

    function vS(e, t) {
        let n = e.getInstruction(t);
        if (be(n)) return;
        let r = XI(e, n)
            .expectedTypes;
        if (n.type === 49) {
            for (let a of n.args) {
                let u = e
                    .getInstruction(
                        a)
                    .valueType;
                if (!oe(u, T) && !
                    oe(u, R) && !oe(
                        u, V) && !
                    oe(u, Ut) && !
                    oe(u, Be) && !
                    oe(u, Ie) && !
                    oe(u, fe) && !
                    oe(u, Le) && !
                    oe(u, he) && !
                    oe(u, pe) && !
                    oe(u, ce) && !
                    oe(u, Ge) && !
                    oe(u, mn) && !
                    oe(u, Ae))
                    throw jb(ne(u))
            }
            let o = {};
            for (let a of n
                .symbols) {
                if (o[a]) throw Qb(
                    a);
                o[a] = !0
            }
            return
        }
        let i = [];
        for (let o = 0; o < n.args
            .length; o++) {
            let a = e
                .getInstruction(n
                    .args[o])
                .valueType,
                u = Uu(r, o);
            (u === void 0 || !Rp(a,
                u)) && i.push(n
                    .args[o])
        }
        if (i.length === 0) return;
        let s = Zo(e, n.args);
        switch (n.type) {
            case 32:
                throw Db(s);
            case 17:
            case 18:
                throw Cb(s);
            case 21: {
                let o = e
                    .getInstruction(
                        n.args[0])
                    .valueType,
                    a = e
                        .getInstruction(
                            n.args[1])
                        .valueType;
                if (o !== T)
                    throw zb([ne(
                        o)]);
                if (a !== T)
                    throw Hb([ne(
                        a)]);
                return
            }
            case 22: {
                let o = e
                    .getInstruction(
                        n.args[1])
                    .valueType;
                throw Ub([ne(o)])
            }
            case 44: {
                if (e
                    .getInstruction(
                        n.args[0])
                    .valueType !==
                    ot || e
                        .getInstruction(
                            n.args[1])
                        .valueType !==
                    ot && e
                        .getInstruction(
                            n.args[1])
                        .valueType !== T
                ) throw J(
                    `Unexpected arg types for ExtendSeed: ${Zo(e, n.args).map(o => o.key).join(", ")}`
                );
                return
            }
            case 31:
            case 15:
            case 16:
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 38:
            case 39:
            case 40:
            case 41:
            case 37:
            case 42:
            case 33:
            case 48:
            case 47:
            case 23:
            case 24:
            case 19:
            case 20:
            case 50:
            case 51:
            case 53:
            case 54:
            case 55:
                throw J(
                    `Invalid argument types for opcode ${n.type}`);
            default: {
                let o = n;
                throw new Error(
                    `Unexpected opcode: ${o.type}`
                )
            }
        }
    }

    function XI(e, t, n = !1) {
        switch (t.type) {
            case 8:
            case 9:
            case 10:
            case 11:
                return n && t.args
                    .length > 0 && e
                        .getInstruction(
                            t.args[0])
                        .valueType ===
                    R ? {
                    expectedTypes: [
                        R, R
                    ]
                } : {
                    expectedTypes: [
                        T, T
                    ]
                };
            case 12:
            case 13:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
                return {
                    expectedTypes: [
                        T, T
                    ]
                };
            case 14:
                return {
                    expectedTypes: [
                        T
                    ]
                };
            case 31:
                return {
                    expectedTypes: [
                        ge, ge
                    ]
                };
            case 32:
                return {
                    expectedTypes: [
                        ge, ge
                    ]
                };
            case 33:
                return {
                    expectedTypes: [
                        ge, t
                            .valueType,
                        t
                            .valueType
                    ]
                };
            case 15:
            case 16:
                return {
                    expectedTypes: t
                        .args.map(
                            () => T)
                };
            case 17:
                return {
                    expectedTypes: [
                        R
                    ]
                };
            case 18:
                return {
                    expectedTypes: [
                        V
                    ]
                };
            case 21:
                return {
                    expectedTypes: [
                        T, T
                    ]
                };
            case 22: {
                let r = e
                    .getInstruction(
                        t.args[1])
                    .valueType;
                return r === R ||
                    r === V ? {
                    expectedTypes: [
                        T, r
                    ]
                } : {
                    expectedTypes: [
                        T, T
                    ]
                }
            }
            case 38: {
                let r = t.valueType,
                    i = ke(r);
                return {
                    expectedTypes: {
                        type: "variadic",
                        initial: [],
                        rest: i
                    }
                }
            }
            case 39:
            case 40:
            case 41:
                return {
                    expectedTypes: [
                        sn, T
                    ]
                };
            case 37: {
                let r = t.symbol,
                    i = bn[r],
                    s = i
                        .argumentTypes;
                if (i.tag ===
                    "reducer" && !
                    XB(e, t.args) &&
                    Array.isArray(
                        s) && typeof s[
                        0] ==
                    "number" && W(s[
                        0]))
                    return {
                        isReducerWithNoListArgs:
                            !0,
                        expectedTypes: {
                            type: "variadic",
                            initial: [],
                            rest: ke(
                                s[
                                0]
                            )
                        }
                    };
                if (Array.isArray(
                    s)) return {
                        expectedTypes: s
                    };
                {
                    let {
                        initial: o,
                        rest: a
                    } = s, u = t
                        .args
                        .length - o
                            .length,
                        c = [...o];
                    for (let l =
                        0; l <
                        u; l++) c
                            .push(a);
                    return {
                        expectedTypes: c
                    }
                }
            }
            case 44:
                return e
                    .getInstruction(
                        t.args[0])
                    .valueType ===
                    ot && e
                        .getInstruction(
                            t.args[1])
                        .valueType !==
                    ot ? {
                    expectedTypes: [
                        ot,
                        T
                    ]
                } : {
                    expectedTypes: t
                        .args
                        .map(
                            r =>
                                e
                                    .getInstruction(
                                        r
                                    )
                                    .valueType
                        )
                };
            case 47:
                return {
                    expectedTypes: t
                        .args.map(
                            r => e
                                .getInstruction(
                                    r)
                                .valueType
                        )
                };
            case 23:
                return {
                    expectedTypes: [
                        T
                    ]
                };
            case 19:
                return {
                    expectedTypes: t
                        .args.map(
                            r => {
                                let i =
                                    e
                                        .getInstruction(
                                            r
                                        )
                                        .valueType;
                                return i ===
                                    ge ||
                                    t
                                        .callData
                                        .type ===
                                    "sum" &&
                                    (i ===
                                        R ||
                                        i ===
                                        V
                                    ) ?
                                    i :
                                    T
                            })
                };
            case 50: {
                let r = t.callData
                    .parameterSymbols
                    .length,
                    i = [];
                for (let s = 0; s <
                    r; s++) i.push(
                        T, T);
                return {
                    expectedTypes: i
                }
            }
            case 24:
            case 20:
            case 51: {
                let r = [T];
                for (let i = 1; i <
                    t.args
                        .length; i++) r
                            .push(e
                                .getInstruction(
                                    t.args[
                                    i])
                                .valueType);
                return {
                    expectedTypes: r
                }
            }
            case 42:
                return {
                    expectedTypes: t
                        .args.map(
                            () => T)
                };
            case 48:
            case 49:
                return {
                    expectedTypes: t
                        .args.map(
                            r => e
                                .getInstruction(
                                    r)
                                .valueType
                        )
                };
            case 53:
                return {
                    expectedTypes: [
                        t
                            .valueType
                    ]
                };
            case 54:
                return {
                    expectedTypes: t
                        .args.map(
                            r => e
                                .getInstruction(
                                    r)
                                .valueType
                        )
                };
            case 55:
                return {
                    expectedTypes: t
                        .args.map(
                            r => e
                                .getInstruction(
                                    r)
                                .valueType
                        )
                };
            default: {
                let r = t;
                throw new Error(
                    `Unexpected opcode: ${r.type}`
                )
            }
        }
    }

    function XB(e, t) {
        for (let n of t)
            if (W(e.getInstruction(
                n)
                .valueType))
                return !0;
        return !1
    }
    var tg = ZI({
        sin: Pn(
            "isinf(x) || isnan(x) ? NaN : dcg_isPiMultiple(abs(x)) ? 0.0 : sin(x)"),
        cos: Pn(
            "isinf(x) || isnan(x) ? NaN : dcg_isOddHalfPiMultiple(abs(x)) ? 0.0 : cos(x)"),
        tan: Vi(Ye`float a=abs(x);
    return isinf(x) || isnan(x) ? NaN
      : dcg_isPiMultiple(a) ? 0.0
      : dcg_isOddHalfPiMultiple(a) ? Infinity
      : tan(x);`),
        cot: Vi(Ye`float a=abs(x);
      return isinf(x) || isnan(x) ? NaN
        : a < 0.03 ? 1.0/x - x/3.0
        : dcg_isPiMultiple(a) ? Infinity
        : dcg_isOddHalfPiMultiple(a) ? 0.0
        : 1.0 / tan(x);`),
        sec: Pn(
            "isinf(x) || isnan(x) ? NaN : dcg_isOddHalfPiMultiple(abs(x)) ? Infinity: 1.0 / cos(x)"),
        csc: Vi(Ye`float a=abs(x);
      return isinf(x) || isnan(x) ? NaN
        : a < 0.03 ? 1.0/x + x/6.0
        : dcg_isPiMultiple(a) ? Infinity
        : 1.0 / sin(x);`),
        arcsin: Vi(
            Ye`if (isinf(x) || isnan(x)) { return NaN; }
    if (x == 1.0) { return dcg_PI/2.0; }
    if (x == -1.0) { return -dcg_PI/2.0; }
    if (x > 1.0 || x < -1.0) return NaN;
    float y0 = asin(x);
    return 90 + y0 + (x - sin(y0)) / cos(y0);`
        ),
        arccos: Vi(
            Ye`if (isinf(x) || isnan(x)) { return NaN; }
    if (x == 1.0) { return 0.0; }
    if (x == -1.0) { return dcg_PI; }
    if (x > 1.0 || x < -1.0) return NaN;
    float y0 = acos(x);
    return y0 + (cos(y0) - x) / sin(y0);`
        ),
        arctan: Ky(Ye`isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) ?
        (y > 0.0 ? 0.25 : 0.75) * sign(x) * dcg_PI
      : x == 0.0 && y == 0.0 ? y
      : atan(x, y)
    `),
        arccot: Pn(
            "isnan(x) ? NaN : dcg_PI/2.0 - atan(x)"
        ),
        arcsec: Pn(
            "isnan(x) ? NaN : dcg_arccos(1.0/x)"
        ),
        arccsc: Pn(
            "isnan(x) ? NaN : dcg_arcsin(1.0/x)"
        ),
        sinh: Pn(
            "isinf(x) ? x : isnan(x) ? NaN : sinh(x)"
        ),
        cosh: Pn(
            "isinf(x) ? Infinity : isnan(x) ? NaN : cosh(x)"
        ),
        tanh: Pn(
            "abs(x) > 10.0 ? sign(x) : isnan(x) ? NaN : tanh(x)"
        ),
        coth: Pn(
            "abs(x) > 10.0 ? sign(x) : isnan(x) ? NaN : x == 0.0 ? Infinity : abs(x) < 0.03 ? 1.0/x + x/3.0 : 1.0/tanh(x)"
        ),
        sech: Pn(
            "isinf(x) ? 0.0 : isnan(x) ? NaN : 1.0/cosh(x)"
        ),
        csch: Pn(
            "isinf(x) ? 0.0 : isnan(x) ? NaN : x == 0.0 ? Infinity : abs(x) < 0.03 ? 1.0/x - x/6.0 : 1.0/sinh(x)"
        ),
        arcsinh: Vi(Ye`float a=abs(x);
      return isnan(x) ? NaN : sign(x) * (
        1.0 + x * x == 1.0
          ? dcg_log1p(a)
          : log(a + dcg_rtxsqpone(a))
      );`),
        arccosh: Pn(
            "x < 1.0 || isnan(x) ? NaN : log(x + dcg_rtxsqmone(x))"
        ),
        arctanh: Vi(
            Ye`if (isnan(x) || abs(x) > 1.0) { return NaN; }
      if (x == 1.0) { return Infinity; }
      if (x == -1.0) { return -Infinity; }
      float y0 = 0.5*(dcg_log1p(x) - dcg_log1p(-x));
      float c = cosh(y0);
      return y0 + (x - tanh(y0)) * c * c;`
        ),
        arccoth: Pn(
            "isnan(x) ? NaN : abs(x) >= 1.0 ? dcg_arctanh(1.0/x) : NaN"
        ),
        arcsech: Pn(
            "isnan(x) ? NaN : 0.0 < x && x <= 1.0 ? dcg_arccosh(1.0/x) : x == 0.0 ? Infinity : NaN"
        ),
        arccsch: Pn(
            "isinf(x) ? 0.0 : isnan(x) ? NaN : dcg_arcsinh(1.0/x)"
        ),
        sinpiSeries: Vi(
            Ye`float xsq = x*x;
    return x*(dcg_PI-xsq*(5.167708-xsq*(2.549761-xsq*0.5890122)));`
        ),
        sinpi: Vi(Ye`if (isnan(x) || isinf(x)) { return NaN; }
    if (x==0.0) { return x; }
    if (x == floor(x)) { return x > 0.0 ? 0.0 : -0.0; }
    int i = int(dcg_round(2.0*x));
    float t = -0.5 * float(i) + x;
    float s = bool(i & 2) ? -1.0 : 1.0;
    float y = bool(i & 1) ? cos(dcg_PI * t) : dcg_sinpiSeries(t);
    return s*y;`),
        sincpi: Pn(
            "isnan(x) ? NaN : isinf(x) ? 0.0 : x == 0.0 ? 1.0 : dcg_sinpi(x)/(dcg_PI*x);"
        ),
        sqrt: Pn(
            "isnan(x) ? NaN : x >= 0.0 ? sqrt(x) : NaN"
        ),
        rtxsqpone: Pn(
            "dcg_hypot(x, 1.0)"
        ),
        rtxsqmone: Vi(
            "float t = x*x; return isnan(x) || t < 1.0 ? NaN : t - 1.0 == t ? abs(x) : sqrt(t - 1.0);"
        ),
        nthroot: Ky(
            "isnan(x) || isnan(y) ? NaN : dcg_pow(x, 1.0/y)"
        ),
        hypot: AS(
            Ye`if (isnan(x) || isnan(y)) return NaN;
      if (isinf(x) || isinf(y)) return Infinity;
      x = abs(x);
      y = abs(y);
      float m = max(x,y);
      x /= m;
      y /= m;
      return m == 0.0 ? 0.0 : sqrt(x*x + y*y) * m;`
        ),
        log: Pn(
            "isnan(x) ? NaN : x > 0.0 ? log(x)*0.4342944819 : x == 0.0 ? -Infinity : NaN"),
        logbase: Ky(Ye`isnan(x) || isnan(y) ? NaN
      : y == 1.0 ?
        (
          x > 1.0 ? Infinity
          : x == 1.0 ? NaN
          : x < 0.0 ? NaN
          : -Infinity
        )
      : y > 0.0 ?
        (
          x > 0.0 ? log(x)/log(y)
          : x == 0.0 && !isinf(y) ? -Infinity
          : NaN
        )
      : NaN`),
        ln: Pn(
            "isnan(x) ? NaN : x > 0.0 ? log(x) : x == 0.0 ? -Infinity : NaN"),
        exp: Pn(
            "isnan(x) ? NaN : exp(x)"),
        floor: Pn(
            "isnan(x) ? NaN : floor(x)"
        ),
        ceil: Pn(
            "isnan(x) ? NaN : ceil(x)"
        ),
        round: Pn(
            "isinf(x) || isnan(x) ? x : floor(0.5 + x)"
        ),
        abs: Pn(
            "isnan(x) ? NaN : abs(x)"),
        sign: Pn(
            "isnan(x) ? NaN : sign(x)"
        ),
        mod: Ky(
            "isinf(x) || isinf(y) || isnan(x) || isnan(y) || y == 0.0 ? NaN : mod(x, y)"),
        stirlingPrefactor: Ea(
            "float",
            "float x, float y",
            Ye`if (isnan(x) || isnan(y)) { return NaN; }
    return pow(x/exp(1.0), y);`),
        stirlerrSeries: Vi(
            Ye`float S0 = 0.083333336;
    float S1 = 0.0027777778;
    float S2 = 0.0007936508;
    float nn = x*x;
    return (S0-(S1-S2/nn)/nn)/x;`),
        factorialAsymptotic: Pn(
            "dcg_stirlingPrefactor(x,x)*sqrt(2.0*dcg_PI*x)*exp(dcg_stirlerrSeries(x))"
        ),
        factorialMinimax: Vi(
            Ye`float n1 = 2.1618295;
    float n2 = 1.5849807;
    float n3 = 0.4026814;
    float d1 = 2.2390451;
    float d2 = 1.6824219;
    float d3 = 0.43668285;

    float n = 1.0 + x*(n1 + x*(n2 + x*n3));
    float d = 1.0 + x*(d1 + x*(d2 + x*d3));
    float xp1 = x+1.0;

    return dcg_stirlingPrefactor(xp1,x)*sqrt(xp1)*(n/d);
    `),
        factorialPositive: Pn(
            Ye`(x>33.0)?Infinity:(x>8.0)?dcg_factorialAsymptotic(x):dcg_factorialMinimax(x);`
        ),
        factorial: Vi(
            Ye`if (isnan(x) || (isinf(x) && x < 0.0)) { return NaN; }
    bool isInteger = x == floor(x);
    if (x < 0.0) {
      if (isInteger) return Infinity;
      return 1.0 / (dcg_sincpi(x) * dcg_factorialPositive(-x));
    }
    float approx = dcg_factorialPositive(x);
    return isInteger ? dcg_round(approx) : approx;`
        ),
        distance: Ea(
            "float",
            "vec2 a, vec2 b",
            Ye`
      if (any(isnan(a)) || any(isnan(b))) return NaN;
      vec2 d = a-b;
      return dcg_hypot(d.x, d.y);`),
        distanceThreeD: Ea(
            "float",
            "vec3 a, vec3 b",
            Ye`
      if (any(isnan(a)) || any(isnan(b))) return NaN;
      vec3 d = a-b;
      return dcg_hypot(dcg_hypot(d.x, d.y), d.z);`
        ),
        hsv: Ea("vec3",
            "float h, float s, float v",
            Ye`if (isnan(h) || isnan(s) || isnan(v)) {discard;}
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      if (isinf(h)) h = 0.0;
      vec3 p = abs(fract(h / 360.0 + K.xyz) * 6.0 - K.www);
      return vec3(clamp(v, 0.0, 1.0) * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), clamp(s, 0.0, 1.0)));`
        ),
        rgb: Ea("vec3",
            "float r, float g, float b",
            Ye`if (isnan(r) || isnan(g) || isnan(b)) {discard;}
    return clamp(vec3(r,g,b),0.0,255.0)/255.0;`
        ),
        erf: Vi(Ye`if (isnan(x)) return NaN;
      float t = abs(x);
      float n = x*x;
      float r = -n;
      return sign(x) * (
        r < -750.0
          ? 1.0
          : t >= 0.065
          ? 1.0 - exp(r) * (
            t > 50000000.0
              ? r / t
              : t > 50.0
              ? (r * (n * (n + 4.5) + 2.0)) / (t * (n * (n + 5.0) + 3.75))
              : ((0.9999999999999999+t*(2.224574423459406+t*(2.444115549920689+
                t*(1.7057986861852539+t*(0.8257463703357973+
                  t*(0.28647031042892007+t*(0.07124513844341643+
                    t*(0.012296749268608364+t*(0.001347817214557592+
                      0.00007263959403471071*t))))))))
                )/(1.0+t*(3.352953590554884+t*(5.227518529742423+
                  t*(5.003720878235473+t*(3.266590890998987+
                    t*(1.5255421920765353+t*(0.5185887413188858+
                      t*(0.12747319185915415+t*(0.02185979575963238+
                        t*(0.0023889438122503674+0.00012875032817508128*t
                ))))))))))
              )
          )
          : t*(1.1283791670955126+r*(0.37612638903183754+
              r*(0.11283791670955126+r*(0.026866170645131252+
                0.005223977625442188*r))))
      );`),
        restriction: Ea(
            "bool",
            "bool x",
            "return x;"
        ),
        restrictionToBoolean: Ea(
            "bool",
            "bool x",
            "return x;")
    });

    function Ea(e, t, n) {
        return {
            type: "scalar",
            value: `${e} dcg_[[name_here]](${t}){ ${n} }`
        }
    }

    function Vi(e) {
        return Ea("float",
            "float x", e)
    }

    function Pn(e) {
        return Vi(`return ${e};`)
    }

    function AS(e) {
        return Ea("float",
            "float x, float y",
            e)
    }

    function Ky(e) {
        return AS(`return ${e};`)
    }

    function Fi(e, {
        outType: t,
        deps: n
    } = {}) {
        let r = t != null ? t :
            () => "float";
        return {
            type: "reducer",
            value: i =>
                `${r(i)} dcg_[[name_here]](float[${i}] L) { ${e(i)} }`,
            deps: n != null ? n : []
        }
    }

    function eg(e, t = () =>
        "float") {
        return {
            type: "double-reducer",
            value: (n, r) => {
                let i = Math
                    .min(n, r),
                    s = t(i),
                    o = e(i);
                return `${s} dcg_[[name_here]](float[${n}] X, float[${r}] Y) { ${o} }`
            }
        }
    }
    var ZB = ZI({
        lcm: Fi(e => Ye`float g = abs(dcg_round(L[0]));
      if (isinf(g)) return Infinity;
      if (isnan(g)) return NaN;
      for (int i=1; i<${e}; i++) {
        float v = abs(dcg_round(L[i]));
        if (isinf(v)) return Infinity;
        if (isnan(v)) return NaN;
        g *= dcg_round(v / dcg_gcd2(g, v));
      }
      return g;`),
        gcd: Fi(e => Ye`float g = abs(dcg_round(L[0]));
      if (isnan(g)) return NaN;
      for (int i=1; i<${e}; i++) {
        float x = L[i];
        if (isnan(x)) return NaN;
        g = dcg_gcd2(g, abs(dcg_round(x)));
      }
      return g;`),
        mean: Fi(e => Ye`float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || (isinf(x) && x == -tot)) return NaN;
        tot += x;
      }
      return tot / ${e}.0;`),
        total: Fi(e => Ye`float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        float x = L[i];
        if (isnan(x) || (isinf(x) && x == -tot)) return NaN;
        tot += x;
      }
      return tot;`),
        stdev: Fi(e => SS(e,
            e - 1
        ), {
            deps: [
                "mean"]
        }),
        stdevp: Fi(e => SS(
            e, e), {
            deps: [
                "mean"]
        }),
        mad: Fi(e => Ye`float mean = dcg_mean(L);
      if (isnan(mean) || isinf(mean)) return NaN;
      float tot = 0.0;
      for (int i=0; i<${e}; i++) {
        tot += abs(L[i] - mean);
      }
      return tot / ${e}.0;`, {
            deps: [
                "mean"]
        }),
        min: Fi(e => OS(e,
            "min")),
        max: Fi(e => OS(e,
            "max")),
        argmin: Fi(e => CS(
            e, "<")),
        argmax: Fi(e => CS(
            e, ">="
        )),
        median: Fi(e => e %
            2 === 1 ?
            `return L[int(dcg_sortPerm(L)[${(e - 1) / 2}])-1];` :
            Ye`float[${e}] perm = dcg_sortPerm(L);
          return 0.5*(L[int(perm[${e / 2}])-1]+L[int(perm[${e / 2 - 1}])-1]);`, {
            deps: [
                "sortPerm"]
        }),
        varp: Fi(e => DS(e,
            e), {
            deps: [
                "mean"]
        }),
        var: Fi(e => DS(e,
            e - 1
        ), {
            deps: [
                "mean"]
        }),
        sortPerm: Fi(e => {
            if (e >
                100)
                throw pl();
            return Ye`int[${e}] perm;
        int[${e}] nextPerm;
        for (int i=0; i<${e}; i++)
          perm[i] = i;
        float lastMin = -Infinity;
        int lastIndex = -1;
        for (int i=0; i<${e}; i++) {
          float currMin = Infinity;
          int currIndex = -1;
          int j;
          for (j=0; j<${e}; j++) {
            float e = L[j];
            if (
              (e > lastMin || (e == lastMin && j > lastIndex))
              && e < currMin
            ) {
              currMin = e;
              currIndex = j;
            }
          }
          perm[i] = currIndex;
          lastMin = currMin;
          lastIndex = currIndex;
        }
        float[${e}] permFloat;
        for (int i=0; i<${e}; i++)
          permFloat[i] = float(perm[i] + 1);
        return permFloat;`
        }, {
            outType: e =>
                `float[${e}]`
        })
    });

    function DS(e, t) {
        return t === 0 ?
            "return NaN;" : Ye`float mean = dcg_mean(L);
    if (isnan(mean) || isinf(mean)) return NaN;
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      float delta = L[i] - mean;
      tot += delta * delta;
    }
    return tot / ${t}.0;`
    }

    function SS(e, t) {
        return t === 0 ?
            "return NaN;" : Ye`float mean = dcg_mean(L);
    if (isnan(mean) || isinf(mean)) return NaN;
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      tot = dcg_hypot(tot, L[i] - mean);
    }
    return tot / ${WI(Math.sqrt(t))};`
    }

    function OS(e, t) {
        return Ye`float m = L[0];
    if (isnan(m)) return NaN;
    for (int i=1; i<${e}; i++) {
      float x = L[i];
      if (isnan(x)) return NaN;
      m = ${t}(m, x);
    }
    return m;`
    }

    function CS(e, t) {
        return Ye`if (isnan(L[0])) return 0.0;
    int arg = 0;
    float best = L[0];
    for (int i=1; i<${e}; i++) {
      float e = L[i];
      if (isnan(e)) return 0.0;
      if (e ${t} best) {
        arg = i;
        best = e;
      }
    }
    return float(arg + 1);`
    }
    var WB = ZI({
        elementsAt: eg(e => `float[${e}] outList;
      for (int i=0; i<${e}; i++) {
        float y = Y[i];
        outList[i] = isnan(y) || isinf(y) ? NaN : X[int(y)-1];
      }
      return outList;`, e =>
            `float[${e}]`
        ),
        cov: eg(e => RS(e,
            e - 1)),
        covp: eg(e => RS(e,
            e)),
        corr: eg(e => Ye`${_S(e)}
      float t1 = 0.0;
      float t2 = 0.0;
      float tc = 0.0;
      for (int i=0; i<${e}; i++) {
        float d1 = X[i] - m1;
        float d2 = Y[i] - m2;
        t1 = dcg_hypot(t1, d1);
        t2 = dcg_hypot(t2, d2);
        tc += d1 * d2;
      }
      return tc / (t1 * t2);`)
    }),
        jB = {
            ...tg,
            ...ZB,
            ...WB
        },
        ng = jB;

    function JB(e, t) {
        switch (e.type) {
            case "scalar":
                return e.value
                    .replace(
                        "[[name_here]]",
                        t);
            case "reducer": {
                let n = e.value;
                return r => n(r)
                    .replace(
                        "[[name_here]]",
                        t)
            }
            case "double-reducer": {
                let n = e.value;
                return (r, i) => n(
                    r, i)
                    .replace(
                        "[[name_here]]",
                        t)
            }
        }
    }

    function ZI(e) {
        for (let [t, n] of Object
            .entries(e)) n.type !==
                "omitted" && (n.value =
                    JB(n, t));
        return e
    }

    function RS(e, t) {
        return Ye`${_S(e)}
    float tot = 0.0;
    for (int i=0; i<${e}; i++) {
      tot += (X[i] - m1) * (Y[i] - m2);
    }
    return tot / ${t}.0;`
    }

    function _S(e) {
        return Ye`float m1 = 0.0;
    for (int i=0; i<${e}; i++) {
      float x = X[i];
      if (isnan(x) || isinf(x)) return NaN;
      m1 += x;
    }
    m1 /= ${e}.0;
    float m2 = 0.0;
    for (int i=0; i<${e}; i++) {
      float y = Y[i];
      if (isnan(y) || isinf(y)) return NaN;
      m2 += y;
    }
    m2 /= ${e}.0;`
    }
    var QB = [Ye`float dcg_rawpow(float x, float y) {
    if (isnan(x) || isnan(y)) return NaN;
    if (isinf(y)) {${""}
      float a = abs(x);
      if (a == 1.0) return NaN;
      if (y > 0.0) {
        return a > 1.0 ? Infinity : 0.0;
      } else {
        return a < 1.0 ? Infinity : 0.0;
      }
    }
    if (x > 0.0) return pow(x, y);
    else if (x == 0.0) {
      if (y > 0.0) return 0.0;
      else if (y == 0.0) return 1.0;
      else return Infinity;
    } else {
      float m = mod(y, 2.0);
      if (m == 1.0) return -pow(-x, y);
      else return pow(-x, y);
    }
  }`, Ye`float dcg_pow(float x, float y) {
    if (isnan(x) || isnan(y)) return NaN;
    if (isinf(y)) {
      float a = abs(x);
      if (a == 1.0) return NaN;
      if (y > 0.0) {
        return a > 1.0 ? Infinity : 0.0;
      } else {
        return a < 1.0 ? Infinity : 0.0;
      }
    }
    if (x > 0.0) return pow(x,y);
    else if (x == 0.0) {
      if (y > 0.0) return 0.0;
      if (y == 0.0) return 1.0;
      if (y < 0.0) return Infinity;
    } else {
      float m = mod(y, 2.0);
      if (m == 0.0) return pow(-x, y);
      else if (m == 1.0) return -pow(-x, y);
      else {${""}
        vec2 a0 = vec2(0.0, 1.0);
        vec2 a1 = vec2(1.0, 0.0);
        float approx = y;
        for (int i=0; i<12; i+=1) {
          float whole = floor(approx);
          vec2 a = whole * a1 + a0;
          if (a.y > 100.0) break;
          a0 = a1; a1 = a;
          if (approx == whole) break;
          approx = 1.0 / (approx - whole);
        }${""}
        float r = a1.x / a1.y;
        float m = max(max(abs(y), abs(r)), 1.0);
        if (abs(mod(a1.y, 2.0) - 1.0) < 0.01 && abs((r - y)/y) < 0.00001) {
          return (mod(a1.x, 2.0) == 0.0 ? 1.0 : -1.0) * pow(-x, y);
        } else {
          return NaN;
        }
      }
    }
  }`, Ye`float dcg_add(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) && x != y ? NaN
      : x + y;
  }`, Ye`float dcg_sub(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) && x != -y ? NaN
      : x - y;
  }`, Ye`float dcg_mul(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && y == 0.0 ? NaN
      : x == 0.0 && isinf(y) ? NaN
      : x * y;
  }`, Ye`float dcg_div(float x, float y) {
    return isnan(x) || isnan(y) ? NaN
      : isinf(x) && isinf(y) ? NaN
      : x == 0.0 && y == 0.0 ? NaN
      : x / y;
  }`, Ye`float dcg_neg(float x) {
    return isnan(x) ? NaN : -x;
  }`, Ye`bool dcg_equal(float x, float y) {
    return isnan(x) || isnan(y) ? false : x == y;
  }`, Ye`bool dcg_less(float x, float y) {
    return isnan(x) || isnan(y) ? false : x < y;
  }`, Ye`bool dcg_lessEqual(float x, float y) {
    return isnan(x) || isnan(y) ? false : x <= y;
  }`, Ye`bool dcg_greater(float x, float y) {
    return isnan(x) || isnan(y) ? false : x > y;
  }`, Ye`bool dcg_greaterEqual(float x, float y) {
    return isnan(x) || isnan(y) ? false : x >= y;
  }`, Ye`float dcg_gcd2(float u, float v) {
    if (isinf(u)) return v;
    if (isinf(v)) return u;
    for (int i=0; i<95; i++) {
      if (v == 0.0) break;
      u = mod(u, v);
      if (u == 0.0) break;
      v = mod(v, u);
    }
    return u+v;
  }`, Ye`float dcg_log1p(float x) {
    return x - 0.5 * x * x == x ? x : log(1.0 + x);
  }`, Ye`bool dcg_isPiMultiple(float absx) {
    if (absx > 1.0e5) return false;
    return floor(0.5 + dcg_PI_INV * absx) * dcg_PI == absx;
  }`, Ye`bool dcg_isOddHalfPiMultiple(float absx) {
    if (absx > 1.0e5) return false;
    float n = floor(0.5 + 2.0 * dcg_PI_INV * absx);
    return mod(n, 2.0) == 1.0 && n * dcg_PI == 2.0 * absx;
  }`].join(`
`),
        NS = ["round", "hypot",
            "rtxsqpone", "rtxsqmone"
        ],
        KB = NS.map(e => tg[e]
            .value).join(`
`) + Object.keys(tg).filter(e => NS
                .indexOf(e) === -1).map(
                    e => tg[e].value).join(`
`),
        L7 = Ye`uniform float NaN;
    uniform float Infinity;
    #define dcg_PI 3.141592653589793
    #define dcg_PI_INV 0.3183098861837907
    ${QB}\n` + KB;

    function Ye(e, ...t) {
        let n = e[0];
        for (let r = 0; r < t
            .length; r++) n += t[r],
                n += e[r + 1];
        return e3(n)
    }

    function e3(e) {
        let t = e.split(`
`);
        if (/^\s/.test(t[0][0]))
            throw new Error(
                "Programming error: Expected un-indented first line"
            );
        if (t.length <= 1) return e;
        let n = Math.min(...t.slice(
            1).map(r => r
                .match(/^\s*/)[
                0].length));
        return t[0] + `
` + t.slice(1).map(r => r.slice(n))
                .join(`
`)
    }

    function Wo(e, t) {
        let n = new jI(e, t),
            r = uy(n);
        return n.finish(r)
    }
    var jI = class extends wl {
        constructor(n, r) {
            super(n, !0);
            this.maxUniforms =
                r;
            this.glsl = !0;
            this
                .shaderUniforms = [];
            this.definitions = {}
        }
        finish(n) {
            return {
                source: n,
                shaderFunctions: t3(
                    this
                        .chunk,
                    this
                        .definitions
                ),
                shaderUniforms: this
                    .shaderUniforms
            }
        }
        printValue(n, r) {
            if (Array
                .isArray(n)
            ) {
                if (n
                    .length >
                    100)
                    throw pl();
                let i = W(
                    r),
                    s = i ?
                        ke(r) :
                        r,
                    o = n
                        .map(
                            c =>
                                this
                                    .printValue(
                                        c,
                                        s
                                    )
                        )
                        .join(
                            ","
                        ),
                    a = rg(
                        r),
                    u = LS({
                        type: a,
                        arity: n
                            .length
                    });
                return this
                    .definitions[
                    u
                ] = !
                    0, (i ?
                        "buildList" :
                        a) +
                    "(" +
                    o + ")"
            }
            switch (
            typeof n) {
                case "boolean":
                    return n
                        .toString();
                case "number":
                    return this
                        .printFloatOrUniformGLSL(
                            n
                        );
                case "string":
                    throw ll(
                        "random"
                    );
                case "object":
                    if (Ja(
                        n))
                        throw new Error(
                            "Action values cannot be compiled"
                        );
                    return this
                        .printFloatOrUniformGLSL(
                            q(
                                n)
                        );
                default:
                    throw new Error(
                        "Unexpected value: " +
                        n
                    )
            }
        }
        printFloatOrUniformGLSL(
            n) {
            if (this
                .shaderUniforms
                .length >=
                this
                    .maxUniforms
            ) return WI(
                n);
            {
                let i =
                    "_DCG_SC_" +
                    this
                        .shaderUniforms
                        .length;
                return this
                    .shaderUniforms
                    .push(
                        n), i
            }
        }
        beforeBeginLoop(n) {
            let r = this
                .chunk
                .getInstruction(
                    n.args[
                    0]),
                i = this
                    .chunk
                    .getInstruction(
                        n.args[
                        1]),
                s = n
                    .callData
                    .type ===
                    "sum";
            if (r.type !==
                1) {
                let u = oi(
                    this
                        .chunk,
                    n
                        .args[
                    0
                    ]
                );
                throw s ?
                    mm(u) :
                    ym(u)
            }
            if (i.type !==
                1) {
                let u = oi(
                    this
                        .chunk,
                    n
                        .args[
                    1
                    ]
                );
                throw s ?
                    mm(u) :
                    ym(u)
            }
            if (r
                .valueType !==
                T || i
                    .valueType !==
                T) throw new Error(
                    "Programming error: non-number in summation bounds"
                );
            let o = q(r
                .value),
                a = q(i
                    .value);
            if (!isFinite(
                a - o
            ) || a -
            o >= 1e3)
                throw s ?
                    cx() :
                    lx()
        }
        checkFiniteBounds() {
            return ""
        }
        emitConstant(n) {
            return this
                .printValue(
                    n.value,
                    n
                        .valueType
                )
        }
        emitNeg(n) {
            return `dcg_neg(${n})`
        }
        emitTernary(n, r, i,
            s) {
            return W(s
                .valueType
            ) ?
                `dcg_ternary(${n},${r},${i})` :
                `${n}?${r}:${i}`
        }
        emitVec2(n, r) {
            return `vec2(${n},${r})`
        }
        emitVec3(n, r, i) {
            return `vec3(${n},${r},${i})`
        }
        emitVecAccess(n, r) {
            return `${n}.${r === 1 ? "x" : r === 2 ? "y" : "z"}`
        }
        emitBinary(n, r, i) {
            switch (n
                .type) {
                case 8:
                    return `dcg_add(${r},${i})`;
                case 9:
                    return `dcg_sub(${r},${i})`;
                case 10:
                    return `dcg_mul(${r},${i})`;
                case 11:
                    return `dcg_div(${r},${i})`;
                case 12:
                    return `dcg_pow(${r},${i})`;
                case 13:
                    return `dcg_rawpow(${r},${i})`;
                case 25:
                    return `dcg_equal(${r},${i})`;
                case 26:
                    return `dcg_less(${r},${i})`;
                case 28:
                    return `dcg_lessEqual(${r},${i})`;
                case 27:
                    return `dcg_greater(${r},${i})`;
                case 29:
                    return `dcg_greaterEqual(${r},${i})`;
                case 31:
                    return `${r}||${i}`;
                case 32:
                    return `${r}&&${i}`;
                default:
                    throw new Error(
                        "Programming Error: invalid binary opcode."
                    )
            }
        }
        emitList(n, r) {
            let i = LS({
                type: rg(
                    r
                        .valueType
                ),
                arity: r
                    .args
                    .length
            });
            return this
                .definitions[
                i] = !0,
                `buildList(${n.join(",")})`
        }
        emitListAccess(n, r, i,
            s) {
            let o = zn(this
                .chunk,
                s.args[
                0]);
            if (o ===
                void 0)
                throw tc(oi(this
                    .chunk,
                    s
                        .args[
                    0
                    ]
                ));
            let a =
                `int(${r})`;
            return `(${a}>=1&&${a}<=${o})?${n}[${a}-1]:${i}`
        }
        emitInboundsListAccess(
            n, r) {
            return `${n}[int(${r})-1]`
        }
        emitNativeFunction(n,
            r) {
            if (!ng[r
                .symbol])
                throw ll(r
                    .symbol
                );
            return `dcg_${r.symbol}(${n.join(",")})`
        }
        emitExtendSeed() {
            throw ll(
                "random"
            )
        }
        emitVarDeclaration(n,
            r) {
            let i = r ?
                ";" : "";
            return i += wS(
                this
                    .chunk,
                n) +
                " " + an(n),
                i
        }
        emitFunctionCall() {
            throw ll(
                "recursion"
            )
        }
    };

    function LS(e) {
        let {
            type: t,
            arity: n
        } = e, r = t + "[" + n +
            "]", i = r +
                " buildList(";
        for (let s = 0; s < n -
            1; s++) i +=
                `${t} _${s}, `;
        i += `${t} _${n - 1}) {
`, i += r + ` a;
`;
        for (let s = 0; s < n; s++)
            i += `a[${s}] = _${s};
`;
        return i += `return a;
}
`, i
    }

    function t3(e, t) {
        let n = e.argNames.length,
            r = e
                .instructionsLength() -
                1;
        for (let i = n; i <=
            r; i++) {
            let s = e
                .getInstruction(i);
            if (s.type === 33) {
                if (W(s
                    .valueType)) {
                    let o = wS(e,
                        i),
                        a =
                            `${o} dcg_ternary(bool x, ${o} y, ${o} z) { if (x) return y; return z; }`;
                    t[a] = !0
                }
            } else if (s.type ===
                37) {
                let o = ng[s
                    .symbol];
                if ((o == null ?
                    void 0 : o
                        .type) ===
                    "reducer") {
                    let a = s.args[
                        0],
                        u = zn(e,
                            a);
                    if (u ===
                        void 0)
                        throw tc(oi(e,
                            a
                        ));
                    for (let c of o
                        .deps)
                        t[ng[c]
                            .value(
                                u)
                        ] = !0;
                    t[o.value(
                        u)] = !0
                } else if ((o ==
                    null ?
                    void 0 : o
                        .type) ===
                    "double-reducer"
                ) {
                    let a = s.args[
                        0],
                        u = s.args[
                            1],
                        c = zn(e,
                            a),
                        l = zn(e,
                            u);
                    if (c ===
                        void 0)
                        throw tc(oi(e,
                            a
                        ));
                    if (l ===
                        void 0)
                        throw tc(oi(e,
                            u
                        ));
                    t[o.value(c,
                        l)] = !0
                }
            }
        }
        return t
    }

    function WI(e) {
        let t = e.toString();
        return /^-?\d+$/.test(t) ?
            t + ".0" : t
    }

    function rg(e) {
        switch (W(e) ? ke(e) : e) {
            case ge:
                return "bool";
            case T:
                return "float";
            case R:
                return "vec2";
            case Ut:
            case V:
                return "vec3";
            default:
                throw new Error(
                    "Unexpected type: " +
                    on(e))
        }
    }

    function wS(e, t) {
        let n = e.getInstruction(t);
        if (W(n.valueType)) {
            let r = zn(e, t);
            if (r === void 0)
                throw tc(oi(e, t));
            if (r > 100) throw pl();
            return `${rg(n.valueType)}[${r}]`
        } else return rg(n
            .valueType)
    }

    function fn(e, t, n) {
        switch (t) {
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 14:
            case 17:
            case 18:
            case 21:
            case 19:
            case 23:
            case 50:
                return T;
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 31:
            case 32:
                return ge;
            case 33: {
                let i = e
                    .getInstruction(
                        n[1])
                    .valueType,
                    s = e
                        .getInstruction(
                            n[2])
                        .valueType,
                    o = ua(i, s);
                return o ===
                    void 0 ? i : o
            }
            case 15:
                return R;
            case 16:
                return V;
            case 38:
                return Hf(n.map(i =>
                    e
                        .getInstruction(
                            i)
                        .valueType
                ));
            case 39:
            case 40:
            case 41: {
                let i = e
                    .getInstruction(
                        n[0])
                    .valueType;
                return W(i) ? ke(
                    i) : Ht
            }
            case 44:
                return ot;
            case 49:
                return rt;
            case 55:
                return e
                    .getInstruction(
                        n[0])
                    .valueType;
            case 1:
            case 2:
            case 37:
            case 42:
            case 47:
            case 48:
            case 3:
            case 0:
            case 24:
            case 22:
            case 20:
            case 51:
            case 4:
            case 53:
            case 54:
                return Ht;
            default:
                let r = t;
                throw new Error(
                    `Unexpected opcode ${r}`
                )
        }
    }

    function Ls(e, t) {
        return e
            .pushLeafInstruction(t)
    }

    function Mn(e, t, n) {
        switch (t.type) {
            case 8:
                return e.Add(n);
            case 9:
                return e.Subtract(
                    n);
            case 10:
                return e.Multiply(
                    n);
            case 11:
                return e.Divide(n);
            case 12:
                return e.Exponent(
                    n);
            case 13:
                return e
                    .RawExponent(n);
            case 14:
                return e.Negative(
                    n);
            case 25:
                return e.Equal(n);
            case 26:
                return e.Less(n);
            case 27:
                return e.Greater(n);
            case 28:
                return e.LessEqual(
                    n);
            case 29:
                return e
                    .GreaterEqual(
                        n);
            case 31:
                return e.Or(n);
            case 32:
                return e.And(n);
            case 33:
                return e.Piecewise(
                    n);
            case 47:
                return e.BlockVar(t
                    .valueType,
                    n);
            case 48:
                return e
                    .BroadcastResult(
                        t.valueType,
                        n);
            case 15:
                return e
                    .OrderedPair(n);
            case 16:
                return e
                    .OrderedTriple(
                        n);
            case 17:
                return e
                    .OrderedPairAccess(
                        t.index, n);
            case 18:
                return e
                    .OrderedTripleAccess(
                        t.index, n);
            case 37:
                return e
                    .NativeFunction(
                        t.symbol, t
                        .callData, n
                    );
            case 42:
                return e
                    .Distribution(t
                        .symbol, n);
            case 21:
                return e
                    .BeginIntegral(t
                        .callData, n
                    );
            case 22:
                return e
                    .EndIntegral(n);
            case 23:
                return e
                    .BeginBroadcast(
                        n);
            case 24:
                return e
                    .EndBroadcast(
                        n);
            case 19:
                return e.BeginLoop(t
                    .callData, n
                );
            case 20:
                return e.EndLoop(n);
            case 38:
                return e.List(n);
            case 39:
                return e.ListAccess(
                    n);
            case 40:
                return e
                    .DeferredListAccess(
                        n);
            case 41:
                return e
                    .InboundsListAccess(
                        n);
            case 44:
                return e.ExtendSeed(
                    t.tag, n);
            case 49:
                return e.Action(t
                    .symbols, n);
            case 50:
                return e.BeginMap(t
                    .callData, n
                );
            case 51:
                return e.EndMap(n);
            case 53:
                return e
                    .BeginFunction(
                        n);
            case 54:
                return e
                    .EndFunction(n);
            case 55:
                return e
                    .FunctionCall(
                        n);
            default:
                let r = t;
                throw new Error(
                    `Unexpected opcode ${r.type}`
                )
        }
    }

    function FS(e) {
        if (e.instructionsLength() -
            1 !== e.getReturnIndex()
        ) throw new Error(
            "Programming Error: only the final instruction in a chunk can be converted to broadcast"
        );
        let t = e.getInstruction(e
            .getReturnIndex());
        if (be(t)) return e
            .getReturnIndex();
        switch (t.type) {
            case 8:
            case 9:
            case 10:
            case 11:
            case 12:
            case 13:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 31:
            case 32:
            case 15:
            case 16:
            case 14:
            case 33:
            case 17:
            case 18:
                return Sc(e, t);
            case 42:
                return Tr(e, Sc(e,
                    t));
            case 37: {
                let r = bn[t
                    .symbol];
                switch (r.tag) {
                    case "default":
                    case "trig":
                    case "trig2":
                    case "inverseTrig":
                    case "color":
                        return Sc(e,
                            t);
                    case "never-broadcast": {
                        let i = [],
                            s = !1;
                        for (let o of
                            t
                                .args) {
                            let a =
                                Tr(e,
                                    o
                                );
                            a !==
                                o ?
                                (s = !
                                    0,
                                    i
                                        .push(
                                            a
                                        )
                                ) :
                                i
                                    .push(
                                        o
                                    )
                        }
                        return s ? e
                            .copyInstructionWithArgs(
                                t, i
                            ) :
                            e
                                .getReturnIndex()
                    }
                    case "reducer":
                        if (n3(e, t
                            .args
                        ))
                            if (t
                                .args
                                .length ===
                                1) {
                                let i =
                                    t
                                        .args[
                                    0
                                    ],
                                    s =
                                        Tr(e,
                                            i
                                        );
                                return s !==
                                    i ?
                                    e
                                        .copyInstructionWithArgs(
                                            t,
                                            [
                                                s]
                                        ) :
                                    e
                                        .getReturnIndex()
                            } else
                                return Sc(
                                    e,
                                    t
                                );
                        else return e
                            .getReturnIndex();
                    case "doubleReducer": {
                        if (t.args
                            .length !==
                            2) throw new Error(
                                "Programming error: double reducers must have two arguments"
                            );
                        let i = Tr(
                            e, t
                                .args[
                        0
                        ]
                        ),
                            s = Tr(
                                e, t
                                    .args[
                            1
                            ]
                            );
                        return i !==
                            t.args[
                            0] ||
                            s !== t
                                .args[
                            1] ? e
                                .copyInstructionWithArgs(
                                    t, [i,
                                    s
                                ]) :
                            e
                                .getReturnIndex()
                    }
                    case "parameterizedReducer": {
                        if (t.args
                            .length !==
                            2) throw new Error(
                                "Programming error: double reducers must have two arguments"
                            );
                        let i = Tr(
                            e, t
                                .args[
                        0
                        ]
                        );
                        return i ===
                            t.args[
                            0] ?
                            Sc(e, t,
                                [!1, !
                                    0
                                ]) :
                            e
                                .copyInstructionWithArgs(
                                    t, [i,
                                    t
                                        .args[
                                    1
                                    ]
                                ])
                    }
                    default: {
                        let i = r
                            .tag;
                        throw new Error(
                            `Programming Error: unexpected tag ${i}`
                        )
                    }
                }
            }
            case 39:
            case 40:
            case 41:
                return Sc(e, t, [!1,
                !0
                ]);
            case 55: {
                let i = e
                    .getInstruction(
                        t.args[0])
                    .signature
                    .argTypes.map(
                        a => !W(a)),
                    s = [t.args[0]],
                    o = !1;
                for (let a = 1; a <
                    t.args
                        .length; a++) {
                    let u = t.args[
                        a],
                        c = Tr(e,
                            u);
                    c !== u ? (o = !
                        0, s
                            .push(c)
                    ) : s
                        .push(u)
                }
                return o ? e
                    .copyInstructionWithArgs(
                        t, s) : Sc(
                            e, t, [!1,
                            ...i
                        ])
            }
            case 21:
            case 22:
            case 19:
            case 20:
            case 50:
            case 51:
                return e
                    .getReturnIndex();
            case 38:
            case 47:
            case 23:
            case 24:
            case 48:
            case 44:
            case 49:
            case 53:
            case 54:
                return e
                    .getReturnIndex();
            default:
                let n = t;
                throw new Error(
                    `Unexpected opcode ${n.type}`
                )
        }
    }

    function n3(e, t) {
        for (let n of t)
            if (W(e.getInstruction(
                n)
                .valueType))
                return !0;
        return !1
    }

    function Sc(e, t, n) {
        let r = t.args,
            i = !1,
            s = [];
        for (let m = 0; m < r
            .length; m++) {
            if (n && !n[m])
                continue;
            let g = r[m],
                d = e
                    .getInstruction(g)
                    .valueType;
            W(d) && s.indexOf(g) ===
                -1 && s.push(g),
                d === We && (i = !0)
        }
        if (s.length === 0) return e
            .getReturnIndex();
        if (t.type === 33 && s
            .indexOf(t.args[0]) == -
            1 && s.indexOf(t.args[
                1]) >= 0 && s
                    .indexOf(t.args[2]) >= 0
        ) {
            let m = Tr(e, t.args[
                1]),
                g = Tr(e, t.args[
                    2]);
            return m !== t.args[
                1] || g !== t.args[
                2] ? Mn(e, t, [t
                    .args[0], m,
                    g
                ]) : e
                    .getReturnIndex()
        }
        e.popInstruction();
        let o = Gf(e, s);
        if (o === void 0)
            throw new Error(
                "Programming Error: expected minListLength to be defined for " +
                s.length +
                " lists");
        let a = o;
        if (bt(e.getInstruction(
            a)) && ln(e, a) === 0 &&
            i) return e
                .ConstantOfType(We,
                    []);
        let u = e.BeginBroadcast([
            a]),
            c = [];
        for (let m of s) c.push(Ma(
            e, m, u));
        let l = [];
        for (let m = 0; m < r
            .length; m++) {
            let g = r[m];
            if (n && !n[m]) l.push(
                g);
            else {
                let d = s.indexOf(
                    g);
                l.push(d === -1 ?
                    g : c[d])
            }
        }
        let p = e
            .copyInstructionWithArgs(
                t, l),
            f = e.EndBroadcast([u,
                p]);
        return e.BroadcastResult(ar(
            e
                .getInstruction(
                    p).valueType
        ), [f])
    }

    function Ma(e, t, n) {
        return e.getInstruction(t)
            .type == 48 ? e
                .DeferredListAccess([t,
                    n
                ]) : e
                    .InboundsListAccess([t,
                        n
                    ])
    }

    function VS(e) {
        let t = [];
        t.push("digraph {");
        for (let n = 0; n < e
            .instructionsLength(); n++
        ) e.getInstruction(n)
            .type !== 0 && t.push(
                `${n} [label="${n}: ${yc(e, n)}"];`
            );
        for (let n = 0; n < e
            .instructionsLength(); n++
        ) {
            let r = e
                .getInstruction(n);
            if (Lv(r))
                for (let i of r
                    .args) t.push(
                        `${n} -> ${i};`
                    )
        }
        return t.push("}"), t.join(`
`)
    }

    function BS(e, t, n) {
        let r = e.argNames.indexOf(
            t);
        if (r === -1) return 0;
        let i = Lr(e, r, n);
        return en(i, e
            .getReturnIndex())
    }

    function Lr(e, t, {
        allowRestriction: n,
        allowClosedBlockReferences: r
    }) {
        return {
            chunk: e,
            argIndex: t,
            orderTable: [],
            mask: eu(e, t),
            allowRestriction: n,
            allowClosedBlockReferences: r
        }
    }

    function en(e, t) {
        let n = e.orderTable[t];
        if (n !== void 0) return n;
        let r = r3(e, t);
        return e.orderTable[t] = r,
            r
    }

    function r3(e, t) {
        let {
            chunk: n,
            mask: r,
            argIndex: i,
            allowRestriction: s,
            allowClosedBlockReferences: o
        } = e;
        if (!o && n.isInClosedBlock(
            t)) return 1 / 0;
        if (t === i) return 1;
        let a = n.getInstruction(t);
        if (ri(a) || Ti(a))
            return 1 / 0;
        switch (a.type) {
            case 8:
            case 9:
            case 26:
            case 28:
            case 27:
            case 29: {
                let [c, l] = a.args;
                return Math.max(en(
                    e, c),
                    en(e, l))
            }
            case 10: {
                let [c, l] = a.args;
                return en(e, c) +
                    en(e, l)
            }
            case 14:
                return en(e, a.args[
                    0]);
            case 11: {
                let [c, l] = a.args;
                return en(e, l) >
                    0 ? 1 / 0 : en(
                        e, c)
            }
            case 12:
            case 13: {
                let [c, l] = a.args,
                    p = n
                        .getInstruction(
                            l);
                if (en(e, c) ===
                    0 && en(e,
                        l) === 0)
                    return 0;
                if (p.type === 1) {
                    let f = q(p
                        .value);
                    return f ===
                        Math.round(
                            f) &&
                        f > 0 ? en(
                            e, c) *
                    f : 1 / 0
                } else return 1 / 0
            }
            case 33: {
                if (!r[t]) return 0;
                let c = n
                    .getInstruction(
                        a.args[2]);
                return s && c
                    .type === 1 &&
                    isNaN(q(c
                        .value)) ?
                    en(e, a.args[
                        1]) : 1 / 0
            }
            case 2:
            case 0:
            case 1:
            case 25:
            case 32:
            case 31:
            case 15:
            case 17:
            case 16:
            case 18:
            case 38:
            case 39:
            case 40:
            case 41:
            case 37:
            case 42:
            case 48:
            case 47:
            case 3:
            case 44:
            case 49:
            case 4:
            case 55:
                return r[t] ? 1 /
                    0 : 0;
            default:
                let u = a;
                throw new Error(
                    `Unexpected opcode ${u.type}`
                )
        }
    }

    function GS(e, t) {
        let n = e.argNames.indexOf(
            t),
            r = e.getReturnIndex(),
            i = ws(Lr(e, n, {
                allowRestriction:
                    !0,
                allowClosedBlockReferences:
                    !1
            }), r);
        if (en(i.orderCtx, r) > 2)
            throw new Error(
                "Programming Error: cannot compute polynomial coefficients for polynomials of order greater than 2"
            );
        let s = Hn(i, r),
            o = !1;
        for (let a = 0; a < e
            .instructionsLength(); a++
        ) e.getInstruction(a)
            .type === 33 && i.mask[
            a] && (o = !0);
        return {
            chunk: i.newChunk,
            coefficients: s,
            mappedArgIndex: i
                .valueMap[n],
            mappedReturnIndex: i
                .valueMap[r],
            isRestrictedPolynomial: o
        }
    }

    function ws(e, t) {
        let {
            chunk: n,
            argIndex: r
        } = e, i = Yr(n, t);
        if (n.isInClosedBlock(r))
            throw new Error(
                "Programming Error: cannot find polynomial coefficients of an instruction in a closed block"
            );
        let s, o;
        r >= 0 && r < n.argNames
            .length ? (s = n
                .argNames.slice(),
                o = n.argTypes
                    .slice(), s.splice(
                        r, 1), o.splice(
                            r, 1)) : (s = n
                                .argNames, o = n
                                    .argTypes);
        let a = new jo({
            argNames: s,
            argTypes: o
        }),
            u = [];
        for (let m = 0; m < n
            .instructionsLength(); m++
        ) {
            if (!i[m]) continue;
            let g = n
                .getInstruction(m);
            if (g.type === 2) m <
                r || r < 0 ? u[m] =
            m : m === r ? u[m] =
                a.SymbolicVar(n
                    .argTypes[m]) :
                u[m] = m - 1;
            else if (be(g)) u[m] =
                Ls(a, g);
            else {
                let d = [];
                for (let y of g
                    .args) d.push(u[
                        y]);
                u[m] = Mn(a, g, d)
            }
        }
        let c = [],
            l = a.Constant(0),
            p = a.Constant(1),
            f = a.Constant(NaN);
        return {
            chunk: n,
            newChunk: a,
            orderCtx: e,
            coefficientTable: c,
            mask: e.mask,
            valueMap: u,
            argIndex: r,
            zero: l,
            one: p,
            nan: f
        }
    }

    function Hn(e, t) {
        let {
            newChunk: n,
            orderCtx: r,
            coefficientTable: i,
            mask: s,
            valueMap: o,
            argIndex: a,
            zero: u,
            one: c,
            nan: l
        } = e, p = i[t];
        if (p !== void 0) return p;
        let f;
        for (s[t] ? t === a ? f = [
            u, c
        ] : en(r, t) > 2 ? f = [
            l
        ] : f = i3(e, t) : f = [
            o[t]
        ]; f.length > 1;) {
            let m = n
                .getInstruction(f[f
                    .length - 1
                ]);
            if (m.type === 1 && q(m
                .value) === 0) f
                    .pop();
            else break
        }
        if (f.length === 0)
            throw new Error(
                "Programming Error: coefficients cannot be empty"
            );
        return i[t] = f, f
    }

    function i3(e, t) {
        let n = e.chunk
            .getInstruction(t),
            {
                newChunk: r
            } = e;
        switch (n.type) {
            case 8: {
                let [s, o] = n.args,
                    a = Hn(e, s),
                    u = Hn(e, o),
                    c = a.length -
                        1, l = u
                            .length - 1,
                    p = [];
                for (let f = 0; f <=
                    Math.max(c,
                        l); f++) c >=
                            f && l >= f ? p
                                .push(r.Add([a[
                                    f],
                                u[f]
                                ])) : p.push(c >
                                    l ? a[f] :
                                    u[f]);
                return p
            }
            case 9:
            case 26:
            case 28:
            case 27:
            case 29: {
                let [s, o] = n.args;
                (n.type === 26 || n
                    .type == 28) &&
                    ([s, o] = [o, s]);
                let a = Hn(e, s),
                    u = Hn(e, o),
                    c = a.length -
                        1,
                    l = u.length -
                        1,
                    p = [];
                for (let f = 0; f <=
                    Math.max(c,
                        l); f++) c >=
                            f && l >= f ? p
                                .push(r
                                    .Subtract([
                                        a[
                                        f],
                                        u[f]
                                    ])) : p
                                        .push(c > l ? a[
                                            f] : r
                                                .Negative([
                                                    u[f]
                                                ]));
                return p
            }
            case 14: {
                let s = n.args[0],
                    o = Hn(e, s),
                    a = [];
                for (let u = 0; u <
                    o.length; u++) a
                        .push(r
                            .Negative([
                                o[u]
                            ]));
                return a
            }
            case 10: {
                let [s, o] = n.args,
                    a = Hn(e, s),
                    u = Hn(e, o),
                    c = a.length -
                        1, l = u
                            .length - 1,
                    p = [];
                for (let f = 0; f <=
                    c; f++)
                    for (let m =
                        0; m <=
                        l; m++) {
                        if (f + m >
                            2)
                            continue;
                        let g = r
                            .Multiply(
                                [a[f],
                                u[
                                m]
                                ]),
                            d = p[
                                f +
                                m];
                        d ===
                            void 0 ?
                            p[f +
                            m] = g :
                            p[f +
                            m] = r
                                .Add([d,
                                    g])
                    }
                return p
            }
            case 11: {
                let [s, o] = n.args,
                    a = Hn(e, s),
                    u = Hn(e, o),
                    c = [];
                for (let l = 0; l <
                    a.length; l++) c
                        .push(r.Divide([
                            a[
                            l],
                            u[0]
                        ]));
                return c
            }
            case 12:
            case 13: {
                let [s, o] = n.args,
                    a = Hn(e, s),
                    u = Hn(e, o);
                if (a.length - 1 ===
                    0) return [r
                        .RawExponent(
                            [a[0],
                            u[
                            0]
                            ])
                    ];
                let l = r
                    .getInstruction(
                        u[0]);
                switch (q(l
                    .value)) {
                    case 0:
                        return [r
                            .Constant(
                                1
                            )
                        ];
                    case 1:
                        return a;
                    case 2:
                        return [r
                            .Multiply(
                                [a[0],
                                a[
                                0]
                                ]
                            ),
                        r
                            .Multiply(
                                [r.Constant(
                                    2
                                ),
                                r
                                    .Multiply(
                                        [a[0],
                                        a[
                                        1]
                                        ]
                                    )
                                ]
                            ),
                        r
                            .Multiply(
                                [a[1],
                                a[
                                1]
                                ]
                            )
                        ]
                }
            }
            case 33:
                return Hn(e, n.args[
                    1]);
            case 0:
            case 23:
            case 2:
            case 1:
            case 25:
            case 32:
            case 31:
            case 15:
            case 17:
            case 16:
            case 18:
            case 38:
            case 39:
            case 40:
            case 41:
            case 37:
            case 42:
            case 21:
            case 22:
            case 19:
            case 20:
            case 24:
            case 48:
            case 47:
            case 3:
            case 44:
            case 49:
            case 50:
            case 51:
            case 4:
            case 53:
            case 54:
            case 55:
                throw new Error(
                    `Cannot find polynomial coefficients of opcode ${n.type} that depends on symbol.`
                );
            default:
                let i = n;
                throw new Error(
                    `Unexpected opcode ${i.type}`
                )
        }
    }

    function kS(e) {
        if (e.instructionsLength() -
            1 !== e.getReturnIndex()
        ) throw new Error(
            "Programming Error: only the final instruction in a chunk can be lifted to numbers"
        );
        let t = e.getInstruction(e
            .getReturnIndex());
        if (be(t)) return e
            .getReturnIndex();
        switch (t.type) {
            case 8:
                return pu(e, t.args[
                    0]) && pu(e,
                        t.args[1]) ?
                    (e.popInstruction(),
                        e
                            .OrderedPair(
                                [e.Add([e.OrderedPairAccess(
                                    1,
                                    [t.args[
                                        0]]
                                ),
                                e
                                    .OrderedPairAccess(
                                        1,
                                        [t.args[
                                            1]]
                                    )
                                ]),
                                e
                                    .Add(
                                        [e.OrderedPairAccess(
                                            2,
                                            [t.args[
                                                0]]
                                        ),
                                        e
                                            .OrderedPairAccess(
                                                2,
                                                [t.args[
                                                    1]]
                                            )
                                        ]
                                    )
                                ])) :
                    fu(e, t.args[
                        0]) && fu(e, t
                            .args[1]) ?
                        (e.popInstruction(),
                            e
                                .OrderedTriple(
                                    [e.Add([e.OrderedTripleAccess(
                                        1,
                                        [t.args[
                                            0]]
                                    ),
                                    e
                                        .OrderedTripleAccess(
                                            1,
                                            [t.args[
                                                1]]
                                        )
                                    ]),
                                    e
                                        .Add(
                                            [e.OrderedTripleAccess(
                                                2,
                                                [t.args[
                                                    0]]
                                            ),
                                            e
                                                .OrderedTripleAccess(
                                                    2,
                                                    [t.args[
                                                        1]]
                                                )
                                            ]
                                        ),
                                    e
                                        .Add(
                                            [e.OrderedTripleAccess(
                                                3,
                                                [t.args[
                                                    0]]
                                            ),
                                            e
                                                .OrderedTripleAccess(
                                                    3,
                                                    [t.args[
                                                        1]]
                                                )
                                            ]
                                        )
                                    ])) :
                        Da(e, t.args) ?
                            (e.popInstruction(),
                                du(e, [e.Add(
                                    [ai(e, t.args[
                                        0
                                    ]),
                                    ai(e,
                                        t
                                            .args[
                                        1
                                        ]
                                    )
                                    ]
                                ),
                                go(e,
                                    t
                                        .args[
                                    0
                                    ]
                                )
                                ])) : e
                                    .getReturnIndex();
            case 9:
                return pu(e, t.args[
                    0]) && pu(e,
                        t.args[1]) ?
                    (e.popInstruction(),
                        e
                            .OrderedPair(
                                [e.Subtract(
                                    [e.OrderedPairAccess(
                                        1,
                                        [t.args[
                                            0]]
                                    ),
                                    e
                                        .OrderedPairAccess(
                                            1,
                                            [t.args[
                                                1]]
                                        )
                                    ]
                                ),
                                e
                                    .Subtract(
                                        [e.OrderedPairAccess(
                                            2,
                                            [t.args[
                                                0]]
                                        ),
                                        e
                                            .OrderedPairAccess(
                                                2,
                                                [t.args[
                                                    1]]
                                            )
                                        ]
                                    )
                                ])) :
                    fu(e, t.args[
                        0]) && fu(e, t
                            .args[1]) ?
                        (e.popInstruction(),
                            e
                                .OrderedTriple(
                                    [e.Subtract(
                                        [e.OrderedTripleAccess(
                                            1,
                                            [t.args[
                                                0]]
                                        ),
                                        e
                                            .OrderedTripleAccess(
                                                1,
                                                [t.args[
                                                    1]]
                                            )
                                        ]
                                    ),
                                    e
                                        .Subtract(
                                            [e.OrderedTripleAccess(
                                                2,
                                                [t.args[
                                                    0]]
                                            ),
                                            e
                                                .OrderedTripleAccess(
                                                    2,
                                                    [t.args[
                                                        1]]
                                                )
                                            ]
                                        ),
                                    e
                                        .Subtract(
                                            [e.OrderedTripleAccess(
                                                3,
                                                [t.args[
                                                    0]]
                                            ),
                                            e
                                                .OrderedTripleAccess(
                                                    3,
                                                    [t.args[
                                                        1]]
                                                )
                                            ]
                                        )
                                    ])) :
                        Da(e, t.args) ?
                            (e.popInstruction(),
                                du(e, [e.Subtract(
                                    [ai(e, t.args[
                                        0
                                    ]),
                                    ai(e,
                                        t
                                            .args[
                                        1
                                        ]
                                    )
                                    ]
                                ),
                                go(e,
                                    t
                                        .args[
                                    0
                                    ]
                                )
                                ])) : e
                                    .getReturnIndex();
            case 14:
                return pu(e, t.args[
                    0]) ? (e
                        .popInstruction(),
                        e
                            .OrderedPair(
                                [e.Negative(
                                    [e.OrderedPairAccess(
                                        1,
                                        [t.args[
                                            0]]
                                    )]
                                ),
                                e
                                    .Negative(
                                        [e.OrderedPairAccess(
                                            2,
                                            [t.args[
                                                0]]
                                        )]
                                    )
                                ])) :
                    fu(e, t.args[
                        0]) ? (e
                            .popInstruction(),
                            e
                                .OrderedTriple(
                                    [e.Negative(
                                        [e.OrderedTripleAccess(
                                            1,
                                            [t.args[
                                                0]]
                                        )]
                                    ),
                                    e
                                        .Negative(
                                            [e.OrderedTripleAccess(
                                                2,
                                                [t.args[
                                                    0]]
                                            )]
                                        ),
                                    e
                                        .Negative(
                                            [e.OrderedTripleAccess(
                                                3,
                                                [t.args[
                                                    0]]
                                            )]
                                        )
                                    ])) :
                        Da(e, t.args) ?
                            (e.popInstruction(),
                                du(e, [e.Negative(
                                    [ai(e, t.args[
                                        0
                                    ])]
                                ),
                                go(e,
                                    t
                                        .args[
                                    0
                                    ]
                                )
                                ])) : e
                                    .getReturnIndex();
            case 10:
                if (Uf(e, t.args[
                    0]) && Uf(e, t
                        .args[1]))
                    return e
                        .popInstruction(),
                        e
                            .SyntheticNativeFunction(
                                "restriction",
                                [e.And([e.SyntheticNativeFunction(
                                    "restrictionToBoolean",
                                    [t.args[
                                        0]]
                                ),
                                e
                                    .SyntheticNativeFunction(
                                        "restrictionToBoolean",
                                        [t.args[
                                            1]]
                                    )
                                ])]);
                if (Uf(e, t.args[
                    0]) || Uf(e, t
                        .args[1])) {
                    let r, i;
                    Uf(e, t.args[
                        0]) ? (r = t
                            .args[
                            0], i =
                            t.args[
                            1]
                    ) : (r =
                        t.args[
                        1],
                        i = t
                            .args[0]
                    );
                    let s = e
                        .getInstruction(
                            i)
                        .valueType;
                    return uo(s) ? (
                        e
                            .popInstruction(),
                        e
                            .Piecewise(
                                [e.SyntheticNativeFunction(
                                    "restrictionToBoolean",
                                    [
                                        r]
                                ),
                                    i,
                                e
                                    .NanOfType(
                                        s
                                    )
                                ])
                    ) : e
                        .getReturnIndex()
                } else return pu(e,
                    t.args[
                    0]
                ) && va(
                    e, t
                        .args[1]
                ) ? (e
                    .popInstruction(),
                    e
                        .OrderedPair(
                            [e.Multiply(
                                [e.OrderedPairAccess(
                                    1,
                                    [t.args[
                                        0]]
                                ),
                                t
                                    .args[
                                1
                                ]
                                ]
                            ),
                            e
                                .Multiply(
                                    [e.OrderedPairAccess(
                                        2,
                                        [t.args[
                                            0]]
                                    ),
                                    t
                                        .args[
                                    1
                                    ]
                                    ]
                                )
                            ])
                ) : va(
                    e, t
                        .args[0]
                ) && pu(
                    e, t
                        .args[1]
                ) ? (e
                    .popInstruction(),
                    e
                        .OrderedPair(
                            [e.Multiply(
                                [t.args[
                                    0],
                                e
                                    .OrderedPairAccess(
                                        1,
                                        [t.args[
                                            1]]
                                    )
                                ]
                            ),
                            e
                                .Multiply(
                                    [t.args[
                                        0],
                                    e
                                        .OrderedPairAccess(
                                            2,
                                            [t.args[
                                                1]]
                                        )
                                    ]
                                )
                            ])
                ) : Da(
                    e, [t
                        .args[
                        0
                    ]
                ]) &&
                    va(e, t
                        .args[1]
                    ) ? (e
                        .popInstruction(),
                        du(e, [e.Multiply(
                            [ai(e, t.args[
                                0
                            ]),
                            t
                                .args[
                            1
                            ]
                            ]
                        ),
                        go(e,
                            t
                                .args[
                            0
                            ]
                        )
                        ])) :
                    va(e, t
                        .args[0]
                    ) && Da(
                        e, [t
                            .args[
                            1
                        ]
                    ]) ? (e
                        .popInstruction(),
                        du(e, [e.Multiply(
                            [t.args[
                                0],
                            ai(e,
                                t
                                    .args[
                                1
                                ]
                            )
                            ]
                        ),
                        go(e,
                            t
                                .args[
                            1
                            ]
                        )
                        ])) :
                        fu(e, t
                            .args[0]
                        ) && va(
                            e, t
                                .args[1]
                        ) ? (e
                            .popInstruction(),
                            e
                                .OrderedTriple(
                                    [e.Multiply(
                                        [e.OrderedTripleAccess(
                                            1,
                                            [t.args[
                                                0]]
                                        ),
                                        t
                                            .args[
                                        1
                                        ]
                                        ]
                                    ),
                                    e
                                        .Multiply(
                                            [e.OrderedTripleAccess(
                                                2,
                                                [t.args[
                                                    0]]
                                            ),
                                            t
                                                .args[
                                            1
                                            ]
                                            ]
                                        ),
                                    e
                                        .Multiply(
                                            [e.OrderedTripleAccess(
                                                3,
                                                [t.args[
                                                    0]]
                                            ),
                                            t
                                                .args[
                                            1
                                            ]
                                            ]
                                        )
                                    ])
                        ) : va(
                            e, t
                                .args[0]
                        ) && fu(
                            e, t
                                .args[1]
                        ) ? (e
                            .popInstruction(),
                            e
                                .OrderedTriple(
                                    [e.Multiply(
                                        [t.args[
                                            0],
                                        e
                                            .OrderedTripleAccess(
                                                1,
                                                [t.args[
                                                    1]]
                                            )
                                        ]
                                    ),
                                    e
                                        .Multiply(
                                            [t.args[
                                                0],
                                            e
                                                .OrderedTripleAccess(
                                                    2,
                                                    [t.args[
                                                        1]]
                                                )
                                            ]
                                        ),
                                    e
                                        .Multiply(
                                            [t.args[
                                                0],
                                            e
                                                .OrderedTripleAccess(
                                                    3,
                                                    [t.args[
                                                        1]]
                                                )
                                            ]
                                        )
                                    ])
                        ) : e
                            .getReturnIndex();
            case 11:
                return pu(e, t.args[
                    0]) && va(e,
                        t.args[1]) ?
                    (e.popInstruction(),
                        e
                            .OrderedPair(
                                [e.Divide(
                                    [e.OrderedPairAccess(
                                        1,
                                        [t.args[
                                            0]]
                                    ),
                                    t
                                        .args[
                                    1
                                    ]
                                    ]
                                ),
                                e
                                    .Divide(
                                        [e.OrderedPairAccess(
                                            2,
                                            [t.args[
                                                0]]
                                        ),
                                        t
                                            .args[
                                        1
                                        ]
                                        ]
                                    )
                                ])) :
                    Da(e, [t.args[
                        0]]) && va(
                            e, t.args[1]
                        ) ? (e
                            .popInstruction(),
                            du(e, [e.Divide(
                                [ai(e, t.args[
                                    0
                                ]),
                                t
                                    .args[
                                1
                                ]
                                ]
                            ),
                            go(e,
                                t
                                    .args[
                                0
                                ]
                            )
                            ])) : fu(e,
                                t.args[0]
                            ) && va(e, t
                                .args[1]) ?
                        (e.popInstruction(),
                            e
                                .OrderedTriple(
                                    [e.Divide(
                                        [e.OrderedTripleAccess(
                                            1,
                                            [t.args[
                                                0]]
                                        ),
                                        t
                                            .args[
                                        1
                                        ]
                                        ]
                                    ),
                                    e
                                        .Divide(
                                            [e.OrderedTripleAccess(
                                                2,
                                                [t.args[
                                                    0]]
                                            ),
                                            t
                                                .args[
                                            1
                                            ]
                                            ]
                                        ),
                                    e
                                        .Divide(
                                            [e.OrderedTripleAccess(
                                                3,
                                                [t.args[
                                                    0]]
                                            ),
                                            t
                                                .args[
                                            1
                                            ]
                                            ]
                                        )
                                    ])) : e
                                        .getReturnIndex();
            case 12:
            case 13:
            case 25:
            case 26:
            case 27:
            case 28:
            case 29:
            case 32:
            case 31:
            case 15:
            case 16:
            case 33:
            case 17:
            case 18:
            case 37:
            case 42:
            case 39:
            case 40:
            case 41:
            case 21:
            case 22:
            case 19:
            case 20:
            case 38:
            case 47:
            case 23:
            case 24:
            case 48:
            case 44:
            case 49:
            case 50:
            case 51:
            case 53:
            case 54:
            case 55:
                return e
                    .getReturnIndex();
            default:
                let n = t;
                throw new Error(
                    `Unexpected opcode ${n.type}`
                )
        }
    }

    function pu(e, t) {
        return e.getInstruction(t)
            .valueType === R
    }

    function fu(e, t) {
        return e.getInstruction(t)
            .valueType === V
    }

    function va(e, t) {
        return e.getInstruction(t)
            .valueType === T
    }

    function Uf(e, t) {
        return e.getInstruction(t)
            .valueType === Vt
    }

    function Da(e, t) {
        return t.every(n => Je(e, n,
            he)) || t.every(n =>
                Je(e, n, Se))
    }

    function du(e, t) {
        return mu(e, t,
            "mathVector", qf(
                "mathVector",
                "mathVectorThreeD"
            ))
    }

    function go(e, t) {
        return mu(e, [t], "start",
            [{
                match: [he],
                build: () =>
                    e
                        .SyntheticNativeFunction(
                            "basePointFromVector",
                            [t])
            }, {
                match: [Se],
                build: () =>
                    e
                        .SyntheticNativeFunction(
                            "basePointFromVectorThreeD",
                            [t])
            }])
    }

    function ai(e, t) {
        return mu(e, [t],
            "displacement", [{
                match: [he],
                build: () =>
                    e
                        .SyntheticNativeFunction(
                            "vectorDisplacementAsPoint",
                            [t])
            }, {
                match: [Se],
                build: () =>
                    e
                        .SyntheticNativeFunction(
                            "vectorThreeDDisplacementAsPoint",
                            [t])
            }])
    }

    function qf(e, t) {
        return [{
            match: [R, R],
            build: (n, r) =>
                n
                    .SyntheticNativeFunction(
                        e, r)
        }, {
            match: [V, V],
            build: (n, r) =>
                n
                    .SyntheticNativeFunction(
                        t, r)
        }]
    }
    var s3 = ["Sum", "Product",
        "Integral", "List",
        "Derivative",
        "Piecewise", "Exponent",
        "PercentOf",
        "FunctionDefinition",
        "UpdateRule",
        "Substitution",
        "ListComprehension"
    ],
        o3 = {
            isGeometryEnabled() {
                return !1
            },
            is3dProduct() {
                return !1
            },
            is3dPolicy() {
                return !1
            },
            isBeta3d() {
                return !1
            },
            areAllScalesLinear() {
                return !0
            },
            assignmentForbidden(e) {
                return !0
            },
            substitutionForbidden(
                e) {
                return !0
            },
            graphingEnabled() {
                return !1
            },
            isValidSlider(e) {
                return !1
            },
            sliderVariables(e) {
                return []
            },
            ansEnabled() {
                return !1
            },
            disabledFeatures() {
                return s3
            },
            dimensionVarsEnabled() {
                return !1
            }
        },
        zS = {
            ...o3,
            isGeometryEnabled() {
                return !0
            },
            is3dProduct() {
                return !0
            },
            is3dPolicy() {
                return !0
            },
            isBeta3d() {
                return !0
            }
        };

    function HS(e) {
        return 48 <= e && e <= 57
    }

    function a3(e) {
        return 97 <= e && e <= 122
    }

    function u3(e) {
        return 65 <= e && e <= 90
    }

    function ig(e) {
        return a3(e) || u3(e)
    }

    function sg(e) {
        return e === 92
    }

    function JI(e) {
        return e === 39
    }

    function US(e) {
        if (9 <= e && e <= 13 ||
            8192 <= e && e <= 8202)
            return !0;
        switch (e) {
            case 32:
            case 160:
            case 5760:
            case 8232:
            case 8233:
            case 8239:
            case 8287:
            case 12288:
            case 65279:
                return !0;
            default:
                return !1
        }
    }

    function gu(e, t) {
        return Kr(e.token.span, t
            .prevSpan)
    }

    function yu(e, t, n) {
        return {
            type: e,
            span: t,
            val: n
        }
    }

    function c3(e, t, n, r) {
        return {
            input: e,
            prevSpan: t,
            pos: n,
            token: r
        }
    }

    function qS(e) {
        return $S(e, 0, to(e, 0))
    }

    function $S(e, t, n) {
        for (; US(e.charCodeAt(t));)
            t += 1;
        let r = f3(e, t);
        return c3(e, n, t, r)
    }

    function ho(e) {
        return $S(e.input, e.token
            .span.end, e.token
            .span)
    }

    function Bi(e) {
        return e.token
    }

    function Jo(e, t) {
        if (Bi(e).type !== t)
            throw `Parse Error: expected ${t}.`;
        return ho(e)
    }

    function YS(e, t) {
        return Bi(e).type === t
    }

    function og(e) {
        return e.pos >= e.input
            .length
    }
    var l3 = {
        "\\left": "Left",
        "\\right": "Right",
        "\\sqrt": "Sqrt",
        "\\frac": "Frac",
        "\\operatorname": "OperatorName",
        "\\token": "Token"
    },
        p3 = {
            "[": "[",
            "]": "]",
            "{": "{",
            "}": "}",
            "^": "^",
            _: "_"
        };

    function f3(e, t) {
        let n = t;
        if (t >= e.length)
            return yu("End", to(e,
                t), "");
        let r = e.charCodeAt(t);
        if (HS(r)) {
            let i = yi(e, n, t + 1);
            return yu("Digit", i, e
                .charAt(n))
        } else if (ig(r)) {
            let i = yi(e, n, t + 1);
            return yu("Letter", i, e
                .charAt(n))
        } else if (sg(r))
            if (t += 1, ig(e
                .charCodeAt(t)
            )) {
                for (; ig(e
                    .charCodeAt(
                        t));)
                    t += 1;
                let i = yi(e, n, t),
                    s = Cn(i),
                    o = l3[s] ||
                        "Cmd";
                return yu(o, i, s)
            } else {
                t += 1;
                let i = yi(e, n, t),
                    s = Cn(i);
                return yu(
                    "EscapedSymbol",
                    i, s)
            }
        else if (JI(r)) {
            for (t += 1; JI(e
                .charCodeAt(t)
            );) t += 1;
            if (e.charAt(t) ===
                "^") {
                t += 1;
                let i = yi(e, n, t),
                    s = Cn(i);
                return yu("Primes^",
                    i, s)
            } else {
                let i = yi(e, n, t),
                    s = Cn(i);
                return yu("Primes",
                    i, s)
            }
        } else {
            let i = yi(e, n, t + 1),
                s = e.charAt(n),
                o = p3[s] ||
                    "Symbol";
            return yu(o, i, s)
        }
    }

    function QI(e, t) {
        return {
            type: "Group",
            span: e,
            args: t
        }
    }

    function XS(e, t, n) {
        return {
            type: "Sqrt",
            span: e,
            optArg: t,
            arg: n
        }
    }

    function ZS(e, t, n) {
        return {
            type: "Frac",
            span: e,
            num: t,
            den: n
        }
    }

    function WS(e, t, n, r) {
        return {
            type: "SupSub",
            span: e,
            sup: t,
            sub: n,
            nprimes: r
        }
    }

    function jS(e, t, n, r) {
        return {
            type: "LeftRight",
            span: e,
            left: t,
            right: n,
            arg: r
        }
    }

    function JS(e, t) {
        return {
            type: "OperatorName",
            span: e,
            arg: t
        }
    }

    function QS(e, t) {
        return {
            type: "TokenNode",
            span: e,
            arg: t
        }
    }

    function KS(e, t) {
        return {
            type: "Symbol",
            span: e,
            val: t
        }
    }

    function eO(e) {
        switch (e) {
            case "Frac":
                return 2;
            case "^":
            case "_":
            case "Primes^":
            case "Left":
            case "Sqrt":
            case "OperatorName":
            case "Token":
                return 1;
            default:
                return 0
        }
    }

    function tO(e) {
        let {
            state: t,
            tree: n
        } = ag(qS(e), !1);
        if (!og(t))
            throw `Parse error: unexpected ${Cn(Bi(t).span)}.`;
        return n
    }

    function Fs(e, t) {
        return {
            state: e,
            tree: t
        }
    }

    function ag(e, t) {
        let n = e,
            r = [];
        e: for (; !og(e);) {
            let s = Bi(e);
            switch (s.type) {
                case "Cmd":
                case "EscapedSymbol":
                case "Letter":
                case "Digit":
                case "Symbol":
                case "[":
                case "{":
                case "^":
                case "_":
                case "Primes":
                case "Primes^":
                case "Left":
                case "Frac":
                case "Sqrt":
                case "OperatorName":
                case "Token":
                case "]": {
                    if (s
                        .type ===
                        "]" && t
                    )
                        break e;
                    let a;
                    if ({
                        state: e,
                        tree: a
                    } = nO(
                        e),
                        a
                            .type ===
                        "Group")
                        for (let u of
                            a
                                .args)
                            r
                                .push(
                                    u
                                );
                    else r.push(
                        a);
                    break
                }
                case "}":
                case "Right":
                case "End":
                    break e;
                default:
                    throw `Unexpected token type ${s.type}.`
            }
        }
        let i = gu(n, e);
        return Fs(e, QI(i, r))
    }

    function nO(e) {
        let t = Bi(e);
        switch (t.type) {
            case "Cmd":
            case "EscapedSymbol":
            case "Letter":
            case "Digit":
            case "Symbol":
                return e = ho(e),
                    Fs(e, t);
            case "[":
            case "]":
                return e = ho(e),
                    Fs(e, KS(t.span,
                        t.val));
            case "{": {
                e = ho(e);
                let r;
                return {
                    state: e,
                    tree: r
                } = ag(e, !1), e =
                    Jo(e, "}"), Fs(
                        e, r)
            }
            case "^":
            case "_":
            case "Primes":
            case "Primes^":
                return x3(e);
            case "Left":
                return b3(e);
            case "Frac":
                return h3(e);
            case "Sqrt":
                return g3(e);
            case "OperatorName":
                return m3(e);
            case "Token":
                return y3(e);
            case "}":
            case "Right":
                throw `Parse Error: unexpected ${t.val}.`;
            case "End":
                throw "Parse Error: unexpected end.";
            default:
                throw `Unexpected token type ${t.type}.`
        }
    }

    function m3(e) {
        let t = e,
            n = Bi(e);
        e = Jo(e, "OperatorName");
        let r;
        ({
            state: e,
            tree: r
        } = hu(e, n));
        let i = gu(t, e);
        return Fs(e, JS(i, r))
    }

    function y3(e) {
        let t = e,
            n = Bi(e);
        e = Jo(e, "Token");
        let r;
        ({
            state: e,
            tree: r
        } = hu(e, n));
        let i = gu(t, e);
        return Fs(e, QS(i, r))
    }

    function g3(e) {
        let t = e,
            n = Bi(e);
        e = Jo(e, "Sqrt");
        let r;
        YS(e, "[") && ({
            state: e,
            tree: r
        } = P3(e));
        let i;
        ({
            state: e,
            tree: i
        } = hu(e, n));
        let s = gu(t, e);
        return Fs(e, XS(s, r, i))
    }

    function h3(e) {
        let t = e,
            n = Bi(e);
        e = Jo(e, "Frac");
        let r;
        ({
            state: e,
            tree: r
        } = hu(e, n));
        let i;
        ({
            state: e,
            tree: i
        } = hu(e, n));
        let s = gu(t, e);
        return Fs(e, ZS(s, r, i))
    }

    function b3(e) {
        let t = e;
        e = Jo(e, "Left");
        let n = Bi(e);
        e = ho(e);
        let r;
        ({
            state: e,
            tree: r
        } = ag(e, !1)), e = Jo(e,
            "Right");
        let i = Bi(e);
        e = ho(e);
        let s = gu(t, e);
        return Fs(e, jS(s, n, i, r))
    }

    function x3(e) {
        let t = e,
            n, r, i = 0;
        e: for (; !og(e);) {
            let o = Bi(e);
            switch (o.type) {
                case "^":
                    if (e = ho(
                        e),
                        n)
                        throw "Parse Error: double superscript.";
                    ({
                        state: e,
                        tree: n
                    } = hu(
                        e, o
                    ));
                    break;
                case "_":
                    if (e = ho(
                        e),
                        r)
                        throw "Parse Error: double subscript.";
                    ({
                        state: e,
                        tree: r
                    } = hu(
                        e, o
                    ));
                    break;
                case "Primes":
                    if (e = ho(
                        e),
                        i > 0)
                        throw "Parse Error: double primes.";
                    i = o.val
                        .length;
                    break;
                case "Primes^":
                    if (e = ho(
                        e),
                        i > 0)
                        throw "Parse Error: double primes.";
                    if (n)
                        throw "Parse Error: double superscript";
                    i = o.val
                        .length -
                        1, {
                            state: e,
                            tree: n
                        } = hu(
                            e, o
                        );
                    break;
                default:
                    break e
            }
        }
        let s = gu(t, e);
        return Fs(e, WS(s, n, r, i))
    }

    function hu(e, t) {
        let n = eO(t.type),
            r;
        if (n <= 0) throw new Error(
            "Programming Error: greediness must be greater than 0."
        );
        let i = eO(Bi(e).type);
        if (i > 0 && i <= n) {
            let s = Cn(t.span);
            throw `Parse Error: can't use ${Cn(Bi(e).span)} as argument of ${s}. Use {}.`
        }
        return {
            state: e,
            tree: r
        } = nO(e), r.type !==
        "Group" && (r = QI(r
            .span, [r])), Fs(e,
                r)
    }

    function P3(e) {
        e = Jo(e, "[");
        let t;
        return {
            state: e,
            tree: t
        } = ag(e, !0), e = Jo(e,
            "]"), Fs(e, t)
    }
    var T3 = {
        mcd: "gcd",
        gcf: "gcd",
        mcm: "lcm",
        signum: "sign",
        sgn: "sign",
        stdDevP: "stdevp",
        stddevp: "stdevp",
        stdDev: "stdev",
        stddev: "stdev",
        variance: "var",
        TTest: "ttest",
        TScore: "tscore",
        IndependentTTest: "ittest",
        iTTest: "ittest",
        inverseCdf: "quantile",
        inversecdf: "quantile",
        arsinh: "arcsinh",
        arcosh: "arccosh",
        artanh: "arctanh",
        arcsch: "arccsch",
        arsech: "arcsech",
        arcoth: "arccoth"
    };

    function rO(e) {
        let t = 0;
        for (; sg(e.charCodeAt(t));)
            t += 1;
        return t > 0 && (e = e
            .slice(t)), T3[e] ||
            e
    }

    function iO(e, t, n) {
        return {
            type: "Comparator",
            span: e,
            symbol: t,
            args: n
        }
    }

    function sO(e, t, n) {
        if (t.length < 1)
            throw "Programming Error: ComparatorChain must have at least one comparator.";
        if (n.length !== t.length +
            1)
            throw "Programming Error: ComparatorChain must have one more arg than symbols";
        return {
            type: "ComparatorChain",
            span: e,
            args: n,
            symbols: t
        }
    }

    function oO(e, t) {
        return {
            type: "Tilde",
            span: e,
            args: t
        }
    }

    function aO(e, t) {
        return {
            type: "Pos",
            span: e,
            args: t
        }
    }

    function uO(e, t) {
        return {
            type: "Neg",
            span: e,
            args: t
        }
    }

    function cO(e, t) {
        return {
            type: "Add",
            span: e,
            args: t
        }
    }

    function lO(e, t) {
        return {
            type: "Sub",
            span: e,
            args: t
        }
    }

    function pO(e, t) {
        return {
            type: "Mul",
            span: e,
            args: t
        }
    }

    function fO(e, t) {
        return {
            type: "DotMul",
            span: e,
            args: t
        }
    }

    function dO(e, t) {
        return {
            type: "CrossMul",
            span: e,
            args: t
        }
    }

    function mO(e, t) {
        return {
            type: "Div",
            span: e,
            args: t
        }
    }

    function yO(e, t) {
        return {
            type: "Bang",
            span: e,
            args: t
        }
    }

    function $f(e, t) {
        return {
            type: "Call",
            span: e,
            args: t
        }
    }

    function KI(e, t) {
        return {
            type: "ImplicitCall",
            span: e,
            args: t
        }
    }

    function gO(e, t) {
        return {
            type: "Index",
            span: e,
            args: t
        }
    }

    function eE(e, t) {
        return {
            type: "Paren",
            span: e,
            args: t
        }
    }

    function tE(e, t) {
        return {
            type: "List",
            span: e,
            args: t
        }
    }

    function hO(e, t) {
        return {
            type: "Pipes",
            span: e,
            args: t
        }
    }

    function nE(e, t) {
        return {
            type: "Subscript",
            span: e,
            args: t
        }
    }

    function ug(e, t) {
        return {
            type: "Superscript",
            span: e,
            args: t
        }
    }

    function Yf(e, t, n) {
        return {
            type: "Prime",
            span: e,
            nprimes: t,
            args: n
        }
    }

    function cg(e, t) {
        return {
            type: "Seq",
            span: e,
            args: t
        }
    }

    function bO(e, t) {
        return {
            type: "Sqrt",
            span: e,
            args: t
        }
    }

    function xO(e, t) {
        return {
            type: "Nthroot",
            span: e,
            args: t
        }
    }

    function PO(e, t) {
        return {
            type: "Frac",
            span: e,
            args: t
        }
    }

    function TO(e, t) {
        return {
            type: "Derivative",
            span: e,
            args: t
        }
    }

    function IO(e, t) {
        return {
            type: "Integral",
            span: e,
            args: t
        }
    }

    function EO(e, t) {
        return {
            type: "EmptyIntegral",
            span: e,
            args: t
        }
    }

    function MO(e, t) {
        return {
            type: "Sum",
            span: e,
            args: t
        }
    }

    function vO(e, t) {
        return {
            type: "Product",
            span: e,
            args: t
        }
    }

    function DO(e, t) {
        return {
            type: "Piecewise",
            span: e,
            args: t
        }
    }

    function SO(e) {
        return {
            type: "EmptyPiecewise",
            span: e
        }
    }

    function OO(e) {
        return {
            type: "EmptyRangeEnd",
            span: e
        }
    }

    function CO(e, t) {
        return {
            type: "Colon",
            span: e,
            args: t
        }
    }

    function rE(e, t) {
        return {
            type: "Ellipsis",
            span: e,
            args: t
        }
    }

    function RO(e, t) {
        return {
            type: "For",
            span: e,
            args: t
        }
    }

    function NO(e, t) {
        return {
            type: "With",
            span: e,
            args: t
        }
    }

    function AO(e, t) {
        return {
            type: "Dot",
            span: e,
            args: t
        }
    }

    function _O(e, t) {
        return {
            type: "PercentOf",
            span: e,
            args: t
        }
    }

    function LO(e, t) {
        return {
            type: "RightArrow",
            span: e,
            args: t
        }
    }

    function iE(e, t) {
        return {
            type: "Juxt",
            span: e,
            args: t
        }
    }

    function wO(e, t) {
        return {
            type: "Letter",
            span: e,
            val: t
        }
    }

    function lg(e, t) {
        return {
            type: "Decimal",
            span: e,
            val: t
        }
    }

    function Oc(e, t) {
        return {
            type: "Cmd",
            span: e,
            val: rO(t)
        }
    }

    function FO(e, t) {
        return {
            type: "Alphanumeric",
            span: e,
            val: t
        }
    }

    function VO(e, t, n, r) {
        return {
            type: "MixedNumber",
            span: e,
            whole: t,
            num: n,
            den: r
        }
    }

    function Un(e) {
        if (e.type ===
            "Subscript") {
            if (e.args[1].type !==
                "Alphanumeric")
                return !1;
            e = e.args[0]
        }
        switch (e.type) {
            case "Cmd":
                return !0;
            case "Letter":
                return !0;
            default:
                return !1
        }
    }

    function BO(e) {
        return e.type !==
            "Superscript" ? !1 : Un(
                e.args[0])
    }

    function GO(e, t) {
        if (e.type !== "Letter" || e
            .val !== "d" || t
                .type !== "Juxt")
            return !1;
        let [n, r] = t.args;
        return n.type !==
            "Letter" || n.val !==
            "d" ? !1 : Un(r)
    }

    function pr(e) {
        return e.type === "Seq" ? e
            .args : [e]
    }

    function Ce(e, t) {
        return {
            type: "Err",
            span: e,
            error: t
        }
    }

    function sE() {
        return {
            type: "UnexpectedParseError"
        }
    }

    function kO() {
        return {
            type: "EmptyInput"
        }
    }

    function zO() {
        return {
            type: "EmptyGroup"
        }
    }

    function oE() {
        return {
            type: "EmptySubscript"
        }
    }

    function HO() {
        return {
            type: "EmptySuperscript"
        }
    }

    function aE() {
        return {
            type: "EmptyRadical"
        }
    }

    function UO() {
        return {
            type: "EmptySquareBracket"
        }
    }

    function qO() {
        return {
            type: "EmptyPipe"
        }
    }

    function $O() {
        return {
            type: "EmptyRadicalIndex"
        }
    }

    function uE() {
        return {
            type: "UnexpectedEnd"
        }
    }

    function Cc(e) {
        return {
            type: "BinaryOperatorMissingRight",
            val: e
        }
    }

    function YO(e) {
        return {
            type: "BinaryOperatorMissingLeft",
            val: e
        }
    }

    function cE(e) {
        return {
            type: "UnaryOperatorMissingRight",
            val: e
        }
    }

    function lE(e) {
        return {
            type: "UnaryOperatorMissingLeft",
            val: e
        }
    }

    function XO(e, t) {
        return {
            type: "MissingCloseDelimiter",
            open: e,
            close: t
        }
    }

    function Xf(e, t) {
        return {
            type: "UnexpectedCloseDelimiter",
            open: e,
            close: t
        }
    }

    function ZO() {
        return {
            type: "UnexpectedDifferential"
        }
    }

    function WO(e) {
        return {
            type: "UnrecognizedSymbol",
            val: e
        }
    }

    function jO(e) {
        return {
            type: "InvalidSubscript",
            val: e
        }
    }

    function JO(e) {
        return {
            type: "UnexpectedSubscript",
            base: e
        }
    }

    function pE(e) {
        return {
            type: "FunctionMissingArgument",
            val: e
        }
    }

    function QO() {
        return {
            type: "PercentMissingOf"
        }
    }

    function fE() {
        return {
            type: "PrimeWithoutParen"
        }
    }

    function KO() {
        return {
            type: "SuperscriptWithPrime"
        }
    }

    function pg() {
        return {
            type: "UnexpectedPrime"
        }
    }

    function eC() {
        return {
            type: "SumMissingBound"
        }
    }

    function tC() {
        return {
            type: "ProductMissingBound"
        }
    }

    function dE() {
        return {
            type: "MissingBound"
        }
    }

    function nC() {
        return {
            type: "IntegralMissingBound"
        }
    }

    function rC() {
        return {
            type: "SumMissingBody"
        }
    }

    function iC() {
        return {
            type: "ProductMissingBody"
        }
    }

    function sC() {
        return {
            type: "IntegralMissingBody"
        }
    }

    function oC() {
        return {
            type: "DerivativeMissingBody"
        }
    }

    function aC() {
        return {
            type: "IntegralMissingDifferential"
        }
    }

    function uC() {
        return {
            type: "DifferentialWithSuperscript"
        }
    }

    function cC() {
        return {
            type: "FractionMissingNumerator"
        }
    }

    function lC() {
        return {
            type: "FractionMissingDenominator"
        }
    }

    function pC() {
        return {
            type: "FractionEmpty"
        }
    }

    function mE(e) {
        return {
            type: "AdjacentNumbers",
            args: e
        }
    }

    function fC() {
        return {
            type: "UnexpectedFor"
        }
    }

    function dC() {
        return {
            type: "TokenWithSubscript"
        }
    }
    var M3 = {
        "+": !0,
        "-": !0,
        "*": !0,
        "\\cdot": !0,
        "\\times": !0,
        "/": !0,
        "!": !0,
        "(": !0,
        ")": !0,
        "\\{": !0,
        "\\}": !0,
        "(|": !0,
        "|)": !0,
        "[": !0,
        "]": !0,
        ",": !0,
        "...": !0,
        ":": !0,
        "=": !0,
        ">": !0,
        "<": !0,
        ">=": !0,
        "<=": !0,
        "->": !0,
        "~": !0,
        "%": !0,
        ".": !0,
        for: !0,
        with: !0,
        Letter: !0,
        Decimal: !0,
        Cmd: !0,
        TokenNode: !0,
        Differential: !0,
        End: !0,
        Trig: !0,
        Ln: !0,
        Log: !0,
        Int: !0,
        Sum: !0,
        Prod: !0,
        Err: !0
    };

    function B9(e) {
        let t = Sa[e];
        if (!t) return !0;
        switch (t) {
            case "Ln":
            case "Log":
            case "for":
            case "with":
            case "Trig":
                return !0;
            default:
                return !1
        }
    }
    var Sa = {
        "\\lt": "<",
        "\\gt": ">",
        "\\le": "<=",
        "\\ge": ">=",
        "\\leq": "<=",
        "\\geq": ">=",
        "\\ldots": "...",
        "\\sim": "~",
        "\\to": "->",
        "\\cdot": "\\cdot",
        "\\times": "\\times",
        "\\div": "/",
        "\\ln": "Ln",
        "\\log": "Log",
        "\\int": "Int",
        "\\sum": "Sum",
        "\\prod": "Prod",
        "\\backslash": "Err",
        "\\for": "for",
        "\\with": "with"
    },
        v3 = ["sin", "cos", "tan",
            "cot", "sec", "csc"
        ];
    for (let e of v3) Sa["\\" + e] =
        "Trig", Sa["\\" + e + "h"] =
        "Trig", Sa["\\arc" + e] =
        "Trig", Sa["\\arc" + e +
        "h"] = "Trig", Sa[
        "\\ar" + e + "h"] =
        "Trig";

    function G9(e) {
        return e === "\\log" ||
            e === "\\prod" || e ===
            "\\sum" || e === "\\int"
    }
    var yE = {
        "+": "+",
        "-": "-",
        "*": "*",
        "/": "/",
        "!": "!",
        "(": "(",
        ")": ")",
        "[": "[",
        "]": "]",
        ",": ",",
        "...": "...",
        ":": ":",
        "=": "=",
        ">=": ">=",
        "<=": "<=",
        ">": ">",
        "<": "<",
        "~": "~",
        ".": "."
    },
        mC = {
            "\\{": "\\{",
            "\\}": "\\}",
            "\\%": "%"
        },
        yC = {
            "|": "(|",
            "\\{": "\\{",
            "[": "[",
            "(": "("
        },
        gC = {
            "|": "|)",
            "\\}": "\\}",
            "]": "]",
            ")": ")"
        },
        hC = Object.keys(M3);

    function bC(e, t, n, r, i, s, o,
        a) {
        return {
            opts: e,
            input: t,
            prevSpan: n,
            startIndex: r,
            endIndex: i,
            token: s,
            mode: o,
            parent: a
        }
    }

    function ye(e, t) {
        return Kr(e.token.span, t
            .prevSpan)
    }

    function qn(e, t) {
        return Kr(e, t.prevSpan)
    }

    function hE(e) {
        return to(e.token.span
            .input, e.token.span
            .start)
    }

    function D3(e, t) {
        return {
            type: "Differential",
            span: e,
            val: t
        }
    }

    function ui(e, t, n) {
        return {
            type: e,
            span: t,
            val: n
        }
    }

    function Oa(e, t) {
        let n = to(e.span.input, e
            .span.start);
        return bE(t, e, 0, n,
            void 0, void 0)
    }

    function bE(e, t, n, r, i, s) {
        let o = t.args;
        if (n > o.length && s)
            return xC(s, r);
        n = Zf(o, n);
        let {
            token: a,
            endIndex: u
        } = PC(t, n, i);
        if (a.type === "End" && s) {
            let c = s.input.args[s
                .startIndex];
            if (c.type ===
                "LeftRight") {
                let l = c.right,
                    p = gC[l.val] ||
                        "Err",
                    f = ui(p, l
                        .span, l.val
                    );
                return bC(e, t, r,
                    n, u, f, i,
                    s)
            }
        } else a.type === "Int" ?
            i = S3(i) : a.type ===
            "Differential" && (i =
                O3(i));
        return bC(e, t, r, n, u, a,
            i, s)
    }

    function Ve(e) {
        let t = e.input.args[e
            .startIndex],
            n = e.token.span;
        return t && t.type ===
            "LeftRight" ? bE(e.opts,
                t.arg, 0, n, e.mode,
                e) : xC(e, n)
    }

    function xC(e, t) {
        let {
            input: n,
            endIndex: r,
            mode: i,
            parent: s
        } = e;
        return bE(e.opts, n, r + 1,
            t, i, s)
    }

    function wr(e) {
        return e.token
    }

    function S3(e) {
        return {
            type: "integral",
            parent: e
        }
    }

    function O3(e) {
        if (!e || e.type !==
            "integral")
            throw new Error(
                "Programming Error: expected lexer to be in integral mode."
            );
        return e.parent
    }

    function Ir(e, t) {
        return wr(e).type === t
    }

    function mg(e) {
        return e.startIndex >= e
            .input.args.length
    }

    function xE(e, t) {
        return t.token.span.start >
            e.token.span.start
    }

    function ir(e, t) {
        return {
            token: t,
            endIndex: e
        }
    }

    function PC(e, t, n) {
        let r = e.args;
        if (t >= r.length) {
            let o = to(e.span.input,
                e.span.end);
            return ir(t, ui("End",
                o, ""))
        }
        let i = e.args[t];
        switch (i.type) {
            case "Sqrt":
            case "Frac":
            case "SupSub":
                return ir(t, i);
            case "Letter": {
                if (!n || n.type !==
                    "integral" || i
                        .val != "d")
                    return ir(t, i);
                let {
                    endIndex: l,
                    token: p
                } = PC(e, t + 1, n);
                if (p.type ===
                    "Letter" || p
                        .type === "Cmd"
                ) {
                    let f = D3(Kr(i
                        .span,
                        p
                            .span
                    ), p
                        .val);
                    return ir(l, f)
                } else return ir(t,
                    i)
            }
            case "LeftRight": {
                let l = i.left,
                    p = yC[l.val] ||
                        "Err";
                var s = Kr(i.span, l
                    .span);
                return ir(t, ui(p,
                    s, l.val
                ))
            }
            case "OperatorName":
                let o = [];
                for (let l of i.arg
                    .args) {
                    if (l.type !==
                        "Letter")
                        return ir(t,
                            ui("Err",
                                i
                                    .span,
                                Cn(i.arg
                                    .span
                                )
                            )
                        );
                    o.push(l.val)
                }
                let a = "\\" + o
                    .join(""),
                    u = Sa[a] ||
                        "Cmd";
                return ir(t, ui(u, i
                    .span, a
                ));
            case "TokenNode": {
                let l = "$";
                if (i.arg.args
                    .length === 0)
                    return ir(t, ui(
                        "Err",
                        i
                            .span,
                        Cn(i.arg
                            .span
                        )
                    ));
                for (let p of i.arg
                    .args) {
                    if (p.type !==
                        "Digit")
                        return ir(t,
                            ui("Err",
                                i
                                    .span,
                                Cn(i.arg
                                    .span
                                )
                            )
                        );
                    l += p.val
                }
                return ir(t, ui(
                    "TokenNode",
                    i.span,
                    l))
            }
            case "Cmd": {
                let l = Sa[i.val] ||
                    "Cmd";
                return ir(t, ui(l, i
                    .span, i
                    .val))
            }
            case "EscapedSymbol": {
                let l = mC[i.val] ||
                    "Err";
                return ir(t, ui(l, i
                    .span, i
                    .val))
            }
            case "Symbol":
                return C3(e, t, i);
            case "Digit":
                return TC(e, t);
            default:
                throw `Unexpected atom ${i.type}.`
        }
    }

    function C3(e, t, n) {
        switch (n.val) {
            case ".":
                return R3(e, t);
            case "-": {
                let i = e.args[t +
                    1];
                if (i && fg(i,
                    ">")) {
                    let s = ui("->",
                        Kr(n.span,
                            i
                                .span
                        ),
                        "->");
                    return ir(t + 1,
                        s)
                }
                break
            }
            case "<": {
                let i = e.args[t +
                    1];
                if (i && fg(i,
                    "=")) {
                    let s = ui("<=",
                        Kr(n.span,
                            i
                                .span
                        ),
                        "<=");
                    return ir(t + 1,
                        s)
                }
                break
            }
            case ">": {
                let i = e.args[t +
                    1];
                if (i && fg(i,
                    "=")) {
                    let s = ui(">=",
                        Kr(n.span,
                            i
                                .span
                        ),
                        ">=");
                    return ir(t + 1,
                        s)
                }
                break
            }
        }
        let r = yE[n.val] || "Err";
        return ir(t, ui(r, n.span, n
            .val))
    }

    function R3(e, t) {
        let n = e.args[t];
        if (n.type !== "Symbol" || n
            .val !== ".")
            throw new Error(
                "Programming Error: expected '.'"
            );
        if (t + 2 < e.args.length &&
            dg(e.args[t + 1]) && dg(
                e.args[t + 2])) {
            let s = Kr(n.span, e
                .args[t + 2]
                .span);
            return ir(t + 2, ui(
                "...", s,
                Cn(s)))
        }
        let r = Zf(e.args, t + 1);
        if (r < e.args.length && e
            .args[r].type ===
            "Digit") return TC(e,
                t);
        let i = yE[n.val] || "Err";
        return ir(t, ui(i, n.span, n
            .val))
    }

    function TC(e, t) {
        let n = N3(e, t);
        if (n) return n;
        let r = e.args,
            i = e.args[t].span,
            s = [],
            o = !1,
            a = !1;
        for (; t < r.length; t++) {
            let c = Zf(r, t);
            if (c >= r.length)
                break;
            let l = r[c];
            if (l.type === "Digit")
                t = c, o = !0, s
                    .push(l.val);
            else if (!a && dg(l)) {
                if (c + 1 < r
                    .length && dg(e
                        .args[c + 1]
                    )) break;
                t = c, a = !0, s
                    .push(".")
            } else break
        }
        if (!o) throw new Error(
            "Programming Error: decimals must have at least one digit."
        );
        let u = Kr(i, e.args[t - 1]
            .span);
        return ir(t - 1, ui(
            "Decimal", u, s
                .join("")))
    }

    function N3(e, t) {
        let n = e.args,
            r = n[t].span,
            i = [];
        for (; t < n.length; t++) {
            let c = Zf(n, t);
            if (c >= n.length)
                break;
            let l = n[c];
            if (l.type !== "Digit")
                break;
            t = c, i.push(l.val)
        }
        if (t = Zf(n, t), t >= n
            .length) return;
        let s = n[t];
        if (s.type !== "Frac")
            return;
        let o = [],
            a = [];
        for (let c of s.num.args)
            if (!gE(c)) {
                if (c.type !==
                    "Digit") return;
                o.push(c.val)
            } for (let c of s.den
                .args)
            if (!gE(c)) {
                if (c.type !==
                    "Digit") return;
                a.push(c.val)
            } let u = Kr(r, s.span);
        return ir(t, VO(u, i.join(
            ""), o.join(
                ""), a.join(
                    "")))
    }

    function gE(e) {
        switch (e.type) {
            case "Sqrt":
            case "Frac":
            case "SupSub":
            case "LeftRight":
            case "OperatorName":
            case "TokenNode":
            case "Symbol":
            case "Letter":
            case "Digit":
                return !1;
            case "Cmd":
                return e.val ===
                    "\\space";
            case "EscapedSymbol":
                return e.val ===
                    "\\ " || e
                        .val ===
                    "\\:" || e
                        .val ===
                    "\\," || e
                        .val === "\\;";
            default:
                throw `Unexpected atom ${e.type}.`
        }
    }

    function Zf(e, t) {
        for (; t < e.length && gE(e[
            t]);) t += 1;
        return t
    }

    function dg(e) {
        return fg(e, ".")
    }

    function fg(e, t) {
        return e.type ===
            "Symbol" && e.val === t
    }

    function op(e) {
        return {
            type: "initial",
            tokenType: e
        }
    }

    function Wf(e) {
        return {
            type: "l",
            tokenType: e
        }
    }

    function jf(e) {
        return {
            type: "r",
            tokenType: e
        }
    }

    function Xt(e) {
        return {
            type: "la",
            tokenType: e
        }
    }

    function ap(e) {
        return {
            type: "ra",
            tokenType: e
        }
    }

    function IC(e, t) {
        for (let n of hC)
            if (t[n] === void 0)
                throw new Error(
                    `Programming Error: token ${n} must be a assigned a ${e} precedence`
                )
    }

    function Rc(e, t, n, r) {
        if (t[n] !== void 0)
            throw new Error(
                `Programming Error: duplicate ${e} entry for token ${n}.`
            );
        t[n] = r
    }

    function EC(e) {
        let t = {},
            n = {},
            r = {};
        for (let a = 0; a < e
            .length; a++) {
            let u = e[a];
            for (let {
                type: c,
                tokenType: l
            }
                of u) switch (c) {
                    case "initial":
                        Rc("initial",
                            t,
                            l, a
                        );
                        break;
                    case "l":
                        Rc("left",
                            n,
                            l, a
                        );
                        break;
                    case "r":
                        Rc("right",
                            r,
                            l, a
                        );
                        break;
                    case "la":
                        Rc("left",
                            n,
                            l, a
                        ),
                            Rc("right",
                                r,
                                l, a
                            );
                        break;
                    case "ra":
                        Rc("left",
                            n,
                            l, a
                        ),
                            Rc("right",
                                r,
                                l,
                                a -
                                1);
                        break
                }
        }
        IC("left", n), IC("right",
            r);

        function i(a) {
            return r[a]
        }

        function s(a) {
            return n[a]
        }

        function o(a) {
            let u = t[a];
            return u === void 0 ? i(
                a) : u
        }
        return {
            rightPrec: i,
            leftPrec: s,
            initialPrec: o
        }
    }
    var up = {},
        A3 = ["sin", "cos", "tan",
            "cot", "sec", "csc",
            "sinh", "cosh", "tanh",
            "coth", "sech", "csch"
        ];
    A3.forEach(function (e) {
        up[e] = "arc" + e,
            up["arc" + e] =
            e
    });
    var _3 = 0;

    function OC(e, t) {
        return L3(e, t)
    }

    function lt(e, t) {
        let n = [];
        for (let r = 0; r < t
            .length; r++) n.push(rn(
                e, t[r]));
        return n
    }

    function L3(e, t) {
        return e.setInput(w3(e, t),
            t.span)
    }

    function CC(e) {
        if (e.type !== "Call")
            return;
        let [t, n] = e.args, r = pr(
            n);
        if (Un(t) && r.every(Un))
            return {
                base: t,
                args: r
            }
    }

    function RC(e) {
        return CC(e) !== void 0
    }

    function NC(e) {
        return e.type === "Paren" &&
            e.args[0].type ===
            "Seq" && e.args[0].args
                .every(Un)
    }

    function IE(e) {
        return Un(e) || NC(e)
    }

    function w3(e, t) {
        let n = e.nodes;
        switch (t.type) {
            case "Comparator":
                if (t.symbol ===
                    "=") {
                    let [r, i] = t
                        .args, s =
                            CC(r);
                    if (s) {
                        let {
                            base: o,
                            args: a
                        } = s;
                        return n
                            .FunctionDefinition(
                                rn(e,
                                    o
                                ),
                                lt(e,
                                    a
                                ),
                                rn(e,
                                    i
                                )
                            )
                    } else {
                        if (r
                            .type ===
                            "Call" &&
                            Un(r.args[
                                0
                            ]))
                            return n
                                .CallAssignment(
                                    rn(e,
                                        r
                                    ),
                                    rn(e,
                                        i
                                    )
                                );
                        if (IE(r)) {
                            let o;
                            if (i
                                .type ===
                                "For"
                            )
                                o =
                                    e
                                        .setInput(
                                            gg(e,
                                                i, {
                                                parentIsList:
                                                    !
                                                    1
                                            }
                                            ),
                                            i
                                                .span
                                        );
                            else if (
                                o =
                                rn(e,
                                    i
                                ),
                                NC(
                                    r)
                            )
                                return n
                                    .CoordinateEquation(
                                        rn(e,
                                            r
                                        ),
                                        o
                                    );
                            return n
                                .Assignment(
                                    rn(e,
                                        r
                                    ),
                                    o
                                )
                        }
                    }
                    return n
                        .Equation(
                            rn(e,
                                r), rn(
                                    e, i
                                ))
                } else return Qo(e,
                    t);
            case "Tilde": {
                let [r, i] = lt(e, t
                    .args);
                return n.Regression(
                    r, i)
            }
            case "ComparatorChain": {
                if (!e
                    .specializeDoubleInequalities ||
                    t.symbols
                        .length !== 2)
                    return Qo(e, t);
                let [r, i, s] = t
                    .args, [o, a] =
                        t.symbols;
                return !Un(i) || t
                    .symbols
                    .includes("=") ?
                    Qo(e, t) : n
                        .DoubleInequality(
                            [rn(e, r),
                                o, rn(e,
                                    i),
                                a, rn(e,
                                    s)
                            ])
            }
            case "Call": {
                let [r, i] = t.args;
                if (r.type ===
                    "Cmd") switch (r
                        .val) {
                        case "histogram":
                            return n
                                .Histogram(
                                    lt(e,
                                        pr(
                                            i)
                                    )
                                );
                        case "dotplot":
                            return n
                                .DotPlot(
                                    lt(e,
                                        pr(
                                            i)
                                    )
                                );
                        case "boxplot":
                            return n
                                .BoxPlot(
                                    lt(e,
                                        pr(
                                            i)
                                    )
                                );
                        case "ttest":
                            return n
                                .TTest(
                                    lt(e,
                                        pr(
                                            i)
                                    )
                                );
                        case "ittest":
                            return n
                                .IndependentTTest(
                                    lt(e,
                                        pr(
                                            i)
                                    )
                                );
                        case "stats":
                            return n
                                .Stats(
                                    lt(e,
                                        pr(
                                            i)
                                    )
                                );
                        default:
                            return Jf(
                                e,
                                t
                            )
                    }
                return Jf(e, t)
            }
            case "For":
                return gg(e, t, {
                    parentIsList:
                        !1
                });
            default:
                return Jf(e, t)
        }
    }

    function AC(e) {
        if (e.type !== "Paren")
            return !1;
        let [t] = e.args;
        return t.type !== "Seq" ? !
            1 : t.args.length ===
            2 || t.args.length === 3
    }

    function rn(e, t) {
        return e.setInput(Jf(e, t),
            t.span)
    }

    function Jf(e, t) {
        let n = e.nodes;
        switch (t.type) {
            case "Pos":
                return rn(e, t.args[
                    0]);
            case "Neg":
                let r = -1,
                    i = t.args[0];
                for (; ;)
                    if (i.type ===
                        "Pos" || i
                            .type ===
                        "Paren" && !
                        AC(i)) i = i
                            .args[0];
                    else if (i
                        .type === "Neg")
                        i = i.args[0],
                            r *= -1;
                    else break;
                switch (i.type) {
                    case "Decimal": {
                        let o = DC(
                            i);
                        return n
                            .Constant(
                                r ===
                                    -1 ?
                                    hi(
                                        o) :
                                    o)
                    }
                    case "MixedNumber": {
                        let o = SC(
                            i);
                        return n
                            .MixedNumber(
                                r ===
                                    -1 ?
                                    hi(
                                        o) :
                                    o)
                    }
                    default:
                        return r ===
                            -1 ? n
                                .Negative(
                                    [rn(e,
                                        i)]
                                ) :
                            rn(e, i)
                }
            case "Add":
                return n.Add(lt(e, t
                    .args));
            case "Sub":
                return n.Subtract(
                    lt(e, t
                        .args));
            case "Mul":
                return n.Multiply(
                    lt(e, t
                        .args));
            case "DotMul":
                return n
                    .DotMultiply(lt(
                        e, t
                        .args));
            case "CrossMul":
                return n
                    .CrossMultiply(
                        lt(e, t
                            .args));
            case "Div":
                return n.Divide(lt(
                    e, t
                    .args));
            case "Bang": {
                let [o] = t.args;
                return o.type ===
                    "Call" && Un(o
                        .args[0]) &&
                    !yg(o.args[
                        0]) && pr(o
                            .args[1])
                            .length === 1 ?
                    n
                        .FunctionFactorial(
                            lt(e, o
                                .args)
                        ) : n
                            .FunctionCall(
                                "\\factorial",
                                lt(e, t
                                    .args))
            }
            case "PercentOf":
                return n.PercentOf(
                    lt(e, t
                        .args));
            case "Call":
                return MC(e, t);
            case "ImplicitCall":
                return z3(t), MC(e,
                    t);
            case "Dot": {
                let o = t.args[1],
                    [a, u] = lt(e, t
                        .args);
                if (yg(o)) {
                    let c = to(o
                        .span
                        .input,
                        o.span
                            .end),
                        l = e
                            .setInput(
                                LC(e), c
                            );
                    u = e.setInput(n
                        .SeededFunctionCall(
                            u, [
                            l]
                        ), o
                        .span)
                } else if (o
                    .type ===
                    "Letter")
                    switch (o.val) {
                        case "x":
                        case "y":
                        case "z":
                            return n
                                .NamedCoordinateAccess(
                                    o
                                        .val,
                                    [
                                        a]
                                );
                        default:
                            break
                    } else if (o
                        .type ===
                        "Call") {
                    let c = o
                        .args[
                        0];
                    if (c
                        .type ===
                        "Letter"
                    )
                        switch (
                        c
                            .val
                        ) {
                            case "x":
                            case "y":
                            case "z":
                                return n
                                    .Multiply(
                                        [e.setInput(
                                            n
                                                .NamedCoordinateAccess(
                                                    c
                                                        .val,
                                                    [
                                                        a]
                                                ),
                                            Kr(t.args[
                                                0
                                            ]
                                                .span,
                                                c
                                                    .span
                                            )
                                        ),
                                        rn(e,
                                            o
                                                .args[
                                            1
                                            ]
                                        )
                                        ]
                                    )
                        }
                } return n
                    .DotAccess([a,
                        u])
            }
            case "Prime": {
                let [o] = t.args;
                if (o.type ===
                    "Call") {
                    let [a, u] = o
                        .args, c =
                            pr(u)
                                .length;
                    if (a.type ===
                        "Cmd" && a
                            .val ===
                        "logbase") {
                        if (c !== 2)
                            throw nc()
                    } else if (c !==
                        1)
                        throw nc();
                    return n.Prime(t
                        .nprimes,
                        lt(e, t
                            .args
                        ))
                } else throw o
                    .type ===
                    "ImplicitCall" ?
                    Tm() : Pm()
            }
            case "Index": {
                let [o, a] = t.args;
                if (a.type ===
                    "Seq") return n
                        .ListAccess(
                            [rn(e,
                                o),
                            e
                                .setInput(
                                    n
                                        .List(
                                            lt(e,
                                                a
                                                    .args
                                            )
                                        ),
                                    void 0
                                )
                            ]);
                if (a.type ===
                    "Ellipsis") {
                    let [u, c] = a
                        .args;
                    return n
                        .ListAccess(
                            [rn(e,
                                o),
                            e
                                .setInput(
                                    n
                                        .Range(
                                            [e.setInput(
                                                n
                                                    .List(
                                                        lt(e,
                                                            pr(
                                                                u)
                                                        )
                                                    ),
                                                void 0
                                            ),
                                            e
                                                .setInput(
                                                    n
                                                        .List(
                                                            c
                                                                .type ===
                                                                "EmptyRangeEnd" ?
                                                                [] :
                                                                lt(e,
                                                                    pr(
                                                                        c)
                                                                )
                                                        ),
                                                    void 0
                                                )
                                            ]
                                        ),
                                    void 0
                                )
                            ])
                }
                return Qf(a) ? n
                    .ListAccess([rn(
                        e, o
                    ), e
                        .setInput(
                            Qo(e,
                                a
                            ),
                            void 0
                        )
                    ]) : n
                        .ListAccess(lt(
                            e, t
                            .args))
            }
            case "Paren": {
                let [o] = t.args;
                if (o.type ===
                    "Seq") {
                    if (o.args
                        .length ===
                        0)
                        throw zx();
                    return n
                        .ParenSeq(
                            lt(e, o
                                .args
                            ))
                } else return rn(e,
                    o)
            }
            case "List": {
                if (t.args
                    .length === 0)
                    return n.List(
                        []);
                let o = t.args[0];
                if (o.type ===
                    "Ellipsis") {
                    let [a, u] = o
                        .args;
                    return n.Range([
                        e
                            .setInput(
                                n
                                    .List(
                                        lt(e,
                                            pr(
                                                a)
                                        )
                                    ),
                                void 0
                            ),
                        e
                            .setInput(
                                n
                                    .List(
                                        lt(e,
                                            pr(
                                                u)
                                        )
                                    ),
                                void 0
                            )
                    ])
                } else if (o
                    .type === "For")
                    return gg(e,
                        o, {
                        parentIsList:
                            !
                            0
                    });
                return n.List(lt(e,
                    pr(o)))
            }
            case "Pipes": {
                let [o] = t.args;
                return n.Norm([rn(e,
                    o)])
            }
            case "Subscript": {
                let [o, a] = t.args;
                if (a.val.length ===
                    0) throw xm();
                let u;
                switch (o.type) {
                    case "Letter":
                        u = o.val;
                        break;
                    case "Cmd":
                        u = o.val;
                        break;
                    default:
                        throw Vx()
                }
                if (u === "ans")
                    throw Nr("ans");
                return n.Identifier(
                    `${u}_${a.val}`
                )
            }
            case "Superscript": {
                let [o, a] = t.args;
                if (o.type ===
                    "Call" && o
                        .args[1]
                        .type !==
                    "Seq" && !yg(o
                        .args[0]) &&
                    !H3(o)) return n
                        .FunctionExponent(
                            lt(e, [o.args[
                                0
                            ],
                            o
                                .args[
                            1
                            ],
                                a
                            ]));
                if (o.type ===
                    "Dot") {
                    let u = o.args[
                        1],
                        [c, l] = lt(
                            e, o
                            .args),
                        p = rn(e,
                            a);
                    if (u.type ===
                        "Letter")
                        switch (u
                            .val) {
                            case "x":
                            case "y":
                            case "z":
                                return n
                                    .Exponent(
                                        [e.setInput(
                                            n
                                                .NamedCoordinateAccess(
                                                    u
                                                        .val,
                                                    [
                                                        c]
                                                ),
                                            o
                                                .span
                                        ),
                                            p
                                        ]
                                    );
                            default:
                                break
                        } else if (u
                            .type ===
                            "Call"
                    ) {
                        let f =
                            u
                                .args[
                            0
                            ];
                        if (f
                            .type ===
                            "Letter"
                        )
                            switch (
                            f
                                .val
                            ) {
                                case "x":
                                case "y":
                                case "z":
                                    return n
                                        .Multiply(
                                            [e.setInput(
                                                n
                                                    .NamedCoordinateAccess(
                                                        f
                                                            .val,
                                                        [
                                                            c]
                                                    ),
                                                Kr(o.args[
                                                    0
                                                ]
                                                    .span,
                                                    f
                                                        .span
                                                )
                                            ),
                                            e
                                                .setInput(
                                                    n
                                                        .Exponent(
                                                            [rn(e, u.args[
                                                                1
                                                            ]),
                                                                p
                                                            ]
                                                        ),
                                                    yi(t.span
                                                        .input,
                                                        u
                                                            .args[
                                                            0
                                                        ]
                                                            .span
                                                            .end,
                                                        a
                                                            .span
                                                            .end
                                                    )
                                                )
                                            ]
                                        );
                                default:
                                    break
                            }
                    } return n
                        .Exponent([e
                            .setInput(
                                n
                                    .DotAccess(
                                        [c,
                                            l]
                                    ),
                                o
                                    .span
                            ),
                            p
                        ])
                } else return n
                    .Exponent(
                        lt(e, t
                            .args
                        ))
            }
            case "Sqrt":
                return n
                    .FunctionCall(
                        "sqrt", lt(
                            e, t
                            .args));
            case "Nthroot":
                return n
                    .FunctionCall(
                        "nthroot",
                        lt(e, [t.args[
                            1
                        ],
                        t
                            .args[
                        0
                        ]
                        ]));
            case "Frac":
                return n.Divide(lt(
                    e, t
                    .args));
            case "Derivative": {
                let o = lt(e, t
                    .args);
                if (!Un(t.args[0]))
                    throw J(
                        `Expected identifier in derivative, but found ${t.args[0].type}`);
                return n.Derivative(
                    o[0], [o[1]]
                )
            }
            case "Integral": {
                let [o, a, u, c] = t
                    .args, l = lt(e,
                        [o, a, u, c]
                    );
                return n.Integral(l)
            }
            case "EmptyIntegral": {
                let [o, a, u] = lt(
                    e, t.args),
                    c = e.setInput(n
                        .Constant(
                            De(1, 1)
                        ),
                        void 0);
                return n.Integral([
                    o, a, u,
                    c
                ])
            }
            case "Sum": {
                let [o, a, u] = t
                    .args;
                if (a.type !==
                    "Comparator" ||
                    !cp(a))
                    throw wP();
                let c = lt(e, [a
                    .args[
                    0], a
                        .args[
                1], u
                ]),
                    l = rn(bg(e, {
                        prefix: "ro",
                        expr: c[
                            0]
                    }), o);
                return n.Sum(c
                    .concat(l))
            }
            case "Product": {
                let [o, a, u] = t
                    .args;
                if (a.type !==
                    "Comparator" ||
                    !cp(a))
                    throw FP();
                let c = lt(e, [a
                    .args[
                    0], a
                        .args[
                1], u
                ]),
                    l = rn(bg(e, {
                        prefix: "ro",
                        expr: c[
                            0]
                    }), o);
                return n.Product(c
                    .concat(l))
            }
            case "Juxt": {
                if (e
                    .writeIntegral) {
                    let [u, c] = t
                        .args;
                    if (c.type ===
                        "Letter" &&
                        c.val ===
                        "t" && u
                            .type ===
                        "Juxt" && ([
                            u, c
                        ] = u
                                .args, c
                                    .type ===
                                "Letter" &&
                            c
                                .val ===
                            "n")) {
                        if (u
                            .type ===
                            "Juxt"
                        ) {
                            if ([u,
                                c] =
                                u
                                    .args,
                                c
                                    .type ===
                                "Letter" &&
                                c
                                    .val ===
                                "i")
                                throw wm()
                        } else if (u
                            .type ===
                            "Letter" &&
                            u
                                .val ===
                            "i")
                            throw wm()
                    }
                }
                let [o, a] = t.args;
                if (o.type ===
                    "MixedNumber" &&
                    !(Un(a) || a
                        .type ===
                        "Piecewise" ||
                        a.type ===
                        "Call" || a
                            .type ===
                        "Paren"))
                    throw bm(hg(o));
                if (a.type ===
                    "MixedNumber")
                    throw bm(hg(a));
                return n.Multiply(
                    lt(e, t
                        .args))
            }
            case "Letter":
                return n.Identifier(
                    t.val);
            case "Cmd": {
                let o = t.val;
                switch (o) {
                    case "ans": {
                        if (e
                            .currentIndex ===
                            void 0)
                            throw uf(
                                "ans"
                            );
                        return n
                            .Ans(
                                `ans_{${e.currentIndex - 1}}`
                            )
                    }
                    case "approx":
                        throw om(o);
                    case "dt": {
                        if (!e
                            .allowDt
                        ) throw uf(
                            o
                        );
                        return n
                            .Identifier(
                                o)
                    }
                    case "index": {
                        if (!e
                            .allowIndex
                        ) throw uf(
                            o
                        );
                        return n
                            .Identifier(
                                o)
                    }
                    default:
                        return n
                            .Identifier(
                                o)
                }
            }
            case "With": {
                if (e
                    .isSubstitutionRHS
                ) throw zm();
                let [o, a] = t.args,
                    u = {
                        ...e,
                        isSubstitutionRHS:
                            !0
                    };
                return n
                    .Substitution(
                        rn(u, o),
                        B3(u, a))
            }
            case "Decimal":
                return n.Constant(
                    DC(t));
            case "MixedNumber":
                return n
                    .MixedNumber(SC(
                        t));
            case "Piecewise":
                return k3(e, t);
            case "RightArrow":
                return G3(e, t);
            case "Seq":
                return n.BareSeq(lt(
                    e, t
                    .args));
            case "EmptyPiecewise":
                return n
                    .Restriction([e
                        .setInput(
                            n
                                .Constant(
                                    !
                                    0
                                ),
                            to(t.span
                                .input,
                                t
                                    .span
                                    .start
                            )
                        )
                    ]);
            case "Comparator":
                throw t.symbol ===
                    "=" ? Nr("=") :
                    am();
            case "ComparatorChain":
                throw t.symbols
                    .includes("=") ?
                    hb() : am();
            case "Tilde":
                throw Nr("~");
            case "Colon":
                throw Nr(":");
            case "Ellipsis":
                throw Nr("...");
            case "For":
                return gg(e, t, {
                    parentIsList:
                        !1
                });
            case "EmptyRangeEnd":
                throw AP();
            case "Err":
                throw U3(t.error);
            default:
                throw `Unexpected surface node ${t.type}.`
        }
    }

    function PE(e) {
        return up.hasOwnProperty(e)
    }

    function _C(e) {
        return e === "ln" || e ===
            "log" || e === "logbase"
    }

    function F3(e) {
        return e.type ===
            "Decimal" && e.val ===
            "2"
    }

    function V3(e) {
        return e.type !== "Neg" ? !
            1 : (e = e.args[0], e
                .type ===
                "Decimal" && e
                    .val === "1")
    }

    function MC(e, t) {
        let n = e.nodes,
            [r, i] = t.args,
            s = rn(e, r),
            o = pr(i),
            a = lt(e, o);
        if (yg(r)) {
            let u = to(i.span.input,
                i.span.start),
                c = e.setInput(LC(
                    e), u);
            return n
                .SeededFunctionCall(
                    s, [c].concat(a)
                )
        }
        if (Un(r)) return n
            .FunctionCall(s, a);
        if (r.type ===
            "Superscript") {
            let [u, c] = r.args;
            if (u.type === "Cmd") {
                let l = u.val;
                if (PE(l) || _C(
                    l)) {
                    if (F3(c))
                        return n
                            .Exponent(
                                [e.setInput(
                                    n
                                        .FunctionCall(
                                            l,
                                            a
                                        ),
                                    void 0
                                ),
                                rn(e,
                                    c
                                )
                                ]);
                    if (V3(c) && up[
                        l] !==
                        void 0)
                        return n
                            .FunctionCall(
                                up[
                                l],
                                a);
                    throw PE(l) ?
                        qx(l) : $x(
                            l ===
                                "logbase" ?
                                "log" :
                                l)
                }
            }
        }
        return n.Multiply([s, rn(e,
            i)])
    }

    function gg(e, t, {
        parentIsList: n
    }) {
        let r = e.nodes,
            [i, s] = t.args,
            o = e.setInput(r
                .Identifier(
                    `_comprehensionIndex_${_3++}`
                ), void 0);
        if (i.type === "For")
            throw Ya("for");
        let a = rn(bg(e, {
            prefix: "li",
            expr: o
        }), i),
            u = [];
        if (s.type === "Seq") {
            let p = !1,
                f = !1,
                m = !1;
            for (let g = 0; g < s
                .args.length; g++) {
                let d = s.args[g];
                cp(d) || e
                    .allowIntervalComprehensions &&
                    d.type ===
                    "ComparatorChain" ?
                    p = !0 : f = !0,
                    d.type ===
                    "Cmd" && d
                        .val ===
                    "cursor" && (
                        m = !0)
            }
            if (p && f) {
                let g = Ya("for");
                throw m && g
                    .setCursorContext({
                        type: "for-assignment-lhs",
                        allowedTypes: [
                            R
                        ]
                    }), g
            }
        }
        let c = [];
        for (let p of pr(s))
            if (e
                .allowIntervalComprehensions &&
                p.type ===
                "ComparatorChain") {
                let f = TE(p),
                    {
                        min: m,
                        identifier: g,
                        max: d,
                        open: y
                    } = f;
                c.push({
                    identifier: rn(
                        e,
                        g
                    ),
                    bounds: [
                        rn(e,
                            m
                        ),
                        rn(e,
                            d
                        )
                    ],
                    open: y
                })
            } else if (p.type ===
                "Comparator" && cp(p)) {
                let f = e.setInput(r
                    .AssignmentExpression(
                        lt(e, p
                            .args)),
                    p.span);
                u.push(f)
            } else {
                if (p.type ===
                    "Comparator")
                    throw bl("a");
                {
                    let f = eT();
                    throw p.type ===
                    "Cmd" && p
                        .val ===
                    "cursor" && f
                        .setCursorContext({
                            type: "for-assignment-lhs",
                            allowedTypes: [
                                R
                            ]
                        }), f
                }
            }
        let l = n;
        return r.ListComprehension(
            o, a, u, l, c)
    }

    function B3(e, t) {
        let n = e.nodes;
        if (t.type === "Seq") {
            let s = !1,
                o = !1,
                a = !1;
            for (let u = 0; u < t
                .args.length; u++) {
                let c = t.args[u];
                if (c.type ===
                    "With")
                    throw Ya("with");
                if (cp(c) || vC(c))
                    s = !0;
                else if (e
                    .allowIntervalComprehensions &&
                    c.type ===
                    "ComparatorChain"
                ) try {
                    TE(c), o = !
                        0
                } catch (l) {
                    a = !0
                } else a = !0
            }
            if ((s || o) && a)
                throw Ya("with");
            if (o) throw Hm()
        }
        if (e
            .allowIntervalComprehensions &&
            t.type ===
            "ComparatorChain") {
            let s;
            try {
                TE(t), s = !0
            } catch (o) {
                s = !1
            }
            if (s) throw Hm()
        }
        if (t.type === "With")
            throw zm();
        let r = pr(t),
            i = [];
        for (let s of r) {
            if (s.type !=
                "Comparator" || !cp(
                    s) && !vC(s))
                throw mf();
            let o = e.setInput(n
                .AssignmentExpression(
                    lt(e, s
                        .args)),
                s.span);
            i.push(o)
        }
        return i
    }

    function vC(e) {
        if (e.type !==
            "Comparator" || e
                .symbol !== "=")
            return !1;
        let t = e.args[0];
        if (t.type !== "Call")
            return !1;
        let [n] = t.args;
        return !!Un(n)
    }

    function TE(e) {
        if (e.symbols.length !== 2)
            throw bl("a");
        let [t, n, r] = e.args, [i,
            s
        ] = e.symbols;
        if (!Un(n)) throw bl("a");
        if (i !== "<" && i !==
            "<=" || s !== "<" &&
            s !== "<=" || e.symbols
                .includes("="))
            throw bl(Cn(n.span));
        return {
            min: t,
            identifier: n,
            max: r,
            open: [i === "<", s ===
                "<"
            ]
        }
    }

    function G3(e, t) {
        let n = e.nodes;
        if (!Un(t.args[0]))
            throw Jb();
        return e = bg(e, {
            prefix: "ec",
            expr: e
                .setInput(n
                    .Identifier(
                        "globalEventCount"
                    ),
                    void 0)
        }), n.UpdateRule(lt(e, t
            .args))
    }

    function k3(e, t) {
        let n = e.nodes,
            [r] = t.args,
            i = pr(r);
        if (i.length === 1 && Qf(i[
            0])) {
            let f = i[0];
            return n.Restriction([e
                .setInput(
                    Qo(e,
                        f), f
                    .span)
            ])
        }
        if (i.length > 1 && i.every(
            Qf)) {
            let f = e.setInput(Qo(e,
                i[0]), i[0]
                .span);
            for (let m = 1; m < i
                .length; m++) {
                let g = e.setInput(
                    Qo(e, i[m]),
                    i[m].span);
                f = e.setInput(n.Or(
                    [f, g]),
                    Kr(i[0]
                        .span,
                        i[m]
                            .span))
            }
            return n.Restriction([
                f])
        }
        let s, o = [];
        e: for (s = 0; s < i
            .length; s++) {
            let f = i[s];
            switch (f.type) {
                case "Colon": {
                    let [m, g] =
                        f.args;
                    if (!Qf(m))
                        throw Zx();
                    if (g
                        .type ===
                        "With" &&
                        g.args[
                            1]
                            .type ===
                        "Seq")
                        throw Ya(
                            "with"
                        );
                    o.push({
                        condition: e
                            .setInput(
                                Qo(e,
                                    m
                                ),
                                m
                                    .span
                            ),
                        if_expr: rn(
                            e,
                            g
                        )
                    });
                    break
                }
                case "Comparator":
                case "ComparatorChain":
                    o.push({
                        condition: e
                            .setInput(
                                Qo(e,
                                    f
                                ),
                                f
                                    .span
                            ),
                        if_expr: e
                            .setInput(
                                n
                                    .Constant(
                                        De(1,
                                            1
                                        )
                                    ),
                                yi("1",
                                    0,
                                    1
                                )
                            )
                    });
                    break;
                case "For":
                    throw Ya(
                        "for"
                    );
                default:
                    break e
            }
        }
        if (s === 0) throw Yx();
        if (s < i.length - 1)
            throw Xx();
        let a, u;
        s === i.length - 1 ? (a =
            Jf(e, i[s]), u = i[
            s]) : a = n
                .Constant(NaN);
        let c = a,
            l = u == null ? void 0 :
                u.span,
            p;
        for (; o.length;) p = o
            .pop(), c = n.Piecewise(
                [p.condition, p
                    .if_expr, e
                        .setInput(c, l)
                ]), l = void 0;
        return c
    }

    function Qf(e) {
        return e.type ===
            "Comparator" || e
                .type ===
            "ComparatorChain"
    }

    function Qo(e, t) {
        let n = e.nodes;
        switch (t.type) {
            case "Comparator":
                return n.Comparator[
                    t.symbol](
                        lt(e, t
                            .args));
            case "ComparatorChain":
                return n
                    .ComparatorChain(
                        t.symbols,
                        lt(e, t
                            .args));
            default:
                throw J(
                    `Unexpected type for condition: ${t.type}`)
        }
    }

    function z3(e) {
        let [t, n] = e.args;
        if (t.type ===
            "Superscript" && (t = t
                .args[0]), t
                    .type === "Cmd" && t
                        .val === "logbase" && n
                            .type === "Seq" && n
                                .args.length === 2) {
            if (!bo(n.args[0]))
                throw hm("log")
        } else if (!bo(n)) throw t
            .type === "Cmd" ?
            hm(t.val) : J(
                `Unexpected type for args of implicit call: ${n.type}`
            )
    }

    function DC(e) {
        return Yu(e.val)
    }

    function SC(e) {
        let t = Yu(e.whole),
            n = Yu(e.num),
            r = Yu(e.den);
        return us(t, Ji(n, r))
    }

    function H3(e) {
        if (e.type !== "Call")
            return !1;
        let t = e.args[0];
        for (; t.type ===
            "Superscript" || t
                .type === "Subscript" ||
            t.type === "Prime";) t =
                t.args[0];
        return t.type !== "Cmd" ? !
            1 : PE(t.val) || _C(t
                .val)
    }

    function cp(e) {
        return e.type ===
            "Comparator" && e
                .symbol === "=" && Un(e
                    .args[0])
    }

    function U3(e) {
        switch (e.type) {
            case "UnexpectedParseError":
            case "MissingBound":
            case "EmptyGroup":
            case "UnexpectedDifferential":
            case "UnexpectedEnd":
                return J(
                    `Unexpected error type: ${e.type}`
                );
            case "InvalidOperatorName":
                return Fx();
            case "UnexpectedCloseDelimiter":
            case "MissingCloseDelimiter":
                return YP(e.open, e
                    .close);
            case "UnrecognizedSymbol":
                return e.val ===
                    "." ? Nr(e
                        .val) : om(e
                            .val);
            case "EmptyInput":
                return nf();
            case "BinaryOperatorMissingRight":
            case "BinaryOperatorMissingLeft":
                return tf(e.val ===
                    "%" ?
                    "% of" : e
                        .val);
            case "UnaryOperatorMissingLeft":
                return Cx(e.val);
            case "UnaryOperatorMissingRight":
                return Rx(e.val);
            case "UnexpectedSubscript":
                return Jx(e.base);
            case "PercentMissingOf":
                return ZP();
            case "SumMissingBound":
                return _P();
            case "ProductMissingBound":
                return LP();
            case "IntegralMissingBound":
                return GP();
            case "SumMissingBody":
                return HP();
            case "ProductMissingBody":
                return UP();
            case "IntegralMissingBody":
                return qP();
            case "DerivativeMissingBody":
                return $P();
            case "IntegralMissingDifferential":
                return kP();
            case "DifferentialWithSuperscript":
                return zP();
            case "FractionMissingNumerator":
                return Nx();
            case "FractionMissingDenominator":
                return Ax();
            case "FractionEmpty":
                return _x();
            case "EmptySuperscript":
                return Lx();
            case "EmptySubscript":
                return xm();
            case "InvalidSubscript":
                return wx(e.val);
            case "SuperscriptWithPrime":
                return Bx();
            case "PrimeWithoutParen":
                return Tm();
            case "UnexpectedPrime":
                return Pm();
            case "EmptyRadical":
                return Gx();
            case "EmptyRadicalIndex":
                return kx();
            case "EmptySquareBracket":
                return Hx();
            case "EmptyPipe":
                return Ux();
            case "FunctionMissingArgument":
                return ds(e.val, 1,
                    0);
            case "AdjacentNumbers":
                return vx(hg(e.args[
                    0]), hg(
                        e.args[
                        1]));
            case "TokenWithSubscript":
                return Dx();
            case "UnexpectedFor":
                return Nr("for");
            default:
                throw `Unexpected surface node ${e.type}.`
        }
    }

    function hg(e) {
        switch (e.type) {
            case "Decimal":
                return e.val;
            case "MixedNumber":
                return `${e.whole} ${e.num}/${e.den}`;
            default:
                let t = e;
                throw new Error(
                    `Unexpected node type ${t.type}`
                )
        }
    }

    function bo(e) {
        switch (e.type) {
            case "Letter":
            case "Decimal":
            case "MixedNumber":
            case "Cmd":
            case "EmptyPiecewise":
                return !0;
            case "Neg": {
                let n = e.args[0];
                for (; ;)
                    if (n.type ===
                        "Pos" || n
                            .type ===
                        "Paren" && !
                        AC(n)) n = n
                            .args[0];
                    else if (n
                        .type === "Neg")
                        n = n.args[0];
                    else break;
                return n.type ===
                    "Decimal" || n
                        .type ===
                    "MixedNumber"
            }
            case "Pos":
                return bo(e.args[
                    0]);
            case "Paren":
                return bo(e.args[
                    0]);
            case "Juxt":
            case "Mul":
            case "DotMul":
            case "CrossMul":
            case "Div":
                return bo(e.args[
                    0]) && bo(e
                        .args[1]);
            case "Subscript":
                return bo(e.args[
                    0]);
            case "Superscript":
            case "Frac":
            case "Add":
            case "Sub":
                return bo(e.args[
                    0]) && bo(e
                        .args[1]);
            case "Piecewise": {
                let [n] = e.args;
                return Qf(n)
            }
            case "Call": {
                let [n, r] = e.args;
                return Un(n) || BO(
                    n) ? !1 :
                    bo(n) && bo(r)
            }
            case "Derivative":
            case "Sqrt":
            case "Nthroot":
            case "Pipes":
            case "Bang":
                return !1;
            case "Comparator":
            case "ComparatorChain":
            case "Tilde":
            case "ImplicitCall":
            case "Index":
            case "List":
            case "Seq":
            case "Integral":
            case "EmptyIntegral":
            case "Sum":
            case "Product":
            case "Colon":
            case "Ellipsis":
            case "For":
            case "With":
            case "Dot":
            case "PercentOf":
            case "Prime":
            case "EmptyRangeEnd":
            case "RightArrow":
                return !1;
            default:
                throw `Unexpected surface node ${e.type}.`
        }
    }

    function yg(e) {
        return e.type !== "Cmd" ? !
            1 : e.val ===
            "random" || e.val ===
        "shuffle"
    }

    function LC(e) {
        let t = e.nodes.ExtendSeed(
            "", [e.setInput(e
                .nodes
                .Identifier(
                    "globalRandomSeed"
                ),
                void 0), e
                    .setInput(e
                        .nodes.Seed(
                            e
                                .nextSeed()
                        ),
                        void 0)
        ]);
        if (!e.seedExtensions)
            return t;
        for (let {
            prefix: n,
            expr: r
        }
            of e.seedExtensions) t =
                e.nodes.ExtendSeed(n, [e
                    .setInput(t,
                        void 0), r
                ]);
        return t
    }

    function bg(e, t) {
        let n = e.seedExtensions ||
            [];
        return {
            ...e,
            seedExtensions: n
                .concat(t)
        }
    }
    var q3 = [
        [op("("), Xt(")"), op(
            "\\{"), Xt(
                "\\}"), jf("["),
        Xt("]"), op("(|"),
        Xt("|)"), Xt(
            "Differential"),
        Xt("End")
        ],
        [Xt("for")],
        [jf("with")],
        [ap("...")],
        [Xt(",")],
        [ap(":")],
        [jf("->")],
        [Wf("with")],
        [Xt("="), Xt(">"), Xt(
            "<"), Xt(">="),
        Xt("<="), Xt("~")
        ],
        [Wf("->")],
        [Xt("+"), Xt("-")],
        [Xt("*"), Xt("\\cdot"),
        Xt("\\times"), Xt(
            "/"), Xt(
                "Decimal"), Xt(
                    "MixedNumber"),
        Xt("Letter"), Xt(
            "Cmd"), Xt(
                "TokenNode"),
        Xt("%"), jf("("),
        Xt("\\{"), Xt("(|"),
        Xt("Frac"), Xt(
            "Sqrt"), Xt(
                "Trig"), Xt(
                    "Ln"), Xt(
                        "Log"), ap("Int"),
        ap("Sum"), ap(
            "Prod")
        ],
        [op("+"), op("-")],
        [Xt("!")],
        [Xt("SupSub")],
        [Wf("["), Xt(".")],
        [Wf("(")],
        [Xt("Err")]
    ],
        {
            leftPrec: xg,
            rightPrec: wC,
            initialPrec: GC
        } = EC(q3),
        FC = {
            trailingComma: !1
        };

    function kC(e, t) {
        let n = t ? {
            ...FC,
            ...t
        } : FC,
            r = Oa(e, n),
            i = $3(r);
        return i.type === "Err" && i
            .error.type ===
            "EmptyGroup" ? Ce(i
                .span, kO()) : i
    }

    function $3(e) {
        return bu(e, {
            isToplevel: !0
        })
    }

    function bu(e, {
        isToplevel: t
    } = {
            isToplevel: !1
        }) {
        if (mg(e)) return Ce(ye(e,
            e), zO());
        let {
            state: n,
            tree: r
        } = Qn(e, 0, {
            isToplevel: t
        });
        return r.type !== "Err" && !
            mg(n) ? ME(n).tree : r
    }

    function B(e, t) {
        return {
            state: e,
            tree: t
        }
    }

    function Qn(e, t, {
        isToplevel: n
    } = {
            isToplevel: !1
        }) {
        let r = e,
            i;
        if ({
            state: r,
            tree: i
        } = Y3(r), i.type ===
            "Err") return B(r, i);
        if (!xE(e, r))
            throw new Error(
                "Programming Error: parseInitial did not advance state."
            );
        for (; !mg(r);) {
            let s;
            if (Ir(r, "(") && !W3(
                i) ? s = wC("(") :
                s = xg(wr(r).type),
                t >= s) break;
            let o = r,
                a = X3(r, i, n) ?
                    xg("for") - 1 : wC(
                        wr(r).type);
            if ({
                state: r,
                tree: i
            } = Z3(r, i, a), i
                .type === "Err")
                return B(r, i);
            if (!xE(o, r))
                throw new Error(
                    "Programming Error: parseSuccessor did not advance state."
                )
        }
        return B(r, i)
    }

    function ns(e) {
        return e.type ===
            "UnexpectedDifferential" ||
            e.type ===
            "UnexpectedCloseDelimiter" ||
            e.type ===
            "UnexpectedEnd" || e
                .type ===
            "BinaryOperatorMissingLeft"
    }

    function Y3(e) {
        let t = e,
            n = wr(e),
            r = GC(n.type),
            i;
        switch (n.type) {
            case "+": {
                if (e = Ve(e), {
                    state: e,
                    tree: i
                } = Qn(e, r), i
                    .type === "Err"
                ) {
                    if (!ns(i
                        .error))
                        return B(e,
                            i);
                    let o = ye(t,
                        e),
                        a = Ce(o,
                            cE(n
                                .val)
                        );
                    return B(e, a)
                }
                return B(e, aO(ye(t,
                    e),
                    [i]))
            }
            case "-":
                if (e = Ve(e), {
                    state: e,
                    tree: i
                } = Qn(e, r), i
                    .type === "Err"
                ) {
                    if (!ns(i
                        .error))
                        return B(e,
                            i);
                    let o = ye(t,
                        e),
                        a = Ce(o,
                            cE(n
                                .val)
                        );
                    return B(e, a)
                } else return B(e,
                    uO(ye(t,
                        e),
                        [i])
                );
            case "(":
                return Kf(e);
            case "\\{":
                return e = Ve(e),
                    Ir(e, "\\}") ? (
                        e = Ve(e),
                        B(e, SO(ye(t,
                            e
                        )))) :
                        ({
                            state: e,
                            tree: i
                        } = Qn(e,
                            r), {
                                state: e,
                                tree: i
                            } = ed(t, e,
                                i,
                                "\\{",
                                "\\}"),
                            i.type ===
                                "Err" ? B(e,
                                    i) : B(
                                        e, DO(
                                            ye(t,
                                                e
                                            ),
                                            [i])
                                    ));
            case "[":
                return e = Ve(e),
                    Ir(e, "]") ? (
                        e = Ve(e),
                        B(e, tE(ye(t,
                            e
                        ),
                            []))) :
                        ({
                            state: e,
                            tree: i
                        } = Qn(e,
                            r), {
                                state: e,
                                tree: i
                            } = ed(t, e,
                                i, "[",
                                "]"), i
                                    .type ===
                                    "Err" ? B(e,
                                        i) : B(
                                            e, tE(
                                                ye(t,
                                                    e
                                                ),
                                                [i])
                                        ));
            case "(|": {
                if (e = Ve(e), Ir(e,
                    "|)")) {
                    e = Ve(e);
                    let o = ye(t,
                        e);
                    return B(e, Ce(
                        o,
                        qO()
                    ))
                }
                return {
                    state: e,
                    tree: i
                } = Qn(e, r), {
                    state: e,
                    tree: i
                } = ed(t, e, i,
                    "(|", "|)"),
                    i.type ===
                        "Err" ? B(e,
                            i) : B(e, hO(ye(
                                t, e
                            ), [
                                i
                            ]))
            }
            case "Frac": {
                if (e.opts
                    .disallowFrac)
                    throw Gm();
                e = Ve(e);
                let o = bu(Oa(n.num,
                    e.opts)),
                    a = bu(Oa(n.den,
                        e.opts));
                if (o.type ===
                    "Err" && o.error
                        .type ===
                    "EmptyGroup" &&
                    a.type ===
                    "Err" && a.error
                        .type ===
                    "EmptyGroup") {
                    let u = ye(t,
                        e),
                        c = Ce(u,
                            pC());
                    return B(e, c)
                }
                if (o.type ===
                    "Err" && o.error
                        .type ===
                    "EmptyGroup") {
                    let u = ye(t,
                        e),
                        c = Ce(u,
                            cC());
                    return B(e, c)
                }
                if (a.type ===
                    "Err" && a.error
                        .type ===
                    "EmptyGroup") {
                    let u = ye(t,
                        e),
                        c = Ce(u,
                            lC());
                    return B(e, c)
                }
                if (o.type ===
                    "Err") return B(
                        e, o);
                if (a.type ===
                    "Err") return B(
                        e, a);
                if (GO(o, a) && a
                    .type === "Juxt"
                ) {
                    let u = a.args[
                        1],
                        c;
                    if ({
                        state: e,
                        tree: c
                    } = Qn(e,
                        xg(
                            "*") - 1
                    ), c
                        .type ===
                        "Err") {
                        if (ns(c
                            .error)) {
                            let l =
                                ye(t,
                                    e
                                );
                            return B(
                                e,
                                Ce(l,
                                    oC()
                                )
                            )
                        }
                        return B(e,
                            c)
                    }
                    return B(e, TO(
                        ye(t,
                            e
                        ),
                        [u,
                            c]
                    ))
                }
                return B(e, PO(ye(t,
                    e),
                    [o, a]))
            }
            case "Sqrt":
                if (e = Ve(e), n
                    .optArg) {
                    let o = bu(Oa(n
                        .optArg,
                        e
                            .opts
                    ));
                    if (o.type ===
                        "Err")
                        return o
                            .error
                            .type ===
                            "EmptyGroup" ?
                            B(e, Ce(o
                                .span,
                                $O()
                            )) :
                            B(e, o);
                    let a = bu(Oa(n
                        .arg,
                        e
                            .opts
                    ));
                    return a
                        .type ===
                        "Err" ? a
                            .error
                            .type ===
                            "EmptyGroup" ?
                        B(e, Ce(a
                            .span,
                            aE()
                        )) : B(
                            e, a) :
                        B(e, xO(ye(t,
                            e
                        ),
                            [o,
                                a]
                        ))
                } else {
                    let o = bu(Oa(n
                        .arg,
                        e
                            .opts
                    ));
                    return o
                        .type ===
                        "Err" ? o
                            .error
                            .type ===
                            "EmptyGroup" ?
                        B(e, Ce(o
                            .span,
                            aE()
                        )) : B(
                            e, o) :
                        B(e, bO(ye(t,
                            e
                        ),
                            [o]
                        ))
                }
            case "Trig":
            case "Ln": {
                e = Ve(e);
                let o = Oc(ye(t, e),
                    n.val),
                    a = 0,
                    u = wr(e);
                if (u.type ===
                    "SupSub") {
                    if (e = Ve(e), u
                        .sub) {
                        let p = ye(
                            t, e
                        ),
                            f = Ce(
                                p,
                                JO(o
                                    .val)
                            );
                        return B(e,
                            f)
                    }
                    let l = Pg(u, e
                        .opts);
                    if (l) {
                        if (l
                            .type ===
                            "Err")
                            return B(
                                e,
                                l
                            );
                        o = ug(ye(t,
                            e),
                            [o,
                                l]
                        )
                    }
                    a = u.nprimes
                }
                let c = Ir(e, "(");
                if (c) {
                    if ({
                        state: e,
                        tree: i
                    } = Kf(e), i
                        .type ===
                        "Err")
                        return B(e,
                            i);
                    i = $f(ye(t, e),
                        [o, i
                            .args[
                            0
                        ]
                        ])
                } else {
                    if ({
                        state: e,
                        tree: i
                    } = Qn(e,
                        r - 1),
                        i.type ===
                        "Err")
                        return ns(i
                            .error
                        ) ?
                            B(e, Ce(ye(t,
                                e
                            ),
                                pE(n
                                    .val)
                            )) :
                            B(e, i);
                    i = KI(ye(t, e),
                        [o, i])
                }
                if (a > 0) {
                    let l = ye(t,
                        e);
                    if (!c) {
                        let p = Ce(
                            l,
                            fE()
                        );
                        return B(e,
                            p)
                    }
                    i = Yf(l, a, [
                        i])
                }
                return B(e, i)
            }
            case "Log": {
                e = Ve(e);
                let o = ye(t, e),
                    a = Oc(o, n
                        .val),
                    u = 0,
                    c, l, p = wr(e);
                if (p.type ===
                    "SupSub" && (e =
                        Ve(e), c =
                        zC(p, e
                            .opts),
                        l = Pg(p, e
                            .opts),
                        u = p
                            .nprimes),
                    c && c.type ===
                    "Err") return B(
                        e, c);
                if (l && l.type ===
                    "Err") return B(
                        e, l);
                let f = Ir(e, "(");
                if (f) {
                    if ({
                        state: e,
                        tree: i
                    } = Kf(e), i
                        .type ===
                        "Err")
                        return B(e,
                            i);
                    i = i.args[0]
                } else if ({
                    state: e,
                    tree: i
                } = Qn(e, r -
                    1), i.type ===
                    "Err")
                    return ns(i
                        .error
                    ) ? B(e,
                        Ce(ye(t,
                            e),
                            pE(n
                                .val)
                        )) :
                        B(e, i);
                let m = c ? Oc(o,
                    "\\logbase"
                ) : a,
                    g = c ? cg(ye(t,
                        e), pr(
                            i)
                            .concat(c)
                    ) : i;
                if (l && (m = ug(ye(
                    t, e
                ), [
                    m, l
                ])), f ? i = $f(
                    ye(t, e), [
                    m, g
                ]) : i = KI(
                    ye(t, e), [
                    m, g
                ]), u > 0) {
                    let d = ye(t,
                        e);
                    if (!f) {
                        let y = Ce(
                            d,
                            fE()
                        );
                        return B(e,
                            y)
                    }
                    i = Yf(d, u, [
                        i])
                }
                return B(e, i)
            }
            case "Int": {
                e = Ve(e);
                let o = wr(e);
                e = Ve(e);
                let a = EE(o, t, e);
                if (a.type ===
                    "Err") return a
                        .error
                        .type ===
                        "MissingBound" ?
                        B(e, Ce(a
                            .span,
                            nC()
                        )) : B(
                            e, a);
                let {
                    sup: u,
                    sub: c
                } = a, l;
                if (Ir(e,
                    "Differential"
                )) return {
                    state: e,
                    tree: l
                } = BC(e), l
                    .type ===
                    "Err" ? B(e,
                        l) : B(e, EO(ye(
                            t, e
                        ), [
                            l,
                            c, u
                        ]));
                if ({
                    state: e,
                    tree: i
                } = Qn(e, r), i
                    .type === "Err")
                    return ns(i
                        .error
                    ) ? B(e,
                        Ce(i.span,
                            sC()
                        )) :
                        B(e, i);
                let p = i;
                return Ir(e,
                    "Differential"
                ) ? ({
                    state: e,
                    tree: l
                } = BC(e), l
                    .type ===
                    "Err" ? B(e,
                        l) : B(
                            e, IO(
                                ye(t,
                                    e
                                ),
                                [l, c,
                                    u,
                                    p
                                ]))
                ) : B(e, Ce(
                    ye(t,
                        e), aC()
                ))
            }
            case "Sum": {
                e = Ve(e);
                let o = wr(e);
                e = Ve(e);
                let a = EE(o, t, e);
                if (a.type ===
                    "Err") return a
                        .error
                        .type ===
                        "MissingBound" ?
                        B(e, Ce(a
                            .span,
                            eC()
                        )) : B(
                            e, a);
                let {
                    sup: u,
                    sub: c
                } = a;
                return {
                    state: e,
                    tree: i
                } = Qn(e, r), i
                    .type ===
                    "Err" ? ns(i
                        .error) ? B(
                            e, Ce(i
                                .span,
                                rC())) :
                        B(e, i) : B(e,
                            MO(ye(t, e),
                                [i, c,
                                    u]))
            }
            case "Prod": {
                e = Ve(e);
                let o = wr(e);
                e = Ve(e);
                let a = EE(o, t, e);
                if (a.type ===
                    "Err") return a
                        .error
                        .type ===
                        "MissingBound" ?
                        B(e, Ce(a
                            .span,
                            tC()
                        )) : B(
                            e, a);
                let {
                    sup: u,
                    sub: c
                } = a;
                return {
                    state: e,
                    tree: i
                } = Qn(e, r), i
                    .type ===
                    "Err" ? ns(i
                        .error) ? B(
                            e, Ce(i
                                .span,
                                iC())) :
                        B(e, i) : B(e,
                            vO(ye(t, e),
                                [i, c,
                                    u]))
            }
            case "Cmd":
                return e = Ve(e),
                    i = Oc(ye(t, e),
                        n.val), B(e,
                            i);
            case "TokenNode": {
                e = Ve(e);
                let o = wr(e);
                return o.type ===
                    "SupSub" && o
                        .sub ? (e = Ve(
                            e), B(e,
                                Ce(ye(t,
                                    e),
                                    dC()
                                ))) : (
                    i = Oc(ye(t,
                        e),
                        n.val),
                    B(e, i))
            }
            case "Letter":
                return e = Ve(e),
                    i = wO(ye(t, e),
                        n.val), B(e,
                            i);
            case "Decimal": {
                e = Ve(e);
                let o = lg(ye(t, e),
                    n.val),
                    a = e.token;
                if (a.type ===
                    "Decimal" || a
                        .type ===
                    "MixedNumber") {
                    let u = e;
                    e = Ve(e);
                    let c = ye(t,
                        e),
                        l = a
                            .type ===
                            "MixedNumber" ?
                            a : lg(ye(u,
                                e),
                                a.val);
                    return B(e, Ce(
                        c,
                        mE([o,
                            l])
                    ))
                }
                return B(e, o)
            }
            case "MixedNumber": {
                if (e.opts
                    .disallowFrac)
                    throw Gm();
                e = Ve(e);
                let o = e.token;
                if (o.type ===
                    "Decimal" || o
                        .type ===
                    "MixedNumber") {
                    let a = e;
                    e = Ve(e);
                    let u = ye(t,
                        e),
                        c = o
                            .type ===
                            "MixedNumber" ?
                            o : lg(ye(a,
                                e),
                                o.val);
                    return B(e, Ce(
                        u,
                        mE([n,
                            c])
                    ))
                }
                return B(e, n)
            }
            case "*":
            case "\\cdot":
            case "\\times":
            case "/":
            case ",":
            case "=":
            case ">":
            case "<":
            case ">=":
            case "<=":
            case "->":
            case "~":
            case ":":
            case "...":
            case "%":
            case ".": {
                e = Ve(e);
                let o = ye(t, e),
                    a = Ce(o, YO(n
                        .val));
                return B(e, a)
            }
            case "for": {
                e = Ve(e);
                let o = ye(t, e),
                    a = Ce(o, fC());
                return B(e, a)
            }
            case "with": {
                e = Ve(e);
                let o = ye(t, e),
                    a = Ce(o, sE());
                return B(e, a)
            }
            case "!": {
                e = Ve(e);
                let o = ye(t, e),
                    a = Ce(o, lE(n
                        .val));
                return B(e, a)
            }
            case "SupSub": {
                e = Ve(e);
                let o = "supsub";
                n.sub ? o =
                    "subscript" : n
                        .sup ? o =
                "superscript" :
                    n.nprimes > 0 &&
                    (o = "prime");
                let a = ye(t, e),
                    u = Ce(a, lE(
                        o));
                return B(e, u)
            }
            case ")":
            case "\\}":
            case "]":
            case "|)":
            case "Differential":
                return ME(e);
            case "Err": {
                e = Ve(e);
                let o = ye(t, e),
                    a = Ce(o, WO(n
                        .val));
                return B(e, a)
            }
            case "End": {
                let o = ye(t, e),
                    a = Ce(o, uE());
                return B(e, a)
            }
            default:
                throw `Unexpected token type ${n.type}.`
        }
    }

    function X3(e, t, n) {
        return Ir(e, "=") && n && (
            RC(t) || IE(t))
    }

    function Z3(e, t, n) {
        let r = wr(e),
            i;
        switch (r.type) {
            case "+":
            case "-":
            case "*":
            case "\\cdot":
            case "\\times":
            case "/":
            case "~":
            case ":":
            case ".":
            case "->":
            case "for": {
                if (e = Ve(e), {
                    state: e,
                    tree: i
                } = Qn(e, n), i
                    .type === "Err")
                    if (ns(i
                        .error)) {
                        let o = qn(t
                            .span,
                            e),
                            a = Ce(
                                o,
                                Cc(r
                                    .val)
                            );
                        return B(e,
                            a)
                    } else return B(
                        e, i
                    );
                return B(e, VC(r
                    .type,
                    qn(t.span,
                        e),
                    [t, i]))
            }
            case "with": {
                if (e = Ve(e), {
                    state: e,
                    tree: i
                } = Qn(e, n), i
                    .type === "Err")
                    if (ns(i
                        .error)) {
                        let o = qn(t
                            .span,
                            e),
                            a = Ce(
                                o,
                                Cc(r
                                    .val)
                            );
                        return B(e,
                            a)
                    } else return B(
                        e, i
                    );
                return B(e, VC(r
                    .type,
                    qn(t.span,
                        e),
                    [t, i]))
            }
            case "%": {
                e = Ve(e);
                let o = wr(e);
                if (o.type !==
                    "Cmd" || o
                        .val !== "of" &&
                    o.val !== "\\of"
                ) {
                    let a = Ce(r
                        .span,
                        QO());
                    return B(e, a)
                }
                if (e = Ve(e), {
                    state: e,
                    tree: i
                } = Qn(e, n), i
                    .type === "Err")
                    if (ns(i
                        .error)) {
                        let a = qn(t
                            .span,
                            e),
                            u = Ce(
                                a,
                                Cc(r
                                    .val)
                            );
                        return B(e,
                            u)
                    } else return B(
                        e, i
                    );
                return B(e, _O(qn(t
                    .span,
                    e),
                    [t, i]))
            }
            case "=":
            case ">=":
            case "<=":
            case ">":
            case "<": {
                let o = [t],
                    a = [];
                for (; ;) {
                    let c = wr(e)
                        .type;
                    if (c !== "=" &&
                        c !==
                        ">=" &&
                        c !==
                        "<=" &&
                        c !== ">" &&
                        c !== "<")
                        break;
                    if (a.push(c),
                        e = Ve(e), {
                            state: e,
                            tree: i
                        } = Qn(e,
                            n), i
                                .type ===
                        "Err")
                        if (ns(i
                            .error)) {
                            let l =
                                qn(t.span,
                                    e
                                ),
                                p =
                                    Ce(l,
                                        Cc(r
                                            .val)
                                    );
                            return B(
                                e,
                                p
                            )
                        } else
                            return B(
                                e,
                                i
                            );
                    o.push(i)
                }
                let u = o[o.length -
                    1];
                return u.type ===
                    "Comparator" ? (
                    o.pop(),
                    Array
                        .prototype
                        .push.apply(
                            o, u
                            .args),
                    a.push(u
                        .symbol)
                ) : u
                    .type ===
                "ComparatorChain" &&
                (o.pop(), Array
                    .prototype
                    .push.apply(
                        o, u
                        .args),
                    Array
                        .prototype
                        .push.apply(
                            a, u
                            .symbols
                        )), o
                            .length === 2 ?
                        B(e, iO(qn(t.span,
                            e),
                            a[0], o
                        )) : B(
                            e, sO(qn(t
                                .span,
                                e),
                                a, o))
            }
            case "!":
                return e = Ve(e), B(
                    e, yO(qn(t
                        .span,
                        e),
                        [t]));
            case "[": {
                let o = e;
                if (e = Ve(e), Ir(e,
                    "]")) {
                    e = Ve(e);
                    let a = ye(o,
                        e);
                    return B(e, Ce(
                        a,
                        UO()
                    ))
                }
                return {
                    state: e,
                    tree: i
                } = Qn(e, n), {
                    state: e,
                    tree: i
                } = ed(o, e, i,
                    "[", "]"), i
                        .type ===
                        "Err" ? B(e,
                            i) : B(e, gO(qn(
                                t
                                    .span,
                                e),
                                [t, i]))
            }
            case "Sqrt":
            case "Frac":
            case "Letter":
            case "Cmd":
            case "TokenNode":
            case "Trig":
            case "Ln":
            case "Log":
            case "Sum":
            case "Int":
            case "Prod":
            case "Decimal":
            case "MixedNumber":
            case "\\{":
            case "(|":
                return {
                    state: e, tree:
                        i
                } = Qn(e, n), i
                    .type ===
                    "Err" ? B(e,
                        i) : B(e, iE(qn(
                            t
                                .span,
                            e),
                            [t, i]));
            case "(":
                if (Un(t)) {
                    if ({
                        state: e,
                        tree: i
                    } = Kf(e), i
                        .type ===
                        "Err")
                        return B(e,
                            i);
                    let o = qn(t
                        .span, e
                    );
                    return B(e, $f(
                        o, [t,
                        i
                            .args[
                        0
                        ]
                    ]))
                } else if (t
                    .type ===
                    "Prime" && Un(t
                        .args[0])) {
                    if ({
                        state: e,
                        tree: i
                    } = Kf(e), i
                        .type ===
                        "Err")
                        return B(e,
                            i);
                    let o = qn(t
                        .span, e
                    );
                    return B(e, Yf(
                        o, t
                        .nprimes,
                        [$f(o, [t.args[
                            0],
                        i
                            .args[
                        0
                        ]
                        ])]
                    ))
                } else return {
                    state: e,
                    tree: i
                } = Qn(e, n), i
                    .type ===
                    "Err" ? B(e,
                        i) : B(e, iE(qn(
                            t
                                .span,
                            e),
                            [t, i]));
            case "SupSub": {
                e = Ve(e);
                let o = HC(r),
                    a = Pg(r, e
                        .opts);
                if (o && o.type ===
                    "Err") return B(
                        e, o);
                if (a && a.type ===
                    "Err") return B(
                        e, a);
                if (o && (t = nE(qn(
                    t
                        .span,
                    e),
                    [t, o])),
                    a && (t = ug(qn(
                        t
                            .span,
                        e),
                        [t, a])), r
                            .nprimes > 0) {
                    let u = qn(t
                        .span, e
                    );
                    if (!Un(t)) {
                        let c = Ce(
                            u,
                            pg()
                        );
                        return B(e,
                            c)
                    }
                    t = Yf(u, r
                        .nprimes,
                        [t])
                }
                return B(e, t)
            }
            case ",": {
                let o = [t];
                for (; Ir(e, ",") &&
                    (e = Ve(e), !(
                        Ir(e,
                            "..."
                        ) ||
                        e.opts
                            .trailingComma &&
                        j3(e)));) {
                    if ({
                        state: e,
                        tree: i
                    } = Qn(e,
                        n), i
                            .type ===
                        "Err")
                        if (ns(i
                            .error)) {
                            let a =
                                qn(t.span,
                                    e
                                ),
                                u =
                                    Ce(a,
                                        Cc(r
                                            .val)
                                    );
                            return B(
                                e,
                                u
                            )
                        } else
                            return B(
                                e,
                                i
                            );
                    o.push(i)
                }
                return B(e, cg(qn(t
                    .span,
                    e),
                    o))
            }
            case "...": {
                if (e = Ve(e), Ir(e,
                    ",") && (e =
                        Ve(e)), n >=
                    xg(wr(e).type))
                    return B(e, rE(
                        qn(t.span,
                            e
                        ),
                        [t, OO(hE(
                            e))]
                    ));
                if ({
                    state: e,
                    tree: i
                } = Qn(e, n), i
                    .type === "Err")
                    if (ns(i
                        .error)) {
                        let o = qn(t
                            .span,
                            e),
                            a = Ce(
                                o,
                                Cc(r
                                    .val)
                            );
                        return B(e,
                            a)
                    } else return B(
                        e, i
                    );
                return B(e, rE(qn(t
                    .span,
                    e),
                    [t, i]))
            }
            case "]":
            case ")":
            case "\\}":
            case "|)":
            case "Differential":
                return ME(e);
            case "Err":
                return Qn(e, n);
            case "End": {
                let o = ye(e, e),
                    a = Ce(o, uE());
                return B(e, a)
            }
            default:
                throw `Unexpected token type ${r.type}.`
        }
    }

    function W3(e) {
        return !!(Un(e) || e
            .type === "Prime" &&
            Un(e.args[0]))
    }

    function VC(e, t, n) {
        switch (e) {
            case "+":
                return cO(t, n);
            case "-":
                return lO(t, n);
            case "*":
                return pO(t, n);
            case "\\cdot":
                return fO(t, n);
            case "\\times":
                return dO(t, n);
            case "/":
                return mO(t, n);
            case "~":
                return oO(t, n);
            case ":":
                return CO(t, n);
            case ".":
                return AO(t, n);
            case "->":
                return LO(t, n);
            case "for":
                return RO(t, n);
            case "with":
                return NO(t, n);
            default:
                throw `Unexpected token type ${e}.`
        }
    }

    function zC(e, t) {
        if (!e.sub) return;
        let n = e.sub,
            r = bu(Oa(n, t));
        return r.type === "Err" && r
            .error.type ===
            "EmptyGroup" ? Ce(r
                .span, oE()) : r
    }

    function HC(e) {
        if (!e.sub) return;
        let t = e.sub;
        if (t.args.length === 0)
            return Ce(t.span, oE());
        let n = [];
        for (let r of t.args)
            if (r.type ===
                "Digit" || r
                    .type === "Letter")
                n.push(r.val);
            else {
                let i = r.span;
                return Ce(i, jO(Cn(
                    i)))
            } return FO(t.span, n
                .join(""))
    }

    function Pg(e, t) {
        if (!e.sup) return;
        let n = bu(Oa(e.sup, t));
        return n.type === "Err" ? n
            .error.type ===
            "EmptyGroup" ? Ce(n
                .span, HO()) : n : e
                    .nprimes > 0 ? Ce(e
                        .span, KO()) : n
    }

    function EE(e, t, n) {
        if (e.type !== "SupSub") {
            let s = ye(t, n);
            return Ce(s, dE())
        }
        if (e.nprimes > 0) {
            let s = ye(t, n);
            return Ce(s, pg())
        }
        let r = zC(e, n.opts),
            i = Pg(e, n.opts);
        if (!r || r.type ===
            "Err" && r.error
                .type ===
            "EmptySubscript" || !
            i || i.type === "Err" &&
            i.error.type ===
            "EmptySuperscript") {
            let s = ye(t, n);
            return Ce(s, dE())
        }
        return r.type === "Err" ?
            r : i.type === "Err" ?
                i : {
                    type: "Bounds",
                    sup: i,
                    sub: r
                }
    }

    function Kf(e) {
        let t = e,
            n = wr(e),
            r = GC(n.type);
        if (Ir(e, "(")) e = Ve(e);
        else throw new Error(
            "Programming Error: expected '(' at start of parseParen."
        );
        if (Ir(e, ")")) {
            let s = cg(hE(e), []);
            e = Ve(e);
            let o = ye(t, e);
            return B(e, eE(o, [s]))
        }
        let i;
        return {
            state: e,
            tree: i
        } = Qn(e, r), {
            state: e,
            tree: i
        } = ed(t, e, i, "(",
            ")"), i.type ===
                "Err" ? B(e, i) : B(e,
                    eE(ye(t, e), [i]))
    }

    function BC(e) {
        let t = e,
            n = wr(e);
        if (n.type !==
            "Differential")
            throw new Error(
                "Programming Error: expected differential"
            );
        e = Ve(e);
        let r = Oc(n.span, n.val),
            i = wr(e);
        if (i.type === "SupSub") {
            e = Ve(e);
            let s = ye(t, e),
                o = HC(i);
            if (o) {
                if (o.type ===
                    "Err") return B(
                        e, o);
                r = nE(s, [r, o])
            }
            if (i.sup) return B(e,
                Ce(s, uC()));
            if (i.nprimes > 0)
                return B(e, Ce(s,
                    pg()))
        }
        return B(e, r)
    }

    function ed(e, t, n, r, i) {
        if (n.type === "Err" && n
            .error.type !==
            "UnexpectedEnd")
            return B(t, n);
        if (n.type === "Err" || !Ir(
            t, i)) {
            let s = ye(e, t),
                o = Ce(s, XO(r, i));
            return B(t, o)
        }
        return t = Ve(t), B(t, n)
    }

    function ME(e) {
        let t = e;
        switch (wr(e).type) {
            case ")": {
                e = Ve(e);
                let r = ye(t, e);
                return B(e, Ce(r,
                    Xf("(",
                        ")")
                ))
            }
            case "]": {
                e = Ve(e);
                let r = ye(t, e);
                return B(e, Ce(r,
                    Xf("[",
                        "]")
                ))
            }
            case "\\}": {
                e = Ve(e);
                let r = ye(t, e);
                return B(e, Ce(r,
                    Xf("\\{",
                        "\\}"
                    )))
            }
            case "|)": {
                e = Ve(e);
                let r = ye(t, e);
                return B(e, Ce(r,
                    Xf("|",
                        "|")
                ))
            }
            case "Differential": {
                e = Ve(e);
                let r = ye(t, e);
                return B(e, Ce(r,
                    ZO()))
            }
            default: {
                e = Ve(e);
                let r = ye(t, e);
                return B(e, Ce(r,
                    sE()))
            }
        }
    }

    function j3(e) {
        return Ir(e, ")") || Ir(e,
            "]") || Ir(e, "\\}")
    }

    function J3() {
        throw ff()
    }

    function UC(e, t) {
        return t && !e._inputSpan &&
            e.setInputSpan(t), e
    }

    function Vs(e, t = {}) {
        let n = typeof e;
        if (n !== "string")
            throw new Error(
                `Type Error: parse can only be called with strings, got ${JSON.stringify(e)} of type ${n}`
            );
        let r = D;
        if (t.disabledFeatures) {
            r = Object.create(r);
            for (let l of t
                .disabledFeatures) {
                if (!r[l])
                    throw new Error(
                        `Programming Error: ${l} cannot be disabled because it is not a parsenode.`
                    );
                r[l] = J3
            }
        }
        let i = t.seedPrefix ===
            void 0 ? "" : t
            .seedPrefix,
            s = 0,
            o = () => {
                let l =
                    `${i}::vc${s}`;
                return s += 1, l
            },
            a = {
                nodes: r,
                currentIndex: t
                    .index,
                setInput: UC,
                nextSeed: o,
                allowDt: !!t
                    .allowDt,
                allowIndex: !!t
                    .allowIndex,
                writeIntegral: !!t
                    .writeIntegral,
                allowIntervalComprehensions:
                    !!t
                        .allowIntervalComprehensions,
                specializeDoubleInequalities:
                    !!t
                        .specializeDoubleInequalities
            },
            u = {};
        t.trailingComma !==
            void 0 && (u
                .trailingComma = t
                    .trailingComma), t
                        .disallowFrac && (u
                            .disallowFrac = !0);

        function c(l) {
            return l.parseOptions =
                t, l
        }
        if (e === "") return c(
            nf());
        try {
            let l = tO(e),
                p = kC(l, u),
                f = OC(a, p);
            return f.parseOptions =
                t, f
        } catch (l) {
            let p;
            return l instanceof D
                .Error ? p = l :
                typeof l ==
                    "string" ? p = new D
                        .Error(l) : p = J(
                            l), c(p)
        }
    }

    function Ca(e, t, n, r) {
        return xu({
            chunk: e,
            argMap: [t],
            start: n,
            unpatchedHeaderMap: new Map,
            processedHeaders: new Set
        }, r)
    }

    function K3(e, t) {
        let {
            chunk: n
        } = e, r = n.getInstruction(
            t), i = [];
        for (let s of r
            .recursionGroup) {
            let o = e
                .unpatchedHeaderMap
                .get(s);
            if (o === void 0)
                throw new Error(
                    "Programming Error: `substitute` did not include all headers in a recursion group."
                );
            i.push(o)
        }
        for (let s of r
            .recursionGroup) e
                .unpatchedHeaderMap
                .delete(s);
        for (let s of i) n
            .getInstruction(s)
            .recursionGroup = i
    }

    function xu(e, t) {
        let {
            chunk: n,
            argMap: r,
            start: i
        } = e;
        if (t < i) return t;
        let s = r[t - i];
        if (s !== void 0) return s;
        let o = eG(e, t);
        e.argMap[t - i] = o;
        let a = n.getInstruction(t);
        if (a.type === 4) {
            let u = o;
            e.unpatchedHeaderMap
                .set(t, u), e
                    .processedHeaders
                    .add(t);
            for (let c of a
                .recursionGroup)
                e.processedHeaders
                    .has(c) || xu(e, c);
            return xu(e, a
                .endIndex), u
        }
        if (ri(a)) switch (a.type) {
            case 23:
            case 21:
            case 50:
                break;
            case 19: {
                let c = a.args
                    .length - 2;
                for (let l =
                    0; l <
                    c; l++) xu(
                        e, t +
                        1 + l);
                break
            }
            case 53: {
                let l = n
                    .getInstruction(
                        a.args[
                        0])
                    .signature
                    .argTypes
                    .length;
                for (let p =
                    0; p <
                    l; p++) xu(
                        e, t +
                        1 + p);
                break
            }
            default:
                let u = a;
                throw new Error(
                    `Programming Error. Unexpected OpCode: ${u.type}`
                )
        } else if (Qm(a)) {
            let u = a.args
                .length - 1;
            for (let c = 0; c <
                u; c++) xu(e,
                    t + 1 + c)
        } return o
    }

    function eG(e, t) {
        let {
            chunk: n,
            start: r
        } = e, i = n.getInstruction(
            t);
        if (Ti(i)) {
            let a = i.args[0];
            for (let u = a; u <=
                t; u++) {
                let c = n
                    .getInstruction(
                        u);
                if (!be(c))
                    for (let l of c
                        .args)
                        l < a && xu(
                            e, l)
            }
        }
        if (i.type === 4) return n
            .FunctionHeader(i
                .symbol, i
                .valueType, i
                .signature, i
                .parameterSymbols
            );
        if (be(i)) return Ls(n, i);
        let s = [];
        for (let a of i.args) s
            .push(xu(e, a));
        let o = e.argMap[t - r];
        if (o !== void 0) return o;
        if (i.type === 55 && !oy(n,
            t)) {
            let a = i.args[0];
            e.unpatchedHeaderMap
                .has(a) && K3(e, a)
        }
        return Mn(n, i, s)
    }
    var Wt = Symbol(
        "FRAME_SENTINEL");

    function Nc(e, t) {
        return vE(e, t)
            .freeDependencies
    }

    function vE(e, t) {
        let n = {};
        return (t.type ===
            "FunctionDefinition" ||
            t.type ===
            "RecursiveFunctionBaseCase"
        ) && (t = t
            ._expression), DE(e,
                t, n)
    }

    function qC(e, t, n) {
        let r = [],
            i = [],
            s = [],
            o = [];
        for (let a of t.scopes) {
            let u = qC(e, a, n);
            for (let c of u
                .freeDependencies)
                r.indexOf(c) === -
                    1 && t.definitions
                        .indexOf(c) === -
                    1 && r.push(c);
            for (let c of u
                .updateSymbols)
                i.indexOf(c) === -
                    1 && i.push(c);
            for (let c of u
                .substitutionSymbols)
                s.indexOf(c) === -
                    1 && s.push(c)
        }
        for (let a of t
            .dependencies) {
            if (t.definitions
                .indexOf(a) !== -1)
                continue;
            let u = tG(e, a, n),
                c = t
                    .substitutionDependencies
                    .indexOf(a) !== -1;
            for (let l of u
                .freeDependencies)
                r.indexOf(l) === -
                    1 && t.definitions
                        .indexOf(l) === -
                    1 && r.push(l), c &&
                    o.indexOf(l) === -
                    1 && t.definitions
                        .indexOf(l) === -
                    1 && o.push(l);
            for (let l of u
                .updateSymbols)
                i.indexOf(l) === -
                    1 && i.push(l);
            for (let l of u
                .substitutionSymbols)
                s.indexOf(l) === -
                    1 && s.push(l)
        }
        return {
            freeDependencies: r,
            updateSymbols: i,
            substitutionSymbols: s
        }
    }

    function DE(e, t, n) {
        if (t.type === "Slider" || t
            .type === "Assignment")
            return DE(e, t
                ._expression, n);
        {
            let {
                freeDependencies: r,
                updateSymbols: i,
                substitutionSymbols: s
            } = qC(e, t.getScope(),
                n), o = t
                    .getUpdateSymbols();
            if (o.length > 0) {
                i = i.slice();
                for (let u of o) i
                    .indexOf(u) ===
                    -1 && i.push(u)
            }
            let a = t
                .getSubstitutionSymbols();
            if (a.length > 0) {
                s = s.slice();
                for (let u of a) s
                    .indexOf(u) ===
                    -1 && s.push(u)
            }
            return {
                freeDependencies: r,
                updateSymbols: i,
                substitutionSymbols: s
            }
        }
    }

    function tG(e, t, n) {
        if (n[t]) return n[t];
        if (Ke[t]) return n[t] = {
            freeDependencies: [],
            updateSymbols: [],
            substitutionSymbols: []
        }, n[t];
        let r = e[t];
        if (r === Wt)
            throw new Error(
                "Programming error: _getSymbolFreeDependencies called with a symbol that is defined in a local scope"
            );
        return r ? (n[t] = {
            freeDependencies: [],
            updateSymbols: [],
            substitutionSymbols: []
        }, n[t] = DE(e, r,
            n), n[t]) : (n[
                t] = {
                freeDependencies: [
                    t
                ],
                updateSymbols: [],
                substitutionSymbols: []
            }, n[t])
    }

    function $C(e, t) {
        for (var n = {}, r = t
            .getDependencies()
            .slice(); r
                .length;) {
            var i = r.pop();
            if (!n.hasOwnProperty(
                i)) {
                var s = e[i];
                if (s === Wt)
                    return;
                n[i] = s, s && s
                    .getDependencies &&
                    Array.prototype
                        .push.apply(r, s
                            .getDependencies()
                        )
            }
        }
        return nG(n)
    }

    function nG(e) {
        let t = [];
        for (let n in e) t.push([n,
            e[n]
        ]);
        return t
    }

    function YC(e, t, n) {
        XC(e, t, n, {})
    }

    function XC(e, t, n, r) {
        let i = {};
        for (let s of n
            .definitions) {
            if (i[s]) switch (n
                .kind) {
                    case "Sum":
                    case "Product":
                    case "Integral":
                        throw J(new Error(
                            `${n.kind} scope is not expected to define multiple symbols`
                        ));
                    case "FunctionDefinition":
                        throw Wx(s);
                    case "ListComprehension":
                        throw km(s);
                    case "Substitution":
                        throw uT(s);
                    default:
                        let o = n
                            .kind;
                        throw J(new Error(
                            `Unexpected scope kind ${o}`
                        ))
                }
            i[s] = !0
        }
        for (let s of n
            .definitions) {
            let o = t[s];
            if (o) switch (n.kind) {
                case "Sum":
                case "Product":
                    throw Mm(s);
                case "Integral":
                    throw Lm(s);
                case "FunctionDefinition":
                    if (s === n
                        .functionDefinitionSymbol
                    ) break;
                    throw Em(s);
                case "ListComprehension": {
                    if (o !==
                        Wt && o
                            .type ===
                        "FunctionDefinition"
                    ) throw hl(
                        s
                    );
                    if (e
                        .assignmentForbidden(
                            s))
                        throw gl(
                            s
                        );
                    break
                }
                case "Substitution":
                    break;
                default:
                    let a = n
                        .kind;
                    throw J(new Error(
                        `Unexpected scope kind ${a}`
                    ))
            }
            if (r[s]) switch (n
                .kind) {
                    case "Sum":
                    case "Product":
                        throw Mm(s);
                    case "Integral":
                        throw Lm(s);
                    case "FunctionDefinition":
                        throw Em(s);
                    case "ListComprehension":
                        throw km(s);
                    case "Substitution":
                        throw yf(s);
                    default:
                        let a = n
                            .kind;
                        throw J(new Error(
                            `Unexpected scope kind ${a}`
                        ))
                }
        }
        r = Object.create(r);
        for (let s of n.definitions)
            r[s] = !0;
        for (let s of n.scopes) XC(
            e, t, s, r)
    }

    function lp(e, t, n) {
        let r = e.getInstruction(t);
        if (!oe(r.valueType, T) && !
            oe(r.valueType, R) && !
            oe(r.valueType, V))
            throw qb([ne(r
                .valueType)]);
        let i = e.getInstruction(n);
        if (!oe(i.valueType, T) && i
            .type !== 0) throw J(
                `Unexpected derivative var type ${i.valueType}`
            );
        let s = e.Constant(0);
        if (t < n) return s;
        let o = e.Constant(1),
            a = e.Constant(NaN),
            u = eu(e, n),
            c = wv(e, t);
        e.derivativeMaps[n] || (e
            .derivativeMaps[
            n] = {
            maxValidReference: e
                .instructionsLength() -
                1,
            map: []
        });
        let {
            map: l,
            maxValidReference: p
        } = e.derivativeMaps[n];
        for (let y = 0; y < l
            .length; y++) {
            let h = l[y];
            h !== void 0 && h > p &&
                (l[y] = void 0)
        }
        let f = [],
            m = !1;
        for (let y = 0; y < n; y++)
            f[y] = y, l[y] = s;
        let g = Yr(e, t);
        return Ig({
            chunk: e,
            derivativeVarIndex: n,
            forwardMask: u,
            backwardMask: c,
            referenced: g,
            valueMap: f,
            derivativeMap: l,
            mustCopy: m,
            ZERO: s,
            ONE: o,
            NAN: a
        }, n, t), e
            .derivativeMaps[n]
            .maxValidReference = e
                .instructionsLength() -
            1, l[t]
    }

    function Ig(e, t, n) {
        let {
            chunk: r,
            valueMap: i,
            derivativeMap: s,
            backwardMask: o
        } = e;
        for (let a = t; a <=
            n; a++) {
            let u = s[a];
            if (u !== void 0)
                if (r
                    .getInstruction(
                        u).type ===
                    0) s[a] =
                        void 0;
                else {
                    i[a] = Tg(e, a);
                    continue
                } if (!o[a]) {
                    i[a] = Tg(e, a);
                    continue
                }
            let c = r
                .getInstruction(a);
            if (ri(c) && c
                .endIndex !== -1)
                switch (c.type) {
                    case 21: {
                        a = rG(e,
                            a);
                        continue
                    }
                    case 19:
                    case 23: {
                        a = oG(e,
                            a);
                        continue
                    }
                    case 53: {
                        a = uG(e,
                            a);
                        continue
                    }
                }
            i[a] = Tg(e, a), s[a] =
                cG(e, a)
        }
        return n
    }

    function rG(e, t) {
        let {
            chunk: n,
            forwardMask: r,
            valueMap: i,
            derivativeMap: s,
            ZERO: o
        } = e, a = n.getInstruction(
            t), u = a.endIndex,
            c = n.getInstruction(u),
            l = o;
        if (r[a.args[1]]) {
            let p = i[a.args[1]];
            l = n.Add([l, n
                .Multiply([
                    s[a.args[
                    1
                    ]],
                    Ca(n,
                        p,
                        t,
                        c
                            .args[
                        1
                        ]
                    )
                ])
            ])
        }
        if (r[a.args[0]]) {
            let p = i[a.args[0]];
            l = n.Subtract([l, n
                .Multiply([
                    s[a.args[
                    0
                    ]],
                    Ca(n,
                        p,
                        t,
                        c
                            .args[
                        1
                        ]
                    )
                ])
            ])
        }
        if (iG(n, t, r)) {
            let p = i.slice();
            p[t] = Mn(n, a, [p[a
                .args[0]
            ], p[a
                .args[1]
            ]]), s[t] = o,
                Ig({
                    ...e,
                    valueMap: p,
                    mustCopy: !0
                }, t + 1, u - 1);
            let f = Mn(n, c, [p[c
                .args[0]
            ], s[c
                .args[1]
            ]]);
            s[u] = f, l = n.Add([l,
                Mn(n, n
                    .getInstruction(
                        u +
                        1),
                    [f])
            ])
        } else
            for (let p = t; p <=
                u; p++) s[p] = o;
        if (sG(n, t, i)) {
            let p = {
                ...e,
                mustCopy: !0
            };
            for (let f = t; f <= u +
                1; f++) i[f] = Tg(p,
                    f)
        } else
            for (let p = t; p <= u +
                1; p++) i[p] = p;
        return s[u + 1] = l, u + c
            .args.length - 1
    }

    function iG(e, t, n) {
        let r = e.getInstruction(t),
            i = e.getInstruction(r
                .endIndex);
        if (i.args[1] < t + 1)
            return n[i.args[1]];
        for (let s = t + 1; s <= i
            .args[1]; s++) {
            let o = e
                .getInstruction(s);
            if (!be(o)) {
                for (let a of o
                    .args)
                    if (a < t && n[
                        a])
                        return !0
            }
        }
        return !1
    }

    function sG(e, t, n) {
        let r = e.getInstruction(t);
        for (let i = t; i <= r
            .endIndex; i++) {
            let s = e
                .getInstruction(i);
            if (!be(s)) {
                for (let o of s
                    .args)
                    if (n[o] !== o)
                        return !0
            }
        }
        return !1
    }

    function oG(e, t) {
        let {
            chunk: n,
            derivativeMap: r,
            valueMap: i,
            ZERO: s
        } = e, o = n.getInstruction(
            t), a = o.endIndex,
            u = n.getInstruction(a),
            c;
        if (o.type === 23) i[t] =
            Mn(n, o, [i[o.args[
                0]]]), r[t] = s, c = t +
                1;
        else {
            let p = [];
            p.push(i[o.args[0]], i[o
                .args[1]]);
            for (let f = 2; f < o
                .args.length; f++) p
                    .push(i[o.args[f]],
                        r[o.args[f]]);
            i[t] = Mn(n, o, p), r[
                t] = s;
            for (let f = 2; f < o
                .args.length; f++)
                i[t + f - 1] = Mn(n,
                    n
                        .getInstruction(
                            t + f - 1),
                    [i[t]]), r[t +
                    f - 1] = Mn(n, n
                        .getInstruction(
                            t + f - 1),
                        [i[t]]);
            c = t + o.args.length -
                1
        }
        Ig({
            ...e,
            mustCopy: !0
        }, c, a - 1);
        let l = [];
        l.push(i[u.args[0]]);
        for (let p = 1; p < u.args
            .length; p++) l.push(i[u
                .args[p]], r[u
                    .args[p]]);
        i[a] = Mn(n, u, l), r[a] =
            s;
        for (let p = 1; p < u.args
            .length; p++) i[a + p] =
                Mn(n, n.getInstruction(
                    a + p), [i[a]]), r[
                    a + p] = Mn(n, n
                        .getInstruction(a +
                            p), [i[a]]);
        return a + u.args.length - 1
    }

    function Tg(e, t) {
        let {
            chunk: n,
            valueMap: r,
            mustCopy: i,
            referenced: s
        } = e;
        if (!s[t]) return t;
        let o = n.getInstruction(t);
        if (be(o)) return i ? Ls(n,
            o) : t;
        {
            let a = [],
                u = !1;
            for (let c of o.args) a
                .push(r[c]), r[
                c] !== c && (u = !
                    0);
            return u || i ? Mn(n, o,
                a) : t
        }
    }

    function aG(e, t) {
        let {
            chunk: n,
            derivativeMap: r
        } = e, i = n.getInstruction(
            t), s = [], o = i
                .recursionGroup;
        for (let a of o) {
            let u = n
                .getInstruction(a),
                c = {
                    argTypes: []
                };
            for (let p of u
                .signature
                .argTypes) c
                    .argTypes.push(p,
                        p);
            let l = r[a];
            l || (l = n
                .FunctionHeader(
                    u.symbol +
                    `_${e.derivativeVarIndex}`,
                    u.valueType,
                    c, u
                    .parameterSymbols
                ), s.push(l)
            ), e
                .derivativeMap[a] =
                l
        }
        for (let a of s) {
            let u = n
                .getInstruction(a);
            u.recursionGroup = s
        }
        return e.derivativeMap[t]
    }

    function uG(e, t) {
        let {
            chunk: n,
            valueMap: r,
            derivativeMap: i
        } = e, o = n.getInstruction(
            t).args[0], a = n
                .getInstruction(o), u =
                a.endIndex, l = n
                    .getInstruction(u).args[
                    1], p = i[o], f = n
                        .BeginFunction([p]);
        i[t] = f;
        let m = a.signature
            .argTypes,
            g = [];
        for (let x = 0; x < m
            .length; x++) {
            let P = m[x],
                M = t + x + 1;
            g.push(M);
            let I = n.BlockVar(P, [
                f]),
                E = n.BlockVar(P, [
                    f]);
            r[M] = I, i[M] = E
        }
        let d = t + m.length + 1,
            y = u - 1,
            h = mc(n, g, d, y),
            b = r.slice();
        return b[o] = o, Ig({
            ...e,
            valueMap: b,
            mustCopy: !0,
            forwardMask: h
        }, d, y), n.EndFunction(
            [f, i[l]]), u
    }

    function cG(e, t) {
        let {
            chunk: n,
            derivativeVarIndex: r,
            forwardMask: i,
            valueMap: s,
            derivativeMap: o,
            ZERO: a,
            ONE: u,
            NAN: c
        } = e, l = n.getInstruction(
            t);
        if (t === r)
            if (W(l.valueType)) {
                let f = _r(n, t),
                    m = n
                        .BeginBroadcast(
                            [f]),
                    g = n
                        .EndBroadcast([
                            m, u
                        ]);
                return n
                    .BroadcastResult(
                        se, [g])
            } else return u;
        if (ri(l) || Ti(l) || l
            .type === 47 || l
                .type === 48 || l
                    .type === 25 || l
                        .type === 27 || l
                            .type === 26 || l
                                .type === 29 || l
                                    .type === 28 || l
                                        .type === 32 || l
                                            .type === 31 || l
                                                .type === 42 || l
                                                    .type === 44 || l
                                                        .type === 49 || l
                                                            .valueType === ot)
            return a;
        if (l.type === 4) return aG(
            e, t);
        if (!i[t] || be(l)) return l
            .valueType !== T ?
            pG(n, [s[t], a]) : l
                .type !== 1 ||
                isFinite(q(l
                    .value)) ? a : c;
        if (l.type === 38 || l
            .type === 15 || l
                .type === 16) {
            let f = [];
            for (let m of l.args) f
                .push(o[m]);
            return Mn(n, l, f)
        }
        if (l.type === 33)
            return Mn(n, l, [s[l
                .args[0]
            ], o[l
                .args[1]
            ], o[l
                .args[2]
            ]]);
        if (l.type === 55) {
            let m = [o[l.args[0]]];
            for (let g of l.args
                .slice(1)) m
                    .push(s[g]), m.push(
                        o[g]);
            return n.FunctionCall(m)
        }
        let p = a;
        for (let f = 0; f < l.args
            .length; f++) {
            if (!i[l.args[f]])
                continue;
            let m = o[l.args[f]];
            if (m === a) continue;
            let g = lG(e, s[t], f,
                m);
            g !== a && (p = p ===
                a ? g : fG(n, [
                    g, p
                ]))
        }
        return p
    }

    function lG(e, t, n, r) {
        let {
            chunk: i,
            ZERO: s,
            ONE: o,
            NAN: a
        } = e, u = i.getInstruction(
            t);
        switch (u.type) {
            case 8:
                return r;
            case 9:
                switch (n) {
                    case 0:
                        return r;
                    default:
                        return i
                            .Negative(
                                [r])
                }
            case 10:
                switch (n) {
                    case 0:
                        return i
                            .Multiply(
                                [r, u
                                    .args[
                                    1
                                ]
                                ]);
                    default:
                        return i
                            .Multiply(
                                [u.args[
                                    0],
                                    r
                                ])
                }
            case 11:
                switch (n) {
                    case 0:
                        return i
                            .Divide(
                                [r, u
                                    .args[
                                    1
                                ]
                                ]);
                    default:
                        return i
                            .Multiply(
                                [u.args[
                                    0],
                                i
                                    .Divide(
                                        [i.Negative(
                                            [
                                                r]
                                        ),
                                        i
                                            .Multiply(
                                                [u.args[
                                                    1],
                                                u
                                                    .args[
                                                1
                                                ]
                                                ]
                                            )
                                        ]
                                    )
                                ])
                }
            case 14:
                return i.Negative([
                    r]);
            case 12:
            case 13:
                switch (n) {
                    case 0:
                        return i
                            .Multiply(
                                [i.Multiply(
                                    [u.args[
                                        1],
                                    i
                                        .Exponent(
                                            [u.args[
                                                0],
                                            i
                                                .Subtract(
                                                    [u.args[
                                                        1],
                                                        o
                                                    ]
                                                )
                                            ]
                                        )
                                    ]
                                ),
                                    r
                                ]);
                    default:
                        return i
                            .Multiply(
                                [i.Piecewise(
                                    [i.Equal(
                                        [u.args[
                                            0],
                                            s
                                        ]
                                    ),
                                    i
                                        .Piecewise(
                                            [i.GreaterEqual(
                                                [u.args[
                                                    1],
                                                    s
                                                ]
                                            ),
                                                s,
                                                a
                                            ]
                                        ),
                                    i
                                        .Multiply(
                                            [i.SyntheticNativeFunction(
                                                "ln",
                                                [u.args[
                                                    0]]
                                            ),
                                                t
                                            ]
                                        )
                                    ]
                                ),
                                    r
                                ])
                }
            case 37:
                return dG(i, t, WC[u
                    .symbol]
                [n], r);
            case 39:
            case 40:
            case 41:
                switch (n) {
                    case 0:
                        return Mn(i,
                            u, [r,
                            u
                                .args[
                            1
                            ]
                        ]);
                    default:
                        return s
                }
            case 17:
            case 18:
                return Mn(i, u, [
                    r]);
            default: {
                let c = u;
                throw new Error(
                    `Unimplemented derivative for opcode ${c.type}`
                )
            }
        }
    }

    function pG(e, t) {
        switch (e.getInstruction(t[
            0]).valueType) {
            case Ie:
                return e
                    .SyntheticNativeFunction(
                        "scaleTangentSegment",
                        t);
            case fe:
                return e
                    .SyntheticNativeFunction(
                        "scaleTangentLine",
                        t);
            case Le:
                return e
                    .SyntheticNativeFunction(
                        "scaleTangentRay",
                        t);
            case pe:
                return e
                    .SyntheticNativeFunction(
                        "scaleTangentCircle",
                        t);
            case ce:
                return e
                    .SyntheticNativeFunction(
                        "scaleTangentArc",
                        t);
            case Ge:
                return e
                    .SyntheticNativeFunction(
                        "scaleTangentUndirectedAngleMarker",
                        t);
            case Ae:
                return e
                    .SyntheticNativeFunction(
                        "scaleTangentDirectedAngleMarker",
                        t);
            default:
                return e.Multiply(t)
        }
    }

    function fG(e, t) {
        switch (e.getInstruction(t[
            0]).valueType) {
            case Ie:
                return e
                    .SyntheticNativeFunction(
                        "addTangentSegment",
                        t);
            case Nt:
                return e
                    .SyntheticNativeFunction(
                        "addTangentSegmentThreeD",
                        t);
            case fe:
                return e
                    .SyntheticNativeFunction(
                        "addTangentLine",
                        t);
            case Le:
                return e
                    .SyntheticNativeFunction(
                        "addTangentRay",
                        t);
            case pe:
                return e
                    .SyntheticNativeFunction(
                        "addTangentCircle",
                        t);
            case ce:
                return e
                    .SyntheticNativeFunction(
                        "addTangentArc",
                        t);
            case Ge:
                return e
                    .SyntheticNativeFunction(
                        "addTangentUndirectedAngleMarker",
                        t);
            case Ae:
                return e
                    .SyntheticNativeFunction(
                        "addTangentDirectedAngleMarker",
                        t);
            default:
                return e.Add(t)
        }
    }

    function dG(e, t, n, r) {
        let i = Object.create(Ke),
            s = Bf({}, {}, -1),
            a = e.getInstruction(t)
                .args;
        for (let u = 0; u < a
            .length; u++) {
            let c = mG[u];
            xr(s, c, a[u]), i[c] =
                Wt
        }
        return xr(s, "x_1", r), i
            .x_1 = Wt, xr(s, "q",
                t), i.q = Wt, Ee(SE(zS,
                    i, e, s, td
                    .root, void 0,
                    void 0), n)
    }
    var mG = ["x", "y", "z", "u"],
        ZC = {
            exp: ["q*x_1"],
            ln: [
                "\\{x >= 0: x_1/x \\}"],
            log: [
                "\\{x >= 0: x_1/(x*\\ln(10)) \\}"],
            sqrt: ["x_1/(2*q)"],
            rtxsqpone: ["x*x_1/q"],
            rtxsqmone: ["x*x_1/q"],
            sin: ["\\cos(x)*x_1"],
            cos: ["-\\sin(x)*x_1"],
            tan: ["(1+q^2)*x_1"],
            arcsin: [
                "x_1/\\sqrt{1 - x^2}"
            ],
            arccos: [
                "-x_1/\\sqrt{1 - x^2}"
            ],
            sinh: ["\\cosh(x)*x_1"],
            cosh: ["\\sinh(x)*x_1"],
            tanh: [
                "(\\sech(x))^2*x_1"],
            arcsinh: [
                "x_1/\\rtxsqpone(x)"
            ],
            arccosh: [
                "\\{ x > 0: x_1/\\rtxsqmone(x) \\}"
            ],
            arctanh: [
                "\\{ \\abs(x) < 1: x_1/(1 - x^2) \\}"
            ],
            csc: [
                "-\\cot(x)*q*x_1"],
            sec: ["\\tan(x)*q*x_1"],
            cot: ["-(1+q^2)*x_1"],
            arccsc: [
                "-x_1/(\\abs(x)*\\rtxsqmone(x))"
            ],
            arcsec: [
                "x_1/(\\abs(x)*\\rtxsqmone(x))"
            ],
            arccot: [
                "-x_1/(1+x^2)"],
            csch: [
                "-\\coth(x)*q*x_1"],
            sech: [
                "-\\tanh(x)*q*x_1"],
            coth: [
                "-(\\csch(x))^2*x_1"],
            arccsch: [
                "-x_1/(\\abs(x)*\\rtxsqpone(x))"
            ],
            arcsech: [
                "\\{ x >= 0: -x_1/(x*\\sqrt{1 - x^2}) \\}"
            ],
            arccoth: [
                "\\{ \\abs(x) > 1 : x_1/(1 - x^2) \\}"
            ],
            factorial: [
                "q*\\polyGamma(0, x + 1)*x_1"
            ],
            floor: [
                "\\{ q=x: 0/0, 0*x_1 \\}"],
            ceil: [
                "\\{ q=x: 0/0, 0*x_1 \\}"],
            round: [
                "\\{ \\abs(\\mod(x, 1) - 0.5) > 0: 0*x_1 \\}"],
            abs: [
                "\\{ x=0: 0/0, \\sign(x)*x_1 \\}"],
            sign: [
                "\\{ x=0: 0/0, 0*x_1 \\}"],
            distance: [
                "-((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y)/q",
                "((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y)/q"
            ],
            distanceThreeD: [
                "-((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y+(y.z-x.z)*x_1.z)/q",
                "((y.x-x.x)*x_1.x+(y.y-x.y)*x_1.y+(y.z-x.z)*x_1.z)/q"
            ],
            segmentThreeD: [
                "\\segmentThreeD(x_1,(0,0,0))",
                "\\segmentThreeD((0,0,0),x_1)"
            ],
            vectorThreeD: [
                "\\vectorThreeD(x_1,(0,0,0))",
                "\\vectorThreeD((0,0,0),x_1)"
            ],
            triangle: [
                "\\triangle(x_1,(0,0,0),(0,0,0))",
                "\\triangle((0,0,0),x_1,(0,0,0))",
                "\\triangle((0,0,0),(0,0,0),x_1)"
            ],
            sphere: [
                "\\sphere(x_1,0)",
                "\\sphere((0,0,0),x_1)"
            ],
            pointDet: [
                "\\pointDet(x_1,y)",
                "\\pointDet(x,x_1)"
            ],
            pointDot: [
                "\\pointDot(x_1,y)",
                "\\pointDot(x,x_1)"
            ],
            pointPerp: [
                "\\pointPerp(x_1)"
            ],
            segment: [
                "\\segment(x_1,(0,0))",
                "\\segment((0,0),x_1)"
            ],
            line: ["\\line(x_1,(0,0))",
                "\\line((0,0),x_1)"
            ],
            ray: ["\\ray(x_1,(0,0))",
                "\\ray((0,0),x_1)"
            ],
            vector: [
                "\\vector(x_1, (0,0))",
                "\\vector((0,0), x_1)"
            ],
            mathVector: [
                "\\mathVector(x_1,(0,0))",
                "\\mathVector((0,0),x_1)"
            ],
            mathVectorThreeD: [
                "\\mathVectorThreeD(x_1,(0,0,0))",
                "\\mathVectorThreeD((0,0,0),x_1)"
            ],
            vectorDisplacementAsPoint: [
                "\\vectorDisplacementAsPoint(x_1)"
            ],
            vectorThreeDDisplacementAsPoint: [
                "\\vectorThreeDDisplacementAsPoint(x_1)"
            ],
            basePointFromVector: [
                "\\basePointFromVector(x_1)"
            ],
            basePointFromVectorThreeD: [
                "\\basePointFromVectorThreeD(x_1)"
            ],
            circle: [
                "\\circle(x_1,0)",
                "\\circle((0,0),x_1)"
            ],
            arc: ["\\arc(x_1,(0,0),(0,0))",
                "\\arc((0,0),x_1,(0,0))",
                "\\arc((0,0),(0,0),x_1)"
            ],
            arcCenter: [
                "(0/0,0/0)"],
            arcOmega: ["0/0"],
            center: [
                "\\center(x_1)"],
            radius: [
                "\\radius(x_1)"],
            undirectedAngleMarker: [
                "\\undirectedAngleMarker(x_1)"
            ],
            directedAngleMarker: [
                "\\directedAngleMarker(x_1,0,0,0)",
                "\\directedAngleMarker((0,0),x_1,0,0)",
                "\\directedAngleMarker((0,0),0,x_1,0)",
                "\\directedAngleMarker((0,0),0,0,x_1)"
            ],
            directedCoterminalAngle: [
                "\\directedCoterminalAngle(x_1)"
            ],
            undirectedCoterminalAngle: [
                "\\undirectedCoterminalAngle(x_1)"
            ],
            supplement: [
                "\\supplement(x_1)"
            ],
            directedAngleMarkerMultiplier: [
                "\\directedAngleMarkerMultiplier(x_1)"
            ],
            undirectedAngleMarkerMultiplier: [
                "\\undirectedAngleMarkerMultiplier(x_1)"
            ],
            directedAngleMarkerRawDelta: [
                "\\directedAngleMarkerRawDelta(x_1)"
            ],
            undirectedAngleMarkerRawDelta: [
                "\\undirectedAngleMarkerRawDelta(x_1)"
            ],
            polygonInteriorUndirectedAngles: [
                "\\polygonInteriorUndirectedAngles(x_1)"
            ],
            polygonInteriorDirectedAngles: [
                "\\polygonInteriorDirectedAngles(x_1)"
            ],
            lineFromSegment: [
                "x_1"],
            lineFromRay: ["x_1"],
            segmentGlider: [
                "\\segmentGlider(x_1,y)",
                "\\{0<y<1:(\\segmentGlider(x,1)-\\segmentGlider(x,0))*x_1,(0,0)\\}"
            ],
            segmentThreeDGlider: [
                "\\segmentThreeDGlider(x_1,y)",
                "\\{0<y<1:(\\segmentThreeDGlider(x,1)-\\segmentThreeDGlider(x,0))*x_1,(0,0,0)\\}"
            ],
            rayGlider: [
                "\\rayGlider(x_1,y)",
                "\\{0<y:(\\rayGlider(x,1)-\\rayGlider(x,0))*x_1,(0,0)\\}"
            ],
            lineGlider: [
                "\\lineGlider(x_1,y)",
                "(\\lineGlider(x,1)-\\lineGlider(x,0))*x_1"
            ],
            circleGlider: [
                "\\circleGlider(x_1,y)",
                "2*\\pi*\\pointPerp(q-\\center(x))*x_1"
            ],
            arcGlider: ["(0/0,0/0)",
                "(0/0,0/0)"
            ],
            polygonGlider: [
                "(0/0,0/0)",
                "(0/0,0/0)"
            ],
            chooseNonIncidentPoint: [
                "(0/0,0/0)"
            ],
            circleCircleIntersection: [
                "(\\radius(x)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(x))))/\\pointDot(\\pointPerp(q-\\center(y)),q-\\center(x))*\\pointPerp(q-\\center(y))",
                "(\\radius(y)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(y))))/\\pointDot(\\pointPerp(q-\\center(x)),q-\\center(y))*\\pointPerp(q-\\center(x))"
            ],
            circleArcIntersection: [
                "(0/0,0/0)"
            ],
            circleLineIntersection: [
                "(\\radius(x)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(x))))/\\pointDot((\\lineGlider(y,1)-\\lineGlider(y,0)),q-\\center(x))*(\\lineGlider(y,1)-\\lineGlider(y,0))",
                "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(y,1))+\\pointDet(\\lineGlider(y,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\pointPerp(q-\\center(x)),\\lineGlider(y,1)-\\lineGlider(y,0)))*(\\pointPerp(q-\\center(x)))"
            ],
            arcCircleIntersection: [
                "(0/0,0/0)"
            ],
            arcArcIntersection: [
                "(0/0,0/0)"
            ],
            arcLineIntersection: [
                "(0/0,0/0)"
            ],
            lineCircleIntersection: [
                "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(x,1))+\\pointDet(\\lineGlider(x,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\pointPerp(q-\\center(y)),\\lineGlider(x,1)-\\lineGlider(x,0)))*(\\pointPerp(q-\\center(y)))",
                "(\\radius(y)*\\radius(x_1)+\\pointDot(\\center(x_1),(q-\\center(y))))/\\pointDot((\\lineGlider(x,1)-\\lineGlider(x,0)),q-\\center(y))*(\\lineGlider(x,1)-\\lineGlider(x,0))"
            ],
            lineArcIntersection: [
                "(0/0,0/0)"
            ],
            lineLineIntersection: [
                "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(x,1))+\\pointDet(\\lineGlider(x,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\lineGlider(y,1)-\\lineGlider(y,0),\\lineGlider(x,1)-\\lineGlider(x,0)))*(\\lineGlider(y,1)-\\lineGlider(y,0))",
                "(\\pointDet(\\lineGlider(x_1,0),\\lineGlider(y,1))+\\pointDet(\\lineGlider(y,0),\\lineGlider(x_1,1))-\\pointDet(q,\\lineGlider(x_1,1)-\\lineGlider(x_1,0)))/(\\pointDet(\\lineGlider(x,1)-\\lineGlider(x,0),\\lineGlider(y,1)-\\lineGlider(y,0)))*(\\lineGlider(x,1)-\\lineGlider(x,0))"
            ],
            parallel: [
                "\\parallel(x_1,(0,0))",
                "\\parallel(\\line((0,0),(0,0)),x_1)"
            ],
            perpendicular: [
                "\\perpendicular(x_1,(0,0))",
                "\\perpendicular(\\line((0,0),(0,0)),x_1)"
            ],
            scaleTangentSegment: [
                "\\scaleTangentSegment(x_1, y)",
                "\\scaleTangentSegment(x, x_1)"
            ],
            scaleTangentLine: [
                "\\scaleTangentLine(x_1, y)",
                "\\scaleTangentLine(x, x_1)"
            ],
            scaleTangentRay: [
                "\\scaleTangentRay(x_1, y)",
                "\\scaleTangentRay(x, x_1)"
            ],
            scaleTangentCircle: [
                "\\scaleTangentCircle(x_1, y)",
                "\\scaleTangentCircle(x, x_1)"
            ],
            scaleTangentArc: [
                "\\scaleTangentArc(x_1, y)",
                "\\scaleTangentArc(x, x_1)"
            ],
            scaleTangentDirectedAngleMarker: [
                "\\scaleTangentDirectedAngleMarker(x_1, y)",
                "\\scaleTangentDirectedAngleMarker(x, x_1)"
            ],
            scaleTangentUndirectedAngleMarker: [
                "\\scaleTangentUndirectedAngleMarker(x_1, y)",
                "\\scaleTangentUndirectedAngleMarker(x, x_1)"
            ],
            addTangentSegment: [
                "\\addTangentSegment(x_1, y)",
                "\\addTangentSegment(x, x_1)"
            ],
            addTangentSegmentThreeD: [
                "\\addTangentSegmentThreeD(x_1, y)",
                "\\addTangentSegmentThreeD(x, x_1)"
            ],
            addTangentLine: [
                "\\addTangentLine(x_1, y)",
                "\\addTangentLine(x, x_1)"
            ],
            addTangentRay: [
                "\\addTangentRay(x_1, y)",
                "\\addTangentRay(x, x_1)"
            ],
            addTangentCircle: [
                "\\addTangentCircle(x_1, y)",
                "\\addTangentCircle(x, x_1)"
            ],
            addTangentArc: [
                "\\addTangentArc(x_1, y)",
                "\\addTangentArc(x, x_1)"
            ],
            addTangentDirectedAngleMarker: [
                "\\addTangentDirectedAngleMarker(x_1, y)",
                "\\addTangentDirectedAngleMarker(x, x_1)"
            ],
            addTangentUndirectedAngleMarker: [
                "\\addTangentUndirectedAngleMarker(x_1, y)",
                "\\addTangentUndirectedAngleMarker(x, x_1)"
            ],
            translation: [
                "\\translation(x_1)"
            ],
            dilation: [
                "\\dilation(x_1, y)",
                "\\dilation(x, x_1)"
            ],
            reflection: [
                "\\reflection(x_1)"
            ],
            rotation: [
                "\\rotation((0/0,0/0),0/0)"
            ],
            compose: [
                "\\reflection(\\line((0/0,0/0),(0/0,0/0)))",
                "\\reflection(\\line((0/0,0/0),(0/0,0/0)))"
            ],
            inverse: [
                "\\reflection(\\line((0/0,0/0),(0/0,0/0)))"
            ],
            transformPoint: [
                "(0/0,0/0)",
                "(0/0,0/0)"
            ],
            transformSegment: [
                "\\segment((0/0,0/0),(0/0,0/0))",
                "\\segment((0/0,0/0),(0/0,0/0))"
            ],
            transformVector: [
                "\\vector((0/0,0/0),(0/0,0/0))",
                "\\vector((0/0,0/0),(0/0,0/0))"
            ],
            transformLine: [
                "\\line((0/0,0/0),(0/0,0/0))",
                "\\line((0/0,0/0),(0/0,0/0))"
            ],
            transformRay: [
                "\\ray((0/0,0/0),(0/0,0/0))",
                "\\ray((0/0,0/0),(0/0,0/0))"
            ],
            transformCircle: [
                "\\circle((0/0,0/0),0/0)",
                "\\circle((0/0,0/0),0/0)"
            ],
            transformArc: [
                "\\arc((0/0,0/0),(0/0,0/0),(0/0,0/0))",
                "\\arc((0/0,0/0),(0/0,0/0),(0/0,0/0))"
            ],
            transformPolygon: [
                "\\polygon([])",
                "\\polygon([])"
            ],
            transformAngleMarker: [
                "\\undirectedAngleMarker(directedAngleMarker([0/0,0/0],0/0,0/0,0/0))",
                "\\undirectedangleMarker(directedAngleMarker([0/0,0/0],0/0,0/0,0/0))"
            ],
            transformDirectedAngleMarker: [
                "\\directedAngleMarker([0/0,0/0],0/0,0/0,0/0)",
                "\\directedangleMarker([0/0,0/0],0/0,0/0,0/0)"
            ],
            mean: ["\\mean(x_1)"],
            total: ["\\total(x_1)"],
            count: ["0"],
            var: [
                "2*\\cov(x, x_1)"],
            varp: [
                "2*\\cov(x, x_1)*(\\count(x)-1)/\\count(x)"],
            stdev: [
                "\\cov(x, x_1)/q"],
            stdevp: [
                "\\covp(x, x_1)/q"
            ],
            mad: [
                "\\mean(\\sign(x-\\mean(x))*(x_1 - \\mean(x_1)))"],
            min: [
                "x_1[\\argmin(x)]"],
            max: [
                "x_1[\\argmax(x)]"],
            median: [
                "0.5*(x_1[\\lowerQuantileIndex(x, 0.5)] + x_1[\\upperQuantileIndex(x, 0.5)])"
            ],
            argmin: ["0/0"],
            argmax: ["0/0"],
            gcd: ["0/0"],
            lcm: ["0/0"],
            erf: [
                "\\frac{2x_1}{\\sqrt{\\pi }}\\exp(-x^2)"],
            invNorm: [
                "\\frac{x_1}{\\pdf(\\normaldist(0,1),q)}"
            ],
            logbase: [
                "\\{x > 0: \\frac{x_1}{x*\\ln(y)} \\}",
                "\\frac{-q*x_1}{y*\\ln(y)}"
            ],
            nthroot: [
                "x^{1/y - 1}/y*x_1",
                "-\\frac{q*\\ln(x)*x_1}{y^2}"
            ],
            hypot: ["x_1*x/q",
                "x_1*y/q"
            ],
            polyGamma: ["0/0",
                "\\polyGamma(1 + x, y)*x_1"
            ],
            mod: ["\\{ q=0: 0/0, x_1 \\}",
                "\\{ \\mod(x/y, 1) > 0: -\\floor(x/y)*x_1 \\}"
            ],
            cov: ["\\cov(x_1, y)",
                "\\cov(x, x_1)"
            ],
            covp: ["\\covp(x_1, y)",
                "\\covp(x, x_1)"
            ],
            corr: ["(\\cov(x_1, y) - (\\cov(x, y)*\\cov(x, x_1)/\\var(x)))/(\\stdevp(x)\\stdevp(y))",
                "(\\cov(x, x_1) - (\\cov(x, y)*\\cov(y, x_1)/\\var(y)))/(\\stdevp(x)\\stdevp(y))"
            ],
            spearman: ["0/0",
                "0/0"],
            quantile: [
                "\\{ \\floor(y*(\\count(x)-1)) = y*(\\count(x)-1) :   x_1[\\upperQuantileIndex(x, y)],  (\\ceil(y*(\\count(x)-1)) - y*(\\count(x)-1))*x_1[\\lowerQuantileIndex(x, y)] +   (y*(\\count(x)-1) - \\floor(y*(\\count(x)-1)))*x_1[\\upperQuantileIndex(x, y)]\\}",
                "\\{ \\floor(y*(\\count(x)-1)) < y*(\\count(x)-1) :   (\\count(x)-1)*(x[\\upperQuantileIndex(x, y)] - x[\\lowerQuantileIndex(x, y)])*x_1\\}"
            ],
            quartile: [
                "0.5*(x_1[\\lowerQuartileIndex(x, y)] + x_1[\\upperQuartileIndex(x, y)])",
                "0/0"
            ],
            tscore: [
                "\\frac{\\sqrt{\\count(x)}(\\stdev(x)*\\mean(x_1)-(\\mean(x)-y)*\\frac{\\cov(x,x_1)}{\\stdev(x)})}{\\stdev(x)^2}",
                "-x_1*\\sqrt{\\count(x)}/\\stdev(x)"
            ],
            quartileIndex: ["0/0",
                "0/0"
            ],
            upperQuartileIndex: [
                "0/0", "0/0"
            ],
            lowerQuartileIndex: [
                "0/0", "0/0"
            ],
            upperQuantileIndex: [
                "0/0", "0/0"
            ],
            lowerQuantileIndex: [
                "0/0", "0/0"
            ],
            nCr: ["q*(\\polyGamma(0, 1 + x) - \\polyGamma(0, 1 + x - y))",
                "q*(\\polyGamma(0, 1 + x - y) - \\polyGamma(0, 1 + y))"
            ],
            nPr: ["q*(\\polyGamma(0, 1 + x) - \\polyGamma(0, 1 + x - y))",
                "q*\\polyGamma(0, 1 + x - y)"
            ],
            arctan: [
                "x_1*y/(y^2+x^2)",
                "-x_1*x/(y^2+x^2)"
            ],
            poissonpdf: ["0/0",
                "x_1\\frac{\\exp(-y)(\\floor(x)-y)y^{(\\floor(x)-1)}}{(\\floor(x))!}"
            ],
            invPoisson: ["0/0",
                "0/0"
            ],
            tpdf: ["x_1*q*\\frac{-(y+1)*x}{y+x^2}",
                "x_1*\\frac{1}{2}q*(  \\frac{x^2-1}{y + x^2} + \\ln(\\frac{y}{y + x^2}) +   \\polyGamma(0, \\frac{1+y}{2}) - \\polyGamma(0, y/2))"
            ],
            invT: ["x_1/\\pdf(\\tdist(y),q)",
                "0/0"
            ],
            tcdf: ["-x_1*\\pdf(\\tdist(z),x)",
                "x_1*\\pdf(\\tdist(z),y)",
                "0/0"
            ],
            poissoncdf: ["0/0",
                "0/0",
                "x_1\\sum _{n=\\max(0,\\floor(\\min(x,y)))}^{\\floor(\\max(x,y))}\\frac{\\exp(-z)(n-z)z^{(n-1)}}{n!}"
            ],
            normalpdf: [
                "-x_1*\\frac{x-y}{z^2} q",
                "x_1*\\frac{x-y}{z^2} q",
                "x_1*(\\frac{(x-y-z)*(x-y+z)}{z^3}) q"
            ],
            binompdf: ["0/0", "0/0",
                "\\{0<=z<=1: x_1*q*(\\frac{\\round(x)}{z}-\\frac{\\round(y)-\\round(x)}{1-z}), 0 \\}"
            ],
            invBinom: ["0/0", "0/0",
                "0/0"
            ],
            uniformpdf: ["0",
                "\\{y<=x: \\frac{x_1}{(z-y)^2}, 0\\}",
                "\\{z>=x: -\\frac{x_1}{(z-y)^2}, 0\\}"
            ],
            invUniform: [
                "\\{y<=x<=z: x_1*(z-y), 0\\}",
                "\\{y<=x<=z: x_1*(1-x), 0\\}",
                "\\{y<=x<=z: x_1*x, 0\\}"
            ],
            normalcdf: [
                "-x_1\\pdf(\\normaldist(z,u), x)",
                "x_1\\pdf(\\normaldist(z,u), y)",
                "-x_1*(\\pdf(\\normaldist(z,u), y) - \\pdf(\\normaldist(z,u), x))",
                "x_1*(  \\{\\abs(y)=1/0:0,\\frac{z-y}{u}\\pdf(\\normaldist(z,u),y)\\} -   \\{\\abs(x)=1/0:0,\\frac{z-x}{u}\\pdf(\\normaldist(z,u),x)\\})"
            ],
            binomcdf: ["0/0", "0/0",
                "0/0",
                "\\{0<=u<=1: x_1*\\sum _{n=\\max(0,\\round(\\min(x,y)))}^{\\round(\\max(x,y))}(  \\pdf(\\binomialdist(z,u),n)*(\\frac{n}{u}-\\frac{\\round(z)-n}{1-u})), 0 \\}"
            ],
            uniformcdf: [
                "\\{z>u: 0/0, -x_1\\pdf(\\uniformdist(z,u), x)\\}",
                "\\{z>u: 0/0, x_1\\pdf(\\uniformdist(z,u), y)\\}",
                "\\{z>u: 0/0, x_1*(\\frac{\\{z<x<u:u-x,0\\} + \\{z<y<u:y-u,0\\}}{(u-z)^2})\\}",
                "\\{z>u: 0/0, x_1*(\\frac{\\{z<x<u:x-z,0\\} + \\{z<y<u:z-y,0\\}}{(u-z)^2})\\}"
            ],
            normalSample: ["0/0",
                "0/0", "0/0"
            ],
            uniformSample: ["0/0",
                "0/0", "0/0"
            ],
            tSample: ["0/0", "0/0"],
            poissonSample: ["0/0",
                "0/0"
            ],
            binomSample: ["0/0",
                "0/0", "0/0"
            ],
            rgb: ["0/0", "0/0",
                "0/0"
            ],
            hsv: ["0/0", "0/0",
                "0/0"
            ],
            polygon: [
                "\\polygon(x_1)"
            ],
            area: ["0/0"],
            perimeter: ["0/0"],
            vertices: [
                "\\vertices(x_1)"
            ],
            segments: [
                "\\segments(x_1)"
            ],
            validateRangeLength: [
                "0", "0", "0",
                "\\{q \\ge 1: x_1, 0\\}"
            ],
            validateSampleCount: [
                "\\{x<0:0,1\\}*x_1"
            ],
            select: [
                "\\select(x_1, y)",
                "0*q"
            ],
            shuffle: ["0*y",
                "\\shuffle(x, x_1)"
            ],
            sortPerm: ["0*x"],
            elementsAt: [
                "\\elementsAt(x_1, y)",
                "0*q"
            ],
            uniquePerm: ["0*q"],
            tone: ["\\tone(x_1,0)",
                "\\tone(0,x_1)"
            ],
            restriction: ["0"],
            restrictionToBoolean: [
                "0"
            ]
        },
        WC = {};
    for (let e in ZC) {
        let t = e,
            n = ZC[t],
            r = [];
        for (let i = 0; i < n
            .length; i++) {
            let s = n[i];
            r.push(Vs(s, {}))
        }
        WC[t] = r
    }

    function jC(e, t) {
        e.map.length = Math.min(e
            .map.length, t), e
                .maxValidReference =
            Math.min(e
                .maxValidReference,
                t - 1)
    }

    function JC(e, t, n) {
        let r = e.argNames.indexOf(
            t);
        if (r === -1) {
            let o = e
                .getInstruction(n);
            return o.type === 1 ?
                OE(o.valueType, o
                    .value) : Xn()
        }
        let i = Lr(e, r, {
            allowRestriction:
                !0,
            allowClosedBlockReferences:
                !1
        }),
            s = yG(i, n);
        return Zr(s, n)
    }

    function yG(e, t) {
        let {
            chunk: n,
            mask: r
        } = e;
        return {
            chunk: n,
            mask: r,
            orderCtx: e,
            domainTable: [],
            index: t
        }
    }

    function Zr(e, t) {
        let {
            domainTable: n
        } = e, r = n[t];
        if (r !== void 0) return r;
        let i = gG(e, t);
        return n[t] = i, i
    }

    function gG(e, t) {
        let {
            chunk: n,
            mask: r,
            orderCtx: i
        } = e, s = n.getInstruction(
            t);
        switch (s.type) {
            case 1:
                return OE(s
                    .valueType,
                    s.value);
            case 3:
            case 2:
                return s
                    .valueType ===
                    T ? Ao() : Xn();
            case 0:
                return Xn();
            case 31:
                return Dp(Zr(e, s
                    .args[0]
                ), Zr(e,
                    s.args[
                    1]));
            case 32:
            case 8:
            case 9:
            case 10:
                return Dn(Zr(e, s
                    .args[0]
                ), Zr(e,
                    s.args[
                    1]));
            case 11: {
                let o = Dn(Zr(e, s
                    .args[0]
                ), Zr(e,
                    s.args[
                    1])),
                    a = n
                        .getInstruction(
                            s.args[1]);
                return a.type ===
                    1 && a
                        .valueType ===
                    T && q(a
                        .value) !== 0 ?
                    o : Dn(Xn(), o)
            }
            case 14:
                return Zr(e, s.args[
                    0]);
            case 15:
            case 16: {
                let o = Ao();
                for (let a of s
                    .args) o = Dn(o,
                        Zr(e, a));
                return o
            }
            case 12:
            case 13:
            case 47:
            case 48:
            case 17:
            case 18:
            case 42:
            case 21:
            case 22:
            case 23:
            case 24:
            case 19:
            case 20:
            case 39:
            case 40:
            case 41:
            case 44:
            case 50:
            case 51:
            case 54:
            case 55: {
                let o = Xn();
                for (let a of s
                    .args) o = Dn(o,
                        Zr(e, a));
                return o
            }
            case 4:
            case 53:
                return Xn();
            case 49:
                return Xn();
            case 38:
                return s.args
                    .length === 1 ?
                    Zr(e, s.args[
                        0]) : Xn();
            case 25:
                return Xn();
            case 33:
                return LM(Zr(e, s
                    .args[0]
                ), Zr(e,
                    s.args[
                    1]),
                    Zr(e, s
                        .args[2]
                    ));
            case 26:
            case 27:
            case 28:
            case 29: {
                if (!r[t])
                    return Ao();
                let o = Dn(Zr(e, s
                    .args[0]
                ), Zr(e,
                    s.args[
                    1]));
                if (en(i, t) > 1)
                    return Dn(Xn(),
                        o);
                let a = e
                    .coefficientCtx;
                a === void 0 && (a =
                    ws(i, e
                        .index),
                    e
                        .coefficientCtx =
                    a);
                let u = a.newChunk,
                    c = Hn(a, t),
                    [l, p] = c;
                if (!bt(u
                    .getInstruction(
                        l)))
                    return Dn(Xn(),
                        o);
                let f = ln(u, l);
                if (isNaN(f))
                    return aa();
                if (p === void 0)
                    return s
                        .type ===
                        28 || s
                            .type ===
                        29 ? f >=
                            0 ? o :
                        aa() : f > 0 ?
                        o : aa();
                {
                    let m = ln(u,
                        p);
                    return Dn(o, Xc(
                        f, m
                    ))
                }
            }
            case 37:
                switch (s.symbol) {
                    case "restriction":
                    case "restrictionToBoolean":
                        return Zr(e,
                            s
                                .args[
                            0
                            ]
                        );
                    case "count":
                        return Ao();
                    default: {
                        if (bn[s
                            .symbol]
                            .noPeel)
                            return Xn();
                        let o =
                            Xn();
                        for (let a of
                            s
                                .args)
                            o = Dn(
                                o,
                                Zr(e,
                                    a
                                )
                            );
                        return o
                    }
                }
        }
    }

    function OE(e, t) {
        if (W(e)) return t
            .length === 1 ? OE(
                ke(e), t[0]) :
            Xn();
        switch (e) {
            case T:
            case R:
            case V:
                return Yy(e, t) ?
                    aa() : Ao();
            case ge:
                return t ? Ao() :
                    aa();
            default:
                return Xn()
        }
    }

    function KC(e) {
        let t = [],
            n = [];
        for (let r = 0; r < e
            .argNames.length; r++) {
            let i = [],
                s = [];
            for (let o = 0; o < e
                .argNames
                .length; o++) i
                    .push(e.argTypes[
                        o] === T), s
                            .push(r === o);
            n.push(s), t.push(i)
        }
        for (let r = e.argNames
            .length; r <= e
                .getReturnIndex(); r++)
            n.push(hG(e, n, r)), t
                .push(bG(e, n, t, r));
        return t[e.getReturnIndex()]
    }

    function hG(e, t, n) {
        let r = e.getInstruction(n),
            i = xG(e.argNames
                .length);
        if (be(r)) return i;
        for (let s of r.args) {
            let o = t[s];
            for (let a = 0; a < o
                .length; a++) i[a] =
                    i[a] || o[a]
        }
        return i
    }

    function bG(e, t, n, r) {
        let i = e.getInstruction(r);
        if (be(i)) return QC(e
            .argNames.length
        );
        switch (i.type) {
            case 8:
            case 9:
            case 14:
            case 16:
            case 18:
            case 38: {
                let a = QC(e
                    .argNames
                    .length);
                for (let u = 0; u <
                    i.args
                        .length; u++) {
                    let c = n[i
                        .args[u]
                    ];
                    for (let l =
                        0; l < c
                            .length; l++
                    ) a[l] = a[
                        l] && c[
                        l]
                }
                return a
            }
            case 11: {
                let a = [],
                    u = n[i.args[
                        0]],
                    c = t[i.args[
                        1]];
                for (let l = 0; l <
                    u.length; l++) a
                        .push(u[l] && !
                            c[l]);
                return a
            }
            case 10: {
                let a = n[i.args[0]]
                    .slice(),
                    u = n[i.args[1]]
                        .slice(),
                    c = t[i.args[
                        0]],
                    l = t[i.args[
                        1]],
                    p = 0,
                    f = 0;
                for (let m = 0; m <
                    a.length; m++) {
                    let g = a[m] &&
                        !l[m],
                        d = u[m] &&
                            !c[m];
                    a[m] = g, u[m] =
                        d, g && (
                            p += 1),
                        d && (f +=
                            1)
                }
                return p >= f ? a :
                    u
            }
            case 33: {
                let a = t[i.args[
                    0]],
                    u = n[i.args[
                        1]],
                    c = n[i.args[
                        2]];
                for (var s = [], r =
                    0; r < a
                        .length; r++) s
                            .push(!a[r] &&
                                u[r] && c[r]
                            );
                return s
            }
            case 39:
            case 40:
            case 41: {
                let a = n[i.args[
                    0]],
                    u = t[i.args[
                        1]],
                    c = [];
                for (var r = 0; r <
                    u.length; r++) c
                        .push(a[r] && !
                            u[r]);
                return c
            }
            case 48: {
                let a = i.args[0],
                    u = e
                        .getInstruction(
                            a),
                    c = r - a;
                return n[u.args[c]]
            }
            case 15:
            case 17:
            case 12:
            case 13:
            case 26:
            case 28:
            case 27:
            case 29:
            case 25:
            case 32:
            case 31:
            case 37:
            case 42:
            case 21:
            case 22:
            case 19:
            case 20:
            case 23:
            case 24:
            case 47:
            case 44:
            case 49:
            case 50:
            case 51:
            case 53:
            case 54:
            case 55: {
                let a = t[r],
                    u = [];
                for (let c of a) u
                    .push(!c);
                return u
            }
            default:
                let o = i;
                throw new Error(
                    `Unexpected opcode ${o.type}`
                )
        }
    }

    function xG(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!1);
        return t
    }

    function QC(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!0);
        return t
    }

    function tR(e) {
        let t = e.getReturnIndex(),
            n = Yr(e, t),
            r = e.getInstruction(t);
        if (r.type !== 48) return e;
        let i = r.args[0],
            s = t - i,
            o = e.getInstruction(i),
            a = o.args[0],
            u = o.args[s],
            c = [],
            l = [];
        c.push(a);
        let p = yo(e, e
            .getReturnIndex(),
            "Programming error: cannot optimize regression on non-constant-length list"
        );
        l.push({
            min: 1,
            max: p,
            length: p
        });
        let f = !1,
            m = !1;
        for (let E = a + 1; E <=
            u; E++) {
            if (!n[E]) continue;
            let v = e
                .getInstruction(E);
            if (v.type === 39 || v
                .type === 41 || v
                    .type === 40) {
                if (v.args[1] !== a)
                    continue;
                let O = v.args[0];
                if (e
                    .getInstruction(
                        O)
                    .valueType !==
                    se || !bt(e
                        .getInstruction(
                            O)))
                    continue;
                let A = ln(e, O),
                    N = IG(A);
                if (!isFinite(N
                    .min) || !
                    isFinite(N.max))
                    continue;
                c.push(E), l.push(N)
            } else eR(v) ? f = !0 :
                (v.type === 12 || v
                    .type === 13) &&
                (m = !0)
        }
        if (c.length === 0 || !m &&
            !f) return e;
        let g = [],
            d = [];
        for (let E = 0; E < e
            .argNames.length; E++) d
                .push(E), g.push(Ao());
        let y = [],
            h = [];
        for (let E = 0; E <= u; E++)
            y.push(CE(e, d, y, E)),
                h.push(CE(e, c, h, E));
        for (let E = 0; E <=
            u; E++) {
            if (!n[E]) continue;
            let v = e
                .getInstruction(E);
            if (v.type === 33) {
                let O = y[E];
                for (let A = 0; A <
                    O.length; A++)
                    if (O[A])
                        return e
            } else if (v.type ===
                12 || v.type === 13
            ) {
                let O = !1,
                    A = !1;
                for (let Z = 0; Z <
                    c.length; Z++)
                    h[v.args[0]][
                        Z] && (O = !0),
                        h[v.args[1]][
                        Z] && (A = !0);
                if (O || !A)
                    continue;
                let N = y[v.args[
                    0]],
                    L = 0,
                    z;
                for (let Z = 0; Z <
                    N.length; Z++)
                    N[Z] && (z = Z,
                        L += 1);
                if (L !== 1 || z ===
                    void 0)
                    continue;
                let G = d[z],
                    $ = Lr(e.copy()
                        .reopenFinalBlock(),
                        G, {
                        allowRestriction:
                            !1,
                        allowClosedBlockReferences:
                            !1
                    });
                if (en($, v.args[
                    0]) !== 1)
                    continue;
                let w = ws($, v
                    .args[0]),
                    [Y, de] = Hn(w,
                        v.args[0]);
                if (de === void 0)
                    continue;
                let re = ln(w
                    .newChunk,
                    de),
                    ie = ln(w
                        .newChunk, Y
                    );
                g[z] = Dn(g[z], Xc(
                    ie, re))
            }
        }
        if (f) {
            let E = e.copy()
                .reopenFinalBlock();
            for (let v = 0; v < c
                .length; v++) {
                let O = Lr(E, c[
                    v], {
                    allowRestriction:
                        !1,
                    allowClosedBlockReferences:
                        !1
                }),
                    A = ws(O, u);
                for (let N = a +
                    1; N <= u; N++
                ) {
                    if (!n[N])
                        continue;
                    let L = E
                        .getInstruction(
                            N);
                    if (eR(L)) {
                        let z = L
                            .args[
                            0];
                        if (en(O,
                            z) !== 1
                        )
                            continue;
                        let G = Hn(
                            A, z
                        )[1];
                        if (G ===
                            void 0)
                            continue;
                        let $ = TG(A
                            .newChunk,
                            G),
                            w, Y =
                                0;
                        for (let ve =
                            0; ve <
                            $
                                .length; ve++
                        ) $[
                            ve] && (
                                w =
                                ve,
                                Y +=
                                1);
                        if (Y !==
                            1 ||
                            w ===
                            void 0)
                            continue;
                        let de = Lr(
                            A
                                .newChunk,
                            w, {
                            allowRestriction:
                                !
                                1,
                            allowClosedBlockReferences:
                                !
                                1
                        });
                        if (en(de,
                            G) !==
                            1)
                            continue;
                        let re = ws(
                            de,
                            G),
                            [ie,
                                Z] = Hn(
                                    re,
                                    G);
                        if (Z ===
                            void 0 ||
                            !bt(re
                                .newChunk
                                .getInstruction(
                                    ie
                                )
                            ) ||
                            !bt(re
                                .newChunk
                                .getInstruction(
                                    Z
                                )
                            ))
                            continue;
                        let Re = ln(
                            re
                                .newChunk,
                            ie),
                            Ne = ln(
                                re
                                    .newChunk,
                                Z),
                            Te = (l[
                                v]
                                .max -
                                l[v]
                                    .min
                            ) /
                                Math
                                    .min(l[
                                        v]
                                        .length -
                                        1,
                                        31),
                            Me =
                                Math
                                    .PI /
                                Te;
                        if (!
                            isFinite(
                                Me
                            ) ||
                            Me <= 0)
                            continue;
                        g[w] = Dn(g[
                            w],
                            Xc(Re,
                                Ne
                            )
                        ),
                            g[w] =
                            Dn(g[w],
                                Xc(Me -
                                    Re,
                                    -
                                    Ne
                                )
                            )
                    }
                }
            }
        }
        let b = !1;
        for (let E of g) {
            if (gi(E) || !Yi(E))
                return e;
            (E.bounds[0] !== -1 /
                0 || E.bounds[1] !==
                1 / 0) && (b = !0)
        }
        if (!b) return e;
        let x = e.copy(),
            P = x.Constant(1),
            M = x.Constant(NaN),
            I = t;
        for (let E = 0; E < x
            .argNames.length; E++)
            I = PG(x, g[E], I, E, P,
                M);
        return x.fuseBroadcast(), x
    }

    function PG(e, t, n, r, i, s) {
        if (gi(t) || !Yi(t) || t
            .bounds[0] === -1 / 0 &&
            t.bounds[1] === 1 / 0)
            return n;
        let o = e.And([e.LessEqual([
            e
                .Constant(
                    t
                        .bounds[
                    0
                    ]
                ), r
        ]), e.LessEqual(
            [r, e
                .Constant(
                    t
                        .bounds[
                    1
                    ]
                )
            ])]);
        return e.Multiply([n, e
            .Piecewise([o,
                i, s
            ])
        ])
    }

    function TG(e, t) {
        let n = [];
        for (let i = 0; i < e
            .argNames.length; i++) n
                .push(i);
        let r = [];
        for (let i = 0; i <= t; i++)
            r.push(CE(e, n, r, i));
        return r[t]
    }

    function eR(e) {
        return e.type === 37 && (e
            .symbol === "sin" ||
            e.symbol === "cos")
    }

    function IG(e) {
        var t = 1 / 0,
            n = -1 / 0,
            r = e.length;
        for (let i of e) t = Math
            .min(t, i), n = Math
                .max(n, i);
        return {
            min: t,
            max: n,
            length: r
        }
    }

    function CE(e, t, n, r) {
        let i = e.getInstruction(r),
            s = EG(t.length);
        for (let o = 0; o < t
            .length; o++)
            if (t[o] === r)
                return s[o] = !0, s;
        if (be(i)) return s;
        for (let o of i.args) {
            let a = n[o];
            for (let u = 0; u < a
                .length; u++) s[u] =
                    s[u] || a[u]
        }
        return s
    }

    function EG(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!1);
        return t
    }

    function nR(e) {
        let t = e.getReturnIndex(),
            n = e.getInstruction(t);
        if (be(n)) return t;
        let r = XI(e, n),
            i = r.expectedTypes,
            s = RE(e, n.args, [i]);
        if (r
            .isReducerWithNoListArgs
        ) {
            let o = MG(e, s
                .didCoerce ? s
                .args : n.args),
                a = ar(r
                    .expectedTypes
                    .rest);
            if (ro(o, a)) {
                s.didCoerce ? e
                    .replaceInstructionWithNoop(
                        t) : e
                            .popInstruction();
                let u = e.List(n
                    .args);
                return e
                    .copyInstructionWithArgs(
                        n, [u])
            }
        } else s.didCoerce && (e
            .replaceInstructionWithNoop(
                t), e
                    .copyInstructionWithArgs(
                        n, s.args));
        return e.getReturnIndex()
    }

    function RE(e, t, n) {
        let r = !1,
            i = [];
        for (let s = 0; s < t
            .length; s++) {
            let o = Np(n, s),
                a = t[s],
                u = e
                    .getInstruction(a)
                    .valueType,
                c = a;
            o.every(l => !ro(u,
                l)) && oe(o[0],
                    T) && (c = Ac(e,
                        a)), c !== a && (
                            r = !0), i.push(
                                c)
        }
        return r ? {
            didCoerce: r,
            args: i
        } : {
            didCoerce: !1
        }
    }

    function Ac(e, t) {
        let n = e.getInstruction(t);
        return n.valueType === We ?
            t : oe(n.valueType,
                Ge) ? iR(e, t) : oe(n
                    .valueType, Ae) ?
                rR(e, t) : oe(n
                    .valueType, Vt) ? e
                        .Piecewise([e
                            .SyntheticNativeFunction(
                                "restrictionToBoolean",
                                [t]), e
                                    .Constant(1), e
                                        .Constant(NaN)
                        ]) : t
    }

    function MG(e, t) {
        let n = e.getInstruction(t[
            0]).valueType;
        if (!ei(n)) return sn;
        for (let r of t)
            if (e.getInstruction(r)
                .valueType !== n)
                return sn;
        return ar(n)
    }

    function Bs(e) {
        var t = e;
        if (t && typeof t.toJSON ==
            "function" && (t = t
                .toJSON()), !t ||
            typeof t != "object")
            return t;
        if (Array.isArray(t))
            return t.map(Bs);
        var n = {};
        for (var r in t) t
            .hasOwnProperty(r) && (
                n[r] = Bs(t[r]));
        return n
    }

    function sR(e, t) {
        let n = [],
            r = [],
            i = [];
        for (let o = 0; o < e
            .argNames.length; o++) t
                .hasOwnProperty(e
                    .argNames[o]) || (n
                        .push(e.argNames[
                            o]), r.push(e
                                .argTypes[o]));
        let s = new jo({
            argNames: n,
            argTypes: r
        });
        for (let o = 0, a = 0; o < e
            .argNames.length; o++) t
                .hasOwnProperty(e
                    .argNames[o]) ? i[
                    o] = s.ConstantOfType(e
                        .argTypes[o], t[e
                            .argNames[o]]) :
                (i[o] = a, a += 1);
        for (let o = e.argNames
            .length; o < e
                .instructionsLength(); o++
        ) {
            let a = e
                .getInstruction(o);
            if (be(a)) i.push(Ls(s,
                a));
            else {
                let u = [];
                for (let c of a
                    .args) u.push(i[
                        c]);
                i.push(Mn(s, a, u))
            }
        }
        return s
    }

    function Pu(e, t) {
        if (t.type !== 33) return !
            1;
        let n = e.getInstruction(t
            .args[2]);
        return n.type === 1 && uo(n
            .valueType) && _v(n
                .valueType, n.value
            ) || Pu(e, n) && oR(
                e, t.args[1]) && oR(
                    e, n.args[1])
    }

    function NE(e, t) {
        let n = [];
        for (; t.type === 33;) n
            .push(t.args[0]), t = e
                .getInstruction(t.args[
                    2]);
        return n
    }

    function* Eg(e, t) {
        let n = e
            .getInstruction(t);
        n.type !== 32 ? yield t :
            (yield* Eg(e, n
                .args[
                0
            ]
            ),
                yield*
                Eg(e,
                    n
                        .args[
                    1
                    ]
                ))
    }

    function aR(e, t) {
        return e.getInstruction(t)
            .type === 25
    }

    function uR(e, t) {
        let n = e.getInstruction(t);
        if (n.type !== 25) return;
        let r = n.args[0],
            i = n.args[1],
            s = e.getInstruction(r),
            o = e.getInstruction(i),
            a = (o.type === 41 || o
                .type === 40) && bt(
                    e.getInstruction(o
                        .args[0]));
        return s.type === 2 && (bt(
            o) || a) && oe(o
                .valueType, T) ? {
            type: "constant",
            variable: e
                .argNames[r],
            index: i
        } : oe(s.valueType,
            T) && oe(o.valueType,
                T) ? {
            type: "implicit",
            index: e.Subtract([
                r, i
            ])
        } : void 0
    }

    function oR(e, t) {
        let n = e.getInstruction(t);
        return n.type === 1 && n
            .valueType === T && q(n
                .value) === 1
    }
    var _E = class {
        constructor(t, n, r,
            i) {
            this.openChunk =
                t;
            this.returnIndex =
                n;
            this.restrictionIndex =
                r;
            this.slices = i
        }
        getSliceVariablesOrImplicit
            () {
            return this
                .slices.map(
                    t => t
                        .type ===
                        "constant" ?
                        t
                            .variable :
                        "_implicit"
                )
        }
        getPeeledSlices() {
            let t = [];
            for (let n of
                this
                    .slices)
                if (n
                    .type ===
                    "constant"
                ) {
                    let r =
                        this
                            .openChunk
                            .getInstruction(
                                n
                                    .index
                            );
                    if (bt(
                        r) &&
                        r
                            .valueType ===
                        T) t
                            .push({
                                type: "constant",
                                variable: n
                                    .variable,
                                value: q(
                                    r
                                        .value
                                )
                            });
                    else if (
                        !(bt(
                            r) &&
                            r
                                .valueType ===
                            se
                        )
                    )
                        throw Bo()
                } else if (
                    this
                        .openChunk
                        .getInstruction(
                            n.index)
                        .valueType ===
                    T) {
                    let i = this
                        .openChunk
                        .copy();
                    i.setReturnIndex(
                        n
                            .index
                    ), i
                        .fuseBroadcast(),
                        t.push({
                            type: "implicit",
                            sliceChunk: i
                        })
                } else
                    throw Bo();
            return t
        }
        getValueAndRestrictionChunk
            () {
            let t = this
                .getPeeledSlices(),
                n = this
                    .openChunk
                    .copy();
            n.setReturnIndex(
                this
                    .returnIndex
            ), n
                .fuseBroadcast();
            let r;
            return this
                .restrictionIndex !==
                void 0 && (
                    r = this
                        .openChunk
                        .copy(),
                    r
                        .setReturnIndex(
                            this
                                .restrictionIndex
                        ), r
                            .fuseBroadcast()
                ), {
                valueChunk: n,
                restrictionChunk: r,
                slices: t
            }
        }
        getSlicesAndRestrictionChunk
            () {
            let t = this
                .getPeeledSlices(),
                n = this
                    .openChunk
                    .copy(),
                r = n
                    .GreaterEqual(
                        [this
                            .returnIndex,
                        n
                            .Constant(
                                0
                            )
                        ]);
            return this
                .restrictionIndex !==
                void 0 && (
                    r = n
                        .And([r, this
                            .restrictionIndex
                        ])), n
                            .setReturnIndex(
                                r), n
                                    .fuseBroadcast(), {
                restrictionChunk: n,
                slices: t
            }
        }
    },
        Mg = class {
            constructor(t, n, r) {
                this.chunk = t;
                this
                    .slices = [];
                this
                    .oldIPtoNewIP = [];
                this
                    .oldIPToRestriction = [];
                var i, s;
                this.produceNumbers =
                    (i = r ==
                        null ?
                        void 0 :
                        r
                            .produceNumbers
                    ) !=
                        null ? i : !
                    1, this
                        .allowSlices =
                    (s = r ==
                        null ?
                        void 0 :
                        r
                            .allowSlices
                    ) !=
                        null ? s : !
                    1, this
                        .newChunk =
                    new jo({
                        argNames: t
                            .argNames,
                        argTypes: t
                            .argTypes
                    }), this
                        .startTrue =
                    this
                        .produceNumbers ?
                        this
                            .newChunk
                            .Constant(
                                1 / 0) :
                        this
                            .newChunk
                            .ConstantOfType(
                                ge, !0),
                    this
                        .peelable =
                    SG(t), CG(t,
                        this
                            .peelable,
                        n)
            }
            selectRestriction() {
                return !0
            }
        },
        LE = class extends Mg {
            constructor(n, r, i) {
                super(n, r, i);
                this.currSelectIndex =
                    0;
                this.selectIndex =
                    i
                        .selectIndex
            }
            selectRestriction() {
                let n = this
                    .selectIndex ===
                    this
                        .currSelectIndex;
                return this
                    .currSelectIndex++,
                    this
                        .produceNumbers ?
                        n : !n
            }
        };

    function Ra(e, t, n) {
        let r = new Mg(e, t, n);
        wE(r, 0, e
            .instructionsLength() -
            1);
        let i = r
            .oldIPToRestriction[e
                .getReturnIndex()];
        return new _E(r.newChunk, r
            .oldIPtoNewIP[e
                .getReturnIndex()
        ], r
            .startTrue === i ?
            void 0 : i, r.slices
        )
    }

    function* cR(e, t, n) {
        var i, s;
        let r = AE(e, n, {
            produceNumbers:
                !1,
            selectIndex: 0
        });
        if (r === void 0 || r
            .count <= 1) {
            yield {
                value: t,
                restriction: void 0
            };
            return
        }
        for (let o = 0; o < r
            .count; o++) {
            let a = (i = AE(e,
                n, {
                produceNumbers:
                    !
                    0,
                selectIndex: o
            })) ==
                null ? void 0 :
                i.chunk,
                u = o === 0 ? r
                    .chunk : (s =
                        AE(e, n, {
                            produceNumbers:
                                !
                                1,
                            selectIndex: o
                        })) ==
                        null ? void 0 :
                    s.chunk;
            if (!a || !u)
                throw new Error(
                    "Programming Error: selectIndex gave invalid chunk."
                );
            yield {
                value: a,
                restriction: u
            }
        }
    }

    function AE(e, t, n) {
        let r = new LE(e, t, n);
        wE(r, 0, e
            .instructionsLength() -
            1);
        let i = r
            .oldIPToRestriction[e
                .getReturnIndex()];
        if (r.currSelectIndex === 0)
            return;
        let s = r.oldIPtoNewIP[e
            .getReturnIndex()],
            o = r.newChunk
                .getInstruction(s);
        if (o.type !== 29)
            throw new Error(
                "Programming Error: Expected GreaterEqual."
            );
        let a = r.produceNumbers ? r
            .newChunk.Subtract([o
                .args[0], o
                    .args[1]
            ]) : s;
        return r
            .selectRestriction() && (i =
                vg(r, [i, a])), r
                    .newChunk
                    .setReturnIndex(i), {
            chunk: r.newChunk,
            count: r
                .currSelectIndex
        }
    }

    function wE(e, t, n) {
        let {
            chunk: r,
            newChunk: i,
            peelable: s,
            oldIPtoNewIP: o,
            oldIPToRestriction: a
        } = e;
        for (let u = t; u <=
            n; u++) {
            let c = r
                .getInstruction(u);
            if (s[u] && (c.type ===
                19 || c.type ===
                23)) u = DG(e,
                    u);
            else if (c.type === 2)
                o[u] = u, a[u] = e
                    .startTrue;
            else if (be(c)) o[u] = i
                .copyInstruction(c),
                a[u] = e.startTrue;
            else if (s[u] && Pu(r,
                c)) {
                o[u] = o[c.args[1]];
                let l = c.args.map(
                    p => a[p]);
                for (let p of RG(e,
                    c)) e
                        .selectRestriction() &&
                        l.push(p);
                a[u] = vg(e, l)
            } else o[u] = i
                .copyInstructionWithArgs(
                    c, c.args.map(
                        l => o[l])),
                a[u] = vg(e, c.args
                    .map(l => a[l]))
        }
    }

    function vg(e, t) {
        let r = [...new Set(t)]
            .filter(i => !lR(e, i));
        return r.length ? Dg(e, r)
            .reduce((i, s) => e
                .produceNumbers ? e
                    .newChunk
                    .SyntheticNativeFunction(
                        "min", [i, s]) :
                e.newChunk.And([i,
                    s])) : e
            .startTrue
    }

    function vG(e, t) {
        let n = [...new Set(t)];
        return n.some(r => !lR(e,
            r)) ? Dg(e, n)
                .reduce((r, i) => e
                    .produceNumbers ? e
                        .newChunk
                        .SyntheticNativeFunction(
                            "max", [r, i]) :
                    e.newChunk.Or([r,
                        i])) : e
            .startTrue
    }

    function Dg(e, t) {
        if (!e.produceNumbers)
            return t;
        let n = e.newChunk;
        return t.map(r => {
            let i = n
                .getInstruction(
                    r);
            if (i
                .valueType !==
                ge)
                return r;
            switch (i
                .type) {
                case 27:
                case 29:
                    return n
                        .Subtract(
                            [i.args[
                                0],
                            i
                                .args[
                            1
                            ]
                            ]
                        );
                case 26:
                case 28:
                    return n
                        .Subtract(
                            [i.args[
                                1],
                            i
                                .args[
                            0
                            ]
                            ]
                        );
                case 25:
                    throw J(
                        "convertBoolsToNums on an equality.");
                case 32:
                    return n
                        .SyntheticNativeFunction(
                            "min",
                            Dg(e,
                                i
                                    .args
                            )
                        );
                case 31:
                    return n
                        .SyntheticNativeFunction(
                            "max",
                            Dg(e,
                                i
                                    .args
                            )
                        );
                case 1:
                    return n
                        .Constant(
                            i
                                .value ?
                                1 /
                                0 :
                                -
                                1 /
                                0
                        );
                default:
                    throw J(
                        "convertBoolsToNums on a non-opcode condition.")
            }
        })
    }

    function lR({
        newChunk: e
    }, t) {
        let n = e.getInstruction(t);
        return n.type === 1 && (n
            .valueType === T &&
            n.value === 1 / 0 ||
            n.valueType ===
            ge && n.value)
    }

    function DG(e, t) {
        let {
            chunk: n,
            newChunk: r,
            oldIPtoNewIP: i,
            oldIPToRestriction: s,
            startTrue: o
        } = e, a = n.getInstruction(
            t), u = a.endIndex,
            c = n.getInstruction(u),
            l, p;
        if (a.type === 23) i[t] = r
            .copyInstructionWithArgs(
                a, [i[a.args[0]]]),
            s[t] = o, p = t + 1;
        else {
            let d = a.args.map(y =>
                i[y]);
            d.push(o), i[t] = r
                .copyInstructionWithArgs(
                    a, d), s[t] = o;
            for (let y = 2; y < a
                .args.length; y++) {
                let h = t + y - 1;
                i[h] = r
                    .copyInstructionWithArgs(
                        n
                            .getInstruction(
                                h), [i[
                                    t]]), s[
                                    h] = o
            }
            l = r.BlockVar(e
                .produceNumbers ?
                T : ge, [i[t]]),
                p = t + a.args
                    .length - 1
        }
        wE(e, p, u - 1);
        let f = c.args.map(d => i[
            d]),
            m = e.slices.filter(d =>
                p <= d.index && d
                    .index < u),
            g = l;
        if (a.type === 19) {
            if (l === void 0)
                throw new Error(
                    "Expected restrictionAccumVar to be defined"
                );
            g = vg(e, [l, s[c.args[
                1]]]), f.push(g)
        } else {
            f.push(s[c.args[1]]);
            for (let d of m) f.push(
                d.index)
        }
        i[u] = r
            .copyInstructionWithArgs(
                c, f), s[u] = o;
        for (let d = 1; d < c.args
            .length; d++) i[u + d] =
                r
                    .copyInstructionWithArgs(
                        n.getInstruction(u +
                            d), [i[u]]);
        if (a.type === 23) {
            let d = r
                .BroadcastResult(e
                    .produceNumbers ?
                    se : Ln, [i[u]]
                );
            for (let y of m) y
                .index = r
                    .BroadcastResult(se,
                        [i[u]]);
            for (let y = 1; y < c
                .args.length; y++)
                s[u + y] = d
        } else {
            let d = r.BlockVar(e
                .produceNumbers ?
                T : ge, [i[u]]);
            l === g && (d = o);
            for (let y = 1; y < c
                .args.length; y++)
                s[u + y] = d
        }
        return u + c.args.length - 1
    }

    function SG(e) {
        let t = [];
        for (let r = 0; r < e
            .instructionsLength(); r++
        ) t.push(!1);
        t[e.getReturnIndex()] = !0;
        let n = e
            .instructionsLength() -
            1;
        for (let r = n; r >=
            0; r--) {
            if (!t[r]) continue;
            let i = e
                .getInstruction(r);
            if (!be(i))
                for (let s of OG(e,
                    i)) t[s] = !
                        0
        }
        return t
    }

    function OG(e, t) {
        switch (t.type) {
            case 14:
            case 8:
            case 9:
            case 26:
            case 28:
            case 27:
            case 29:
            case 10:
            case 11:
            case 12:
            case 13:
            case 25:
            case 32:
            case 15:
            case 16:
            case 38:
            case 47:
            case 19:
            case 39:
            case 40:
            case 41:
            case 23:
            case 24:
            case 48:
            case 50:
                return t.args;
            case 33:
                return Pu(e, t) ?
                    NE(e, t).concat(
                        [t.args[1]]
                    ) : [];
            case 37: {
                let r = bn[t
                    .symbol];
                return r.noPeel ?
                    [] : r.tag ===
                        "reducer" || r
                            .tag ===
                        "doubleReducer" ||
                        r.tag ===
                        "never-broadcast" ||
                        r.tag ===
                        "parameterizedReducer" ?
                        t.args.filter(
                            i => e
                                .getInstruction(
                                    i)
                                .type !== 48
                        ) : t.args
            }
            case 20:
                return t.args.slice(
                    1);
            case 51:
                return [];
            case 31:
                return [];
            case 17:
            case 18:
            case 42:
            case 21:
            case 22:
            case 44:
            case 49:
            case 53:
            case 54:
            case 55:
                return [];
            default:
                let n = t;
                throw new Error(
                    `Unexpected opcode ${n.type}`
                )
        }
    }

    function CG(e, t, n) {
        let r = [];
        for (let i = 0; i < e
            .argNames.length; i++) {
            let s = e.argNames[i];
            n.indexOf(s) < 0 && r
                .push(i)
        }
        for (let i of r) {
            let s = eu(e, i);
            for (let o = 0; o < e
                .instructionsLength(); o++
            ) t[i] && (t[i] = !
                s[o])
        }
    }

    function RG(e, t) {
        let n = NE(e.chunk, t).map(
            r => e.oldIPtoNewIP[
                r]);
        if (e.allowSlices && n
            .length === 1) {
            let r = uR(e.newChunk,
                n[0]);
            if (r) return e.slices
                .push(r), []
        }
        if (n.some(r => aR(e
            .newChunk, r)))
            throw Bo();
        if (n.length === 1) {
            let r = n[0];
            return [...Eg(e
                .newChunk, r
            )]
        }
        return [vG(e, n)]
    }
    var jo = class e {
        constructor(t) {
            this
                .derivativeMaps = {};
            if (this
                .instructions = [],
                this
                    .blockMask = [],
                this
                    .comments = [],
                t.argNames
                    .length !==
                t.argTypes
                    .length)
                throw new Error(
                    "Programming Error: length of argNames must match length of argTypes"
                );
            this.argNames =
                t.argNames,
                this
                    .argTypes =
                t.argTypes;
            for (let n =
                0; n < this
                    .argTypes
                    .length; n++
            ) {
                let r = this
                    .argTypes[
                    n];
                this.LoadArg(
                    r)
            }
            this.returnIndex =
                this
                    .Constant(
                        NaN)
        }
        computeNeedsThunking() {
            for (let t =
                this
                    .returnIndex; t >=
                0; t--)
                if (this
                    .instructions[
                    t]
                    .type ===
                    55)
                    return !
                        0;
            return !1
        }
        setError(t) {
            this.error = t
        }
        getError() {
            return this
                .error
        }
        getReturnIndex() {
            return this
                .returnIndex
        }
        setReturnIndex(t) {
            if (!(0 <= t &&
                t < this
                    .instructions
                    .length
            ))
                throw new Error(
                    `Programming Error: out of bounds return index ${t}`
                );
            this.returnIndex =
                t
        }
        addComments(t) {
            for (let n in
                t) {
                let r = this
                    .comments[
                    n
                ] ||
                    "";
                this.comments[
                    n] =
                    r + t[n]
            }
            return this
        }
        instructionsLength() {
            return this
                .instructions
                .length
        }
        getInstruction(t) {
            return this
                .instructions[
                t]
        }
        popInstruction() {
            this.truncate(
                this
                    .instructions
                    .length -
                1)
        }
        truncate(t) {
            this.instructions
                .length =
                Math.min(t,
                    this
                        .instructions
                        .length
                ), this
                    .blockMask
                    .length =
                Math.min(t,
                    this
                        .blockMask
                        .length
                ), this
                    .comments
                    .length =
                Math.min(t,
                    this
                        .comments
                        .length
                );
            for (let n in
                this
                    .derivativeMaps)
                + n >= t ?
                    delete this
                        .derivativeMaps[
                    n] : jC(
                        this
                            .derivativeMaps[
                        n],
                        t);
            this.setReturnIndex(
                this
                    .instructions
                    .length -
                1)
        }
        dereferenceFunctionHeader
            (t) {
            let n = this
                .getInstruction(
                    t);
            return n
                .endIndex ===
                -1 ?
                void 0 : n
                    .endIndex
        }
        getDirectDependencies(
            t) {
            if (t.type ===
                55) {
                let n = t
                    .args,
                    r = this
                        .dereferenceFunctionHeader(
                            n[0]
                        );
                if (r !==
                    void 0)
                    return n
                        .concat(
                            r
                        )
            }
            return t.args
        }
        getRecursionStructure(
            t) {
            let n = this
                .getInstruction(
                    t);
            if (n
                .endIndex ===
                -1) throw J(
                    "Programming error: cannot get recursion structure before function is closed"
                );
            if (!n
                .__cachedRecursionStructure
            ) {
                let r = {};
                for (let i of
                    n
                        .recursionGroup) {
                    let s =
                        this
                            .getInstruction(
                                i
                            );
                    r[s.symbol] =
                        i
                }
                n.__cachedRecursionStructure =
                    eD(this,
                        r)
            }
            return n
                .__cachedRecursionStructure
        }
        getRecursiveFunctionMetadata
            (t) {
            let n = this
                .getRecursionStructure(
                    t),
                r = this
                    .getInstruction(
                        t);
            return {
                type: n
                    .canIterate ?
                    "iterative" :
                    "general",
                recursionGroup: r
                    .recursionGroup
                    .map(
                        i =>
                            this
                                .getInstruction(
                                    i
                                )
                                .symbol
                    ),
                returnType: r
                    .valueType,
                signature: r
                    .signature,
                recursiveStructure: n
            }
        }
        pushInstructionChecked(
            t) {
            if (this
                .instructions
                .length >=
                32768)
                throw sx();
            this.instructions
                .push(t),
                this
                    .setReturnIndex(
                        this
                            .instructions
                            .length -
                        1)
        }
        pushLeafInstruction(t) {
            return this
                .pushInstructionChecked(
                    t), this
                        .getReturnIndex()
        }
        pushInstruction(t) {
            return this
                .checkInstructionArguments(
                    t), this
                        .pushInstructionChecked(
                            t), this
                                .setReturnIndex(
                                    FS(this)
                                ), this
                                    .setReturnIndex(
                                        kS(this)
                                    ), this
                                        .setReturnIndex(
                                            nR(this)
                                        ), vS(
                                            this,
                                            this
                                                .getReturnIndex()
                                        ), this
                                            .returnIndex ===
                                        this
                                            .instructions
                                            .length -
                                        1 && this
                                            .setReturnIndex(
                                                TS(this)
                                            ), this
                                                .getReturnIndex()
        }
        checkInstructionArguments
            (t) {
            for (let n of t
                .args)
                if (this
                    .blockMask[
                    n])
                    throw new Error(
                        "Programming Error: cannot reference an instruction in a closed block"
                    )
        }
        markClosedBlock(t, n) {
            for (let r =
                t; r <
                n; r++) this
                    .blockMask[
                    r] = !0
        }
        LoadArg(t) {
            return this
                .pushLeafInstruction({
                    type: 2,
                    valueType: t
                })
        }
        BlockVar(t, n) {
            return this
                .pushInstruction({
                    type: 47,
                    valueType: t,
                    args: n
                })
        }
        SymbolicVar(t, n) {
            return this
                .pushLeafInstruction({
                    type: 3,
                    valueType: t,
                    symbol: n
                })
        }
        BroadcastResult(t, n) {
            let r = n[0],
                s = this
                    .instructions[
                    r].args[
                    0],
                a = this
                    .getInstruction(
                        s).args[
                    0],
                u = this
                    .getInstruction(
                        a);
            return this
                .pushInstruction({
                    type: 48,
                    valueType: t,
                    args: n,
                    constantLength: bt(
                        u
                    ) ?
                        ln(this,
                            a
                        ) :
                        void 0
                })
        }
        Constant(t) {
            return this
                .ConstantOfType(
                    T, t)
        }
        ConstantOfType(t, n) {
            if (typeof n ==
                "number" &&
                (n = De(n,
                    1)), W(
                        t) && n
                            .length >
                1e4)
                throw Qp();
            return this
                .pushLeafInstruction({
                    type: 1,
                    valueType: t,
                    value: n
                })
        }
        NanOfType(t) {
            if (t === St) {
                let n = this
                    .Constant(
                        NaN
                    );
                return this
                    .Distribution(
                        "uniformdist",
                        [n,
                            n]
                    )
            } else return this
                .ConstantOfType(
                    t,
                    $r(
                        t)
                )
        }
        Add(t) {
            let n = 8,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Subtract(t) {
            let n = 9,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Multiply(t) {
            let n = 10,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Divide(t) {
            let n = 11,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Exponent(t) {
            let n = 12,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        RawExponent(t) {
            let n = 13,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Negative(t) {
            let n = 14,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Equal(t) {
            let n = 25,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Less(t) {
            let n = 26,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Greater(t) {
            let n = 27,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        LessEqual(t) {
            let n = 28,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        GreaterEqual(t) {
            let n = 29,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Comparator(t, n) {
            switch (t) {
                case "=":
                    return this
                        .Equal(
                            n
                        );
                case ">":
                    return this
                        .Greater(
                            n
                        );
                case "<":
                    return this
                        .Less(
                            n
                        );
                case "<=":
                    return this
                        .LessEqual(
                            n
                        );
                case ">=":
                    return this
                        .GreaterEqual(
                            n
                        );
                default: {
                    let r =
                        t;
                    throw new Error(
                        `Unexpected comparator symbol: ${r}`
                    )
                }
            }
        }
        Or(t) {
            let n = 31,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        And(t) {
            let n = 32,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        Piecewise(t) {
            let n = 33,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        OrderedPair(t) {
            let n = 15,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        OrderedPairAccess(t,
            n) {
            let r = 17,
                i = fn(this,
                    r, n);
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    index: t,
                    args: n
                })
        }
        OrderedTriple(t) {
            let n = 16,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        OrderedTripleAccess(t,
            n) {
            let r = 18,
                i = fn(this,
                    r, n);
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    index: t,
                    args: n
                })
        }
        List(t) {
            let n = 38,
                r = fn(this,
                    n, t);
            if (t.length >
                1e4)
                throw Qp();
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        ListAccess(t) {
            let n = 39,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        DeferredListAccess(t) {
            let n = 40,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        InboundsListAccess(t) {
            let n = 41,
                r = fn(this,
                    n, t);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                })
        }
        NativeFunction(t, n,
            r) {
            let i = 37,
                s = bn[t]
                    .returnType,
                o =
                    typeof s ==
                        "function" ?
                        s(r.map(a =>
                            this
                                .getInstruction(
                                    a
                                )
                                .valueType
                        )) : s;
            return this
                .pushInstruction({
                    type: i,
                    valueType: o,
                    args: r,
                    symbol: t,
                    callData: n
                })
        }
        SyntheticNativeFunction(
            t, n) {
            let r = 37,
                i = bn[t]
                    .returnType,
                s =
                    typeof i ==
                        "function" ?
                        i(n.map(a =>
                            this
                                .getInstruction(
                                    a
                                )
                                .valueType
                        )) : i,
                o = {
                    errorSymbol: t,
                    providedArity: n
                        .length,
                    isDotCall:
                        !1
                };
            return this
                .pushInstruction({
                    type: r,
                    valueType: s,
                    args: n,
                    symbol: t,
                    callData: o
                })
        }
        Distribution(t, n) {
            let r = 42,
                i = St;
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    args: n,
                    symbol: t
                })
        }
        BeginIntegral(t, n) {
            let r = 21,
                i = fn(this,
                    r, []);
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    args: n,
                    endIndex: -1,
                    callData: t
                })
        }
        EndIntegral(t) {
            let n = 22,
                r = fn(this,
                    n, t),
                i = t[0],
                s = this
                    .getInstruction(
                        i);
            this.instructions[
                i] = {
                type: s
                    .type,
                valueType: s
                    .valueType,
                args: s
                    .args,
                endIndex: this
                    .instructionsLength(),
                callData: s
                    .callData
            };
            let o = this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                });
            return this
                .markClosedBlock(
                    i, o), o
        }
        BeginBroadcast(t, n) {
            let r = 23,
                i = fn(this,
                    r, []),
                s = this
                    .getInstruction(
                        t[0]);
            if (bt(s) && ln(
                this, t[
            0]
            ) > 1e4)
                throw Qp();
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    endIndex: -1,
                    args: t,
                    listComprehensionCallData: n
                })
        }
        EndBroadcast(t) {
            let n = 24,
                r = fn(this,
                    n, t),
                i = t[0],
                s = this
                    .getInstruction(
                        i),
                o = {
                    type: s
                        .type,
                    valueType: s
                        .valueType,
                    args: s
                        .args,
                    endIndex: this
                        .instructionsLength()
                };
            this.instructions[
                i] = o;
            let a = this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                });
            return this
                .markClosedBlock(
                    i, a), a
        }
        BeginLoop(t, n) {
            let r = 19,
                i = fn(this,
                    r, n);
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    args: n,
                    endIndex: -1,
                    callData: t
                })
        }
        EndLoop(t) {
            let n = 20,
                r = fn(this,
                    n, t),
                i = t[0],
                s = this
                    .getInstruction(
                        i);
            this.instructions[
                i] = {
                type: s
                    .type,
                valueType: s
                    .valueType,
                args: s
                    .args,
                endIndex: this
                    .instructionsLength(),
                callData: s
                    .callData
            };
            let o = this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                });
            return this
                .markClosedBlock(
                    i, o), o
        }
        BeginMap(t, n) {
            let r = 50,
                i = fn(this,
                    r, n);
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    args: n,
                    endIndex: -1,
                    callData: t
                })
        }
        EndMap(t) {
            let n = 51,
                r = fn(this,
                    n, t),
                i = t[0],
                s = this
                    .getInstruction(
                        i);
            this.instructions[
                i] = {
                type: s
                    .type,
                valueType: s
                    .valueType,
                args: s
                    .args,
                endIndex: this
                    .instructionsLength(),
                callData: s
                    .callData
            };
            let o = this
                .pushInstruction({
                    type: n,
                    valueType: r,
                    args: t
                });
            return this
                .markClosedBlock(
                    i, o), o
        }
        FunctionHeader(t, n, r,
            i) {
            let s = 4;
            return this
                .pushLeafInstruction({
                    type: s,
                    valueType: n,
                    endIndex: -1,
                    symbol: t,
                    signature: r,
                    parameterSymbols: i,
                    recursionGroup: []
                })
        }
        BeginFunction(t) {
            let n = 53,
                r = this
                    .getInstruction(
                        t[0]);
            return this
                .pushInstruction({
                    type: n,
                    valueType: r
                        .valueType,
                    endIndex: -1,
                    args: t
                })
        }
        EndFunction(t) {
            let n = 54,
                r = t[0],
                i = this
                    .getInstruction(
                        r);
            this.instructions[
                r] = {
                type: i
                    .type,
                valueType: i
                    .valueType,
                args: i
                    .args,
                endIndex: this
                    .instructionsLength()
            };
            let s = i.args[
                0],
                o = this
                    .getInstruction(
                        i.args[
                        0]);
            this.instructions[
                s] = {
                type: o
                    .type,
                valueType: o
                    .valueType,
                endIndex: this
                    .instructionsLength(),
                symbol: o
                    .symbol,
                signature: o
                    .signature,
                parameterSymbols: o
                    .parameterSymbols,
                recursionGroup: o
                    .recursionGroup
            };
            let a = this
                .pushInstruction({
                    type: n,
                    valueType: Ht,
                    args: t
                });
            return this
                .markClosedBlock(
                    r, a), a
        }
        FunctionCall(t) {
            let n = 55;
            return this
                .pushInstruction({
                    type: n,
                    valueType: fn(
                        this,
                        n,
                        t
                    ),
                    args: t
                })
        }
        ExtendSeed(t, n) {
            let r = 44,
                i = ot;
            return this
                .pushInstruction({
                    type: r,
                    valueType: i,
                    args: n,
                    tag: t
                })
        }
        Noop() {
            let t = 0,
                n = Ht;
            return this
                .pushLeafInstruction({
                    type: t,
                    valueType: n
                })
        }
        Action(t, n) {
            return this
                .pushInstruction({
                    type: 49,
                    valueType: rt,
                    args: n,
                    symbols: t
                })
        }
        replaceInstructionWithConstant
            (t, n) {
            this.instructions[
                t] = n,
                this
                    .blockMask[
                t] =
                void 0
        }
        replaceInstructionWithBlockVarOrFunctionCall
            (t, n) {
            this.instructions[
                t] = n
        }
        reopenFinalBlock() {
            let t = this
                .getInstruction(
                    this
                        .getReturnIndex()
                );
            if (t.type !==
                48)
                return this;
            let n = t.args[
                0],
                i = this
                    .getInstruction(
                        n).args[
                    0];
            for (let s =
                i; s <
                n; s++) this
                    .blockMask[
                    s] =
                    void 0;
            return this
                .truncate(
                    n), this
        }
        reopenAllBlocks() {
            this.blockMask = []
        }
        isInClosedBlock(t) {
            return !!this
                .blockMask[
                t]
        }
        copy() {
            let t = new e({
                argNames: this
                    .argNames,
                argTypes: this
                    .argTypes
            });
            return t
                .instructions =
                this
                    .instructions
                    .slice(), t
                        .blockMask =
                this
                    .blockMask
                    .slice(), t
                        .comments =
                this
                    .comments
                    .slice(), t
                        .derivativeMaps =
                Bs(this
                    .derivativeMaps
                ), t
                    .setReturnIndex(
                        this
                            .getReturnIndex()
                    ), t
        }
        fuseBroadcast() {
            return this
                .setReturnIndex(
                    Tr(this,
                        this
                            .getReturnIndex()
                    )),
                this
        }
        copyInstruction(t) {
            return Ls(this,
                t)
        }
        copyInstructionWithArgs(
            t, n) {
            return Mn(this,
                t, n)
        }
        replaceInstructionWithNoop
            (t) {
            this.instructions[
                t] = {
                type: 0,
                valueType: Ht
            }
        }
        getReturnType() {
            return this
                .instructions[
                this
                    .getReturnIndex()
            ]
                .valueType
        }
        isConstant() {
            return bt(this
                .instructions[
                this
                    .getReturnIndex()
            ])
        }
        asValue() {
            return ln(this,
                this
                    .getReturnIndex()
            )
        }
        asCompilerValue() {
            let t = this
                .instructions[
                this
                    .getReturnIndex()
            ];
            switch (t
                .type) {
                case 1:
                    return t
                        .value;
                default:
                    throw new Error(
                        `Unexpected opcode ${t.type}.`
                    )
            }
        }
        getConstantListLength
            () {
            return zn(this,
                this
                    .getReturnIndex()
            )
        }
        getListLengthDependencies
            () {
            let t = this
                .copy(),
                n = _r(t, t
                    .getReturnIndex()
                );
            return oi(t, n)
        }
        elementAt(t) {
            let n = this
                .copy(),
                r = n
                    .getReturnIndex();
            return n
                .setReturnIndex(
                    zf(n, r,
                        t)),
                n
        }
        substituteConstantArguments
            (t) {
            return sR(this,
                t)
        }
        interpretWithParameters(
            t) {
            return yS(this,
                this
                    .getReturnIndex(),
                t)
        }
        getCompiledFunction(t) {
            let n;
            if (t) {
                n = t
                    .slice();
                for (let o of
                    this
                        .argNames)
                    n
                        .indexOf(
                            o
                        ) ===
                        -1 && n
                            .push(o)
            } else n = this
                .argNames;
            let {
                source: r,
                constants: i
            } = cy(this),
                s = {};
            return {
                args: n,
                source: r,
                constants: i,
                executionMetadata: s,
                fn: Ff(n, r,
                    i, s
                )
            }
        }
        getRestrictedFunctionForGLSL
            (t, n) {
            let r = Ra(this,
                t, {
                allowSlices:
                    !
                    0
            }),
                {
                    restrictionChunk: i,
                    valueChunk: s
                } = r
                    .getValueAndRestrictionChunk(),
                o;
            if (i !==
                void 0)
                try {
                    o = Wo(i,
                        n
                    )
                } catch (
                a) {
                    i = void 0
                }
            return o ===
                void 0 && r
                    .getSliceVariablesOrImplicit()
                    .length ==
                0 ? {
                concrete: new pn(
                    this
                ),
                restriction: void 0,
                restrictionExpr: void 0
            } : {
                concrete: new pn(
                    s
                ),
                restriction: o,
                restrictionExpr: i &&
                    new pn(
                        i
                    )
            }
        }
        polynomialOrder(t, n) {
            return BS(this,
                t, n)
        }
        getPolynomialCoefficients
            (t) {
            return GS(this,
                t)
        }
        takeDerivative(t) {
            let n = this
                .argNames
                .indexOf(t);
            return n === -
                1 ? this
                    .Constant(
                        0) : this
                            .setReturnIndex(
                                lp(this,
                                    this
                                        .getReturnIndex(),
                                    n)),
                this
        }
        gradient(t) {
            let n = [],
                r = this
                    .getReturnIndex();
            for (let i of
                t) {
                let s = this
                    .argNames
                    .indexOf(
                        i);
                s === -1 ? n
                    .push(
                        this
                            .Constant(
                                0
                            )
                    ) :
                    n.push(
                        lp(this,
                            r,
                            s
                        )
                    )
            }
            return this
                .List(n),
                this
        }
        deriveRegressionRestrictions
            () {
            return tR(this)
        }
        boundDomain(t) {
            return JC(this,
                t, this
                    .getReturnIndex()
            )
        }
        findLinearSubset(t) {
            let n = KC(
                this),
                r = [];
            for (let i of
                t) {
                let s = this
                    .argNames
                    .indexOf(
                        i);
                if (s === -
                    1) throw new Error(
                        "Programming Error: findLinearSubset called with a non-dependency"
                    );
                r.push(n[s])
            }
            return r
        }
        isLinearIn(t) {
            let n = this
                .argNames
                .filter(r =>
                    t
                        .includes(
                            r));
            return n
                .length ===
                0 ? !1 :
                this
                    .findLinearSubset(
                        n)
                    .every(
                        Boolean)
        }
        isImplicitPlane() {
            let t = n =>
                n === "x" ||
                n === "y" ||
                n === "z";
            return this
                .isLinearIn(
                    ["x",
                        "y",
                        "z"
                    ]) &&
                this
                    .argNames
                    .every(t)
        }
        print(t, n = this
            .comments) {
            let r;
            return t ===
                void 0 ? (
                t = this
                    .instructionsLength() -
                1, r = {
                    printUnreferencedInstructions:
                        !
                        0,
                    comments: n
                }) :
                r = {
                    printUnreferencedInstructions:
                        !1,
                    comments: n
                }, Wv(this,
                    t, r)
        }
        printInstruction(t) {
            return yc(this,
                t)
        }
        toDot() {
            return VS(this)
        }
        getLiveArgNames() {
            let t = Yr(this,
                this
                    .getReturnIndex()
            ),
                n = [];
            for (let r =
                0; r < this
                    .argNames
                    .length; r++
            ) t[r] && n
                .push(this
                    .argNames[
                    r]);
            return n
        }
        getCursorContext() {
            return this
                .cursorContext
        }
        setCursorContext(t) {
            this.cursorContext =
                t
        }
    };
    var Ko = {
        normaldist: {
            pdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "normalpdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            cdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "normalcdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            mean: function (e, t,
                n) {
                return e
                    .getInstruction(
                        t)
                    .args[0]
            },
            median: function (e,
                t, n) {
                return Ko
                    .normaldist
                    .mean(e,
                        t, n
                    )
            },
            stdev: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "abs",
                        [r.args[
                            1]]
                    )
            },
            var: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .Multiply(
                        [r.args[
                            1],
                        r
                            .args[
                        1
                        ]
                        ])
            },
            quantile: function (
                e, t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .Add([e.Multiply(
                        [e.SyntheticNativeFunction(
                            "invNorm",
                            n
                        ),
                        e
                            .SyntheticNativeFunction(
                                "abs",
                                [r.args[
                                    1]]
                            )
                        ]
                    ),
                    r
                        .args[
                    0
                    ]
                    ])
            },
            random: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "normalSample",
                        [n[0],
                        r
                            .args[
                        0
                        ],
                        r
                            .args[
                        1
                        ]
                        ])
            }
        },
        tdist: {
            pdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "tpdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            cdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "tcdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            mean: function (e, t,
                n) {
                return e
                    .Constant(
                        0)
            },
            median: function (e,
                t, n) {
                return e
                    .Constant(
                        0)
            },
            stdev: function (e,
                t, n) {
                return e
                    .SyntheticNativeFunction(
                        "sqrt",
                        [Ko.tdist
                            .var(
                                e,
                                t,
                                n
                            )
                        ])
            },
            var: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t),
                    i = e
                        .Constant(
                            2),
                    s = r
                        .args[
                        0];
                return e
                    .Piecewise(
                        [e.GreaterEqual(
                            [s,
                                i]
                        ),
                        e
                            .Divide(
                                [s, e
                                    .Subtract(
                                        [s,
                                            i]
                                    )
                                ]
                            ),
                        e
                            .Constant(
                                NaN
                            )
                        ])
            },
            quantile: function (
                e, t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "invT",
                        [n[0],
                        r
                            .args[
                        0
                        ]
                        ])
            },
            random: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "tSample",
                        [n[0],
                        r
                            .args[
                        0
                        ]
                        ])
            }
        },
        poissondist: {
            pdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "poissonpdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            cdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "poissoncdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            mean: function (e, t,
                n) {
                return e
                    .getInstruction(
                        t)
                    .args[0]
            },
            median: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "invPoisson",
                        [e.Constant(
                            .5
                        ),
                        r
                            .args[
                        0
                        ]
                        ])
            },
            stdev: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "sqrt",
                        [r.args[
                            0]]
                    )
            },
            var: function (e, t,
                n) {
                return Ko
                    .poissondist
                    .mean(e,
                        t, n
                    )
            },
            quantile: function (
                e, t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "invPoisson",
                        [n[0],
                        r
                            .args[
                        0
                        ]
                        ])
            },
            random: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "poissonSample",
                        [n[0],
                        r
                            .args[
                        0
                        ]
                        ])
            }
        },
        binomialdist: {
            pdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "binompdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            cdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "binomcdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            mean: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .Multiply(
                        [r.args[
                            0],
                        r
                            .args[
                        1
                        ]
                        ])
            },
            median: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "invBinom",
                        [e.Constant(
                            .5
                        ),
                        r
                            .args[
                        0
                        ],
                        r
                            .args[
                        1
                        ]
                        ])
            },
            stdev: function (e,
                t, n) {
                return e
                    .SyntheticNativeFunction(
                        "sqrt",
                        [Ko.binomialdist
                            .var(
                                e,
                                t,
                                n
                            )
                        ])
            },
            var: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t),
                    [i, s] =
                        r.args;
                return e
                    .Multiply(
                        [i, e
                            .Multiply(
                                [s, e
                                    .Subtract(
                                        [e.Constant(
                                            1
                                        ),
                                            s
                                        ]
                                    )
                                ]
                            )
                        ])
            },
            quantile: function (
                e, t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "invBinom",
                        [n[0],
                        r
                            .args[
                        0
                        ],
                        r
                            .args[
                        1
                        ]
                        ])
            },
            random: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "binomSample",
                        [n[0],
                        r
                            .args[
                        0
                        ],
                        r
                            .args[
                        1
                        ]
                        ])
            }
        },
        uniformdist: {
            pdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "uniformpdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            cdf: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "uniformcdf",
                        n
                            .concat(
                                r
                                    .args
                            )
                    )
            },
            mean: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .Divide(
                        [e.Add([r.args[
                            0],
                        r
                            .args[
                        1
                        ]
                        ]),
                        e
                            .Constant(
                                2
                            )
                        ])
            },
            median: function (e,
                t, n) {
                return Ko
                    .uniformdist
                    .mean(e,
                        t, n
                    )
            },
            stdev: function (e,
                t, n) {
                return e
                    .SyntheticNativeFunction(
                        "sqrt",
                        [Ko.uniformdist
                            .var(
                                e,
                                t,
                                n
                            )
                        ])
            },
            var: function (e, t,
                n) {
                let r = e
                    .getInstruction(
                        t),
                    i = e
                        .Subtract(
                            [r.args[
                                1],
                            r
                                .args[
                            0
                            ]
                            ]);
                return e
                    .Divide(
                        [e.Multiply(
                            [i,
                                i]
                        ),
                        e
                            .Constant(
                                12
                            )
                        ])
            },
            quantile: function (
                e, t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "invUniform",
                        [n[0],
                        r
                            .args[
                        0
                        ],
                        r
                            .args[
                        1
                        ]
                        ])
            },
            random: function (e,
                t, n) {
                let r = e
                    .getInstruction(
                        t);
                return e
                    .SyntheticNativeFunction(
                        "uniformSample",
                        [n[0],
                        r
                            .args[
                        0
                        ],
                        r
                            .args[
                        1
                        ]
                        ])
            }
        }
    };

    function pR(e, t, n) {
        let r = n[0],
            i = e.Constant(0),
            s = e.Constant(1);
        if (zn(e, t) === 0) return e
            .Constant(NaN);
        let a = _r(e, t);
        return e.InboundsListAccess(
            [t, e.Add([e.SyntheticNativeFunction(
                "floor",
                [e.Multiply(
                    [e.SyntheticNativeFunction(
                        "uniformSample",
                        [r, i,
                            s
                        ]
                    ),
                        a
                    ]
                )]
            ),
                s])])
    }

    function nd(e, t, n) {
        if (t === n) return !0;
        if (t < n) return !1;
        let r = [!0];
        for (let s = n + 1; s <=
            t; s++) r.push(!1);
        let i = [t];
        for (; i.length;) {
            let s = i.pop();
            if (r[s - n]) continue;
            r[s - n] = !0;
            let o = e
                .getInstruction(s);
            if (!be(o))
                for (let a of e
                    .getDirectDependencies(
                        o)) {
                    if (a === n)
                        return !0;
                    a < n || r[a -
                        n] || i
                            .push(a)
                }
        }
        return !1
    }
    var Na;

    function fR(e) {
        Na = e
    }

    function dR() {
        Na && (Na.cacheHits += 1)
    }

    function mR() {
        Na && (Na.cacheMisses += 1)
    }

    function yR() {
        Na && (Na.cacheWrites += 1)
    }

    function gR() {
        Na && (Na.cacheReads += 1)
    }

    function xR(e, t, n, r, i) {
        let s = oe(n, pe) || oe(n,
            ce),
            o = oe(i, pe) || oe(i,
                ce);
        if (!s && !o) return;
        let a = bR(e, t, n),
            u = bR(e, r, i),
            c = a.filter(l => u
                .some(p => FE(l,
                    p)) && !!e.lookup(l[
                        0]));
        for (let l of a) hR(e, l,
            r) && c.every(p => !FE(
                l, p)) && c.push(l);
        for (let l of u) hR(e, l,
            t) && c.every(p => !FE(
                l, p)) && c.push(l);
        if (c.length === 1)
            return c[0]
    }

    function FE(e, t) {
        return e[0] === t[0] && e[
            1] === t[1]
    }

    function hR(e, [t, n], r) {
        let i = e.lookup(t),
            s = i && e
                .getGeometryTree(i);
        return ((s == null ?
            void 0 : s
                .symbol) ===
            "glider" || (s ==
                null ? void 0 :
                s.symbol) ===
            "intersection" || (
                s == null ?
                    void 0 : s
                        .symbol) ===
            "strictintersection" ||
            (s == null ?
                void 0 : s
                    .symbol) ===
            "midpoint") && (s ==
                null ? void 0 : s
                    .parents.some(o =>
                        o && e
                            .resolvesTo(o[
                                0], r) && (
                            n ===
                            void 0 || o[
                            1] ===
                            void 0 || o[
                            1] === n
                        )))
    }

    function bR(e, t, n) {
        var s;
        let r = [],
            i = ((s = e
                .getGeometryTree(
                    t)) ==
                null ? void 0 : s
                .parents) || [];
        for (let o = 0; o < i
            .length; o++) {
            let a = i[o];
            if (oe(n, pe) && o ===
                0 || !a) continue;
            let u = e.lookup(a[0]);
            u && e
                .isPointOrListOfPoints(
                    u) && r.push(a)
        }
        return r
    }

    function VE(e, t, n) {
        if (!t) return;
        let r = BE(t, n
            ._expression);
        r === "start-to-end" ? e
            .setCursorContext({
                type: n.type ===
                    "Assignment" ?
                    "assignment-rhs" :
                    "function-definition-body",
                allowedTypes: [
                    Ht
                ]
            }) : r ===
            "empty-list" && e
                .setCursorContext({
                    type: "expression-arguments",
                    expressionType: "List",
                    argIndex: 0,
                    argCount: 0,
                    isLastValidArg:
                        !1,
                    positionWithinArg: "start-to-end",
                    allowedTypesForInsertedArg: [
                        Ht
                    ]
                })
    }

    function PR(e, t, n) {
        if (t) {
            let r = BE(t, n.args[
                1]);
            r === "start-to-end" ? e
                .setCursorContext({
                    type: "for-assignment-rhs",
                    allowedTypes: [
                        Ie,
                        pe,
                        ce,
                        fe,
                        Le,
                        Be,
                        ...
                        Zi
                    ]
                }) : r ===
                "empty-list" && e
                    .setCursorContext({
                        type: "for-assignment-rhs",
                        allowedTypes: [
                            Ht
                        ]
                    })
        }
    }

    function pp(e, t, n, r, i) {
        let s = NG(e, t, n, r, i);
        s && e.setCursorContext(s)
    }

    function BE(e, t) {
        let n = t.getInputSpan();
        return n ? e.start === n
            .start && e.end === n
                .end ? "start-to-end" :
            e.start === e.end && e
                .start === n.end ?
                "end" : e.start === e
                    .end && e.start === n
                        .start ? "start" : e
                            .start === e.end && t
                                .type === "List" && t
                                    .args.length === 0 ?
                    "empty-list" :
                    "not-aligned" :
            "not-aligned"
    }

    function GE(e, t) {
        if (!e) return;
        let n = !1;
        t instanceof xi && t.args[
            1] instanceof cn && (
                n = !0, t = t.args[
                1]);
        let r = t.args;
        if (r) {
            if (r.length === 0) {
                let i = t
                    .getInputSpan();
                if (!i) return;
                let s = Cn(i),
                    o = -1;
                return t.type ===
                    "List" ? o = s
                        .indexOf("[") :
                    (t.type ===
                        "FunctionCall" ||
                        t.type ===
                        "SeededFunctionCall"
                    ) && (o = s
                        .indexOf(
                            "(")),
                    o < 0 ? void 0 :
                        e.start === i
                            .start + o + 1 ?
                            {
                                argIndex: 0,
                                positionWithinArg: "start-to-end",
                                isDotCall: n
                            } : void 0
            }
            for (let i = 0; i < r
                .length; i++) {
                let s = r[i],
                    o = s
                        .getInputSpan();
                if ((o == null ?
                    void 0 : o
                        .input) !==
                    e.input)
                    continue;
                if (e.start < o
                    .start) break;
                let a = BE(e, s);
                if (a !==
                    "not-aligned")
                    return {
                        argIndex: i,
                        positionWithinArg: a,
                        isDotCall: n
                    }
            }
        }
    }

    function NG(e, t, n, r, i) {
        if (!n || !r.args) return;
        let s = GE(n, r);
        if (s === void 0) return;
        s.isDotCall && (r = r.args[
            1]);
        let o = s
            .positionWithinArg ===
            "end" ? s.argIndex + 1 :
            s.argIndex;
        s.isDotCall && (o += 1);
        let a;
        s.positionWithinArg ===
            "empty-list" || s
                .positionWithinArg ===
            "start-to-end" ? a = [
                ...i.slice(0, o),
                void 0, ...i.slice(
                    o + 1)
            ] : r instanceof hr ?
            a = o === 1 ? [i[0],
            void 0, i[1]
            ] : [i[0], i[1],
            void 0] : a = [...i
                .slice(0, o),
            void 0, ...i.slice(
                o)
            ], a = a.map(p => {
                if (!(p ===
                    void 0 ||
                    e
                        .getInstruction(
                            p)
                        .type ===
                    2))
                    return p
            });
        let u = [];
        for (let p of a) u.push(
            p === void 0 ?
                void 0 : e
                    .getInstruction(p)
                    .valueType);
        let c = Jy(t, r, u),
            l = c && Np(c, o);
        if (s.positionWithinArg ===
            "empty-list") {
            let p = l == null ?
                void 0 : l.filter(W)
                    .map(ke);
            return (p == null ?
                void 0 : p
                    .length) === 0 ?
                void 0 : {
                    type: "expression-arguments",
                    expressionType: "List",
                    argIndex: 0,
                    argCount: 0,
                    isLastValidArg:
                        !1,
                    positionWithinArg: "start-to-end",
                    allowedTypesForInsertedArg: p !=
                        null ? p : [
                        Ht
                    ]
                }
        } else {
            if ((l == null ?
                void 0 : l
                    .length) === 0)
                return;
            let p = !1;
            if (c) {
                let g = 0;
                for (let d of c) {
                    let y = Array
                        .isArray(
                            d) ? d
                                .length -
                    1 : 1 / 0;
                    g = Math.max(g,
                        y)
                }
                p = s
                    .positionWithinArg ===
                    "end" && s
                        .argIndex ===
                    g - 1 || s
                        .positionWithinArg ===
                    "start-to-end" &&
                    s.argIndex === g
            }
            let f = r.args.length;
            if (r instanceof hr && r
                .args.length === 3
            ) {
                let g = r.args[2];
                g instanceof Zt && g
                    .isNaN() && (f =
                        2)
            }
            let m = {
                type: "expression-arguments",
                expressionType: r
                    .type,
                argIndex: s
                    .argIndex,
                argCount: f,
                isLastValidArg: p,
                positionWithinArg: s
                    .positionWithinArg,
                allowedTypesForInsertedArg: l !=
                    null ? l : [
                    Ht
                ]
            };
            if (r instanceof cn && (
                m
                    .functionSymbol =
                r._symbol, m
                    .isDotCall = s
                    .isDotCall,
                r instanceof cn &&
                r._symbol ===
                "polygon")) {
                let g = r.args
                    .filter(d => !(
                        d instanceof ze &&
                        d
                            ._symbol ===
                        "cursor"
                    ));
                if (g.length > 0) {
                    let d = g[0]
                        .getInputSpan(),
                        y = g[g
                            .length -
                            1]
                            .getInputSpan();
                    m.polygonVertices =
                        d && y ? {
                            firstLatex: Cn(
                                d
                            ),
                            lastLatex: Cn(
                                y
                            )
                        } : void 0
                }
            }
            return m
        }
    }

    function TR(e) {
        return e.type ===
            "FunctionDefinition"
    }

    function Sg(e) {
        return e.type ===
            "Identifier"
    }

    function Gs(e) {
        return e.type === "Table"
    }

    function rd(e) {
        return e.type === "Image"
    }

    function xo(e) {
        return e.type === "Error"
    }

    function fp(e) {
        return e.type ===
            "Regression"
    }

    function AG(e) {
        let t = Bf({}, {}, -1);
        for (let n = 0; n < e
            .argNames.length; n++)
            xr(t, e.argNames[n], n);
        return t
    }
    var dp = class dp {
        constructor(t, n, r,
            i) {
            if (this.kind =
                t, this
                    .substitutedGlobals = {
                    ...n ==
                        null ?
                        void 0 :
                        n.substitutedGlobals
                }, t && r &&
                i)
                for (let s of
                    i)
                    r[s] &&
                        r[s] !==
                        Wt && !
                        this
                            .substitutedGlobals[
                        s
                        ] &&
                        (this
                            .substitutedGlobals[
                            s
                        ] =
                            t)
        }
        allowsRegressionParameterDependency
            () {
            if (!this.kind)
                return !0;
            for (let t in
                this
                    .substitutedGlobals)
                return !1;
            return !0
        }
        getRegressionDependencyError
            (t) {
            if (this
                .allowsRegressionParameterDependency()
            ) return;
            let [n, r] =
                Object.entries(
                    this
                        .substitutedGlobals
                )[0];
            return aT(n, t,
                r)
        }
        getKind() {
            return this.kind
        }
        getSubstitutedGlobals
            () {
            return this
                .substitutedGlobals
        }
        with(t, n) {
            return new dp(
                "with",
                this, t,
                n)
        }
        for(t, n) {
            return new dp("for",
                this, t, n)
        }
    };
    dp.root = new dp;
    var td = dp,
        zE = class {
            constructor(t, n) {
                this.definitions =
                    t;
                this.baseCases =
                    n;
                this.type =
                    "type-inference";
                this
                    .argTypes = {};
                this
                    .returnTypes = {};
                this
                    .baseCaseTypes = {};
                this
                    .firstValidBaseCaseIdentifiers = {};
                this.stack = [];
                this.isUnconditionallyRecursive = !
                    1
            }
            registerFunctionCall(t,
                n) {
                this.argTypes[
                    t] || (this
                        .argTypes[
                        t] =
                        n)
            }
        };

    function SE(e, t, n, r, i, s,
        o) {
        return {
            policy: e,
            frame: t,
            chunk: n,
            scope: r,
            substitutionContext: i,
            recursiveFunctionContext: s,
            selection: o
        }
    }

    function zs(e, t, n) {
        return {
            ...e,
            frame: t,
            scope: n
        }
    }

    function _g(e) {
        let {
            policy: t,
            frame: n,
            argNames: r,
            argTypes: i,
            selection: s
        } = e, o = new jo({
            argNames: r,
            argTypes: i
        }), a = AG(o);
        return SE(t, n, o, a, td
            .root, void 0, s)
    }

    function mp(e, t) {
        let {
            policy: n,
            frame: r,
            argNames: i,
            argTypes: s,
            selection: o
        } = e, a = vE(r, t), {
            freeDependencies: u,
            updateSymbols: c
        } = a;
        if (i || (i = u), !s) {
            s = [];
            for (let p = 0; p < i
                .length; p++) s
                    .push(T)
        }
        let l = _g({
            policy: n,
            frame: r,
            argNames: i,
            argTypes: s,
            selection: o
        });
        try {
            YC(n, r, t.getScope()),
                Ee(l, t), (e
                    .coerceToNumber ||
                    oe(l.chunk
                        .getReturnType(),
                        Vt)) && Ac(l
                            .chunk, l.chunk
                                .getReturnIndex()
                        ), e
                            .wrapInList && !W(l
                                .chunk
                                .getReturnType()
                            ) && l.chunk
                                .List([l.chunk
                                    .getReturnIndex()
                                ]), l.chunk
                                    .fuseBroadcast(),
                LG(l, t, a), _G(l,
                    t, c)
        } catch (p) {
            let f = p instanceof C ?
                p : J(p);
            f.setCursorContext(l
                .chunk
                .getCursorContext()
            ), l.chunk
                .setError(f)
        }
        return l.chunk
    }

    function _G(e, t, n) {
        if (t.type ===
            "FunctionDefinition")
            for (let i of n) {
                if (t._argSymbols
                    .indexOf(i) !==
                    -1 || t
                        ._symbol === i)
                    throw fm(i);
                if (t._sybmol === i)
                    throw pm(i)
            }
        let r = [];
        for (let i of n) e.frame[
            i] || r.push(i);
        if (r.length) {
            let i = _R(e, r[0])
                .setDependencies(e
                    .chunk.argNames
                    .concat(r));
            throw e.chunk
                .isConstant() && e
                    .chunk
                    .getReturnType() ===
            rt && i
                .setActionValue(e
                    .chunk.asValue()
                ), i
        }
    }

    function LG(e, t, {
        substitutionSymbols: n
    }) {
        if (t.type ===
            "FunctionDefinition")
            for (let i of n) {
                if (t._argSymbols
                    .indexOf(i) !==
                    -1 || t
                        ._symbol === i)
                    throw yf(i);
                if (t._sybmol === i)
                    throw hl(i)
            }
        let r = [];
        for (let i of n) e.frame[
            i] || r.push(i);
        if (r.length) {
            let i = r[0];
            if (e.policy
                .substitutionForbidden(
                    i)) throw gl(i)
        }
    }

    function Ee(e, t) {
        let n;
        if (gR(), VG(e, t)) dR(),
            n = e.chunk
                .copyInstruction(t
                    .__IRCache
                    .instruction);
        else {
            mR();
            let r = e.chunk
                .instructionsLength();
            n = BG(e, t), n = wG(e,
                r, n), FG(e, t,
                    n)
        }
        return e.chunk
            .setReturnIndex(n), n
    }

    function wG(e, t, n) {
        let {
            chunk: r,
            scope: i
        } = e;
        if (n <= t) return n;
        let s = r.getInstruction(n);
        return bt(s) ? (r.truncate(
            Math.max(t, i
                .maxIndex +
                1)), Ls(r,
                    s)) : n
    }

    function FG(e, t, n) {
        let {
            frame: r,
            chunk: i
        } = e, s = i.getInstruction(
            n);
        if (!bt(s)) return;
        let o = $C(r, t);
        o && (yR(), t.__IRCache = {
            keys: o,
            instruction: s
        })
    }

    function VG(e, t) {
        let {
            frame: n,
            substitutionContext: r
        } = e;
        if (!t.__IRCache) return !1;
        let i = t.__IRCache.keys;
        for (let [s, o] of i) {
            let a = n[s];
            if (a !== o || a && a
                .type ===
                "RegressionParameter" &&
                !r
                    .allowsRegressionParameterDependency()
            ) return !1
        }
        return !0
    }

    function BG(e, t) {
        var l, p, f, m;
        let {
            policy: n,
            frame: r,
            chunk: i,
            scope: s,
            substitutionContext: o,
            selection: a
        } = e, u = t.type;
        switch (u) {
            case "Constant": {
                let d = t
                    ._constantValue,
                    y = typeof d ==
                        "boolean" ? ge :
                        T;
                return i
                    .ConstantOfType(
                        y, d)
            }
            case "RegressionParameter":
                return i.Constant(t
                    ._constantNode
                    ._constantValue
                );
            case "MixedNumber":
                return i.Constant(t
                    ._constantValue
                );
            case "Negative":
                return i.Negative(
                    Og(e, t, t
                        .args));
            case "Add":
                return i.Add(ks(e,
                    t, t
                    .args));
            case "Subtract":
                return i.Subtract(
                    ks(e, t, t
                        .args));
            case "Multiply": {
                let d = ks(e, t, t
                    .args);
                if (e.policy
                    .is3dProduct()
                ) {
                    let y = i
                        .getInstruction(
                            d[0])
                        .valueType,
                        h = i
                            .getInstruction(
                                d[1])
                            .valueType;
                    if (oe(y, V) &&
                        oe(h, V))
                        throw Xp([ne(
                            y),
                        ne(
                            h)
                        ]);
                    if (oe(y, R) &&
                        oe(h, R))
                        throw Yp([ne(
                            y),
                        ne(
                            h)
                        ])
                }
                return i.Multiply(d)
            }
            case "DotMultiply": {
                let [d, y] = ks(e,
                    t, t.args);
                return (p = (l = IR(
                    e,
                    d, y
                )) !=
                    null ? l :
                    Da(i, [d,
                        y]) ?
                        IR(e, ai(i,
                            d),
                            ai(i,
                                y), {
                            forcePermitted:
                                !
                                0
                        }) :
                        void 0) !=
                    null ? p : i
                        .Multiply([d,
                            y])
            }
            case "CrossMultiply": {
                let [d, y] = ks(e,
                    t, t.args);
                if (!e.policy
                    .is3dPolicy())
                    return i
                        .Multiply([
                            d, y
                        ]);
                if (Je(i, d, Se) &&
                    Je(i, y, Se))
                    return du(i, [
                        ER(e,
                            ai(i,
                                d
                            ),
                            ai(i,
                                y
                            )
                        ),
                        go(i,
                            d
                        )
                    ]);
                if (Je(i, d, V) &&
                    Je(i, y, V))
                    return ER(e, d,
                        y);
                if (Je(i, d, R) &&
                    Je(i, y, R) ||
                    Je(i, d, T) &&
                    Je(i, y, V) ||
                    Je(i, d, V) &&
                    Je(i, y, T)) {
                    let h = i
                        .getInstruction(
                            d)
                        .valueType,
                        b = i
                            .getInstruction(
                                y)
                            .valueType;
                    throw $p([ne(h),
                    ne(
                        b)
                    ])
                } else return i
                    .Multiply([
                        d, y
                    ])
            }
            case "Divide":
                return i.Divide(ks(
                    e, t, t
                    .args));
            case "Exponent":
                return i.Exponent(
                    ks(e, t, t
                        .args));
            case "Comparator['=']":
            case "Comparator['>']":
            case "Comparator['<']":
            case "Comparator['>=']":
            case "Comparator['<=']":
                return i.Comparator(
                    t.operator,
                    ks(e, t, t
                        .args));
            case "ComparatorChain": {
                let d = Tu(e, t, t
                    .args),
                    y = i
                        .Comparator(t
                            .symbols[0],
                            [d[0], d[1]]
                        );
                for (let h = 1; h <
                    t.symbols
                        .length; h++)
                    y = i.And([y, i
                        .Comparator(
                            t
                                .symbols[
                            h
                            ],
                            [d[h],
                            d[h +
                            1
                            ]
                            ])
                    ]);
                return y
            }
            case "Or":
                return i.Or(ks(e, t,
                    t.args));
            case "PercentOf":
                return i.Divide([i
                    .Multiply(
                        ks(e,
                            t,
                            t
                                .args
                        )
                    ), i
                        .Constant(
                            100)
                ]);
            case "ParenSeq":
                return UG(e, t);
            case "BareSeq":
                return qG(e, t);
            case "NamedCoordinateAccess": {
                let [d] = Og(e, t, t
                    .args), y =
                        t.symbol, h =
                        Je(i, d, V), b;
                switch (y) {
                    case "x":
                        b = 1;
                        break;
                    case "y":
                        b = 2;
                        break;
                    case "z": {
                        if (!h)
                            throw Nr(
                                "."
                            )
                                .allowExport();
                        b = 3;
                        break
                    }
                    default: {
                        let x = y;
                        throw new Error(
                            `Programming Error: unexpected named coordinate: '${x}'.`
                        )
                    }
                }
                return h ? i
                    .OrderedTripleAccess(
                        b, [d]) : i
                            .OrderedPairAccess(
                                b, [d])
            }
            case "Norm": {
                let d = Og(e, t, t
                    .args)[0];
                return (m = (f = HE(
                    e, d
                )) !=
                    null ? f :
                    Da(i, [d]) ?
                        HE(e, ai(i,
                            d)) :
                        void 0) !=
                    null ? m : i
                        .SyntheticNativeFunction(
                            "abs", [d])
            }
            case "UpdateRule": {
                let d = t._symbol;
                var c = r[d];
                if (c !== void 0) {
                    if (c !== Wt &&
                        c.isError)
                        throw c;
                    if (c === Wt ||
                        c.type !==
                        "Assignment" &&
                        c.type !==
                        "Slider")
                        throw _R(e,
                            d)
                }
                let y = Ee(e, t
                    .args[1]);
                return i.Action([d],
                    [y])
            }
            case "List": {
                if (t
                    .getDependencies()
                    .length > 0)
                    return Xr(t
                        .args),
                        i.List(Tu(e,
                            t, t
                            .args
                        ));
                if (t.args
                    .length === 0)
                    return pp(i, n,
                        a, t, []
                    ), i
                        .ConstantOfType(
                            We, []);
                {
                    let d = i
                        .instructionsLength(),
                        y = [],
                        h, b;
                    Xr(t.args);
                    for (let P of t
                        .args) {
                        let M = Ee(
                            e, P
                        ),
                            I = i
                                .getInstruction(
                                    M);
                        if (h ===
                            void 0
                        ) {
                            if (h =
                                I
                                    .valueType,
                                !ei(
                                    h)
                            )
                                throw ec(
                                    [ne(
                                        h)]
                                );
                            b = ar(
                                h)
                        } else if (I
                            .valueType !==
                            h) {
                            if (zr(I.valueType,
                                h
                            ) ||
                                zr(h,
                                    I
                                        .valueType
                                )
                            )
                                return i
                                    .truncate(
                                        d
                                    ),
                                    i
                                        .List(
                                            Tu(e,
                                                t,
                                                t
                                                    .args
                                            )
                                        );
                            throw Jp()
                        }
                        if (I
                            .type !==
                            1) throw new Error(
                                "Programming error: expected list with no dependencies to constant collapse."
                            );
                        y.push(I
                            .value),
                            i
                                .truncate(
                                    d)
                    }
                    let x = GE(e
                        .selection,
                        t);
                    if (e
                        .selection &&
                        x !==
                        void 0 &&
                        b !==
                        void 0 && x
                            .positionWithinArg !==
                        "empty-list"
                    ) {
                        let P = ke(
                            b);
                        i.setCursorContext({
                            type: "expression-arguments",
                            expressionType: "List",
                            argIndex: x
                                .argIndex,
                            argCount: t
                                .args
                                .length,
                            isLastValidArg:
                                !
                                1,
                            positionWithinArg: x
                                .positionWithinArg,
                            allowedTypesForInsertedArg: [
                                P
                            ]
                        })
                    }
                    return i
                        .ConstantOfType(
                            b, y)
                }
            }
            case "ListAccess": {
                let d = Ee(e, t
                    .args[0]),
                    y = i
                        .getInstruction(
                            d);
                if (t.args[1]
                    .type ===
                    "Range" && t
                        .args[1].args[1]
                        .length === 0) {
                    if (!W(y
                        .valueType))
                        throw Zp([ne(y
                            .valueType),
                        ne(
                            T)
                        ]);
                    let h = _r(i,
                        d),
                        b = UE(e,
                            Ee(e, t
                                .args[
                                1
                            ]
                                .args[
                                0
                            ]
                            ), i
                                .List([
                                    h]), {
                            stepMustBePositive:
                                !
                                0
                        });
                    return i
                        .ListAccess(
                            [d, b])
                } else {
                    let h = Ee(e, t
                        .args[1]
                    ),
                        b = i
                            .getInstruction(
                                h);
                    if (lu(i, n, t,
                        [d, h]),
                        b
                            .valueType ===
                        Ln) return i
                            .SyntheticNativeFunction(
                                "select",
                                [d,
                                    h]
                            );
                    if (b
                        .valueType ===
                        ge && W(y
                            .valueType
                        )) {
                        let x = i
                            .ConstantOfType(
                                y
                                    .valueType,
                                []);
                        return i
                            .Piecewise(
                                [h, d,
                                    x
                                ])
                    }
                    return i
                        .ListAccess(
                            [d, h])
                }
            }
            case "Range": {
                let [d, y] = ks(e,
                    t, t.args);
                return UE(e, d, y, {
                    stepMustBePositive:
                        !1
                })
            }
            case "ListComprehension":
                return YG(e, t);
            case "Piecewise": {
                let d = GG(e, t, t
                    .args),
                    y = i
                        .getInstruction(
                            d[0]),
                    h = i
                        .getInstruction(
                            d[1]),
                    b = i
                        .getInstruction(
                            d[2]),
                    x = ro(h
                        .valueType,
                        b.valueType
                    ) || ro(b
                        .valueType,
                        h.valueType
                    );
                if (y.type === 1 &&
                    y.valueType ===
                    ge && x) {
                    let I = d[y
                        .value ?
                        1 : 2],
                        E = i
                            .getInstruction(
                                I),
                        v = h
                            .valueType !==
                            We ? h
                            .valueType :
                            b.valueType;
                    return E
                        .valueType ===
                        We && v !==
                        We ? i
                            .ConstantOfType(
                                v, []) :
                        I
                }
                let P = h.valueType,
                    M = W(P) ? ke(
                        P) : P;
                if (!x && bt(b) && b
                    .valueType ===
                    T && Wi(b
                        .value) && uo(M)
                ) {
                    if (oe(h.valueType,
                        Vt))
                        return i
                            .SyntheticNativeFunction(
                                "restriction",
                                [i.And([d[0],
                                i
                                    .SyntheticNativeFunction(
                                        "restrictionToBoolean",
                                        [d[
                                            1]]
                                    )
                                ])]
                            );
                    let I = i
                        .NanOfType(
                            M);
                    d = [d[0], d[1],
                        I
                    ]
                }
                return i.Piecewise(
                    d)
            }
            case "Restriction":
                return i
                    .SyntheticNativeFunction(
                        "restriction",
                        Og(e, t, t
                            .args));
            case "Ans":
            case "Identifier": {
                let d = t._symbol,
                    y = t
                        ._errorSymbol;
                if (t.type ===
                    "Ans" && i
                        .argNames
                        .indexOf(d) !==
                    -1) throw JP();
                let h = qy(s, d),
                    b = r[d];
                if (h !== void 0 &&
                    (s.symbolMap
                        .hasOwnProperty(
                            d) ||
                        b ===
                        void 0 ||
                        b === Wt))
                    return h;
                if (b === void 0) {
                    if (Ke[d]) {
                        let P = e
                            .policy
                            .is3dPolicy();
                        throw Ke[d]
                            .isFunction ?
                            ms(y,
                                P) : ic(
                                    y)
                    }
                    throw new Error(
                        `Programming Error: reached undefined symbol ${d}`
                    )
                }
                if (b !== Wt && xo(
                    b)) throw b;
                if (b === Wt || b
                    .isFunction)
                    throw Sx(y);
                if (b.type ===
                    "RegressionParameter"
                ) {
                    let P = o
                        .getRegressionDependencyError(
                            y);
                    if (P) throw P
                }
                let x = Ee(e, b);
                return xr(s, d, x,
                    b), x
            }
            case "FunctionCall":
            case "SeededFunctionCall": {
                Xr(t.args);
                let d = Tu(e, t, t
                    .args);
                return Xr(d), Cg(e,
                    t._symbol, t
                    ._errorSymbol,
                    d, t.args)
            }
            case "Substitution":
                return QG(e, t);
            case "FunctionExponent": {
                let d = t.args[0]
                    ._symbol,
                    y = r[d];
                return y !== Wt && (
                    y != null &&
                    y.isFunction
                ) ? Ee(e,
                    new D
                        .Exponent([
                            new D
                                .FunctionCall(
                                    d,
                                    [t.args[
                                        1]]
                                ),
                            t
                                .args[
                            2
                            ]
                        ])) : Ee(e,
                            new D
                                .Multiply([t
                                    .args[
                                    0
                                ],
                                new D
                                    .Exponent(
                                        [t.args[
                                            1],
                                        t
                                            .args[
                                        2
                                        ]
                                        ]
                                    )
                                ]))
            }
            case "FunctionFactorial": {
                let d = t.args[0]
                    ._symbol,
                    y = r[d];
                return y !== Wt && (
                    y != null &&
                    y.isFunction
                ) ? Ee(e,
                    new D
                        .FunctionCall(
                            "\\factorial",
                            [new D
                                .FunctionCall(
                                    d,
                                    [t.args[
                                        1]]
                                )
                            ])) :
                    Ee(e, new D
                        .Multiply([t
                            .args[
                            0
                        ],
                        new D
                            .FunctionCall(
                                "\\factorial",
                                [t.args[
                                    1]]
                            )
                        ]))
            }
            case "DotAccess": {
                let d = t.args[0],
                    y = t.args[1],
                    h = r[y
                        ._symbol];
                if (d.type ===
                    "Identifier" &&
                    d._symbol ===
                    "construction")
                    return KG(e, y);
                if ((y.type ===
                    "Identifier" ||
                    y.type ===
                    "FunctionCall"
                ) && h !==
                    Wt && (h !=
                        null && h
                            .isFunction)
                ) {
                    let b = y
                        ._symbol,
                        x = y
                            ._errorSymbol,
                        P = y
                            .type ===
                            "Identifier" ?
                            [d] : [d]
                                .concat(y
                                    .args),
                        M = Tu(e, t,
                            P);
                    return Cg(e, b,
                        x, M,
                        P, {
                        dotLHSIndex: M[
                            0
                        ]
                    })
                } else if (y
                    .type ===
                    "SeededFunctionCall"
                ) {
                    let b = y
                        ._symbol,
                        x = y
                            ._errorSymbol,
                        P = [y.seed,
                            d
                        ].concat(y
                            .args
                            .slice(
                                1)),
                        M = Tu(e, t,
                            P);
                    return Cg(e, b,
                        x, M,
                        P, {
                        dotLHSIndex: M[
                            1
                        ]
                    })
                } else throw Nr(".")
            }
            case "Seed":
                return i
                    .ConstantOfType(
                        ot, t
                        ._stringValue
                    );
            case "ExtendSeed":
                return i.ExtendSeed(
                    t.tag, ks(e,
                        t, t
                        .args));
            case "Integral": {
                let d = t
                    ._differential
                    ._symbol,
                    y = Object
                        .create(r);
                y[d] = XP(d);
                let h = ts(s),
                    b = zs(e, y, h),
                    x = Ee(b, t
                        .args[1]),
                    P = Ee(b, t
                        .args[2]),
                    M = i
                        .getInstruction(
                            x),
                    I = i
                        .getInstruction(
                            P),
                    E = i
                        .SymbolicVar(T,
                            d),
                    v = ts(s);
                xr(v, d, E);
                let O = Object
                    .create(r);
                O[d] = Wt;
                let A = Ee(zs(e, O,
                    v), t
                        .args[3]);
                if (!nd(i, A, E))
                    return i
                        .Multiply([
                            A, i
                                .Subtract(
                                    [P,
                                        x]
                                )
                        ]);
                let N = Gf(i, [x, P,
                    A
                ]);
                if (N !== void 0 &&
                    nd(i, N, E))
                    throw oT(d);
                let L = N !==
                    void 0 ? i
                        .BeginBroadcast(
                            [N]) :
                    void 0,
                    z = x;
                L !== void 0 && W(M
                    .valueType
                ) && (z =
                    Ma(i, x, L)
                    );
                let G = P;
                L !== void 0 && W(I
                    .valueType
                ) && (G =
                    Ma(i, P, L)
                    );
                let $ = i
                    .getInstruction(
                        A)
                    .valueType,
                    w = W($) ? ke(
                        $) : $,
                    Y;
                if (w === R || w ===
                    V) {
                    let de = [],
                        re = w ===
                            R ? 2 : 3;
                    for (let ie =
                        0; ie <
                        re; ie++) {
                        let Z = i
                            .BeginIntegral({
                                indexSymbol: d
                            }, [z,
                                G
                            ]),
                            Re = Ca(
                                i,
                                Z,
                                E, A
                            ),
                            Ne = i
                                .getInstruction(
                                    Re);
                        L !==
                            void 0 &&
                            W(Ne
                                .valueType) &&
                            (Re =
                                Ma(i,
                                    Re,
                                    L
                                )
                            ),
                            Re =
                            w ===
                                R ? i
                                    .OrderedPairAccess(
                                        ie +
                                        1, [
                                        Re]
                                    ) :
                                i
                                    .OrderedTripleAccess(
                                        ie +
                                        1, [
                                        Re]
                                    );
                        let Te = i
                            .EndIntegral(
                                [Z,
                                    Re]
                            );
                        de.push(i
                            .BlockVar(
                                T,
                                [
                                    Te]
                            )
                        )
                    }
                    Y = w === R ? i
                        .OrderedPair(
                            de) : i
                                .OrderedTriple(
                                    de)
                } else {
                    let de = i
                        .BeginIntegral({
                            indexSymbol: d
                        }, [z,
                            G]),
                        re = Ca(i,
                            de, E, A
                        ),
                        ie = i
                            .getInstruction(
                                re);
                    L !== void 0 &&
                        W(ie
                            .valueType) &&
                        (re = Ma(i,
                            re,
                            L));
                    let Z = i
                        .EndIntegral(
                            [de, re]
                        );
                    Y = i.BlockVar(
                        T, [Z])
                }
                if (L !== void 0) {
                    let de = i
                        .EndBroadcast(
                            [L, Y]);
                    return i
                        .BroadcastResult(
                            ar(w), [
                            de
                        ])
                } else return Y
            }
            case "Sum":
            case "Product": {
                let d = t._index
                    ._symbol,
                    y = t.type ===
                        "Sum",
                    h = Object
                        .create(r);
                h[d] = y ? VP(d) :
                    BP(d);
                let b = ts(s),
                    x = zs(e, h, b),
                    P = Ee(x, t
                        .args[1]);
                P = Ac(x.chunk, P);
                let M = Ee(x, t
                    .args[2]);
                if (M = Ac(x.chunk,
                    M), !Je(i,
                        P, T)) {
                    let K = Dc(i, [
                        P]);
                    throw y ? wb(
                        K) : Bb(K)
                }
                if (!Je(i, M, T)) {
                    let K = Dc(i, [
                        M]);
                    throw y ? Fb(
                        K) : Gb(K)
                }
                let I = i
                    .SyntheticNativeFunction(
                        "round", [P]
                    ),
                    E = i
                        .SyntheticNativeFunction(
                            "round", [M]
                        ),
                    v = i
                        .getInstruction(
                            I),
                    O = i
                        .getInstruction(
                            E);
                if (v.type === 1 &&
                    v.valueType ===
                    T && !isFinite(
                        q(v.value)))
                    throw y ? um() :
                        cm();
                if (O.type === 1 &&
                    O.valueType ===
                    T && !isFinite(
                        q(O.value)))
                    throw y ? um() :
                        cm();
                let A = i
                    .SymbolicVar(T,
                        d),
                    N = ts(s);
                xr(N, d, A);
                let L = Object
                    .create(r);
                L[d] = Wt;
                let z = Ee(zs(e, L,
                    N), t
                        .args[3]),
                    G = i
                        .getInstruction(
                            z)
                        .valueType,
                    $ = W(G) ? ke(
                        G) : G,
                    Y = (t.type ===
                        "Sum" ? Bh :
                        [T]).find(
                            K => zr($,
                                K));
                if (Y === void 0) {
                    let K = Dc(i, [
                        z]);
                    throw y ? Vb(
                        K) : kb(K)
                }
                if (!nd(i, z, A)) {
                    let K = i.Add([i
                        .Subtract(
                            [E,
                                I]
                        ),
                    i
                        .Constant(
                            1
                        )
                    ]);
                    K = i
                        .SyntheticNativeFunction(
                            "max", [
                            K, i
                                .Constant(
                                    0
                                )
                        ]);
                    let _e = y ? i
                        .Multiply([
                            z, K
                        ]) : i
                            .Exponent([
                                z, K
                            ]);
                    return i
                        .Piecewise([
                            i
                                .Less(
                                    [K, i
                                        .Constant(
                                            1 /
                                            0
                                        )
                                    ]
                                ),
                            _e,
                            i
                                .NanOfType(
                                    Y
                                )
                        ])
                }
                let de = Gf(i, [I,
                    E, z
                ]);
                if (de !== void 0 &&
                    nd(i, de, A))
                    throw y ? iT(
                        d) : sT(d);
                let re = de !==
                    void 0 ? i
                        .BeginBroadcast(
                            [de]) :
                    void 0,
                    ie = I;
                re !== void 0 && W(v
                    .valueType
                ) && (ie =
                    Ma(i, I, re)
                    );
                let Z = E;
                re != null && W(O
                    .valueType
                ) && (Z =
                    Ma(i, E, re)
                    );
                let Re = i.Constant(
                    y ? 0 : 1),
                    Ne = Y === R ? i
                        .OrderedPair([
                            Re, Re
                        ]) : Y === V ? i
                            .OrderedTriple([
                                Re, Re,
                                Re
                            ]) : Re,
                    Te = i
                        .BeginLoop({
                            type: y ?
                                "sum" :
                                "product",
                            indexSymbol: d
                        }, [ie, Z,
                            Ne
                        ]),
                    Me = i.BlockVar(
                        Y, [Te]),
                    ve = Ca(i, Te,
                        A, z),
                    Q = i
                        .getInstruction(
                            ve);
                re !== void 0 && W(Q
                    .valueType
                ) && (ve =
                    Ma(i, ve,
                        re));
                let U = y ? i.Add([
                    Me, ve
                ]) : i.Multiply(
                    [Me, ve]),
                    xe = i.EndLoop([
                        Te, U
                    ]),
                    le = i.BlockVar(
                        Y, [xe]);
                if (re !== void 0) {
                    let K = i
                        .EndBroadcast(
                            [re, le]
                        );
                    return i
                        .BroadcastResult(
                            ar(Y), [
                            K
                        ])
                } else return le
            }
            case "Derivative": {
                let d = t._symbol,
                    y = Ee(e, new D
                        .Identifier(
                            d));
                if (!Je(i, y, T))
                    throw $b(d, Dc(
                        i, [
                        y]
                    ));
                let h = i
                    .getInstruction(
                        y),
                    b, x, P = !1;
                if ((h.type === 2 ||
                    h.type === 3
                ) && h
                    .valueType === T
                ) b = e, x = y;
                else {
                    let v = ts(s);
                    x = i
                        .SymbolicVar(
                            h
                                .valueType
                        ), xr(v,
                            d, x),
                        P = !0;
                    let O = Object
                        .create(r);
                    O[d] = Wt, b =
                        zs(e, O, v)
                }
                let M = 1;
                for (; t.args[0]
                    .type ===
                    "Derivative" &&
                    t.args[0]
                        ._symbol === t
                        ._symbol;) M +=
                            1, t = t.args[
                            0];
                let E = Tr(i, Ee(b,
                    t.args[
                    0]));
                for (let v = 0; v <
                    M; v++) E = lp(
                        i, E, x);
                return x === y ? E :
                    (P && delete i
                        .derivativeMaps[
                        x], Ca(
                            i, y, x,
                            E))
            }
            case "Prime": {
                let d = t.args[0],
                    y = r[d
                        ._symbol];
                if (!y) throw Im(d
                    ._symbol
                );
                if (y === Wt || !y
                    .isFunction)
                    throw Ox(d
                        ._symbol
                    );
                let h = Ee(e, d
                    .args[0]),
                    b = i
                        .getInstruction(
                            h),
                    x = !1,
                    P;
                (b.type === 2 || b
                    .type === 3) &&
                    b.valueType === T ?
                    P = h : (P = i
                        .SymbolicVar(
                            b
                                .valueType
                        ), x = !
                        0);
                let M, I;
                if (d._symbol ===
                    "logbase") {
                    if (d.args
                        .length !==
                        2)
                        throw nc();
                    M = [P, Ee(e, d
                        .args[
                        1
                    ]
                    )],
                        I = [d.args[
                            0],
                        d.args[
                        1]
                        ]
                } else {
                    if (d.args
                        .length !==
                        1)
                        throw nc();
                    M = [P], I = [d
                        .args[0]
                    ]
                }
                let v = Tr(i, Cg(e,
                    d
                        ._symbol,
                    d
                        ._errorSymbol,
                    M, I));
                for (let O = 0; O <
                    t.order; O++)
                    v = lp(i, v, P);
                return P === h ? v :
                    (x && delete i
                        .derivativeMaps[
                        P], Ca(
                            i, h, P,
                            v))
            }
            case "Slider":
                return e.chunk
                    .Constant(t
                        .getConcreteTree(
                            n, r)
                        .asCompilerValue()
                    );
            case "Assignment":
                return VE(i, e
                    .selection,
                    t), Ee(e, t
                        ._expression
                    );
            case "CoordinateEquation":
                return Ee(e, t
                    ._expression
                );
            case "FunctionDefinition": {
                let d = t;
                return VE(i, e
                    .selection,
                    d), d
                        .recursionInfo ?
                        wR(e, d, d
                            .recursionInfo
                        ) : Ee(e, t
                            ._expression
                        )
            }
            case "RecursiveFunctionBaseCase":
                return Ee(e, t
                    ._expression
                );
            case "Construction":
                throw Nr(
                    "construction"
                );
            default:
                let g = u;
                throw new Error(
                    `Programming error, unimplemented node type ${g}`
                )
        }
    }

    function Og(e, t, n) {
        let r = [Ee(e, n[0])];
        return pp(e.chunk, e.policy,
            e.selection, t, r),
            lu(e.chunk, e.policy, t,
                r), r
    }

    function ks(e, t, n) {
        let r = [Ee(e, n[0]), Ee(e,
            n[1])];
        return pp(e.chunk, e.policy,
            e.selection, t, r),
            lu(e.chunk, e.policy, t,
                r), r
    }

    function HE(e, t) {
        let n = e.chunk;
        return Je(n, t, V) ? n
            .SyntheticNativeFunction(
                "hypot", [n
                    .OrderedTripleAccess(
                        1, [t]), n
                            .SyntheticNativeFunction(
                                "hypot", [n
                                    .OrderedTripleAccess(
                                        2, [
                                        t]
                                    ), n
                                        .OrderedTripleAccess(
                                            3, [
                                            t]
                                        )
                            ])
            ]) : Je(n, t, R) ? n
                .SyntheticNativeFunction(
                    "hypot", [n
                        .OrderedPairAccess(
                            1, [t]), n
                                .OrderedPairAccess(
                                    2, [t])
                ]) : void 0
    }

    function IR(e, t, n, {
        forcePermitted: r
    } = {
            forcePermitted: !1
        }) {
        let i = e.chunk;
        return (r || e.policy
            .is3dProduct()) &&
            Je(i, t, R) && Je(i, n,
                R) ? i.Add([i
                    .Multiply([i
                        .OrderedPairAccess(
                            1, [
                            t]
                        ), i
                            .OrderedPairAccess(
                                1, [
                                n]
                            )
                    ]), i.Multiply([
                        i
                            .OrderedPairAccess(
                                2, [
                                t]
                            ), i
                                .OrderedPairAccess(
                                    2, [
                                    n]
                                )
                    ])
                ]) : (r || e.policy
                    .is3dProduct()) &&
                    Je(i, t, V) && Je(i, n,
                        V) ? i.Add([i.Add([i
                            .Multiply(
                                [i.OrderedTripleAccess(
                                    1,
                                    [
                                        t]
                                ),
                                i
                                    .OrderedTripleAccess(
                                        1,
                                        [
                                            n]
                                    )
                                ]),
                        i
                            .Multiply(
                                [i.OrderedTripleAccess(
                                    2,
                                    [
                                        t]
                                ),
                                i
                                    .OrderedTripleAccess(
                                        2,
                                        [
                                            n]
                                    )
                                ])
                        ]), i.Multiply([
                            i
                                .OrderedTripleAccess(
                                    3, [
                                    t]
                                ), i
                                    .OrderedTripleAccess(
                                        3, [
                                        n]
                                    )
                        ])]) : void 0
    }

    function ER(e, t, n) {
        let r = e.chunk,
            i = r
                .OrderedTripleAccess(1,
                    [t]),
            s = r
                .OrderedTripleAccess(2,
                    [t]),
            o = r
                .OrderedTripleAccess(3,
                    [t]),
            a = r
                .OrderedTripleAccess(1,
                    [n]),
            u = r
                .OrderedTripleAccess(2,
                    [n]),
            c = r
                .OrderedTripleAccess(3,
                    [n]);
        return r.OrderedTriple([r
            .Subtract([r
                .Multiply(
                    [s,
                        c]
                ), r
                    .Multiply(
                        [o,
                            u]
                    )
            ]), r.Subtract([
                r
                    .Multiply(
                        [o,
                            a]
                    ), r
                        .Multiply(
                            [i,
                                c]
                        )
            ]), r.Subtract([
                r
                    .Multiply(
                        [i,
                            u]
                    ), r
                        .Multiply(
                            [s,
                                a]
                        )
            ])
        ])
    }

    function GG(e, t, n) {
        let r = [Ee(e, n[0]), Ee(e,
            n[1]), Ee(e, n[
                2])];
        return pp(e.chunk, e.policy,
            e.selection, t, r),
            lu(e.chunk, e.policy, t,
                r), r
    }

    function Tu(e, t, n) {
        let r = [];
        for (let i of n) r.push(Ee(
            e, i));
        return pp(e.chunk, e.policy,
            e.selection, t, r),
            lu(e.chunk, e.policy, t,
                r), r
    }

    function Cg(e, t, n, r, i, s) {
        let {
            frame: o,
            chunk: a,
            scope: u,
            recursiveFunctionContext: c
        } = e;
        if (c && c.type ===
            "type-inference" && c
                .definitions[t]) {
            c.registerFunctionCall(
                t, r.map(g => a
                    .getInstruction(
                        g)
                    .valueType));
            let f = c.definitions[
                t];
            if (f instanceof C)
                throw f;
            let m = VR(e, c, f, r);
            return a.SymbolicVar(m
                .returnType)
        }
        let l = qy(u, t);
        if (l !== void 0) {
            let f = a
                .getInstruction(l);
            if (f.type === 4) {
                if (f.signature
                    .argTypes
                    .length !== r
                        .length)
                    throw ds(t, f
                        .signature
                        .argTypes
                        .length,
                        r.length
                    );
                for (let m = 0; m <
                    r.length; m++) {
                    let g = a
                        .getInstruction(
                            r[m])
                        .valueType,
                        d = f
                            .signature
                            .argTypes[
                            m];
                    if (!oe(g, d))
                        throw gb(m,
                            on(
                                d),
                            on(
                                g)
                        )
                }
                return a
                    .FunctionCall([
                        l, ...r
                    ])
            } else if (oe(f
                .valueType, Ue))
                return Ag(e.chunk, [
                    l, ...r
                ], n, !0);
            if (r.length >= 1) {
                let m = r.length ===
                    1 ? r[0] : Ee(e,
                        new D
                            .ParenSeq(i)
                    );
                return a.Multiply([
                    l, m
                ])
            } else throw f.type ===
                2 ? Im(n) : f
                    .valueType ===
                    St ? _m(n) : Am(
                        n)
        }
        let p = o[t];
        if (p !== Wt && (p !=
            null && p.isError))
            throw p;
        if (p === void 0 || p ===
            Wt || !p.isFunction) {
            if (Ke[t] && Ke[t]
                .isFunction) {
                if (t ===
                    "logbase" && o
                        .ln && o.log)
                    throw QP();
                let f = e.policy
                    .is3dPolicy();
                throw ms(n, f)
            }
            if (p && p !== Wt) {
                let f = Ee(e, p);
                if (a
                    .getInstruction(
                        f)
                    .valueType ===
                    St) throw _m(n);
                if (oe(a.getInstruction(
                    f)
                    .valueType,
                    Ue))
                    return Ag(e
                        .chunk,
                        [f, ...
                            r],
                        n, !0)
            }
            if (r.length >= 1) {
                let f = r.length ===
                    1 ? r[0] : Ee(e,
                        new D
                            .ParenSeq(i)
                    );
                return a.Multiply([
                    Ee(e,
                        new D
                            .Identifier(
                                t
                            )
                    ), f
                ])
            }
            throw p ? Am(n) :
                new Error(
                    `Programming Error: reached undefined symbol ${t}`
                )
        }
        if (TR(p)) {
            if (s && s
                .dotLHSIndex !==
                void 0) throw Wp(n);
            if (r.length !== p
                ._argSymbols.length)
                throw ds(n, p
                    ._argSymbols
                    .length, r
                    .length);
            let f = ts(u),
                m = Object.create(
                    o);
            for (let d = 0; d < p
                ._argSymbols
                .length; d++) xr(f,
                    p._argSymbols[
                    d], r[d], i[d]),
                    m[p._argSymbols[
                    d]] = Wt;
            let g = zs(e, m, f);
            return p.recursionInfo ?
                wR(g, p, p
                    .recursionInfo
                ) : Ee(g, p
                    ._expression)
        } else {
            if (oo.hasOwnProperty(
                t)) return HG(e, t,
                    n, r, i, s);
            if (bn.hasOwnProperty(
                t)) return Rg(e, t,
                    n, r, s);
            {
                let f = e.policy
                    .is3dPolicy();
                throw ms(n, f)
            }
        }
    }

    function kG(e, t) {
        let n = go(e, t),
            r = e.Add([n, ai(e,
                t)]);
        return e
            .SyntheticNativeFunction(
                "segment", [n, r])
    }

    function Rg(e, t, n, r, i) {
        let {
            chunk: s
        } = e, o = bn[t], a = !!(
            i && i
                .dotLHSIndex !==
            void 0), u = r
                .length, {
                    minArity: c,
                    maxArity: l
                } = o;
        if (u > l || u < c) throw J(
            "Unexpected arity mismatch"
        );
        let p = RR(s, r, o),
            f = {
                errorSymbol: n,
                providedArity: u,
                isDotCall: a
            };
        switch (o.tag) {
            case "default":
            case "reducer":
            case "doubleReducer":
            case "parameterizedReducer":
            case "color":
            case "never-broadcast":
                return s
                    .NativeFunction(
                        t, f, p);
            case "trig": {
                let m = Ee(e, new D
                    .Identifier(
                        "trigAngleMultiplier"
                    )),
                    g = s.Multiply([
                        p[0], m
                    ]);
                return s
                    .NativeFunction(
                        t, f, [g])
            }
            case "trig2": {
                let m = Ee(e, new D
                    .Identifier(
                        "trigAngleMultiplier"
                    )),
                    g = s.Multiply([
                        p[1], m
                    ]);
                return s
                    .NativeFunction(
                        t, f, [p[0],
                        g
                    ])
            }
            case "inverseTrig": {
                let m = Ee(e, new D
                    .Identifier(
                        "trigAngleMultiplier"
                    )),
                    g = s
                        .NativeFunction(
                            t, f, p);
                return s.Divide([g,
                    m
                ])
            }
            default: {
                let m = o.tag;
                throw new Error(
                    `Programming Error: unexpected tag ${m}`
                )
            }
        }
    }

    function RR(e, t, {
        minArity: n,
        defaultArguments: r
    }) {
        if (!r || !(t.length - n < r
            .length)) return t;
        let i = t.slice();
        for (; i.length - n < r
            .length;) i.push(e
                .copyInstruction(r[i
                    .length - n
                ]));
        return i
    }

    function zG(e, t, {
        match: n,
        noBroadcast: r
    }) {
        let i = [r ? n : ti(n)];
        return Qy(i, t.map(s => e
            .getInstruction(
                s).valueType
        ), 0).length > 0
    }

    function mu(e, t, n, r) {
        let i = r.find(s => zG(e, t,
            s));
        if (!i) {
            if (typeof n ==
                "string") throw Pi(
                    n, Zo(e, t));
            return n(e, t)
        }
        return i.build(e, t)
    }

    function MR(e, t) {
        if (t.length !== 2) throw J(
            "Can only take the midpoint of two points"
        );
        let n = e.Constant(De(1,
            2));
        return e.Multiply([n, e.Add(
            t)])
    }

    function HG(e, t, n, r, i, s) {
        let {
            chunk: o,
            policy: a
        } = e, u = oo[t];
        if (u
            .fallthroughUnlessDistribution &&
            u
                .fallthroughUnlessDistribution &&
            !SR(o, r)) return Rg(e,
                t, n, r, s);
        let {
            minArity: c,
            maxArity: l
        } = u, p = r.length;
        if (p < c || p > l)
            throw new Error(
                "Programming Error: unexpected arity mismatch"
            );
        let f;
        if (t === "cdf") p === 2 ?
            f = [r[0], o.Constant(-
                1 / 0), r[1]] : f =
            r;
        else if (t === "random")
            if (p === 1 || p < 4 &&
                !W(o.getInstruction(
                    r[1])
                    .valueType) && o
                        .getInstruction(r[
                            1])
                        .valueType !== St) {
                let d = o
                    .Distribution(
                        "uniformdist",
                        [o.Constant(
                            0),
                        o
                            .Constant(
                                1)
                        ]);
                f = [r[0], d]
                    .concat(r.slice(
                        1))
            } else f = r;
        else f = RR(o, r, u);
        let m = Vp(t);
        if (m) {
            let d = RE(o, f, m);
            d.didCoerce && (f = d
                .args)
        }

        function g(d, y = n) {
            return mu(o, f, y, d)
        }
        switch (t) {
            case "length":
                if (a
                    .isGeometryEnabled() ||
                    a.is3dPolicy()
                ) {
                    let d = f[0],
                        y = a
                            .is3dPolicy() ?
                            _b : Ab;
                    return g([{
                        match: [
                            We],
                        build: () => {
                            throw y(n,
                                Zo(o,
                                    f
                                )[
                                0
                                ]
                            )
                        }
                    }, {
                        match: [
                            Nt],
                        build: () => {
                            let h =
                                o
                                    .Constant(
                                        0
                                    ),
                                b =
                                    o
                                        .Constant(
                                            1
                                        );
                            return o
                                .SyntheticNativeFunction(
                                    "distanceThreeD",
                                    [o.SyntheticNativeFunction(
                                        "segmentThreeDGlider",
                                        [d,
                                            h]
                                    ),
                                    o
                                        .SyntheticNativeFunction(
                                            "segmentThreeDGlider",
                                            [d,
                                                b]
                                        )
                                    ]
                                )
                        }
                    }, {
                        match: [
                            Ie],
                        build: () => {
                            let h =
                                o
                                    .Constant(
                                        0
                                    ),
                                b =
                                    o
                                        .Constant(
                                            1
                                        );
                            return o
                                .SyntheticNativeFunction(
                                    "distance",
                                    [o.SyntheticNativeFunction(
                                        "segmentGlider",
                                        [d,
                                            h]
                                    ),
                                    o
                                        .SyntheticNativeFunction(
                                            "segmentGlider",
                                            [d,
                                                b]
                                        )
                                    ]
                                )
                        }
                    }, {
                        match: [
                            ce],
                        build: () => {
                            let h =
                                o
                                    .SyntheticNativeFunction(
                                        "abs",
                                        [o.SyntheticNativeFunction(
                                            "arcOmega",
                                            [f[
                                                0]]
                                        )]
                                    ),
                                {
                                    radius: b,
                                    startPoint: x
                                } =
                                    LR(o,
                                        f[
                                        0]
                                    ),
                                P =
                                    o
                                        .SyntheticNativeFunction(
                                            "arcGlider",
                                            [f[0],
                                            o
                                                .Constant(
                                                    1
                                                )
                                            ]
                                        );
                            return o
                                .Piecewise(
                                    [o.Equal(
                                        [h, o
                                            .Constant(
                                                0
                                            )
                                        ]
                                    ),
                                    o
                                        .SyntheticNativeFunction(
                                            "distance",
                                            [x,
                                                P]
                                        ),
                                    o
                                        .Multiply(
                                            [b,
                                                h]
                                        )
                                    ]
                                )
                        }
                    }, {
                        match: [
                            Gh],
                        build: () =>
                            HE(e,
                                ai(o,
                                    d
                                )
                            )
                    }, {
                        match: [
                            sn],
                        noBroadcast:
                            !
                            0,
                        build: () => {
                            throw y(n,
                                Zo(o,
                                    f
                                )[
                                0
                                ]
                            )
                        }
                    }])
                } else return o
                    .SyntheticNativeFunction(
                        "count",
                        f);
            case "round":
                return g([{
                    match: [
                        T],
                    build: () =>
                        o
                            .SyntheticNativeFunction(
                                "round",
                                f
                            )
                }, {
                    match: [T,
                        T
                    ],
                    build: () => {
                        let d =
                            o
                                .SyntheticNativeFunction(
                                    "round",
                                    [f[
                                        1]]
                                ),
                            y =
                                o
                                    .RawExponent(
                                        [o.Constant(
                                            10
                                        ),
                                            d
                                        ]
                                    );
                        return o
                            .Divide(
                                [o.SyntheticNativeFunction(
                                    "round",
                                    [o.Multiply(
                                        [f[0],
                                            y
                                        ]
                                    )]
                                ),
                                    y
                                ]
                            )
                    }
                }]);
            case "midpoint":
                return g([{
                    match: [
                        Ie],
                    build: () => {
                        let d =
                            o
                                .Constant(
                                    De(1,
                                        2
                                    )
                                );
                        return o
                            .SyntheticNativeFunction(
                                "segmentGlider",
                                [f[0],
                                    d
                                ]
                            )
                    }
                }, {
                    match: [
                        Nt],
                    build: () => {
                        let d =
                            o
                                .Constant(
                                    De(1,
                                        2
                                    )
                                );
                        return o
                            .SyntheticNativeFunction(
                                "segmentThreeDGlider",
                                [f[0],
                                    d
                                ]
                            )
                    }
                }, {
                    match: [R,
                        R
                    ],
                    build: MR
                }, {
                    match: [V,
                        V
                    ],
                    build: MR
                }]);
            case "circle":
                return g([{
                    match: [R,
                        Ie
                    ],
                    build: () => {
                        let d =
                            o
                                .Constant(
                                    0
                                ),
                            y =
                                o
                                    .Constant(
                                        1
                                    );
                        return o
                            .SyntheticNativeFunction(
                                "circle",
                                [f[0],
                                o
                                    .SyntheticNativeFunction(
                                        "distance",
                                        [o.SyntheticNativeFunction(
                                            "segmentGlider",
                                            [f[1],
                                                d
                                            ]
                                        ),
                                        o
                                            .SyntheticNativeFunction(
                                                "segmentGlider",
                                                [f[1],
                                                    y
                                                ]
                                            )
                                        ]
                                    )
                                ]
                            )
                    }
                }, {
                    match: [R,
                        R
                    ],
                    build: () =>
                        o
                            .SyntheticNativeFunction(
                                "circle",
                                [f[0],
                                o
                                    .SyntheticNativeFunction(
                                        "distance",
                                        f
                                    )
                                ]
                            )
                }, {
                    match: [R,
                        T
                    ],
                    build: () =>
                        o
                            .SyntheticNativeFunction(
                                "circle",
                                f
                            )
                }]);
            case "segment":
                return g(qf("segment",
                    "segmentThreeD"
                ));
            case "vector":
                return g(qf("vector",
                    "vectorThreeD"
                ));
            case "distance":
                return g(qf("distance",
                    "distanceThreeD"
                ));
            case "center":
            case "radius":
                return g([{
                    match: [{
                        meta: "union",
                        types: [pe,
                            ce
                        ]
                    }],
                    build: () => {
                        let d =
                            XG(o,
                                f[
                                0]
                            );
                        return o
                            .SyntheticNativeFunction(
                                t,
                                [
                                    d]
                            )
                    }
                }]);
            case "glider":
                return NR(e.chunk,
                    f);
            case "intersection":
            case "strictintersection": {
                let d = 0;
                t ===
                    "strictintersection" &&
                    ((Je(o, f[0],
                        Ie) ||
                        Je(o, f[
                            0],
                            ce)
                    ) && (
                            d += 3),
                        (Je(o, f[1],
                            Ie
                        ) ||
                            Je(o, f[
                                1],
                                ce)
                        ) && (
                            d += 12)
                    ), Je(o, f[
                        0], Le) && (
                        d += 1), Je(
                            o, f[1], Le
                        ) && (d +=
                            4);
                let y = JG(e, i, f);
                if (!y) return kE(o,
                    f, d);
                let h = Ee(e, new D
                    .Identifier(
                        y[0]));
                return y[1] !==
                    void 0 && (h = o
                        .ListAccess(
                            [h, o
                                .Constant(
                                    y[
                                    1]
                                )
                            ])), o
                                .SyntheticNativeFunction(
                                    "chooseNonIncidentPoint",
                                    [h, kE(o, [f[
                                        0],
                                    f[
                                    1]
                                    ],
                                        d),
                                        kE(o, [f[
                                            1],
                                        f[
                                        0]
                                        ],
                                            d <<
                                            2 &
                                            12 |
                                            d >>
                                            2 &
                                            3)
                                    ])
            }
            case "parallel":
            case "perpendicular":
                return g([{
                    match: [{
                        meta: "union",
                        types: _d
                    },
                        R
                    ],
                    build: () => {
                        let y = [
                            Ng(o,
                                f[
                                0]
                            ),
                            f[
                            1]
                        ];
                        return o
                            .SyntheticNativeFunction(
                                t,
                                y
                            )
                    }
                }]);
            case "start":
                return go(o, f[0]);
            case "end":
                return o.Add([go(o,
                    f[0]
                ),
                ai(o, f[
                    0])
                ]);
            case "translate":
            case "reflect":
            case "rotate":
            case "dilate":
                return ZG(e, t, f);
            case "apply":
                return Ag(o, f, n, !
                    1);
            case "normaldist":
            case "tdist":
            case "poissondist":
            case "binomialdist":
            case "uniformdist":
                return o
                    .Distribution(t,
                        f);
            case "pdf":
            case "cdf":
            case "median":
            case "stdev":
            case "var":
            case "quantile":
                return DR(o, f, t);
            case "total":
            case "mean":
                return t ===
                    "mean" && SR(o,
                        r) ? DR(o,
                            f, t) : g([{
                                match: {
                                    type: "variadic",
                                    initial: [],
                                    rest: We
                                },
                                build: () =>
                                    Rg(e,
                                        t,
                                        n,
                                        f,
                                        s
                                    )
                            }, {
                                match: {
                                    type: "variadic",
                                    initial: [
                                        R
                                    ],
                                    rest: R
                                },
                                build: () => {
                                    let y =
                                        h =>
                                            o
                                                .SyntheticNativeFunction(
                                                    t,
                                                    f
                                                        .map(
                                                            b =>
                                                                o
                                                                    .OrderedPairAccess(
                                                                        h,
                                                                        [
                                                                            b]
                                                                    )
                                                        )
                                                );
                                    return o
                                        .OrderedPair(
                                            [y(1),
                                            y(
                                                2)
                                            ]
                                        )
                                }
                            }, {
                                match: {
                                    type: "variadic",
                                    initial: [
                                        V
                                    ],
                                    rest: V
                                },
                                build: () => {
                                    let y =
                                        h =>
                                            o
                                                .SyntheticNativeFunction(
                                                    t,
                                                    f
                                                        .map(
                                                            b =>
                                                                o
                                                                    .OrderedTripleAccess(
                                                                        h,
                                                                        [
                                                                            b]
                                                                    )
                                                        )
                                                );
                                    return o
                                        .OrderedTriple(
                                            [y(1),
                                            y(
                                                2),
                                            y(
                                                3)
                                            ]
                                        )
                                }
                            }], () =>
                                Rg(e, t, n,
                                    f, s));
            case "random": {
                let d = f[0],
                    y = f[1],
                    h = o
                        .getInstruction(
                            f[0]),
                    b = o
                        .getInstruction(
                            y);
                if (h.valueType !==
                    ot) throw J(
                        `Unexpected value type for seed arg: ${h.valueType}`
                    );
                if (b.valueType ===
                    wn) throw bx();
                let x;
                if (W(b.valueType))
                    x = pR;
                else {
                    if (b.type !==
                        42 || b
                            .valueType !==
                        St) throw J(
                            'Expected distribution argument to "random"'
                        );
                    x = Ko[b.symbol]
                    [t]
                }
                if (f.length > 2) {
                    let P = f[2],
                        M = o
                            .getInstruction(
                                P);
                    if (M
                        .valueType !==
                        T) throw J(
                            `Expected numSamples argument to random() to be a number but got ${M.valueType}`
                        );
                    if (f.length ===
                        4) {
                        if (o
                            .getInstruction(
                                f[3]
                            )
                            .valueType !==
                            T) throw J(
                                `Expected userSeed argument to random() to be a number but got ${M.valueType}`
                            );
                        d = o
                            .ExtendSeed(
                                "us",
                                [d, f[
                                    3]]
                            )
                    }
                    let I = o
                        .Constant(
                            1),
                        E = o
                            .SyntheticNativeFunction(
                                "round",
                                [o.SyntheticNativeFunction(
                                    "validateSampleCount",
                                    [
                                        P]
                                )]),
                        v = o
                            .BeginBroadcast(
                                [E]);
                    d = o
                        .ExtendSeed(
                            "lc", [
                            d, o
                                .Subtract(
                                    [v,
                                        I]
                                )
                        ]);
                    let O = x(o, y,
                        [d]),
                        A = o
                            .EndBroadcast(
                                [v, O]);
                    return o
                        .BroadcastResult(
                            ar(o.getInstruction(
                                O
                            )
                                .valueType
                            ), [
                            A
                        ])
                }
                return x(o, y, [d])
            }
            case "shuffle": {
                let d = f[0],
                    y = f[1],
                    h = f[2];
                if (!W(o.getInstruction(
                    y)
                    .valueType
                ) || h !==
                void 0 && o
                    .getInstruction(
                        h)
                    .valueType !== T
                ) throw J(
                    `Unexpected args for "${t}"`
                );
                return h !==
                    void 0 && (d = o
                        .ExtendSeed(
                            "us", [
                            d, h
                        ])), o
                            .SyntheticNativeFunction(
                                "shuffle", [
                                d, y
                            ])
            }
            case "sort":
                return g([{
                    match: [
                        se],
                    noBroadcast:
                        !
                        0,
                    build: () =>
                        vR(e,
                            f[
                            0],
                            f[
                            0]
                        )
                }, {
                    match: [{
                        meta: "union",
                        types: Zi
                    },
                        se
                    ],
                    noBroadcast:
                        !
                        0,
                    build: () =>
                        vR(e,
                            f[
                            0],
                            f[
                            1]
                        )
                }]);
            case "join": {
                let d = [],
                    y = !0;
                for (let N of f) {
                    let L = o
                        .getInstruction(
                            N);
                    bt(L) || (y = !
                        1);
                    let z = L
                        .valueType;
                    if (z !== We)
                        if (W(z)) d
                            .push({
                                isList:
                                    !
                                    0,
                                index: N,
                                elementType: ke(
                                    z
                                )
                            });
                        else if (ei(
                            z)) d
                                .push({
                                    isList:
                                        !
                                        1,
                                    index: N,
                                    elementType: z
                                });
                        else throw Pi(n,
                            Zo(o,
                                r
                            )
                        )
                }
                if (d.length === 0)
                    return o
                        .ConstantOfType(
                            We, []);
                for (let N of d)
                    if (N
                        .elementType !==
                        d[0]
                            .elementType
                    ) throw Pi(
                        n,
                        Zo(o,
                            r
                        )
                    );
                if (y) {
                    let N = [];
                    for (let L of
                        d) {
                        let z = o
                            .getInstruction(
                                Tr(o,
                                    L
                                        .index
                                )
                            );
                        Kv(z), L
                            .isList ?
                            N.push(
                                ...z
                                    .value
                            ) :
                            N.push(z
                                .value
                            )
                    }
                    return o
                        .ConstantOfType(
                            ar(d[0]
                                .elementType
                            ), N
                        )
                }
                let h = o.Constant(
                    0),
                    b = o.Constant(
                        1),
                    x = {};
                for (let N of d) N
                    .isList && x[N
                        .index] ===
                    void 0 && (x[N
                        .index
                    ] = _r(
                        o, N
                        .index)
                    );
                let P = o
                    .SyntheticNativeFunction(
                        "total", d
                            .map(N => N
                                .isList ?
                                x[N
                                    .index] :
                                b)),
                    M = o
                        .BeginBroadcast(
                            [P]),
                    I = h,
                    E = [],
                    v = [];
                for (let N of d) {
                    let L = N
                        .isList ? o
                            .ListAccess(
                                [N.index,
                                o
                                    .Subtract(
                                        [M,
                                            I]
                                    )
                                ]) : N
                        .index;
                    if (v.push(L),
                        N !== d[d
                            .length -
                        1]) {
                        let z = N
                            .isList ?
                            x[N
                                .index] :
                            b;
                        I = o.Add([I,
                            z
                        ]), E
                            .push(o
                                .LessEqual(
                                    [M,
                                        I]
                                )
                            )
                    }
                }
                let O = v[v.length -
                    1];
                for (let N = v
                    .length -
                    2; N >=
                    0; N--) O = o
                        .Piecewise([E[
                            N], v[
                        N], O
                        ]);
                let A = o
                    .EndBroadcast([
                        M, O
                    ]);
                return o
                    .BroadcastResult(
                        ar(d[0]
                            .elementType
                        ), [A])
            }
            case "unique": {
                let d = f[0],
                    y = o
                        .getInstruction(
                            d);
                if (!W(y
                    .valueType) || y
                        .valueType ===
                    wn) throw J(
                        `Unexpected types for ${t}`
                    );
                return o
                    .SyntheticNativeFunction(
                        "elementsAt",
                        [d, o
                            .SyntheticNativeFunction(
                                "uniquePerm",
                                [d])
                        ])
            }
            case "polygon":
                return g([{
                    match: [],
                    build: () => {
                        let d =
                            o
                                .ConstantOfType(
                                    Pt,
                                    []
                                );
                        return o
                            .SyntheticNativeFunction(
                                "polygon",
                                [
                                    d]
                            )
                    }
                }, {
                    match: [T,
                        T
                    ],
                    noBroadcast:
                        !
                        0,
                    build: () => {
                        throw Kp()
                    }
                }, {
                    match: [T,
                        T
                    ],
                    build: () => {
                        let d =
                            o
                                .OrderedPair(
                                    f
                                );
                        return o
                            .SyntheticNativeFunction(
                                "polygon",
                                [
                                    d]
                            )
                    }
                }, {
                    match: {
                        type: "variadic",
                        initial: [],
                        rest: R
                    },
                    build: () =>
                        o
                            .SyntheticNativeFunction(
                                "polygon",
                                f
                            )
                }]);
            case "directedangle":
                return OR(e, f, n);
            case "angle":
                return o
                    .SyntheticNativeFunction(
                        "undirectedAngleMarker",
                        [OR(e, f,
                            n)]);
            case "angles":
                return o
                    .SyntheticNativeFunction(
                        "polygonInteriorUndirectedAngles",
                        [f[0], Ee(e,
                            new D
                                .Identifier(
                                    "trigAngleMultiplier"
                                )
                        )]);
            case "directedangles":
                return o
                    .SyntheticNativeFunction(
                        "polygonInteriorDirectedAngles",
                        [f[0], Ee(e,
                            new D
                                .Identifier(
                                    "trigAngleMultiplier"
                                )
                        )]);
            case "coterminal": {
                if (Je(o, f[0], Ae))
                    return o
                        .SyntheticNativeFunction(
                            "directedCoterminalAngle",
                            f);
                if (Je(o, f[0], Ge))
                    return o
                        .SyntheticNativeFunction(
                            "undirectedCoterminalAngle",
                            f);
                throw J(
                    `Unexpected types for ${t}`)
            }
            case "histogram":
            case "dotplot":
            case "boxplot":
            case "ttest":
            case "ittest":
            case "stats":
            case "det":
            case "inv":
            case "transpose":
            case "rref":
            case "trace":
            case "points":
            case "lines":
            case "circles":
            case "polygons":
            case "rays":
            case "arcs":
            case "vectors":
                throw Nr(n);
            default: {
                let d = t;
                throw new Error(
                    `Programming Error: unexpected compiler function ${d}`
                )
            }
        }
    }

    function NR(e, t) {
        return mu(e, t, "glider", [{
            match: [Ie,
                T
            ],
            build: () =>
                e
                    .SyntheticNativeFunction(
                        "segmentGlider",
                        t)
        }, {
            match: [fe,
                T
            ],
            build: () =>
                e
                    .SyntheticNativeFunction(
                        "lineGlider",
                        t)
        }, {
            match: [Le,
                T
            ],
            build: () =>
                e
                    .SyntheticNativeFunction(
                        "rayGlider",
                        t)
        }, {
            match: [pe,
                T
            ],
            build: () =>
                e
                    .SyntheticNativeFunction(
                        "circleGlider",
                        t)
        }, {
            match: [ce,
                T
            ],
            build: () =>
                e
                    .SyntheticNativeFunction(
                        "arcGlider",
                        t)
        }, {
            match: [Be,
                T
            ],
            build: () =>
                e
                    .SyntheticNativeFunction(
                        "polygonGlider",
                        t)
        }])
    }

    function vR(e, t, n) {
        let {
            chunk: r
        } = e;
        if (zn(r, n) === 0)
            return n;
        let s = r
            .SyntheticNativeFunction(
                "min", [_r(r, t),
                _r(r, n)
            ]);
        return n = r.ListAccess([n,
            UE(e, r.List([r
                .Constant(
                    1
                )
            ]), r.List([
                s
            ]), {
                stepMustBePositive:
                    !0
            })
        ]), r
            .SyntheticNativeFunction(
                "elementsAt", [t, r
                    .SyntheticNativeFunction(
                        "sortPerm",
                        [n])
            ])
    }

    function DR(e, t, n) {
        let r = t[0],
            i = e.getInstruction(r);
        if (!oe(i.valueType, St))
            throw J(
                `Unexpected args for "${n}"`);
        let s = t.slice(1);
        for (let o of s)
            if (!oe(e
                .getInstruction(
                    o)
                .valueType, T))
                throw J(
                    `Unexpected args for "${n}"`);
        if (W(i.valueType)) {
            let o = [],
                a = 1 / 0;
            for (let c of t) {
                let l = Tr(e, c);
                o.push(l);
                let p = e
                    .getInstruction(
                        l);
                if (W(p
                    .valueType)) {
                    let f = zn(e,
                        l);
                    if (f ===
                        void 0)
                        throw df(oi(e,
                            l
                        ));
                    a = Math.min(a,
                        f)
                }
            }
            let u = [];
            for (let c = 0; c <
                a; c++) {
                let l = zf(e, o[0],
                    c),
                    p = e
                        .getInstruction(
                            l);
                if (p.type !== 42)
                    throw J(
                        `Unexpected opcode for distribution arg: ${p.type}`);
                let f = [];
                for (let m of o
                    .slice(1))
                    W(e.getInstruction(
                        m)
                        .valueType
                    ) ? f.push(
                        zf(e, m, c)
                    ) : f.push(
                        m);
                u.push(Ko[p.symbol][
                    n
                ](e, l, f))
            }
            return e.List(u)
        } else {
            if (i.type !== 42)
                throw J(
                    `Unexpected opcode for distribution arg: ${i.type}`);
            return Ko[i.symbol][n](
                e, r, s)
        }
    }

    function SR(e, t) {
        return t.length !== 0 && e
            .getInstruction(t[0])
            .valueType !== We && oe(
                e.getInstruction(t[
                    0]).valueType,
                St)
    }

    function UG(e, t) {
        let {
            chunk: n
        } = e;
        Xr(t.args);
        let r = Tu(e, t, t.args),
            i = !1,
            s = !1;
        for (let o = 0; o < r
            .length; o++) {
            let u = n
                .getInstruction(r[
                    o]).valueType;
            i = i || u === rt, s =
                s || u !== rt
        }
        if (i && s) throw J(
            "Unexpected mix of actions and non-actions"
        );
        if (i) return AR(e, r);
        if (r.length === 2) return n
            .OrderedPair(r);
        if (r.length == 3) return n
            .OrderedTriple(r);
        throw J(
            `Unexpected tuple dimensions: ${r.length}`)
    }

    function qG(e, t) {
        let {
            chunk: n
        } = e;
        Xr(t.args);
        let r = Tu(e, t, t.args);
        if (r.length < 1) throw J(
            "Empty bare sequence"
        );
        let i = n.getInstruction(r[
            0]).valueType;
        if (i === T) throw J(
            "Ambiguous bare sequence"
        );
        return i === rt ? AR(e, r) :
            n.List(r)
    }

    function AR(e, t) {
        let {
            chunk: n
        } = e, r = [], i = [];
        for (let o of t) {
            let a = n
                .getInstruction(o);
            switch (a.type) {
                case 49: {
                    Array.prototype
                        .push.apply(
                            r, a
                            .symbols
                        ), Array
                            .prototype
                            .push.apply(
                                i, a
                                .args);
                    break
                }
                case 1: {
                    let c = a.value
                        .updateRules;
                    for (let l in c)
                        r.push(l), i
                            .push(n
                                .ConstantOfType(
                                    c[l]
                                        .valueType,
                                    c[l]
                                        .value
                                ));
                    break
                }
                default: {
                    var s = oi(n,
                        o);
                    throw s.length >
                        0 ? tx(s) :
                        J(
                            `Unexpected opcode for action: ${a.type}`)
                }
            }
        }
        return n.Action(r, i)
    }

    function _R(e, t) {
        var n = e.frame[t];
        return n === Wt ? fm(t) : e
            .policy
            .assignmentForbidden(
                t) ? ex(t) : n && n
                    .type ===
                    "FunctionDefinition" ?
            pm(t) : Kb(t)
                .allowExport()
    }

    function $G(e, t) {
        switch (e.getInstruction(t)
            .valueType) {
            case Ie:
            case pe:
            case ce:
                return [e.Constant(
                    0), e
                        .Constant(1)
                ];
            case fe:
                return [e.Constant(-
                    1 / 0),
                e.Constant(
                    1 / 0)
                ];
            case Le:
                return [e.Constant(
                    0), e
                        .Constant(
                            1 / 0)
                ];
            case Be:
                return [e.Constant(
                    0), e
                        .SyntheticNativeFunction(
                            "count",
                            [e.SyntheticNativeFunction(
                                "vertices",
                                [
                                    t]
                            )])
                ];
            default:
                return
        }
    }

    function YG(e, t) {
        let {
            policy: n,
            frame: r,
            chunk: i,
            scope: s,
            selection: o,
            recursiveFunctionContext: a
        } = e;
        if (!(t instanceof ya))
            throw new Error(
                "Programming error: expected a ListComprehension node but got " +
                t.type);
        let u = t._body,
            c = [],
            l = [],
            p = i.Constant(1),
            f = Object.create(r);
        Xr(t._inputLists);
        for (let {
            _symbol: I
        }
            of t._inputLists) {
            let E = I;
            if (a && r[E]) throw gf(
                E);
            f[E] = tT(E)
        }
        for (let I of t
            .parameters) {
            let E = I.identifier
                ._symbol;
            if (a && r[E]) throw gf(
                E);
            f[E] = nT(E)
        }
        let m = ts(s),
            g = zs(e, f, m);
        for (let I = t._inputLists
            .length - 1; I >=
            0; I--) {
            let E = t._inputLists[
                I],
                v = E._symbol,
                O = Ee(g, E.args[
                    1]);
            PR(i, o, E);
            let A = i
                .getInstruction(O);
            if (!W(A.valueType)) {
                let L = $G(i, O);
                if (L) {
                    c.push({
                        symbol: v,
                        object: O,
                        gliderBounds: L
                    });
                    continue
                }
                let z;
                if (ei(A
                    .valueType)) {
                    let G = E.args[
                        1]
                        .getInputSpan();
                    G && (z = Cn(G))
                }
                throw KP(v, ne(A
                    .valueType
                ), z)
            }
            let N = _r(i, O);
            l.push({
                symbol: v,
                assignedList: O,
                lengthIndex: N
            }), p = i.Multiply([
                p, N
            ])
        }
        let d = Object.create(r),
            y = ts(s),
            h = [],
            b;
        if (l.length > 0) {
            let I = i.Constant(1);
            b = i.BeginBroadcast([
                p], {
                inputListSymbols: l
                    .map(
                        v =>
                            v
                                .symbol
                    )
            }), xr(y, t
                ._index._symbol,
                b);
            let E = I;
            for (let v = l.length -
                1; v >=
                0; v--) {
                let {
                    symbol: O,
                    assignedList: A,
                    lengthIndex: N
                } = l[v], L;
                if (l.length === 1)
                    L = b;
                else {
                    let z = i
                        .SyntheticNativeFunction(
                            "floor",
                            [i.Divide(
                                [i.Subtract(
                                    [b,
                                        I]
                                ),
                                    E
                                ]
                            )]);
                    L = i.Add([i.SyntheticNativeFunction(
                        "mod",
                        [z,
                            N]
                    ),
                        I
                    ]), v > 0 &&
                        (E = i
                            .Multiply(
                                [E,
                                    N]
                            ))
                }
                xr(y, O, i
                    .ListAccess(
                        [A, L])
                ), h.push(O)
            }
        }
        let x;
        if (t.parameters.length >
            0 || c.length > 0) {
            let I = [],
                E = [];
            for (let v of t
                .parameters) I
                    .push(v.identifier
                        ._symbol), E
                            .push(Ee(g, v
                                .bounds[0]),
                                Ee(g, v.bounds[
                                    1]));
            for (let v of c) I.push(
                v.symbol), E
                    .push(v
                        .gliderBounds[
                        0], v
                            .gliderBounds[1]
                    );
            x = i.BeginMap({
                parameterSymbols: I
            }, E);
            for (let v = 0; v < t
                .parameters.length +
                c.length; v++) i
                    .BlockVar(T, [x]);
            for (let v = 0; v < t
                .parameters
                .length; v++) {
                let O = t
                    .parameters[v]
                    .identifier
                    ._symbol,
                    [A, N] = t
                        .parameters[v]
                        .open,
                    L = E[2 * v],
                    z = E[2 * v +
                        1],
                    G = x + v + 1,
                    $ = i.Piecewise(
                        [i.And([A ? i
                            .Greater(
                                [G,
                                    L]
                            ) :
                            i
                                .GreaterEqual(
                                    [G,
                                        L]
                                ),
                        N ?
                            i
                                .Less(
                                    [G,
                                        z]
                                ) :
                            i
                                .LessEqual(
                                    [G,
                                        z]
                                )
                        ]), G, i
                            .NanOfType(
                                T)
                        ]);
                d[O] = Wt, xr(y, O,
                    $), h.push(
                        O)
            }
            for (let v = 0; v < c
                .length; v++) {
                let O = c[v].symbol,
                    A = x + t
                        .parameters
                        .length + v + 1;
                d[O] = Wt, xr(y, O,
                    NR(i, [c[v]
                        .object,
                        A
                    ])), h.push(
                        O)
            }
        }
        for (let I of l) d[I
            .symbol] = Wt;
        let M = Ee({
            ...zs(e, d, y),
            substitutionContext: e
                .substitutionContext
                .for(r, h)
        }, u);
        if (x !== void 0) {
            let I = i.EndMap([x,
                M]),
                E = i
                    .getInstruction(M)
                    .valueType;
            if (ca(E)) throw fT();
            if (!kh(E)) throw lT(E);
            let v = n.is3dPolicy() ?
                2 : 1;
            if (t.parameters
                .length + c.length >
                v) throw pT(E, t
                    .parameters
                    .length);
            let O = zh(E, t
                .parameters
                .length + c
                    .length);
            M = i.BlockVar(O, [I])
        }
        if (b !== void 0) {
            let I = i
                .getInstruction(M);
            if (!ei(I.valueType))
                throw ec([ne(I
                    .valueType)]);
            let E = i.EndBroadcast([
                b, M
            ]);
            M = i.BroadcastResult(
                ar(I.valueType),
                [E])
        } else t
            .shouldCoerceToList && (
                M = i.List([M]));
        return M
    }

    function UE(e, t, n, r) {
        let {
            stepMustBePositive: i
        } = r, {
            chunk: s
        } = e;
        t = Ac(s, t), n = Ac(s, n);
        let o = s.getInstruction(t),
            a = s.getInstruction(n),
            u = yo(s, t,
                "Programming error: expected range start list to have constant length."
            ),
            c = yo(s, n,
                "Programming error: expected range start list to have constant length."
            );
        if (o.valueType !== se || a
            .valueType !== se)
            throw of();
        let l = s.Constant(1),
            p = s.Constant(0),
            f = s.ListAccess([t,
                l]),
            m = s.ListAccess([t, s
                .Constant(2)
            ]),
            g = s.ListAccess([n, s
                .Constant(c)
            ]),
            d = s.Subtract([g, f]),
            y = u > 1 ? s.Subtract([
                m, f
            ]) : s.Piecewise([s
                .GreaterEqual([
                    d, p
                ]), l, s
                    .Constant(-1)
            ]),
            h = s.Add([l, s
                .SyntheticNativeFunction(
                    "round", [s
                        .Divide(
                            [d,
                                y]
                        )
                ])
            ]),
            b = s
                .SyntheticNativeFunction(
                    "validateRangeLength",
                    [t, n, y, h]);
        i && (b = s.Piecewise([s
            .GreaterEqual(
                [y, p]),
            b, p
        ]));
        let x = s.BeginBroadcast([
            b]),
            P = s.Add([f, s
                .Multiply([y, s
                    .Subtract(
                        [x,
                            l]
                    )
                ])
            ]),
            M = s.EndBroadcast([x,
                P]);
        return s.addComments({
            [f]: "start",
            [m]: "second",
            [g]: "last",
            [h]: "proposedLength",
            [y]: "step",
            [P]: "body"
        }), s.BroadcastResult(
            ar(s.getInstruction(
                P)
                .valueType), [M]
        )
    }

    function Ng(e, t) {
        return Je(e, t, Ie) ? e
            .SyntheticNativeFunction(
                "lineFromSegment", [
                t
            ]) : Je(e, t, he) ?
            e
                .SyntheticNativeFunction(
                    "lineFromSegment", [
                    kG(e, t)
                ]) : Je(e, t, Le) ?
                e
                    .SyntheticNativeFunction(
                        "lineFromRay", [t]
                    ) : t
    }

    function XG(e, t) {
        if (Je(e, t, ce)) {
            let {
                center: n,
                radius: r
            } = LR(e, t);
            return e
                .SyntheticNativeFunction(
                    "circle", [n, r]
                )
        }
        return t
    }

    function LR(e, t) {
        let n = e
            .SyntheticNativeFunction(
                "arcCenter", [t]),
            r = e
                .SyntheticNativeFunction(
                    "arcGlider", [t, e
                        .Constant(0)
                ]),
            i = e
                .SyntheticNativeFunction(
                    "distance", [n, r]);
        return {
            center: n,
            radius: i,
            startPoint: r
        }
    }

    function OR(e, t, n) {
        let {
            chunk: r
        } = e;
        if (t.length === 3 && Je(r,
            t[0], R) && Je(r, t[
                1], R) && Je(r, t[
                    2], R)) {
            let i = t[0],
                s = t[1],
                o = t[2],
                a = r.Subtract([i,
                    s]),
                u = r.Subtract([o,
                    s]),
                c = r
                    .OrderedPairAccess(
                        1, [a]),
                l = r
                    .OrderedPairAccess(
                        2, [a]),
                p = r
                    .OrderedPairAccess(
                        1, [u]),
                f = r
                    .OrderedPairAccess(
                        2, [u]),
                m = r
                    .SyntheticNativeFunction(
                        "arctan", [l, c]
                    ),
                g = r.Subtract([r
                    .Multiply([
                        c, f
                    ]), r
                        .Multiply([
                            l, p
                        ])
                ]),
                d = r.Add([r
                    .Multiply([
                        c, p
                    ]), r
                        .Multiply([
                            l, f
                        ])
                ]),
                y = r
                    .SyntheticNativeFunction(
                        "arctan", [g, d]
                    ),
                h = r
                    .SyntheticNativeFunction(
                        "abs", [y]),
                b = r.Constant(Math
                    .PI),
                x = r.Constant(Math
                    .PI * 2);
            y = r.Piecewise([r
                .Equal([h,
                    b]), b,
            r.Piecewise(
                [r.Less([h,
                    b]),
                    y, r
                        .Multiply(
                            [r.Multiply(
                                [r.SyntheticNativeFunction(
                                    "sign",
                                    [
                                        y]
                                ),
                                r
                                    .Constant(
                                        -
                                        1
                                    )
                                ]
                            ),
                            r
                                .Subtract(
                                    [x,
                                        h]
                                )
                            ]
                        )
                ])
            ]);
            let P = r
                .SyntheticNativeFunction(
                    "directedAngleMarker",
                    [s, m, y, Ee(e,
                        new D
                            .Identifier(
                                "trigAngleMultiplier"
                            ))]),
                M = r.Constant(0),
                I = r.And([r.Equal([
                    g, M
                ]), r.Equal(
                    [d, M])]);
            return r.Piecewise([I, r
                .NanOfType(
                    Ae), P
            ])
        } else throw J(
            `Unexpected types for ${n}`
        )
    }

    function rR(e, t) {
        return e.Divide([e
            .SyntheticNativeFunction(
                "directedAngleMarkerRawDelta",
                [t]), e
                    .SyntheticNativeFunction(
                        "directedAngleMarkerMultiplier",
                        [t])
        ])
    }

    function iR(e, t) {
        return e
            .SyntheticNativeFunction(
                "abs", [e.Divide([e
                    .SyntheticNativeFunction(
                        "undirectedAngleMarkerRawDelta",
                        [t]
                    ), e
                        .SyntheticNativeFunction(
                            "undirectedAngleMarkerMultiplier",
                            [t])
                ])])
    }

    function ZG(e, t, n) {
        let {
            chunk: r
        } = e, i = n.slice(1), s =
                Vp(t);
        if (!s) throw new Error(
            `Unexpected transformation type: ${t}`
        );
        let o = s.map(c => {
            let l = 0;
            for (let p =
                1; p < n
                    .length; p++
            ) {
                let f = r
                    .getInstruction(
                        n[p]
                    )
                    .valueType,
                    m = Uu(
                        c, p
                    );
                m && Rp(f,
                    m) &&
                    l++
            }
            return {
                signature: c,
                matchedArgsCount: l,
                signatureArgsCount: Array
                    .isArray(
                        c) ?
                    c
                        .length -
                    1 : c
                        .initial
                        .length +
                    1,
                providedArgsCount: n
                    .length -
                    1
            }
        }).sort((c, l) => l
            .matchedArgsCount !==
            c.matchedArgsCount ?
            l.matchedArgsCount -
            c.matchedArgsCount :
            c
                .signatureArgsCount -
            l.signatureArgsCount
        ),
            a;
        switch (t) {
            case "translate": {
                a = [{
                    match: [
                        he],
                    build: () =>
                        r
                            .SyntheticNativeFunction(
                                "translation",
                                [r.SyntheticNativeFunction(
                                    "vectorDisplacementAsPoint",
                                    i
                                )]
                            )
                }, {
                    match: [R,
                        R
                    ],
                    build: () =>
                        r
                            .SyntheticNativeFunction(
                                "translation",
                                [r.Subtract(
                                    [i[1],
                                    i[
                                    0]
                                    ]
                                )]
                            )
                }];
                break
            }
            case "reflect": {
                a = [{
                    match: [{
                        meta: "union",
                        types: _d
                    }],
                    build: () => {
                        let c =
                            Ng(r,
                                i[
                                0]
                            );
                        return r
                            .SyntheticNativeFunction(
                                "reflection",
                                [
                                    c]
                            )
                    }
                }];
                break
            }
            case "rotate": {
                a = [{
                    match: [R,
                        T
                    ],
                    build: () => {
                        let c =
                            Ee(e,
                                new D
                                    .Identifier(
                                        "trigAngleMultiplier"
                                    )
                            );
                        return r
                            .SyntheticNativeFunction(
                                "rotation",
                                [i[0],
                                r
                                    .Multiply(
                                        [i[1],
                                            c
                                        ]
                                    )
                                ]
                            )
                    }
                }];
                break
            }
            case "dilate": {
                a = [{
                    match: [R,
                        T
                    ],
                    build: () =>
                        r
                            .SyntheticNativeFunction(
                                "dilation",
                                i
                            )
                }];
                break
            }
            default: {
                let c = t;
                throw new Error(
                    `Programming error: exhaustive check failed: ${c}`
                )
            }
        }
        let u = mu(r, i, () => {
            throw Rb(t, Zo(
                r, i
            ),
                o[0]
                    .signature
            )
        }, a);
        return Ag(r, [u, n[0]], t, !
            0)
    }

    function WG(e, t) {
        let {
            match: n
        } = e;
        return {
            ...e,
            match: Array.isArray(
                n) ? [t, ...n] : {
                ...n,
                initial: [t, ...
                    n
                        .initial
                ]
            }
        }
    }

    function jG(e) {
        return e.map(([t, n]) => ({
            match: [t],
            build: (r,
                i) =>
                r
                    .SyntheticNativeFunction(
                        n, i
                    )
        }))
    }

    function Ag(e, t, n, r) {
        let s = jG([
            [Ue, "compose"],
            [R,
                "transformPoint"],
            [Ie,
                "transformSegment"],
            [fe,
                "transformLine"],
            [Le,
                "transformRay"],
            [he,
                "transformVector"],
            [pe,
                "transformCircle"],
            [ce,
                "transformArc"],
            [Be,
                "transformPolygon"],
            [Ge,
                "transformAngleMarker"],
            [Ae,
                "transformDirectedAngleMarker"]
        ]).map(a => WG(a, Ue));

        function o() {
            throw r ? Nb(n, Dc(e, t
                .slice(1))) :
                Pi(n, Dc(e, t))
        }
        return mu(e, t, o, s)
    }

    function kE(e, t, n) {
        let r = Ng(e, t[0]),
            i = Ng(e, t[1]),
            s = [r, i, e
                .ConstantOfType(T,
                    n)
            ];
        if (Je(e, r, pe)) {
            if (Je(e, i, pe))
                return e
                    .SyntheticNativeFunction(
                        "circleCircleIntersection",
                        s);
            if (Je(e, i, ce))
                return e
                    .SyntheticNativeFunction(
                        "circleArcIntersection",
                        s);
            if (Je(e, i, fe))
                return e
                    .SyntheticNativeFunction(
                        "circleLineIntersection",
                        s)
        }
        if (Je(e, r, ce)) {
            if (Je(e, i, pe))
                return e
                    .SyntheticNativeFunction(
                        "arcCircleIntersection",
                        s);
            if (Je(e, i, ce))
                return e
                    .SyntheticNativeFunction(
                        "arcArcIntersection",
                        s);
            if (Je(e, i, fe))
                return e
                    .SyntheticNativeFunction(
                        "arcLineIntersection",
                        s)
        }
        if (Je(e, r, fe)) {
            if (Je(e, i, pe))
                return e
                    .SyntheticNativeFunction(
                        "lineCircleIntersection",
                        s);
            if (Je(e, i, ce))
                return e
                    .SyntheticNativeFunction(
                        "lineArcIntersection",
                        s);
            if (Je(e, i, fe))
                return e
                    .SyntheticNativeFunction(
                        "lineLineIntersection",
                        s)
        }
        throw J(
            "Invalid intersection types")
    }

    function JG(e, [t, n], [r, i]) {
        let {
            chunk: s,
            frame: o
        } = e, a = s.getInstruction(
            r).valueType, u = s
                .getInstruction(i)
                .valueType, c = f => {
                    let m = o[f];
                    return m && m !==
                        Wt ? m : aS(e
                            .scope, f)
                }, l = Sg(t) ? c(t
                    ._symbol) : t, p =
                Sg(n) ? c(n._symbol) :
                    n;
        if (!(!l || !p)) return xR({
            getGeometryTree: f =>
                jy(f)
                    .tree,
            lookup: c,
            isPointOrListOfPoints: f => {
                if (f
                    .isFunction
                )
                    return !
                        1;
                let m =
                    Ee(e,
                        f
                    );
                return oe(
                    s
                        .getInstruction(
                            m
                        )
                        .valueType,
                    R
                )
            },
            resolvesTo: (
                f, m
            ) =>
                o[f] ===
                m
        }, l, a, p, u)
    }

    function QG(e, t) {
        let {
            policy: n,
            frame: r,
            scope: i,
            recursiveFunctionContext: s
        } = e, o = t._body, a = ts(
            i), u = Object
                .create(r), c = [];
        for (let p = 0; p < t
            ._assignments
            .length; p++) {
            let f = t._assignments[
                p]._lhs,
                m;
            if (f instanceof ze) m =
                f._symbol;
            else throw mf();
            let g = t._assignments[
                p].args[1],
                d = r[m];
            if (d) {
                if (d !== Wt && d
                    .isError)
                    throw d;
                if (d !== Wt && d
                    .type ===
                    "FunctionDefinition"
                ) throw hl(m);
                if (n
                    .assignmentForbidden(
                        m))
                    throw gl(m);
                if (s) throw gf(m)
            }
            let y = Ee(e, g);
            xr(a, m, y, g), u[m] =
                Wt, c.push(m)
        }
        return Ee({
            ...zs(e, u, a),
            substitutionContext: e
                .substitutionContext
                .with(r, c)
        }, o)
    }
    var CR = {
        points: Pt,
        lines: Bn,
        segments: Tn,
        polygons: Rn,
        circles: Fn,
        arcs: Vn,
        angles: gn,
        directedangles: hn,
        rays: Gn,
        vectors: kn
    };

    function KG(e, t) {
        let {
            chunk: n,
            frame: r
        } = e, i = r.construction;
        if (i.isError) throw i;
        if (i.type !==
            "Construction") throw J(
                `Expected construction node but found ${i.type}}`
            );
        if (!Sg(t)) throw J(
            `Expected identifier but found ${t.type}`
        );
        let s = t._symbol;
        if (!(s in CR)) throw Nr(
            "construction");
        let o = CR[s];
        if (i.args.length === 0)
            return n.ConstantOfType(
                o, []);
        let a = ke(o),
            u = [];
        for (let c of i.args) try {
            let l = Ee(e, c);
            n.getInstruction(l)
                .valueType ===
                a && u.push(l)
        } catch (l) {
            if (l instanceof D
                .Base) continue;
            throw l
        }
        return n.List(u)
    }

    function id(e, t) {
        let n = e.args;
        if (e instanceof cn && t
            .definitions[e._symbol])
            return !1;
        if (e instanceof hr) {
            let a = [id(e.args[0],
                t) ||
                new Zt(!0)
            ],
                u = id(e.args[1],
                    t),
                c = id(e.args[2],
                    t);
            return u && a.push(u),
                c && a.push(c), a
                    .length === 1 ? !1 :
                    (a.length === 2 && a
                        .push(a[1]),
                        new hr(a))
        }
        let i = [],
            s = !1;
        for (let o of n) {
            let a = id(o, t);
            if (a === !1) {
                s = !0;
                continue
            }
            i.push(a)
        }
        return s ? !1 : e
            .copyWithArgs(i)
    }

    function wR(e, t, n) {
        let {
            chunk: r,
            frame: i,
            scope: s
        } = e, o = {}, a = Object
            .keys(n.definitions);
        for (let h of a) {
            let b = n.definitions[
                h];
            if (b instanceof C)
                throw b;
            o[h] = b
        }
        let u = t._argSymbols
            .filter(h => qy(s,
                h) === void 0 && i[
                h] === void 0),
            c = t._argSymbols.map(
                h => u.includes(h) ?
                    r.SymbolicVar(T,
                        h) : Ee(e, new ze(
                            h))),
            l = new zE(o, n
                .baseCases);
        try {
            VR(e, l, t, c)
        } catch (h) {
            throw l
                .isUnconditionallyRecursive &&
                h instanceof C && !h
                    .blocksExport ? a
                        .length > 1 || FR(t,
                            t._expression) ?
                $a(a) : im(a) : h
        }
        let p = {},
            f = {},
            m = {},
            g = ts(s),
            d = Object.create(i);
        for (let h of a) {
            let b = l.returnTypes[
                h];
            if (b === void 0)
                throw J(
                    `Could not infer the return type for recursive function ${h}.`);
            let x = l.argTypes[h];
            if (x === void 0)
                throw J(
                    `Could not infer the argument types for recursive function ${h}.`);
            f[h] = {
                argTypes: x
            }, p[h] = b, m[h] =
                r.FunctionHeader(h,
                    b, f[h], o[h]
                    ._argSymbols),
                xr(g, h, m[h]), d[
                h] = Wt
        }
        let y = [];
        for (let h of a) y.push(m[
            h]);
        for (let h of y) r
            .getInstruction(h)
            .recursionGroup = y;
        for (let h of a) {
            let b = ts(g),
                x = Object.create(
                    d),
                P = o[h],
                M = m[h],
                I = r.BeginFunction(
                    [M]);
            for (let O = 0; O < P
                ._argSymbols
                .length; O++) {
                let A = P
                    ._argSymbols[O],
                    N = r.BlockVar(
                        f[h]
                            .argTypes[
                        O], [I]);
                x[A] = Wt, xr(b, A,
                    N)
            }
            let E = {
                ...zs(e, x, b),
                recursiveFunctionContext: {
                    type: "compile-general"
                }
            },
                v = BR(E, P, n
                    .baseCases, Ee(
                        E, P
                        ._expression
                    ));
            if (r.getInstruction(v)
                .valueType !== p[h])
                throw Pi(h, Zo(r,
                    c));
            v = Tr(r, v), r
                .EndFunction([I, v])
        }
        if (l
            .isUnconditionallyRecursive
        ) {
            let h = r
                .getRecursiveFunctionMetadata(
                    m[t._symbol]),
                b = h == null ?
                    void 0 : h
                        .recursiveStructure;
            throw b != null && b
                .canIterate ?
                new Error(
                    "Programming error: expected canIterate==false for unconditionally recursive function."
                ) : b != null &&
                    b
                        .maxRecursiveCallOffsets &&
                    a.every(x => b
                        .maxRecursiveCallOffsets[
                        x] === 0) ?
                    $a(a) : cb(a, {
                        type: "missing-non-recursive-branch",
                        recursionGroup: a,
                        recursiveStructure: b
                    })
        }
        return r.FunctionCall([m[t
            ._symbol],
        ...c
        ])
    }

    function FR(e, t) {
        return t instanceof cn && t
            ._symbol === e._symbol ?
            t.args.every((n, r) =>
                n instanceof ze && n
                    ._symbol === e
                        ._argSymbols[r]) : t
                            .args.every(n => FR(e,
                                n))
    }

    function VR(e, t, n, r) {
        let {
            chunk: i,
            scope: s,
            frame: o
        } = e, a = t.returnTypes[n
            ._symbol], u = t
                .argTypes[n._symbol];
        if (a !== void 0 && u !==
            void 0) return {
                returnType: a,
                argTypes: u
            };
        let c = n._argSymbols
            .length,
            l = r.length;
        if (c !== l) throw ds(n
            ._symbol, c, l);
        let p = r.map(I => i
            .getInstruction(I)
            .valueType),
            f =
                `${n._symbol}:${p.join(",")}:${Object.keys(t.returnTypes).join(",")}`;
        if (t.stack.includes(f))
            return t
                .isUnconditionallyRecursive = !
                0, {
                returnType: T,
                argTypes: p
            };
        t.stack.push(f);
        let m = i
            .instructionsLength(),
            g = i.getReturnIndex(),
            d;
        {
            let I = id(n
                ._expression, t
            ),
                E = n._symbol,
                v = t.baseCases[E],
                O = ts(s),
                A = Object.create(
                    o),
                N = {
                    ...zs(e, A, O),
                    recursiveFunctionContext: t
                },
                L = [];
            for (let G = 0; G < n
                ._argSymbols
                .length; G++) {
                let $ = n
                    ._argSymbols[G],
                    w = i
                        .SymbolicVar(p[
                            G]);
                L.push(w), A[$] =
                    Wt, xr(O, $, w)
            }
            if (!t.baseCaseTypes
                .hasOwnProperty(E)
            ) {
                let G, $, w;
                for (let Y of v) {
                    let de = Y
                        .getRef();
                    if (!Y
                        .specifiedArg
                        .valid || !
                        de)
                        continue;
                    let re = new ze(
                        de),
                        ie = Ee(N,
                            re);
                    w || (w = re);
                    let Z = i
                        .getInstruction(
                            ie)
                        .valueType;
                    if (G ===
                        void 0) G =
                            Y
                                .specifiedArg
                                .argIndex;
                    else if (G !== Y
                        .specifiedArg
                        .argIndex)
                        throw Hp();
                    let Re = $;
                    if (Re ===
                        void 0) $ =
                            Z;
                    else {
                        let Ne = ua(
                            Re,
                            Z);
                        if (Ne ===
                            void 0)
                            throw zp();
                        $ = Ne
                    }
                }
                t.baseCaseTypes[E] =
                    $, t
                        .firstValidBaseCaseIdentifiers[
                    E] = w
            }
            let z = t
                .firstValidBaseCaseIdentifiers[
                E];
            if (I || z) {
                let G = BR(N, n, t
                    .baseCases,
                    Ee(N, I ||
                        z)),
                    {
                        someArgBroadcasts: $,
                        inferredArgTypes: w
                    } = e2(i, L, g,
                        G);
                if (p = w, d = i
                    .getInstruction(
                        G)
                    .valueType, $) {
                    if (!W(d))
                        throw J(
                            `TODO: expected a list type but found ${on(d)}`);
                    d = ke(d)
                }
                let Y = t
                    .returnTypes[n
                        ._symbol];
                if (Y !== void 0 &&
                    d !== Y)
                    throw zp();
                t.argTypes[n
                    ._symbol] =
                    w, t
                        .returnTypes[n
                        ._symbol] =
                    d
            }
        }
        i.truncate(m);
        let y = ts(s),
            h = Object.create(o),
            b = {
                ...zs(e, h, y),
                recursiveFunctionContext: t
            };
        for (let I = 0; I < n
            ._argSymbols.length; I++
        ) {
            let E = n._argSymbols[
                I],
                v = i.SymbolicVar(p[
                    I]);
            h[E] = Wt, xr(y, E, v)
        }
        let x = Ee(b, n
            ._expression);
        t.stack.pop();
        let P = i.getInstruction(x)
            .valueType,
            M = d === void 0 ? P :
                ua(d, P);
        if (M === void 0) throw J(
            `Mismatched return types: ${d && on(d)} vs ${on(P)}`
        );
        return t.returnTypes[n
            ._symbol] = M, i
                .truncate(m), {
            returnType: M,
            argTypes: p
        }
    }

    function e2(e, t, n, r) {
        let i = [],
            u = [];
        for (let p = 0; p < r -
            n; p++) u.push(0);
        if (e.getInstruction(r)
            .type === 48) {
            u.push(1);
            for (let p = r; p >=
                0; p--) {
                let f = u[p - n];
                if (f === 0)
                    continue;
                let m = e
                    .getInstruction(
                        p);
                if (!be(m)) {
                    if (m.type ===
                        24 ? i.push(
                            p) : m
                                .type ===
                            23 && i
                                .pop(), (m
                                    .type ===
                                    48 || m
                                        .type ===
                                    24) && (
                            u[m.args[
                            0
                            ] -
                            n
                            ] |=
                            f), m
                                .type ===
                            39 || m
                                .type ===
                            41 || m
                                .type === 40
                    )
                        for (let g of
                            i) {
                            let y =
                                e
                                    .getInstruction(
                                        g
                                    )
                                    .args[
                                0
                                ];
                            if (m
                                .args[
                                1
                            ] ===
                                y) {
                                u[m.args[
                                    0] -
                                    n
                                ] |=
                                    f;
                                break
                            }
                        }
                    if (i.length >
                        0) {
                        let g = i[i
                            .length -
                            1],
                            y = e
                                .getInstruction(
                                    g)
                                .args[
                                0];
                        for (let h of
                            m
                                .args)
                            h >=
                                y && (u[h -
                                    n
                                ] |=
                                    f);
                        m.type ===
                            33 && m
                                .args[
                            0] >=
                            y && (u[m
                                .args[
                                0
                            ] -
                                n
                            ] |=
                                2)
                    }
                }
            }
        }
        let c = [],
            l = !1;
        for (let p = 0; p < t
            .length; p++) {
            let f = t[p],
                m = e
                    .getInstruction(f)
                    .valueType;
            if (u[f - n] & 2) {
                if (!W(m)) throw J(
                    `Expected list type but found ${on(m)}`
                );
                l = !0, c.push(ke(
                    m))
            } else c.push(m)
        }
        return {
            inferredArgTypes: c,
            someArgBroadcasts: l
        }
    }

    function BR(e, t, n, r) {
        let {
            chunk: i
        } = e;
        for (let s of n[t
            ._symbol]) {
            let o = s.specifiedArg;
            if (!o.valid) continue;
            let a = t._argSymbols[o
                .argIndex],
                u = Ee(e, new ze(
                    a)),
                c = i.Equal([u, i
                    .Constant(o
                        .argValue
                    )
                ]),
                l = Ee(e, s),
                p = i
                    .getInstruction(l)
                    .valueType,
                f = i
                    .getInstruction(r)
                    .valueType;
            if (ua(p, f) === void 0)
                throw zp();
            r = i.Piecewise([c, l,
                r])
        }
        return r
    }
    Tt.prototype.buildIRExpression =
        function (e, t, n) {
            var i;
            var r = mp({
                policy: e,
                frame: t,
                wrapInList: n &&
                    n
                        .wrapInList,
                coerceToNumber: n &&
                    n
                        .coerceToNumber,
                selection: n &&
                    n
                        .selection
            }, this);
            return e
                .isGeometryEnabled() &&
                r.argNames.some(s =>
                    s[0] === "$") ?
                cT() : (i = r
                    .getError()) !=
                    null ? i : new pn(r)
        };
    C.prototype.buildIRExpression =
        function (e, t, n) {
            return this
        };
    var GR = Wc;

    function qE(e) {
        for (var t = [], n = 0; n <
            e.length; n++) t.push(
                ne(e[n].valueType));
        return t
    }

    function kR(e, t) {
        var n = t.length,
            r = t[0];
        if (n < 2) throw As(this
            ._symbol);
        if (!GR(r.valueType, [se,
            We])) throw As(this
                ._symbol);
        if (n > 2) throw gm(this
            ._symbol, 2)
    }
    D.Histogram.prototype
        .typeCheck = kR;
    D.DotPlot.prototype.typeCheck =
        kR;
    D.BoxPlot.prototype.typeCheck =
        function (e, t) {
            var n = t.length,
                r = t[0];
            if (n === 0) throw As(
                this._symbol
            );
            if (!GR(r.valueType, [
                se, We
            ])) throw As(this
                ._symbol);
            if (n > 1) throw As(this
                ._symbol)
        };
    D.TTest.prototype.typeCheck =
        function (e, t) {
            var n = this._symbol;
            if (t.length === 0)
                throw As(n);
            if (t[0].valueType ===
                We) throw yl(n);
            if (t[0].valueType !==
                se) throw As(n);
            if (t.length > 2)
                throw gm(n, 2);
            if (t[0].length < 2)
                throw yl(n);
            if (t[1] && t[1]
                .valueType !== T)
                throw Pi(n, qE(t))
        };
    D.IndependentTTest.prototype
        .typeCheck = function (e,
            t) {
            var n = this._symbol;
            if (t.length !== 2)
                throw ef(n);
            if (!W(t[0]
                .valueType) || !W(t[
                    1]
                    .valueType))
                throw sf(n);
            if (t[0].valueType ===
                We || t[1]
                    .valueType === We)
                throw yl("ittest");
            if (t[0].valueType !==
                se || t[1]
                    .valueType !== se)
                throw Pi(n, qE(t));
            if (t[0].length < 2 ||
                t[1].length < 2)
                throw yl("ittest")
        }, D.Stats.prototype
            .typeCheck = function (e,
                t) {
            var n = t.length,
                r = t[0];
            if (n === 0) throw As(
                this._symbol
            );
            if (r.valueType === We)
                throw Pi(this
                    ._symbol,
                    qE(t));
            if (r.valueType !== se)
                throw As(this
                    ._symbol);
            if (n > 1) throw As(this
                ._symbol)
        };
    var Iu = function (e, t, n) {
        n = n || 0;
        var r = Array(n + 1)
            .join("  "),
            i = r + "  ";
        return `[
` + i + e.map(function (s) {
            return s
                .repr(t,
                    n +
                    1)
        }).join(`,
` + i) + `
` + r + "]"
    },
        fr = function (e, t) {
            return t = t || "", "" +
                t + e
        };
    D.Expression.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "(" + Iu(this
                    .args, e, t) +
                ")"
        };
    D.IRExpression.prototype.repr =
        function (e, t) {
            t = t || 0;
            var n = Array(t + 1)
                .join("  "),
                r = n + "  ",
                i = this._chunk
                    .print().split(`
`);
            return i.pop(), fr(this
                .type, e) +
                "(`\n" + r + i.join(`
` + r) + `
` + n + "`)"
        };
    D.DoubleInequality.prototype
        .repr = function (e, t) {
            t = t || 0;
            var n = Array(t + 1)
                .join("  "),
                r = n + "  ";
            return fr(this.type,
                e) + `([
` + r + this.args[0].repr(e, t + 1) + `,
` + r + "'" + this.args[1] + `',
` + r + this.args[2].repr(e, t + 1) + `,
` + r + "'" + this.args[3] + `',
` + r + this.args[4].repr(e, t + 1) + `
` + n + "])"
        };
    D.ComparatorChain.prototype
        .repr = function (e, t) {
            return t = t || 0, fr(
                this.type, e) +
                "([" + this.symbols
                    .map(n => `'${n}'`)
                    .join(",") + `],
` + Iu(this.args, e, t) + ")"
        };
    D.Identifier.prototype.repr =
        function (e) {
            return fr(this.type,
                e) + "('" + this
                    ._symbol + "')"
        };
    D.Constant.prototype.repr =
        function (e) {
            return fr(this.type,
                e) + "(" + this
                    .asValue() + ")"
        };
    D.ExtendSeed.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "('" + this
                    .tag + "', " + Iu(
                        this.args, e, t
                    ) + ")"
        };
    D.Seed.prototype.repr =
        function (e) {
            return fr(this.type,
                e) + "(" + this
                    .asValue() + ")"
        };
    D.FunctionCall.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "('" + this
                    ._symbol + "', " +
                Iu(this.args, e,
                    t) + ")"
        };
    D.RecursiveFunctionBaseCase
        .prototype.repr = function (
            e, t) {
            return this.originalNode
                .repr(e, t)
        };
    D.Assignment.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "(" + new D
                    .Identifier(this
                        ._symbol).repr(
                            e, t) + ", " +
                this._expression
                    .repr(e, t) + ")"
        };
    D.CoordinateEquation.prototype
        .repr = function (e, t) {
            return this.asEquation()
                .repr(e, t)
        };
    D.Regression.prototype.repr = D
        .Equation.prototype.repr = D
            .CallAssignment.prototype
            .repr = function (e, t) {
                return fr(this.type,
                    e) + "(" + this._lhs
                        .repr(e, t) + ", " +
                    this._rhs.repr(e,
                        t) + ")"
            };
    D.FunctionDefinition.prototype
        .repr = function (e, t) {
            return fr(this.type,
                e) + "(" + new D
                    .Identifier(this
                        ._symbol).repr(
                            e, t) + ", " +
                Iu(this._argSymbols
                    .map(function (
                        n) {
                        return new D
                            .Identifier(
                                n
                            )
                    }), e, t) +
                ", " + this
                    ._expression.repr(e,
                        t) + ")"
        };
    D.Error.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "('" + this
                    ._msg + "')"
        };
    D.Derivative.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "('" + this
                    ._symbol + "', " +
                Iu(this.args, e,
                    t) + ")"
        };
    D.SolvedEquation.prototype
        .repr = function (e, t) {
            return fr(this.type,
                e) + "('" + this
                    ._symbol + "', " +
                this._expression
                    .repr(e, t) + ")"
        };
    D.OptimizedRegression.prototype
        .repr = function (e, t) {
            return fr(this.type,
                e) + "(" + JSON
                    .stringify(this
                        .parameters) +
                ", " + JSON
                    .stringify(this
                        .residuals) +
                ", " + JSON
                    .stringify(this
                        .statistics) +
                ", " + this.model
                    .repr(e, t + 1) +
                ", " + JSON
                    .stringify({
                        isModelValid: this
                            .isModelValid,
                        residualVariable: this
                            .residualVariable,
                        residualSuggestionId: this
                            .residualSuggestionId,
                        shouldSuggestLogMode: this
                            .shouldSuggestLogMode,
                        isLinear: this
                            .isLinear,
                        parameterWarning: this
                            .parameterWarning
                    }) + ")"
        };
    D.Table.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "(" + Iu(this
                    .columns, e, t
                ) + ")"
        };
    D.TableColumn.prototype.repr =
        function (e, t) {
            return fr(this.type,
                e) + "(" + this
                    .header.repr(e, t) +
                ", " + this.length +
                ", " + Iu(this
                    .values, e, t) +
                ")"
        };
    D.Image.prototype.repr =
        function (e, t) {
            var n = Array(t + 1)
                .join("  "),
                r = n + "  ";
            return fr(this.type,
                e) + `({
` + r + "center: " + this.center.repr(
                    e, t + 1) + `,
` + r + "radianAngle: " + this
                    .radianAngle.repr(e,
                        t + 1) + `,
` + r + "width: " + this.width.repr(e,
                            t + 1) + `,
` + r + "height: " + this.height.repr(
                                e, t + 1) + `},
` + r + "opacity: " + this.opacity
                    .repr(e, t + 1) + `,
` + r + JSON.stringify(this
                        .moveStrategy) + `
` + n + "})"
        };
    D.Ticker.prototype.repr =
        function (e, t) {
            var n = Array(t + 1)
                .join("  "),
                r = n + "  ";
            return fr(this.type,
                e) + `({
` + r + "handler: " + this.handler
                    .repr(e, t + 1) + `,
` + r + "minStep: " + this.minStep
                    .repr(e, t + 1) + `
` + n + "})"
        };
    D.Slider.prototype.repr =
        function (e, t) {
            var n = Array(t + 1)
                .join("  "),
                r = n + "  ";
            return fr(this.type,
                e) + `({
` + r + "sliderAssignment: " + this
                    .sliderAssignment
                    .repr(e, t + 1) + `,
` + r + "sliderMin: " + (this
                    .sliderMin &&
                    this.sliderMin
                        .repr(e, t + 1)
                ) + `,
` + r + "sliderMax: " + (this
                    .sliderMax &&
                    this.sliderMax
                        .repr(e, t + 1)
                ) + `,
` + r + "sliderStep: " + (this
                    .sliderStep &&
                    this.sliderStep
                        .repr(e, t + 1)
                ) + `},
` + n + ")"
        };
    var Lg = function (e, t) {
        return e.map(function (
            n) {
            return n
                .substitute(
                    t)
        })
    };
    D.Identifier.prototype
        .substitute = function (e) {
            return e[this._symbol] ?
                e[this._symbol] :
                this
        };
    D.FunctionCall.prototype
        .substitute = function (e) {
            var t = e[this._symbol];
            if (t) {
                if (t.type ===
                    "Identifier")
                    return new D
                        .FunctionCall(
                            t, Lg(
                                this
                                    .args,
                                e));
                if (t.type ===
                    "Constant")
                    return new D
                        .Multiply([
                            t,
                            this
                                .args
                                .length ===
                                1 ?
                                this
                                    .args[
                                    0
                                ]
                                    .substitute(
                                        e
                                    ) :
                                new D
                                    .Constant(
                                        NaN
                                    )
                        ])
            }
            return D.Expression
                .prototype
                .substitute.call(
                    this, e)
        };
    D.Constant.prototype
        .substitute = function (e) {
            return this
        };
    D.Expression.prototype
        .substitute = function (e) {
            return this
                .copyWithArgs(Lg(
                    this.args, e
                ))
        };
    D.Derivative.prototype
        .substitute = function (e) {
            var t = e[this._symbol];
            if (t) {
                if (t.type ===
                    "Identifier")
                    return new D
                        .Derivative(
                            t, Lg(
                                this
                                    .args,
                                e));
                throw new Error(
                    "Cannot substitute for a derivative variable with a non-Identifier"
                )
            }
            return new D.Derivative(
                this._symbol,
                Lg(this.args, e)
            )
        };
    D.Expression.prototype
        .simpleFunctionExpression =
        function () {
            return this
        };
    D.Assignment.prototype
        .simpleFunctionExpression =
        function () {
            return this._expression
        };
    D.CoordinateEquation.prototype
        .simpleFunctionExpression =
        function () {
            return this.asEquation()
                .simpleFunctionExpression()
        };
    D.FunctionDefinition.prototype
        .simpleFunctionExpression =
        function () {
            return this._expression
        };
    D.RecursiveFunctionBaseCase
        .prototype
        .simpleFunctionExpression =
        function () {
            return this._expression
        };
    D.Equation.prototype
        .simpleFunctionExpression =
        D.CallAssignment.prototype
            .simpleFunctionExpression =
        function () {
            return this
                .asComparator()
                .simpleFunctionExpression()
        };

    function ea(e) {
        return e >= 100
    }

    function zR(e, t) {
        switch (e) {
            case 106:
                return 200;
            case 107:
                return 201;
            case 108:
                return 202;
            case 103:
                return 214;
            case 130:
                return 215;
            case 112:
                return 209;
            case 113:
                return 210;
            case 110:
                switch (t) {
                    case "z":
                        return 206;
                    case "theta":
                        return 205;
                    case "x":
                    case "y":
                    case "r":
                    case "_implicit":
                        return 211;
                    default:
                        return 10
                }
            case 109:
                switch (t) {
                    case "r":
                        return 203;
                    case "theta":
                        return 204;
                    case "x":
                    case "y":
                    case "z":
                    case "_implicit":
                        return 213;
                    default:
                        return 10
                }
            case 111:
                switch (t) {
                    case "theta":
                        return 207;
                    case "phi":
                        return 208;
                    case "x":
                    case "y":
                    case "z":
                    case "rho":
                    case "_implicit":
                        return 212;
                    default:
                        return 10
                }
            default:
                return 10
        }
    }

    function $E(e) {
        switch (e) {
            case 123:
            case 122:
            case 121:
            case 120:
            case 124:
            case 126:
            case 127:
                return !0;
            default:
                return !1
        }
    }
    var wg = {
        normaldist: {
            type: "distribution",
            symbol: "normaldist",
            params: ["mean",
                "stdev"
            ],
            defaults: ["0",
                "1"],
            discrete: !1
        },
        tdist: {
            type: "distribution",
            symbol: "tdist",
            params: ["dof"],
            defaults: [void 0],
            discrete: !1
        },
        binomialdist: {
            type: "distribution",
            symbol: "binomialdist",
            params: ["trials",
                "probsuccess"
            ],
            defaults: [void 0,
                "0.5"
            ],
            discrete: !0
        },
        poissondist: {
            type: "distribution",
            symbol: "poissondist",
            params: ["mean"],
            defaults: [void 0],
            discrete: !0
        },
        uniformdist: {
            type: "distribution",
            symbol: "uniformdist",
            params: ["min",
                "max"
            ],
            defaults: ["0",
                "1"],
            discrete: !1
        }
    },
        t2 = {
            Histogram: {
                type: "visualization",
                symbol: "histogram",
                params: ["data",
                    "binwidth"
                ],
                defaults: [void 0,
                    "1"
                ]
            },
            DotPlot: {
                type: "visualization",
                symbol: "dotplot",
                params: ["data",
                    "binwidth"
                ],
                defaults: [void 0,
                    "1"
                ]
            },
            BoxPlot: {
                type: "visualization",
                symbol: "boxplot",
                params: ["data"],
                defaults: [void 0]
            }
        };

    function HR(e) {
        let t = Vs(e, {
            trailingComma: !
                0
        });
        return Aa(t)
    }

    function Aa(e) {
        let t = e,
            n = t2[t.type];
        if (!n) switch (t.type ===
            "Assignment" && (t =
                t._expression),
            t.type) {
                case "FunctionCall": {
                    n = wg[t
                        ._symbol];
                    break
                }
                default:
                    return
            }
        if (!n) return;
        let r = {},
            i = n.params,
            s = t.args;
        for (let o = 0; o < i
            .length; o++) {
            let a = s[o];
            r[i[o]] = a && a
                .getInputString() ||
                ""
        }
        return {
            ...n,
            span: t.getInputSpan(),
            values: r
        }
    }
    var r2 = {
        X_OR_Y: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SINGLE_POINT: {
            points: !0,
            lines: !1,
            fill: !1
        },
        POINT_LIST: {
            points: !0,
            lines: !1,
            fill: !1
        },
        PARAMETRIC: {
            points: !1,
            lines: !0,
            fill: !1
        },
        POLAR: {
            points: !1,
            lines: !0,
            fill: !1
        },
        IMPLICIT: {
            points: !1,
            lines: !0,
            fill: !1
        },
        POLYGON: {
            points: !1,
            lines: !0,
            fill: !0
        },
        HISTOGRAM: {
            points: !1,
            lines: !0,
            fill: !0
        },
        DOTPLOT: {
            points: !0,
            lines: !1,
            fill: !1
        },
        BOXPLOT: {
            points: !1,
            lines: !0,
            fill: !1
        },
        TTEST: {
            points: !1,
            lines: !1,
            fill: !1
        },
        STATS: {
            points: !1,
            lines: !1,
            fill: !1
        },
        VECTOR2D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        POINT3D: {
            points: !0,
            lines: !1,
            fill: !1
        },
        POINT3D_LIST: {
            points: !0,
            lines: !1,
            fill: !1
        },
        CURVE3D_xyz_t: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8z_at_z: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_zr\u03B8_at_r: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_zr\u03B8_at_\u03B8: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_zr\u03B8_at_xyz: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8\u03C6_at_\u03B8: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8\u03C6_at_\u03C6: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_r\u03B8\u03C6_at_xyz: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SLICE_xyz_uv: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SEGMENT3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        VECTOR3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SPHERE3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_xyz_uv: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_z_r\u03B8: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_r_\u03B8z: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_r_\u03B8\u03C6: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_r_\u03B8z_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE: {
            points: !1,
            lines: !0,
            fill: !1
        },
        TRIANGLE3D: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        },
        SURFACE_CONSTANT_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        },
        IMPLICIT_SURFACE: {
            points: !1,
            lines: !0,
            fill: !1
        },
        IMPLICIT_SURFACE_AMBIGUOUS: {
            points: !1,
            lines: !0,
            fill: !1
        }
    };

    function YE(e, t, n) {
        var i, s, o, a, u, c;
        if (e === void 0) return {
            points: !1,
            lines: !1,
            fill: !1
        };
        let r = r2[e];
        switch (e) {
            case "SINGLE_POINT":
                return {
                    points: !0,
                    lines: !1,
                    fill: !1
                };
            case "POINT_LIST":
            case "POINT3D_LIST":
            case "DOTPLOT":
                return {
                    points: (i = t
                        .points
                    ) !=
                        null ? i : r
                        .points,
                    lines: (s =
                        t.lines
                    ) !=
                        null ? s : r
                        .lines,
                    fill: !1
                };
            case "POINT3D":
                return {
                    points: (o = t
                        .points
                    ) !=
                        null ? o : r
                        .points,
                    lines: !1,
                    fill: !1
                };
            case "PARAMETRIC":
            case "POLYGON":
            case "X_OR_Y":
            case "VECTOR2D":
            case "POLAR":
            case "IMPLICIT":
            case "HISTOGRAM":
            case "BOXPLOT":
            case "TTEST":
            case "STATS":
            case "CURVE3D_xyz_t":
                return {
                    points: !1,
                    lines: (a =
                        t.lines
                    ) !=
                        null ? a : r
                        .lines,
                    fill: (u = t
                        .fill
                    ) !=
                        null ? u : r
                        .fill
                };
            case "TRIANGLE3D":
            case "SPHERE3D":
            case "SURFACE":
            case "SURFACE_r_z":
            case "SURFACE_z_r":
            case "SURFACE_r_":
            case "SURFACE_xyz_uv":
            case "IMPLICIT_SURFACE":
            case "SURFACE_AMBIGUOUS":
            case "SURFACE_CONSTANT_AMBIGUOUS":
            case "SURFACE_r_z_AMBIGUOUS":
            case "IMPLICIT_SURFACE_AMBIGUOUS":
            case "SEGMENT3D":
            case "VECTOR3D":
            case "SLICE":
            case "SLICE_rz_at_z":
            case "SLICE_zr_at_r":
            case "SLICE_zr_at_":
            case "SLICE_zr_at_xyz":
            case "SLICE_r_at_":
            case "SLICE_r_at_":
            case "SLICE_r_at_xyz":
            case "SLICE_xyz_uv":
                return {
                    points: !1,
                    lines: (c =
                        t.lines
                    ) !=
                        null ? c : r
                        .lines,
                    fill: !1
                };
            default:
                n && n(e);
                let l = e;
                return YE(e, t) || l
        }
    }

    function XE(e) {
        if (e === void 0) return !1;
        switch (e) {
            case "SINGLE_POINT":
            case "POINT_LIST":
            case "PARAMETRIC":
            case "POLYGON":
            case "X_OR_Y":
            case "VECTOR2D":
            case "POLAR":
            case "IMPLICIT":
            case "SURFACE":
            case "SURFACE_AMBIGUOUS":
            case "SURFACE_CONSTANT_AMBIGUOUS":
            case "SURFACE_r_z":
            case "SURFACE_r_z_AMBIGUOUS":
            case "SURFACE_z_r":
            case "SURFACE_r_":
            case "SURFACE_xyz_uv":
            case "IMPLICIT_SURFACE":
            case "IMPLICIT_SURFACE_AMBIGUOUS":
            case "CURVE3D_xyz_t":
            case "SLICE":
            case "SLICE_rz_at_z":
            case "SLICE_zr_at_r":
            case "SLICE_zr_at_":
            case "SLICE_zr_at_xyz":
            case "SLICE_r_at_":
            case "SLICE_r_at_":
            case "SLICE_r_at_xyz":
            case "SLICE_xyz_uv":
            case "SEGMENT3D":
            case "VECTOR3D":
            case "SPHERE3D":
            case "POINT3D":
            case "POINT3D_LIST":
            case "TRIANGLE3D":
                return !0;
            case "HISTOGRAM":
            case "BOXPLOT":
            case "DOTPLOT":
            case "TTEST":
            case "STATS":
                return !1;
            default:
                return e
        }
    }

    function UR(e) {
        return e ===
            "SURFACE_r_" || e ===
            "SLICE_r_at_" ||
            e ===
            "SLICE_r_at_" ||
            e === "SLICE_r_at_xyz"
    }

    function qR(e) {
        return e ===
            "SURFACE_z_r" || e ===
            "SLICE_zr_at_r" ||
            e ===
            "SLICE_zr_at_" ||
            e === "SLICE_zr_at_xyz"
    }

    function $R(e) {
        return e ===
            "SURFACE_r_z" || e ===
            "SURFACE_r_z_AMBIGUOUS" ||
            e === "SLICE_rz_at_z"
    }

    function ta(e) {
        if (typeof e == "string")
            return e;
        if (e === void 0) return "";
        if (isNaN(e))
            return "\\frac{0}{0}";
        if (e === 1 / 0)
            return "\\infty";
        if (e === -1 / 0)
            return "-\\infty";
        let t = e + "";
        return t = t.replace(
            /^1e\+?([-\d]+)/,
            "10^{$1}"), t = t
                .replace(
                    /([-\d\.]+)e\+?([-\d]+)/,
                    "$1\\cdot 10^{$2}"),
            t
    }

    function i2(e) {
        let t = e + "";
        if (/\d+\.?\d*e[\+\-]*\d+/i
            .test(t)) {
            let r = "0",
                i = String(t)
                    .toLowerCase()
                    .split("e"),
                s = parseFloat(i[
                    0]),
                o = parseInt(i[1],
                    10),
                a = Math.abs(o),
                u = Math.abs(s)
                    .toString().split(
                        ".");
            if (o < 0) t = "0." +
                new Array(a).join(
                    r) + u.join("");
            else {
                var n = u[1];
                n && (a = a - n
                    .length),
                    t = u.join("") +
                    new Array(a + 1)
                        .join(r)
            }
            s < 0 && (t = "-" + t)
        }
        return t
    }

    function CQ(e, t = 2) {
        var n = i2(e),
            r = n.indexOf(".");
        if (r === -1) return n;
        for (var i, s = r + 1; s < n
            .length; s++)
            if (i) {
                if (n[s] !== i)
                    break
            } else if (n[s] ===
                "0" || n[s] === "9") i =
                    n[s];
            else break;
        return n.substr(0, Math.max(
            r + 5, s + t))
    }

    function vn(e, t) {
        if (W(e)) {
            let n = [];
            for (let r = 0; r < t
                .length; r++) n
                    .push(vn(ke(e), t[
                        r]));
            return `\\left[${n.join(",")}\\right]`
        }
        switch (e) {
            case T:
                return ta(t);
            case R: {
                let [s, o] = t;
                return `\\left(${ta(s)},${ta(o)}\\right)`
            }
            case V: {
                let [s, o, a] = t;
                return `\\left(${ta(s)},${ta(o)},${ta(a)}\\right)`
            }
            case Ut:
                return "\\operatorname{rgb}\\left(" +
                    [vn(T, t[0]),
                    vn(T, t[1]),
                    vn(T, t[2])
                    ].join(",") +
                    "\\right)";
            case Be: {
                let s = [];
                for (let o of t) s
                    .push(vn(R, o));
                return "\\operatorname{polygon}\\left(" +
                    s.join(",") +
                    "\\right)"
            }
            case Ie:
                return "\\operatorname{segment}\\left(" +
                    [vn(R, t[0]),
                    vn(R, t[1])
                    ].join(",") +
                    "\\right)";
            case fe:
                return "\\operatorname{line}\\left(" +
                    [vn(R, t[0]),
                    vn(R, t[1])
                    ].join(",") +
                    "\\right)";
            case Le:
                return "\\operatorname{ray}\\left(" +
                    [vn(R, t[0]),
                    vn(R, t[1])
                    ].join(",") +
                    "\\right)";
            case he:
                let n = t[0],
                    r = t[1],
                    i = [r[0] + n[
                        0], r[1] +
                    n[1]
                    ];
                return `\\operatorname{vector}\\left(${vn(R, r)},${vn(R, i)}\\right)`;
            case pe:
                return "\\operatorname{circle}\\left(" +
                    [vn(R, t[0]),
                    vn(T, t[1])
                    ].join(",") +
                    "\\right)";
            case ce:
                return "\\operatorname{arc}\\left(" +
                    [vn(R, t[0]),
                    vn(R, t[1]),
                    vn(R, t[2])
                    ].join(",") +
                    "\\right)";
            case Ge:
                return "\\operatorname{angle}\\left(" +
                    [vn(R, t[0]),
                    vn(T, t[1]),
                    vn(T, t[2])
                    ].join(",") +
                    "\\right)";
            case Ae:
                return "\\operatorname{directedangle}\\left(" +
                    [vn(R, t[0]),
                    vn(T, t[1]),
                    vn(T, t[2])
                    ].join(",") +
                    "\\right)";
            case mn:
                return `\\operatorname{tone}\\left(${vn(T, t[0])},${vn(T, t[1])}\\right)`;
            default:
                throw new Error(
                    "Cannot serialize a value of type " +
                    ne(e) + ".")
        }
    }

    function ZE(e) {
        let t = {};
        for (let n in e.updateRules)
            t[n] = WE(e, n);
        return t
    }

    function WE(e, t) {
        let {
            valueType: n,
            value: r
        } = e.updateRules[t];
        return `${ur(t)}=${vn(n, r)}`
    }
    var xs = class {
        constructor(t) {
            this.xtolerance =
                t
                    .xtolerance ||
                t
                    .tolerance ||
                0, this
                    .ytolerance =
                t
                    .ytolerance ||
                t
                    .tolerance ||
                0, this
                    .ztolerance =
                t
                    .ztolerance ||
                t
                    .tolerance ||
                0, this
                    .map = t
                    .map, this
                        .segments = [],
                this
                    .segment = [],
                this
                    .pivotPoint =
                void 0, this
                    .pendingPoint =
                void 0
        }
        colinear(t, n, r) {
            let i = this
                .map(t),
                s = this
                    .map(n),
                o = this
                    .map(r);
            var a = Rs(o[0],
                o[1], o[
                2
                ] ||
            0, i[0],
                i[1], i[
                2
                ] ||
            0, s[0],
                s[1], s[
                2
                ] ||
            0);
            if (a < 1)
                return !1;
            var u = [i[0] +
                a * (s[
                    0] -
                    i[0]
                ),
            i[1] +
            a * (s[
                1] -
                i[1]
            ), i
                .length ===
                3 ? i[
                2] + a *
            (s[2] -
                i[2]
            ) :
                0
            ];
            return Math.abs(
                o[0] -
                u[0]) <=
                this
                    .xtolerance &&
                Math.abs(o[
                    1] -
                    u[1]) <=
                this
                    .ytolerance &&
                (i.length ===
                    2 ||
                    Math
                        .abs(o[
                            2] -
                            u[2]
                        ) <=
                    this
                        .ztolerance
                )
        }
        addPoint(t) {
            if (this
                .dimensions =
                t.length,
                this
                    .xtolerance <
                0 && this
                    .ytolerance <
                0 && (this
                    .dimensions ===
                    2 ||
                    this
                        .ztolerance <
                    0)) {
                this.segment
                    .push
                    .apply(
                        this
                            .segment,
                        t);
                return
            }
            if (!this
                .segment
                .length) {
                this.segment
                    .push
                    .apply(
                        this
                            .segment,
                        t);
                return
            }
            let n = this
                .dimensions ===
                2 ? [this
                    .segment[
                    this
                        .segment
                        .length -
                    2],
                this
                    .segment[
                this
                    .segment
                    .length -
                1]
            ] : [this
                .segment[
                this
                    .segment
                    .length -
                3],
            this
                .segment[
            this
                .segment
                .length -
            2],
            this
                .segment[
            this
                .segment
                .length -
            1]
            ];
            if (!(t[0] ===
                n[0] &&
                t[1] ===
                n[1] &&
                t[2] ===
                n[2])) {
                if (!this
                    .pivotPoint ||
                    !this
                        .pendingPoint
                ) {
                    this.pivotPoint =
                        t,
                        this
                            .pendingPoint =
                        t;
                    return
                } (!this
                    .colinear(
                        n,
                        this
                            .pivotPoint,
                        t
                    ) ||
                    as(n[
                        0] -
                        t[
                        0],
                        n[
                        1] -
                        t[
                        1],
                        (n[2] ||
                            0
                        ) -
                        (t[2] ||
                            0
                        )
                    ) <
                    as(n[
                        0] -
                        this
                            .pendingPoint[
                        0
                        ],
                        n[
                        1] -
                        this
                            .pendingPoint[
                        1
                        ],
                        (n[2] ||
                            0
                        ) -
                        (this
                            .pendingPoint[
                            2
                        ] ||
                            0
                        )
                    )
                ) && (
                        this
                            .flushPending(),
                        this
                            .pivotPoint =
                        t), this
                            .pendingPoint =
                    t
            }
        }
        flushPending() {
            this.pendingPoint &&
                (this
                    .segment
                    .push
                    .apply(
                        this
                            .segment,
                        this
                            .pendingPoint
                    ),
                    this
                        .pivotPoint =
                    void 0,
                    this
                        .pendingPoint =
                    void 0)
        }
        breakSegment() {
            this.flushPending(),
                this.segment
                    .length > (
                    this
                        .dimensions ||
                    2) &&
                this
                    .segments
                    .push(this
                        .segment
                    ), this
                        .segment = []
        }
        getSegments() {
            return this
                .breakSegment(),
                this
                    .segments
        }
        finish() {
            return {
                segments: this
                    .getSegments(),
                resolved: !0
            }
        }
    };
    var XR = 5,
        s2 = Math.pow(2, 14),
        {
            abs: Hs
        } = Math;

    function ud(e, t) {
        let n = o2(e, t);
        return {
            segments: n.contours
                .strokeSegments,
            fillSegments: n.contours
                .fillSegments,
            resolved: n.quadTree
                .resolved
        }
    }

    function o2(e, t) {
        let n = Math.pow(2, -XR),
            r = YR(t, n),
            i = YR(t, 2 * n),
            s = a2(e, r, i),
            o = m2(s.root, e, r),
            a = x2(o, e, r);
        return {
            paddedDomain: r,
            rootDomain: i,
            quadTree: s,
            triangles: o,
            contours: a
        }
    }

    function gp(e, t, n) {
        return {
            x: e,
            y: t,
            z: n
        }
    }

    function Eu(e, t, n) {
        return {
            x: e,
            y: t,
            isZero: n
        }
    }

    function Fg(e, t, n) {
        return {
            vertices: [e, t, n],
            visited: !1,
            next: void 0
        }
    }

    function YR(e, t) {
        let {
            mathToPixels: n
        } = e, r = n.interpolateX(e
            .xmin, e.xmax, -t),
            i = n.interpolateX(e
                .xmax, e.xmin, -t),
            s = n.interpolateY(e
                .ymin, e.ymax, -t),
            o = n.interpolateY(e
                .ymax, e.ymin, -t);
        return {
            ...e,
            xmin: r,
            ymin: s,
            xmax: i,
            ymax: o
        }
    }

    function sd(e, t) {
        return {
            depth: e,
            vertices: t,
            children: void 0,
            center: void 0
        }
    }

    function jE(e, t, n) {
        e.center = ZR(e.vertices[0],
            e.vertices[1], e
                .vertices[2], e
                    .vertices[3], t, n)
    }

    function a2(e, t, n) {
        let r = u2(e, n),
            i = [],
            s = [];
        s.push(r);
        let o = 1,
            a = !0;
        e: for (; s.length;) {
            let u = i;
            i = s, s = u;
            let c;
            for (; c = i.pop();)
                if (l2(c, e,
                    t)) {
                    if (c2(c, e,
                        t),
                        !c
                            .children
                    ) {
                        a = !1;
                        break e
                    }
                    if (s.push(c
                        .children[
                        0
                    ]
                    ), s
                        .push(c
                            .children[
                            1
                        ]
                        ), s
                            .push(c
                                .children[
                                2
                            ]
                            ), s
                                .push(c
                                    .children[
                                    3
                                ]
                                ),
                        o += 3,
                        o >= s2
                    ) {
                        a = !1;
                        break e
                    }
                } else jE(c, e,
                    t)
        }
        for (let u = 0; u < i
            .length; u++) jE(i[u],
                e, t);
        for (let u = 0; u < s
            .length; u++) jE(s[u],
                e, t);
        return {
            root: r,
            resolved: a
        }
    }

    function u2(e, t) {
        let n = t.xmin,
            r = t.xmax,
            i = t.ymin,
            s = t.ymax;
        return sd(0, [yp(n, s, e),
        yp(r, s, e), yp(
            r, i, e),
        yp(n, i, e)
        ])
    }

    function c2(e, t, n) {
        let r = e.depth + 1,
            i = e.vertices[0],
            s = e.vertices[1],
            o = e.vertices[2],
            a = e.vertices[3],
            u = ci(i, s, t, n),
            c = ci(s, o, t, n),
            l = ci(o, a, t, n),
            p = ci(a, i, t, n),
            f = ci(i, o, t, n);
        e.children = [sd(r, [i, u,
            f, p
        ]), sd(r, [u, s, c,
            f
        ]), sd(r, [f, c, o,
            l
        ]), sd(r, [p, f, l,
            a
        ])]
    }

    function l2(e, t, n) {
        if (e.depth < XR) return !0;
        if (f2(e, n) || p2(e, n))
            return !1;
        let r = e.vertices[0],
            i = e.vertices[1],
            s = e.vertices[2],
            o = e.vertices[3];
        if (isNaN(r.z) && isNaN(i
            .z) && isNaN(s.z) &&
            isNaN(o.z)) return !1;
        if (isNaN(r.z) || isNaN(i
            .z) || isNaN(s.z) ||
            isNaN(o.z)) return !0;
        let a = ZR(r, i, s, o, t,
            n),
            u = ra(r, i, t, n),
            c = ra(i, s, t, n),
            l = ra(s, o, t, n),
            p = ra(o, r, t, n);
        return vu(r, u, t, n) || vu(
            i, u, t, n) || vu(i,
                c, t, n) || vu(s, c,
                    t, n) || vu(s, l, t,
                        n) || vu(o, l, t,
                            n) || vu(o, p, t, n) ||
            vu(r, p, t, n) || Mu(r,
                u, a, t, n) || Mu(u,
                    i, a, t, n) || Mu(i,
                        c, a, t, n) || Mu(c,
                            s, a, t, n) || Mu(s,
                                l, a, t, n) || Mu(l,
                                    o, a, t, n) || Mu(o,
                                        p, a, t, n) || Mu(p,
                                            r, a, t, n)
    }

    function Mu(e, t, n, r, i) {
        if (e.z > 0 == t.z > 0 && t
            .z > 0 == n.z > 0)
            return !1;
        let s = 0;
        isFinite(e.z) && (s = Math
            .max(s, Math.abs(e
                .z))), isFinite(
                    t.z) && (s = Math
                        .max(s, Math.abs(t
                            .z))), isFinite(
                                n.z) && (s = Math
                                    .max(s, Math.abs(n
                                        .z)));
        let o = 32 * Number
            .EPSILON * s,
            a, u, c, l;
        if (e.z > 0 == t.z > 0) {
            if (a = ci(e, t, r, i),
                a.z > 0 != e.z > 0)
                return !0;
            u = na(e, n, r, i, o),
                c = na(t, n, r, i,
                    o), l = na(a, n,
                        r, i, o)
        } else if (t.z > 0 == n.z >
            0) {
            if (a = ci(t, n, r, i),
                a.z > 0 != t.z > 0)
                return !0;
            u = na(t, e, r, i, o),
                c = na(n, e, r, i,
                    o), l = na(a, e,
                        r, i, o)
        } else {
            if (a = ci(n, e, r, i),
                a.z > 0 != n.z > 0)
                return !0;
            u = na(n, t, r, i, o),
                c = na(e, t, r, i,
                    o), l = na(a, t,
                        r, i, o)
        }
        let {
            mathToPixels: p,
            map3d: f
        } = i;
        if (f) {
            let g = f(l.x, l.y),
                d = f(u.x, u.y),
                y = f(c.x, c.y);
            var m = kM(g[0], g[1],
                g[2], d[0], d[
            1], d[2], y[0],
                y[1], y[2]);
            return m > i.tolerance
        } else {
            let [g, d] = p
                .mapCoordinatePair([
                    l.x, l.y
                ]), [y, h] = p
                    .mapCoordinatePair([
                        u.x, u.y
                    ]), [b, x] = p
                        .mapCoordinatePair([
                            c.x, c.y
                        ]);
            return GM(g, d, y, h, b,
                x) > i.tolerance
        }
    }

    function vu(e, t, n, r) {
        if (isNaN(e.z) && isNaN(t
            .z)) return !1;
        if (isNaN(e.z) || isNaN(t
            .z)) return e.z > 0 || t
                .z > 0;
        let s = 4 * ci(e, t, n, r)
            .z - t.z - 3 * e.z,
            o = 1e-4,
            a = (n((1 - o) * e.x +
                o * t.x, (1 -
                    o) * e.y + o * t
                        .y) - e.z) / o,
            u = Math.max(Math.abs(e
                .z), Math.abs(t
                    .z));
        return Math.abs(s - a) >
            .125 * u
    }

    function p2(e, t) {
        let {
            mathToPixels: n,
            map3d: r,
            tolerance: i
        } = t;
        if (r) return !1;
        {
            let [s, o] = n
                .mapCoordinatePair([
                    e.vertices[
                        1].x, e
                            .vertices[1]
                        .y
                ]), [a, u] = n
                    .mapCoordinatePair([
                        e.vertices[
                            0].x, e
                                .vertices[0]
                            .y
                    ]), [c, l] = n
                        .mapCoordinatePair([
                            e.vertices[
                                3].x, e
                                    .vertices[3]
                                .y
                        ]);
            if (Hs(s - a) < 10 *
                i || Hs(u - l) <
                10 * i) return !0
        }
        return !1
    }

    function f2(e, t) {
        return e.vertices[0].x < t
            .xmin || e.vertices[0]
                .y > t.ymax || e
                    .vertices[2].x > t
                .xmax || e.vertices[2]
                    .y < t.ymin
    }

    function hp(e, t) {
        return e.x < t.xmin || e.x >
            t.xmax || e.y < t
                .ymin || e.y > t.ymax
    }

    function yp(e, t, n) {
        return gp(e, t, n(e, t))
    }

    function ci(e, t, n, r) {
        let {
            mathToPixels: i
        } = r;
        return yp(i.interpolateX(e
            .x, t.x, .5), i
                .interpolateY(e.y, t
                    .y, .5), n)
    }

    function ra(e, t, n, r) {
        if (hp(e, r) || hp(t, r))
            return ci(e, t, n, r);
        if (isNaN(e.z) || isNaN(t
            .z)) return d2(e, t, n,
                r);
        if (e.z > 0 != t.z > 0)
            return ci(e, t, n, r);
        let i = .01,
            s = n((1 - i) * e.x +
                i * t.x, (1 - i) * e
                    .y + i * t.y) - e.z,
            o = t.z - n(i * e.x + (
                1 - i) * t.x,
                i * e.y + (1 - i) *
                t.y);
        return isNaN(s) || isNaN(
            o) || s > 0 == o > 0 ?
            ci(e, t, n, r) : WR(gp(e
                .x, e.y, s), gp(
                    t.x, t.y, o), n,
                r)
    }

    function ZR(e, t, n, r, i, s) {
        let o = ra(e, n, i, s);
        return e.z > 0 == n.z > 0 &&
            o.z > 0 != e.z > 0 || (
                o = ra(t, r, i, s),
                t.z > 0 == r.z >
                0 && o.z > 0 != t
                    .z > 0) ? o : ci(e,
                        n, i, s)
    }

    function WR(e, t, n, r) {
        if (isNaN(e.z)) return t;
        if (isNaN(t.z)) return e;
        if (!isFinite(e.z) && !
            isFinite(t.z))
            return ci(e, t, n, r);
        if (isFinite(e.z))
            if (isFinite(t.z)) {
                let i = 1 - e.z / t
                    .z,
                    s = 1 - t.z / e
                        .z;
                return yp(e.x / i +
                    t.x / s, e
                        .y / i + t
                            .y / s, n)
            } else return e;
        else return t
    }

    function na(e, t, n, r, i) {
        let {
            mathToPixels: s,
            map3d: o
        } = r, a = e.x, u = t.x, c =
                e.y, l = t.y, p = e.z,
            f = t.z;
        if (hp(e, r) || hp(t, r)) {
            let m = ci(e, t, n, r);
            return Eu(m.x, m.y, !1)
        }
        if (o) {
            let [m, g, d] = o(a, c),
                [y, h, b] = o(u, l);
            for (; Hs(m - y) > r
                .tolerance || Hs(g -
                    h) > r
                    .tolerance || Hs(d -
                        b) > r
                    .tolerance;) {
                let x = .5 * (a +
                    u),
                    P = .5 * (c +
                        l),
                    M = n(x, P);
                if (M > 0 == p > 0 ?
                    (a = x, c = P,
                        p = M) : (
                        u = x, l =
                        P, f = M), (
                            x === a ||
                            x === u) &&
                    (P === c ||
                        P === l))
                    break;
                [m, g, d] = o(a, c),
                    [y, h, b] = o(u,
                        l)
            }
        } else {
            let [m, g] = s
                .mapCoordinatePair([
                    a, c
                ]), [d, y] = s
                    .mapCoordinatePair([
                        u, l
                    ]);
            for (; Hs(m - d) > r
                .tolerance || Hs(g -
                    y) > r
                    .tolerance;) {
                let h = .5 * (a +
                    u),
                    b = .5 * (c +
                        l),
                    x = n(h, b);
                x > 0 == p > 0 ? (
                    a = h, c =
                    b, p = x) :
                    (u = h, l = b,
                        f = x), [m,
                            g
                        ] = s
                            .mapCoordinatePair(
                                [a, c]), [d,
                                    y
                                ] = s
                                    .mapCoordinatePair(
                                        [u, l])
            }
        }
        if (isNaN(p)) return Eu(u,
            l, !1);
        if (isNaN(f)) return Eu(a,
            c, !1);
        {
            let m = Math.abs(p),
                g = Math.abs(f);
            if (m < i && g > 100 *
                i) return 1 / m >=
                    g ? Eu(a, c, !
                        0) : Eu(u, l, !
                            1);
            if (g < i && m > 100 *
                i) return 1 / g >=
                    m ? Eu(u, l, !
                        0) : Eu(a, c, !
                            1);
            let d = WR(gp(a, c, p),
                gp(u, l, f), n,
                r),
                y = p === 0 || f ===
                    0 || d.z === 0 || d
                        .z >= p == f >= d
                            .z && Math.abs(d
                                .z) < 1e250;
            return Eu(d.x, d.y, y)
        }
    }

    function d2(e, t, n, r) {
        let {
            mathToPixels: i,
            map3d: s
        } = r;
        if (isNaN(e.z) === isNaN(t
            .z)) return ci(e, t,
                n, r);
        if (isNaN(e.z)) {
            let p = e;
            e = t, t = p
        }
        let o = e.x,
            a = t.x,
            u = e.y,
            c = t.y,
            l = e.z;
        if (s) {
            let [p, f, m] = s(o, u),
                [g, d, y] = s(a, c);
            for (; Hs(p - g) > r
                .tolerance || Hs(f -
                    d) > r
                    .tolerance || Hs(m -
                        y) > r
                    .tolerance || isNaN(
                        p) || isNaN(g);
            ) {
                let h = .5 * (o +
                    a),
                    b = .5 * (u +
                        c),
                    x = n(h, b);
                if (isNaN(x) ===
                    isNaN(l) ? (o =
                        h, u = b,
                        l = x) : (
                    a = h, c = b
                ), (h ===
                    o || h === a
                ) && (b ===
                    u || b === c
                    )) break;
                [p, f, m] = s(o, u),
                    [g, d, y] = s(a,
                        c)
            }
        } else {
            let [p, f] = i
                .mapCoordinatePair([
                    o, u
                ]), [m, g] = i
                    .mapCoordinatePair([
                        a, c
                    ]);
            for (; Hs(p - m) > r
                .tolerance || Hs(f -
                    g) > r
                    .tolerance;) {
                let d = .5 * (o +
                    a),
                    y = .5 * (u +
                        c),
                    h = n(d, y);
                isNaN(h) === isNaN(
                    l) ? (o = d,
                        u = y, l = h
                ) : (a = d,
                    c = y), [p,
                        f
                    ] = i
                        .mapCoordinatePair(
                            [o, u]), [m,
                                g
                            ] = i
                                .mapCoordinatePair(
                                    [a, c])
            }
        }
        return gp(o, u, l)
    }

    function m2(e, t, n) {
        let r = {
            triangles: [],
            edgeCache: {},
            domain: n,
            fn: t
        };
        return od(e, r), r.triangles
    }

    function od(e, t) {
        e.children && (od(e
            .children[0], t
        ), od(e
            .children[1], t
        ), od(e
            .children[2], t
        ), od(e
            .children[3], t
        ), Du(e
            .children[0], e
                .children[1], t
        ), Du(e
            .children[3], e
                .children[2], t
        ), Su(e
            .children[1], e
                .children[2], t
        ), Su(e
            .children[0], e
                .children[3], t)
        )
    }

    function Du(e, t, n) {
        e.children && t.children ? (
            Du(e.children[1], t
                .children[0], n
            ), Du(e
                .children[2], t
                    .children[3], n)
        ) : e.children ? (
            Du(e.children[1], t,
                n), Du(e
                    .children[2], t,
                    n)) : t
                        .children ? (Du(e, t
                            .children[0], n
                        ), Du(e, t
                            .children[3], n)
        ) : y2(e, t, n)
    }

    function Su(e, t, n) {
        e.children && t.children ? (
            Su(e.children[2], t
                .children[1], n
            ), Su(e
                .children[3], t
                    .children[0], n)
        ) : e.children ? (
            Su(e.children[2], t,
                n), Su(e
                    .children[3], t,
                    n)) : t
                        .children ? (Su(e, t
                            .children[1], n
                        ), Su(e, t
                            .children[0], n)
        ) : g2(e, t, n)
    }

    function y2(e, t, n) {
        if (!e.center || !t.center)
            return;
        let r, i;
        e.depth >= t.depth ? (r =
            ra(e.vertices[1], e
                .vertices[2], n
                .fn, n.domain),
            i = Gg(e.vertices[
                1], t.center, e
                    .vertices[2], e
                .center, r)) : (
            r = ra(t.vertices[
                0], t.vertices[
            3], n.fn, n
                .domain), i =
            Gg(t.vertices[0], t
                .center, t
                    .vertices[3], e
                .center, r)),
            jR(i, n.edgeCache, n
                .domain);
        for (let s = 0; s < 4; s++)
            n.triangles.push(i[s])
    }

    function g2(e, t, n) {
        if (!e.center || !t.center)
            return;
        let r, i;
        e.depth >= t.depth ? (r =
            ra(e.vertices[3], e
                .vertices[2], n
                .fn, n.domain),
            i = Gg(e.vertices[
                2], t.center, e
                    .vertices[3], e
                .center, r)) : (
            r = ra(t.vertices[
                1], t.vertices[
            0], n.fn, n
                .domain), i =
            Gg(t.vertices[1], t
                .center, t
                    .vertices[0], e
                .center, r)),
            jR(i, n.edgeCache, n
                .domain);
        for (let s = 0; s < 4; s++)
            n.triangles.push(i[s])
    }

    function Gg(e, t, n, r, i) {
        return [Fg(e, i, t), Fg(t,
            i, n), Fg(n, i,
                r), Fg(r, i, e)]
    }

    function ad(e, t, n) {
        return e.z > 0 && !hp(e,
            n) && (!(t.z > 0) || hp(
                t, n))
    }

    function Vg(e, t) {
        return "" + e.x + "," + e
            .y + "," + t.x + "," + t
                .y
    }

    function jR(e, t, n) {
        Bg(e[0], e[1], e[2], Vg(e[1]
            .vertices[2], e[
                1].vertices[
        0]), t, n), Bg(
            e[1], e[2], e[3],
            Vg(e[2].vertices[0],
                e[2].vertices[2]
            ), t, n), Bg(e[
                2], e[3], e[0],
                Vg(e[3].vertices[2],
                    e[3].vertices[0]
                ), t, n), Bg(e[
                    3], e[0], e[1],
                    Vg(e[0].vertices[0],
                        e[0].vertices[2]
                    ), t, n)
    }

    function Bg(e, t, n, r, i, s) {
        let o = t.vertices[0],
            a = t.vertices[1],
            u = t.vertices[2];
        ad(a, u, s) && (t.next = n),
            ad(o, a, s) && (t.next =
                e), ad(u, o, s) &&
            b2(t, r, i), ad(o, u,
                s) && h2(t, r, i)
    }

    function h2(e, t, n) {
        n[t] ? n[t].next = e : n[
            t] = e
    }

    function b2(e, t, n) {
        n[t] ? e.next = n[t] : n[
            t] = e
    }

    function x2(e, t, n) {
        let {
            tolerance: r,
            mathToPixels: i,
            map3d: s
        } = n, o;
        if (s) {
            let a = {
                tolerance: r,
                map: u => s(u[
                    0], u[1]
                )
            };
            o = {
                fillAccumulator: new xs(
                    a),
                strokeAccumulator: new xs(
                    a),
                fn: t,
                domain: n
            }
        } else {
            let a = {
                tolerance: r,
                map: u => i
                    .mapCoordinatePair(
                        u)
            };
            o = {
                fillAccumulator: new xs(
                    a),
                strokeAccumulator: new xs(
                    a),
                fn: t,
                domain: n
            }
        }
        for (let a = 0; a < e
            .length; a++) {
            let u = e[a];
            u.next && !u.visited &&
                P2(u, o)
        }
        return {
            strokeSegments: o
                .strokeAccumulator
                .finish().segments,
            fillSegments: o
                .fillAccumulator
                .finish().segments
        }
    }

    function P2(e, t) {
        for (; ;) {
            let n = e.vertices[0],
                r = e.vertices[1],
                i = e.vertices[2],
                s = 0;
            isFinite(n.z) && (s =
                Math.max(s, Math
                    .abs(n.z))),
                isFinite(r.z) && (
                    s = Math.max(s,
                        Math.abs(r
                            .z))),
                isFinite(i.z) && (
                    s = Math.max(s,
                        Math.abs(i
                            .z)));
            let o = 32 * Number
                .EPSILON * s;
            if (JE(n, r, t, o), JE(
                r, i, t, o), JE(
                    i, n, t, o), e
                        .visited || !e.next)
                break;
            e.visited = !0, e = e
                .next
        }
        t.strokeAccumulator
            .breakSegment(), t
                .fillAccumulator
                .breakSegment()
    }

    function JE(e, t, n, r) {
        if (ad(e, t, n.domain)) {
            let i = na(e, t, n.fn, n
                .domain, r);
            n.fillAccumulator
                .addPoint([i.x, i
                    .y]), i.isZero ?
                    n.strokeAccumulator
                        .addPoint([i.x, i
                            .y]) : n
                                .strokeAccumulator
                                .breakSegment()
        }
    }
    var rs = {
        pointsOfInterest: !0,
        plotSingleVariableImplicitEquations:
            !0,
        plotImplicits: !0,
        plotInequalities: !0,
        sliders: !0
    };

    function QE(e) {
        return Math.abs(e) < 5e-8
    }
    var cd = class extends xs {
        constructor(t, n, r) {
            let {
                tolerance: i,
                mathToPixels: s
            } = t;
            super({
                tolerance: i,
                map: o =>
                    s
                        .mapCoordinatePair(
                            o
                        )
            }), this
                .fn = n,
                this
                    .mappedFn =
                o => s.mapY(
                    n(o)),
                this
                    .derivative =
                r, this
                    .poiData = {
                    zeros: {
                        x: [],
                        y: []
                    },
                    intercept: {
                        x: [],
                        y: []
                    },
                    extrema: {
                        x: [],
                        y: []
                    }
                }, this
                    .zeroBuffer = [],
                this
                    .extremumBuffer = []
        }
        getPOI() {
            return rs
                .pointsOfInterest ?
                (this
                    .poiData
                    .intercept =
                    this
                        .findIntercept(
                            this
                                .fn
                        ),
                    this
                        .poiData
                ) : {
                    zeros: {
                        x: [],
                        y: []
                    },
                    intercept: {
                        x: [],
                        y: []
                    },
                    extrema: {
                        x: [],
                        y: []
                    }
                }
        }
        addPoint(t) {
            this.segment
                .length ===
                0 && QE(t[
                    1]) && (
                    this
                        .poiData
                        .zeros.x
                        .push(t[
                            0]),
                    this
                        .poiData
                        .zeros.y
                        .push(t[
                            1])
                ), this
                    .updateZeroBuffer(
                        t), this
                            .updateExtremumBuffer(
                                t),
                super
                    .addPoint(t)
        }
        updateZeroBuffer(t) {
            let [n, r] =
                this.map ? this
                    .map(t) : t;
            if (!isFinite(
                n) || !
                isFinite(r)
            ) {
                this.zeroBuffer
                    .length =
                    0;
                return
            }
            switch (this
                .zeroBuffer
                .length) {
                case 0: {
                    if (QE(t[
                        1]))
                        return;
                    this.zeroBuffer
                        .push(
                            t
                        );
                    return
                }
                case 1:
                    if (t[
                        1] ===
                        0) {
                        this.zeroBuffer
                            .push(
                                t
                            );
                        return
                    } else if (
                        t[
                        1] >
                        0 !=
                        this
                            .zeroBuffer[
                        0
                        ]
                        [
                        1] >
                        0) {
                        let i =
                            kT(this
                                .zeroBuffer[
                                0
                            ]
                            [
                                0],
                                this
                                    .zeroBuffer[
                                0
                                ]
                                [
                                1],
                                t[
                                0],
                                t[
                                1],
                                this
                                    .fn
                            );
                        i && (this
                            .poiData
                            .zeros
                            .x
                            .push(
                                i[
                                0]
                            ),
                            this
                                .poiData
                                .zeros
                                .y
                                .push(
                                    i[
                                    1]
                                )
                        ),
                            this
                                .zeroBuffer
                                .length =
                            0,
                            this
                                .zeroBuffer
                                .push(
                                    t
                                );
                        return
                    } else {
                        this.zeroBuffer
                            .length =
                            0,
                            this
                                .zeroBuffer
                                .push(
                                    t
                                );
                        return
                    }
                case 2: {
                    if (t[
                        1] ===
                        0)
                        return;
                    if (t[
                        1] >
                        0 !=
                        this
                            .zeroBuffer[
                        0
                        ]
                        [
                        1] >
                        0) {
                        let i =
                            vf(this
                                .zeroBuffer[
                                0
                            ]
                            [
                                0],
                                this
                                    .zeroBuffer[
                                0
                                ]
                                [
                                1],
                                this
                                    .zeroBuffer[
                                1
                                ]
                                [
                                0],
                                this
                                    .zeroBuffer[
                                1
                                ]
                                [
                                1],
                                t[
                                0],
                                t[
                                1],
                                this
                                    .fn
                            );
                        i && (this
                            .poiData
                            .zeros
                            .x
                            .push(
                                i[
                                0]
                            ),
                            this
                                .poiData
                                .zeros
                                .y
                                .push(
                                    i[
                                    1]
                                )
                        ),
                            this
                                .zeroBuffer
                                .length =
                            0,
                            this
                                .zeroBuffer
                                .push(
                                    t
                                );
                        return
                    } else {
                        this.zeroBuffer
                            .length =
                            0,
                            this
                                .zeroBuffer
                                .push(
                                    t
                                );
                        return
                    }
                }
            }
        }
        updateExtremumBuffer(
            t) {
            let [n, r] =
                this.map ? this
                    .map(t) : t;
            if (!isFinite(
                n) || !
                isFinite(r)
            ) {
                this.extremumBuffer
                    .length =
                    0;
                return
            }
            switch (this
                .extremumBuffer
                .length) {
                case 0: {
                    this.extremumBuffer
                        .push(
                            t
                        );
                    return
                }
                case 1: {
                    t[1] ===
                        this
                            .extremumBuffer[
                        0
                        ]
                        [
                        1] &&
                        (this
                            .extremumBuffer
                            .length =
                            0
                        ),
                        this
                            .extremumBuffer
                            .push(
                                t
                            );
                    return
                }
                case 2:
                    if (t[
                        1] ===
                        this
                            .extremumBuffer[
                        1
                        ]
                        [1]
                    ) {
                        this.extremumBuffer
                            .push(
                                t
                            );
                        return
                    } else if (
                        t[
                        1] >
                        this
                            .extremumBuffer[
                        1
                        ]
                        [
                        1] !=
                        this
                            .extremumBuffer[
                        1
                        ]
                        [
                        1] >
                        this
                            .extremumBuffer[
                        0
                        ]
                        [1]
                    ) {
                        let i =
                            this
                                .bisectExtremumUsingDerivative(
                                    this
                                        .extremumBuffer[
                                    0
                                    ]
                                    [
                                    0],
                                    this
                                        .extremumBuffer[
                                    0
                                    ]
                                    [
                                    1],
                                    this
                                        .extremumBuffer[
                                    1
                                    ]
                                    [
                                    0],
                                    this
                                        .extremumBuffer[
                                    1
                                    ]
                                    [
                                    1],
                                    t[
                                    0],
                                    t[
                                    1]
                                );
                        i && (this
                            .poiData
                            .extrema
                            .x
                            .push(
                                i[
                                0]
                            ),
                            this
                                .poiData
                                .extrema
                                .y
                                .push(
                                    i[
                                    1]
                                ),
                            !
                            Hl(this
                                .extremumBuffer[
                                0
                            ]
                            [
                                0],
                                this
                                    .mappedFn(
                                        this
                                            .extremumBuffer[
                                        0
                                        ]
                                        [
                                        0]
                                    ),
                                i[
                                0],
                                this
                                    .mappedFn(
                                        i[
                                        0]
                                    ),
                                t[
                                0],
                                this
                                    .mappedFn(
                                        t[
                                        0]
                                    ),
                                this
                                    .mappedFn,
                                this
                                    .ytolerance
                            ) &&
                            i[
                            0] >
                            this
                                .segment[
                            this
                                .segment
                                .length -
                            2
                            ] &&
                            (this
                                .pendingPoint =
                                i
                            )
                        ),
                            this
                                .extremumBuffer
                                .shift(),
                            this
                                .extremumBuffer
                                .push(
                                    t
                                );
                        return
                    } else {
                        this.extremumBuffer
                            .shift(),
                            this
                                .extremumBuffer
                                .push(
                                    t
                                );
                        return
                    }
                case 3: {
                    if (t[
                        1] ===
                        this
                            .extremumBuffer[
                        1
                        ]
                        [1])
                        return;
                    if (t[
                        1] >
                        this
                            .extremumBuffer[
                        1
                        ]
                        [
                        1] !=
                        this
                            .extremumBuffer[
                        1
                        ]
                        [
                        1] >
                        this
                            .extremumBuffer[
                        0
                        ]
                        [1]
                    ) {
                        let i,
                            s =
                                .5 *
                                (this
                                    .extremumBuffer[
                                    1
                                ]
                                [
                                    0] +
                                    this
                                        .extremumBuffer[
                                    2
                                    ]
                                    [
                                    0]
                                ),
                            o =
                                this
                                    .fn(
                                        s);
                        o ===
                            this
                                .extremumBuffer[
                            1
                            ]
                            [
                            1] ?
                            i =
                            vf(this
                                .extremumBuffer[
                                0
                            ]
                            [
                                0],
                                this
                                    .extremumBuffer[
                                0
                                ]
                                [
                                1],
                                this
                                    .extremumBuffer[
                                1
                                ]
                                [
                                0],
                                this
                                    .extremumBuffer[
                                1
                                ]
                                [
                                1],
                                t[
                                0],
                                t[
                                1],
                                this
                                    .fn
                            ) :
                            i =
                            this
                                .bisectExtremumUsingDerivative(
                                    this
                                        .extremumBuffer[
                                    1
                                    ]
                                    [
                                    0],
                                    this
                                        .extremumBuffer[
                                    1
                                    ]
                                    [
                                    1],
                                    s,
                                    o,
                                    this
                                        .extremumBuffer[
                                    2
                                    ]
                                    [
                                    0],
                                    this
                                        .extremumBuffer[
                                    2
                                    ]
                                    [
                                    1]
                                ),
                            i &&
                            (this
                                .poiData
                                .extrema
                                .x
                                .push(
                                    i[
                                    0]
                                ),
                                this
                                    .poiData
                                    .extrema
                                    .y
                                    .push(
                                        i[
                                        1]
                                    )
                            ),
                            this
                                .extremumBuffer
                                .shift(),
                            this
                                .extremumBuffer
                                .shift(),
                            this
                                .extremumBuffer
                                .push(
                                    t
                                );
                        return
                    } else {
                        this.extremumBuffer
                            .shift(),
                            this
                                .extremumBuffer
                                .shift(),
                            this
                                .extremumBuffer
                                .push(
                                    t
                                );
                        return
                    }
                }
            }
        }
        bisectExtremumUsingDerivative
            (t, n, r, i, s, o) {
            let a;
            if (this
                .derivative
            ) {
                let u = this
                    .derivative(
                        t),
                    c = this
                        .derivative(
                            s);
                if (!isNaN(
                    u) &&
                    !isNaN(
                        c) &&
                    (i > n &&
                        u >
                        0 &&
                        c <
                        0 ||
                        i <
                        n &&
                        u <
                        0 &&
                        c >
                        0)
                ) {
                    let l =
                        kT(t,
                            u,
                            s,
                            c,
                            this
                                .derivative
                        );
                    l && (a = [l[
                        0],
                    this
                        .fn(l[
                            0])
                    ])
                }
            }
            return a || (a =
                UD(t, n,
                    r,
                    i,
                    s,
                    o,
                    this
                        .fn)
            ), a
        }
        breakSegment() {
            this.zeroBuffer
                .length = 0,
                this
                    .extremumBuffer
                    .length = 0,
                this
                    .flushPending(),
                this.segment
                    .length >
                2 && (this
                    .segments
                    .push(
                        this
                            .segment
                    ),
                    QE(this
                        .segment[
                        this
                            .segment
                            .length -
                        1
                    ]
                    ) &&
                    (this
                        .poiData
                        .zeros
                        .x
                        .push(
                            this
                                .segment[
                            this
                                .segment
                                .length -
                            2
                            ]
                        ),
                        this
                            .poiData
                            .zeros
                            .y
                            .push(
                                this
                                    .segment[
                                this
                                    .segment
                                    .length -
                                1
                                ]
                            )
                    )),
                this
                    .segment = []
        }
        findIntercept(t) {
            if (!t) return {
                x: [],
                y: []
            };
            let n = t(0);
            return isFinite(
                n) ? {
                x: [0],
                y: [t(
                    0)]
            } : {
                x: [],
                y: []
            }
        }
        finish() {
            return {
                segments: this
                    .getSegments(),
                resolved: !
                    0,
                poi: this
                    .getPOI()
            }
        }
    };
    var T2 = e => {
        for (var t = [], n = [],
            r = e.length,
            i = 0; i <
            r; i++) t.push(e[i][
                0
            ]), n.push(e[i][1]);
        return {
            defined: {
                x: t,
                y: n
            }
        }
    },
        Us = T2;
    var {
        sin: I2,
        cos: E2
    } = Math, Qe = class e {
        constructor(t = 0, n =
            0, r = 0) {
            this.x = t;
            this.y = n;
            this.z = r
        }
        copy(t) {
            return this.x =
                t.x, this
                    .y = t.y,
                this.z = t
                    .z, this
        }
        set(t, n, r) {
            return this.x =
                t, this.y =
                n, this.z =
                r, this
        }
        clone() {
            return new e(
                this.x,
                this.y,
                this.z)
        }
        equals(t) {
            return t.x ===
                this.x && t
                    .y === this
                    .y && t
                        .z === this
                    .z
        }
        isZero() {
            return this
                .x === 0 &&
                this.y ===
                0 && this
                    .z === 0
        }
        isFinite() {
            return isFinite(
                this.x
            ) &&
                isFinite(
                    this.y
                ) &&
                isFinite(
                    this.z)
        }
        subVectors(t, n) {
            return this.x =
                t.x - n.x,
                this.y = t
                    .y - n.y,
                this.z = t
                    .z - n.z,
                this
        }
        addVectors(t, n) {
            return this.x =
                t.x + n.x,
                this.y = t
                    .y + n.y,
                this.z = t
                    .z + n.z,
                this
        }
        multiply(t) {
            return this.x *=
                t, this.y *=
                t, this.z *=
                t, this
        }
        magnitude() {
            return Math
                .sqrt(this
                    .x *
                    this.x +
                    this.y *
                    this.y +
                    this.z *
                    this.z)
        }
        normalize() {
            return this
                .multiply(
                    1 / this
                        .magnitude()
                ), this
        }
        cross(t) {
            return this
                .crossVectors(
                    this, t)
        }
        crossVectors(t, n) {
            let r = t.x,
                i = t.y,
                s = t.z,
                o = n.x,
                a = n.y,
                u = n.z;
            return this.x =
                i * u - s *
                a, this.y =
                s * o - r *
                u, this.z =
                r * a - i *
                o, this
        }
        dot(t) {
            return this.x *
                t.x + this
                    .y * t.y +
                this.z * t.z
        }
        rotateAroundAxis(t, n) {
            let r = M2(t,
                n);
            return new e(r[
                0] *
                this.x +
                r[1] *
                this.y +
                r[2] *
                this.z,
                r[3] *
                this.x +
                r[4] *
                this.y +
                r[5] *
                this.z,
                r[6] *
                this.x +
                r[7] *
                this.y +
                r[8] *
                this.z)
        }
    };

    function M2(e, t) {
        let n = e.x,
            r = e.y,
            i = e.z,
            s = I2(t),
            o = E2(t),
            a = 1 - o;
        return [a * n * n + o, a *
            n * r + s * i, a *
            n * i - s * r, a *
            r * n - s * i, a *
            r * r + o, a * r *
            i + s * n, a * i *
            n + s * r, a * i *
            r - s * n, a * i *
            i + o
        ]
    }
    var ee = class {
        constructor(t, n) {
            this.min = t;
            this.max = n
        }
        get width() {
            return this
                .max - this
                    .min
        }
    };

    function ld(e, t, n, r, i, s =
        100) {
        if (isFinite(r) || ([r,
            i] = [i, r], [t,
                n] = [n, t]),
            isFinite(i)) return KE(
                e, t, n, r, i, s
            );
        for (; ;) {
            let o = gs(t, n, .5),
                a = e(...o);
            if (a === 0) return o;
            if (!isFinite(a)) n = o,
                i = a;
            else if (r < 0 == a < 0)
                t = o, r = a;
            else return n = o, i =
                a, KE(e, t, n,
                    r, i, s);
            if (s *= .5, s < 1)
                return
        }
    }

    function JR(e, t, n, r, i, s =
        100) {
        if (isFinite(r) || ([r,
            i] = [i, r], [t,
                n] = [n, t]), !
            isFinite(i))
            for (; ;) {
                let o = gs(t, n,
                    .5),
                    a = e(...o);
                if (a === 0)
                    return {
                        posNeg: o
                    };
                if (!isFinite(a))
                    n = o, i = a;
                else if (r < 0 ==
                    a < 0) t = o,
                        r = a;
                else if (r > 0) {
                    n = o, i = a;
                    break
                } else return {
                    posNeg: e0(
                        e,
                        o,
                        t,
                        a,
                        r, s
                    ),
                    posNaN: v2(
                        e,
                        o,
                        n, s
                    )
                };
                if (s *= .5, s <
                    1) {
                    let u = gs(t, n,
                        .5);
                    return r > 0 ? {
                        posNaN: u
                    } : {}
                }
            }
        return {
            posNeg: KE(e, t, n, r,
                i, s)
        }
    }

    function KE(e, t, n, r, i, s) {
        return r > 0 ? e0(e, t, n,
            r, i, s) : e0(e, n,
                t, i, r, s)
    }

    function e0(e, t, n, r, i, s) {
        let o = r - i;
        for (; ;) {
            let a = gs(t, n, .5),
                u = e(...a);
            if (u < 0) n = a, i = u;
            else if (u > 0) t = a,
                r = u;
            else return u === 0 ?
                a : void 0;
            if (s *= .5, s < 1) {
                if (r - i < .1 * o)
                    return gs(t, n,
                        .5);
                if (s < 1e-6) return
            }
        }
    }

    function v2(e, t, n, r) {
        for (; ;) {
            let i = gs(t, n, .5),
                s = e(...i);
            if (!isFinite(s)) n = i;
            else if (s >= 0) t = i;
            else return;
            if (r *= .5, r < 1)
                return gs(t, n, .5)
        }
    }

    function bp(e, t, n, r, i, s,
        o) {
        let [a, u, c] = [new Qe,
        new Qe, new Qe
        ], [l, p, f] = [new Qe,
        new Qe, new Qe
        ], [m, g] = [new Qe,
        new Qe];
        for (let y = 0; y < e
            .length / 3; y++) {
            let h = e[3 * y],
                b = e[3 * y + 1],
                x = e[3 * y + 2];
            a.set(t[3 * h], t[3 *
                h + 1], t[
            3 * h + 2]), u
                .set(t[3 * b], t[3 *
                    b + 1], t[
                3 * b + 2]), c
                    .set(t[3 * x], t[3 *
                        x + 1], t[
                    3 * x + 2]), l
                        .set(n[3 * h], n[3 *
                            h + 1], n[
                        3 * h + 2]), p
                            .set(n[3 * b], n[3 *
                                b + 1], n[
                            3 * b + 2]), f
                                .set(n[3 * x], n[3 *
                                    x + 1], n[
                                3 * x + 2]), m
                                    .subVectors(c, a), g
                                        .subVectors(a, u);
            var d = m.cross(g)
                .normalize();
            if (!(l.dot(d) > o && p
                .dot(d) > o && f
                    .dot(d) > o) ||
                l.dot(p) < 0 || l
                    .dot(f) < 0 || p
                        .dot(f) < 0) {
                let M = t.length /
                    3;
                e[3 * y] = M, e[3 *
                    y + 1] = M +
                    1, e[3 * y +
                    2] = M + 2, t
                        .push(a.x, a.y,
                            a.z), t
                                .push(u.x, u.y,
                                    u.z), t
                                        .push(c.x, c.y,
                                            c.z), n
                                                .push(d.x, d.y,
                                                    d.z), n
                                                        .push(d.x, d.y,
                                                            d.z), n
                                                                .push(d.x, d.y,
                                                                    d.z), r
                                                                        .push(r[2 * h],
                                                                            r[2 * h + 1]
                                                                        ), r.push(r[
                                                                            2 * b],
                                                                            r[2 * b + 1]
                                                                        ), r.push(r[
                                                                            2 * x],
                                                                            r[2 * x + 1]
                                                                        );
                let I = i;
                if (i > 0) {
                    for (let E =
                        0; E <
                        I; E++) s
                            .push(s[I *
                                h +
                                E]);
                    for (let E =
                        0; E <
                        I; E++) s
                            .push(s[I *
                                b +
                                E]);
                    for (let E =
                        0; E <
                        I; E++) s
                            .push(s[I *
                                x +
                                E])
                }
            }
        }
    }
    var kg = [
        [1, 2, 4, 21, 20, 18],
        [0, 1, 3, 20, 19, 18],
        [2, 6, 7, 25, 21, 18],
        [5, 6, 8, 25, 22, 18],
        [5, 9, 11, 23, 22, 18],
        [0, 9, 10, 23, 19, 18],
        [10, 12, 14, 24, 23,
            19],
        [3, 12, 13, 24, 20, 19],
        [4, 13, 15, 24, 21, 20],
        [15, 7, 16, 25, 24, 21],
        [11, 17, 14, 24, 23,
            22],
        [17, 8, 16, 25, 24, 22]
    ],
        Er = [0, 1, 0, 2, 0, 3, 1,
            2, 2, 3, 0, 4, 0, 7, 3,
            7, 4, 7, 0, 5, 1, 5, 4,
            5, 1, 6, 2, 6, 5, 6, 3,
            6, 6, 7, 4, 6, 0, 8, 1,
            8, 2, 8, 3, 8, 4, 8, 5,
            8, 6, 8, 7, 8
        ],
        KR = [
            [0, 2, 3, 8],
            [0, 1, 2, 8],
            [0, 3, 7, 8],
            [0, 4, 7, 8],
            [0, 4, 5, 8],
            [0, 1, 5, 8],
            [1, 5, 6, 8],
            [1, 2, 6, 8],
            [2, 3, 6, 8],
            [3, 6, 7, 8],
            [4, 5, 6, 8],
            [4, 6, 7, 8]
        ],
        eN = [
            [0, 0, 0],
            [0, 1, 0],
            [1, 1, 0],
            [1, 0, 0],
            [0, 0, 1],
            [0, 1, 1],
            [1, 1, 1],
            [1, 0, 1],
            [.5, .5, .5]
        ],
        t0 = [
            [1, 2, 4],
            [4, 20, 21],
            [2, 18, 21],
            [1, 18, 20],
            [0, 1, 3],
            [3, 19, 20],
            [0, 18, 19],
            [2, 6, 7],
            [7, 21, 25],
            [6, 18, 25],
            [5, 6, 8],
            [8, 22, 25],
            [5, 18, 22],
            [5, 9, 11],
            [11, 22, 23],
            [9, 18, 23],
            [0, 9, 10],
            [10, 19, 23],
            [10, 12, 14],
            [14, 23, 24],
            [12, 19, 24],
            [3, 12, 13],
            [13, 20, 24],
            [4, 13, 15],
            [15, 21, 24],
            [15, 7, 16],
            [16, 24, 25],
            [11, 17, 14],
            [17, 22, 24],
            [17, 8, 16]
        ],
        n0 = [];
    for (let e = 0; e < 30; e++) {
        let t = t0[e],
            n = new Set;
        for (let r of t) n.add(Er[
            r * 2]), n.add(Er[
                r * 2 + 1]);
        n0[e] = [...n]
    }
    var tN = [
        [0, 3, 2, 1],
        [4, 6, 3, 5],
        [7, 2, 9, 8],
        [10, 12, 9, 11],
        [13, 12, 15, 14],
        [16, 6, 15, 17],
        [18, 17, 20, 19],
        [21, 5, 20, 22],
        [23, 1, 22, 24],
        [25, 24, 8, 26],
        [27, 14, 28, 19],
        [29, 28, 11, 26]
    ],
        D2 = 1 << 31,
        S2 = 1 << 30,
        QR = 1 << 24,
        _c = 1 << 24,
        Ps = 1 << 24,
        qs = 65536,
        $s = 256,
        Ys = 1;

    function nN(e, t, n) {
        return n * qs + t * $s + e *
            Ys
    }
    var O2 = {
        0: 0 * QR,
        1: $s,
        2: Ys + $s,
        3: Ys,
        4: qs,
        5: $s + qs,
        6: Ys + $s + qs,
        7: Ys + qs,
        8: 8 * QR
    };

    function rN(e, t) {
        return D2 + e + O2[t]
    }
    var C2 = {
        3: 2 * Ps + $s,
        4: 0 * Ps + Ys,
        7: 5 * Ps + Ys,
        8: 2 * Ps + qs,
        10: 5 * Ps + $s,
        11: 0 * Ps + qs,
        12: 6 * Ps + $s,
        13: 5 * Ps + Ys + $s,
        14: 2 * Ps + $s + qs,
        15: 9 * Ps + Ys,
        16: 0 * Ps + Ys + qs,
        17: 1 * Ps + qs
    };

    function pd(e, t) {
        var n;
        return S2 + e + ((n = C2[
            t]) != null ? n :
            Ps * t)
    }
    var R2 = {
        18: 10 * _c + $s,
        21: 7 * _c + $s,
        23: 16 * _c + Ys,
        25: 13 * _c + Ys,
        27: 4 * _c + qs,
        29: 0 * _c + qs
    };

    function r0(e, t) {
        var n;
        return e + ((n = R2[t]) !=
            null ? n : _c * t)
    }
    var xp = class {
        constructor(t, n, r, i,
            s) {
            this.PAConstructor =
                t;
            this.x = n;
            this.y = r;
            this.z = i;
            this.gridsize =
                s;
            this.i = 0;
            this.j = 0;
            this.k = 0;
            this.cubeVertex =
                new Array(
                    9);
            this.cubeVertexValue =
                new this
                    .PAConstructor(
                        9);
            if (s > 250)
                throw new Error(
                    "Programming Error: resolution should be clamped well below 250."
                );
            this.size =
                new Qe(this
                    .x
                    .width /
                    s, this
                        .y
                        .width /
                s, this
                    .z
                    .width /
                s)
        }
        loopOverUnitCubes(t) {
            let n = this
                .gridsize,
                r = n + 1,
                i = new zg(
                    this.x
                        .min,
                    this.y
                        .min,
                    this.z
                        .min,
                    this
                        .size.x,
                    this
                        .size.y,
                    this
                        .size.z,
                    n + 1,
                    n + 1,
                    n + 1),
                s = new zg(
                    this.x
                        .min +
                    this
                        .size
                        .x / 2,
                    this.y
                        .min +
                    this
                        .size
                        .y / 2,
                    this.z
                        .min +
                    this
                        .size
                        .z / 2,
                    this
                        .size.x,
                    this
                        .size.y,
                    this
                        .size.z,
                    n, n, n
                ),
                o = i
                    .setupArray(
                        this
                            .PAConstructor
                    ),
                a = i
                    .setupArray(
                        this
                            .PAConstructor
                    ),
                u = s
                    .setupArray(
                        this
                            .PAConstructor
                    );
            this.evaluateArray(
                a, i, 0);
            for (let c =
                0; c <
                n; c++) {
                this.k = c,
                    [o,
                        a] = [a,
                        o
                    ], this
                        .evaluateArray(
                            a,
                            i,
                            c +
                            1),
                    this
                        .evaluateArray(
                            u,
                            s, c
                        );
                for (let l =
                    0; l <
                    n; l++
                ) {
                    this.j =
                        l;
                    for (let p =
                        0; p <
                        n; p++
                    ) {
                        this.i =
                            p;
                        let f =
                            l *
                            r +
                            p;
                        this.cubeVertexValue
                            .setFrom(
                                0,
                                o,
                                f
                            ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    1,
                                    o,
                                    f +
                                    r
                                ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    2,
                                    o,
                                    f +
                                    r +
                                    1
                                ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    3,
                                    o,
                                    f +
                                    1
                                ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    4,
                                    a,
                                    f
                                ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    5,
                                    a,
                                    f +
                                    r
                                ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    6,
                                    a,
                                    f +
                                    r +
                                    1
                                ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    7,
                                    a,
                                    f +
                                    1
                                ),
                            this
                                .cubeVertexValue
                                .setFrom(
                                    8,
                                    u,
                                    l *
                                    n +
                                    p
                                ),
                            t()
                    }
                }
            }
        }
        evaluateArray(t, n, r) {
            let i = n.z0 +
                r * n.dz;
            for (let s =
                0; s < n
                    .numX; s++)
                for (let o =
                    0; o <
                    n
                        .numY; o++
                ) {
                    let a =
                        n
                            .x0 +
                        s *
                        n
                            .dx,
                        u =
                            n
                                .y0 +
                            o *
                            n
                                .dy;
                    this.setAt(
                        t,
                        o *
                        n
                            .numX +
                        s,
                        a,
                        u,
                        i
                    )
                }
        }
        setVertexPositions() {
            for (let t =
                0; t <
                9; t++) {
                let n = eN[
                    t];
                this.cubeVertex[
                    t
                ] = [
                        this
                            .x
                            .min +
                        (this
                            .i +
                            n[
                            0]
                        ) *
                        this
                            .size
                            .x,
                        this
                            .y
                            .min +
                        (this
                            .j +
                            n[
                            1]
                        ) *
                        this
                            .size
                            .y,
                        this
                            .z
                            .min +
                        (this
                            .k +
                            n[
                            2]
                        ) *
                        this
                            .size
                            .z
                    ]
            }
        }
    },
        zg = class {
            constructor(t, n, r, i,
                s, o, a, u, c) {
                this.x0 = t;
                this.y0 = n;
                this.z0 = r;
                this.dx = i;
                this.dy = s;
                this.dz = o;
                this.numX = a;
                this.numY = u;
                this.numZ = c
            }
            setupArray(t) {
                return new t(
                    this
                        .numX *
                    this
                        .numY)
            }
        };
    var Hg = class {
        constructor(t) {
            this.length = t;
            this.n = 1;
            this.buffer =
                new Float64Array(
                    t)
        }
        set(t, n) {
            this.buffer[t] =
                n
        }
        get(t) {
            return this
                .buffer[t]
        }
        setFrom(t, n, r) {
            if (n.n !== this
                .n) throw new Error(
                    "Programming Error: Mismatched dimensions"
                );
            this.set(t, n
                .get(r))
        }
    },
        Ug = class {
            constructor(t) {
                this.length = t;
                this.n = 2;
                this.buffer =
                    new Float64Array(
                        t * 2)
            }
            set(t, n, r) {
                this.buffer[t *
                    2] = n,
                    this.buffer[
                    t * 2 +
                    1] = r
            }
            getX(t) {
                return this
                    .buffer[t *
                    2]
            }
            getY(t) {
                return this
                    .buffer[t *
                    2 + 1]
            }
            setFrom(t, n, r) {
                if (n.n !== this
                    .n) throw new Error(
                        "Programming Error: Mismatched dimensions"
                    );
                this.set(t, n
                    .getX(
                        r), n
                            .getY(r)
                )
            }
        };
    var dd = 50;

    function Lc(e) {
        return e !== void 0 && e !==
            0
    }

    function N2(e) {
        return Lc(e.posNeg) || Lc(e
            .posNaN)
    }
    var fd = {};

    function i0(e = fd, t = fd, n =
        fd) {
        return {
            edge0: e,
            edge1: t,
            edge2: n
        }
    }

    function iN(e, t, n, r, {
        isInequality: i
    }) {
        return new s0(e, t, new ee(n
            .xmin, n.xmax),
            new ee(n.ymin, n
                .ymax), new ee(n
                    .zmin, n.zmax),
            r, {
            isInequality: i
        })
            .fullLoopOverUnitCubes()
    }
    var s0 = class extends xp {
        constructor(n, r, i, s,
            o, a, {
                isInequality: u
            }) {
            super(Hg, i, s,
                o, a);
            this.f = n;
            this.gradient =
                r;
            this.cubeEdge =
                new Array(
                    26);
            this.face =
                i0();
            this.cubeHasCrossing = !
                1;
            this.allNormalsFromGradient = !
                0;
            this
                .normalFromGradient = [];
            this.edgesMaybeCross =
                0;
            this
                .positions = [];
            this.uvs = [];
            this
                .normals = [];
            this
                .triangles = [];
            this.isInequality =
                u, this
                    .sheet =
                Array((a +
                    1) *
                    (a + 1)
                ), this
                    .strip =
                Array(a +
                    1);
            for (let c =
                0; c < (a +
                    1) * (
                    a + 1
                ); c++)
                this.sheet[
                    c] =
                    i0();
            for (let c =
                0; c < a +
                1; c++) this
                    .strip[c] =
                    i0()
        }
        setAt(n, r, i, s, o) {
            let a = this.f(
                i, s, o);
            n.set(r, a)
        }
        fullLoopOverUnitCubes
            () {
            this.positions = [],
                this
                    .normals = [],
                this
                    .triangles = [],
                this
                    .loopOverUnitCubes(
                        this
                            .onEachCube
                            .bind(
                                this
                            ));
            let {
                uvs: n,
                positions: r,
                normals: i
            } = this;
            if (!this
                .allNormalsFromGradient
            )
                for (let s =
                    0; s <
                    i
                        .length /
                    3; s++
                ) {
                    if (this
                        .normalFromGradient[
                        s
                    ]
                    )
                        continue;
                    let o =
                        i[3 *
                        s
                        ],
                        a =
                            i[3 *
                            s +
                            1
                            ],
                        u =
                            i[3 *
                            s +
                            2
                            ],
                        c =
                            Math
                                .sqrt(
                                    o *
                                    o +
                                    a *
                                    a +
                                    u *
                                    u
                                );
                    i[3 *
                        s] =
                        o /
                        c,
                        i[3 *
                        s +
                        1
                        ] =
                        a /
                        c,
                        i[3 *
                        s +
                        2
                        ] =
                        u /
                        c
                }
            return bp(this
                .triangles,
                this
                    .positions,
                i, n, 0,
                [], .7
            ), {
                positions: r,
                normals: i,
                faces: this
                    .triangles,
                uvs: n,
                resolved:
                    !0,
                extraAttrs: []
            }
        }
        onEachCube() {
            this.edgesMaybeCross =
                0, this
                    .cubeHasCrossing = !
                1;
            for (let n =
                0; n <
                26; n++) {
                let r = this
                    .cubeVertexValue
                    .get(Er[n *
                        2
                    ]),
                    i = this
                        .cubeVertexValue
                        .get(Er[n *
                            2 +
                            1
                        ]);
                (r === 0 ||
                    i === 0
                ) && (
                        this
                            .cubeHasCrossing = !
                        0), !(
                            r > 0 &&
                            i > 0 ||
                            r < 0 &&
                            i < 0
                        ) && (
                            isFinite(
                                r
                            ) ||
                            isFinite(
                                i)
                        ) && (
                        this
                            .edgesMaybeCross |=
                        1 << n)
            }
            this.edgesMaybeCross &&
                (this
                    .setVertexPositions(),
                    this
                        .setEdges()
                ), this
                    .saveEdges(),
                this
                    .cubeHasCrossing &&
                this
                    .generateTriangles()
        }
        setEdges() {
            let {
                i: n,
                j: r,
                k: i,
                gridsize: s
            } = this, o =
                    this.sheet[(
                        n +
                        0) *
                    (s +
                        1) + r +
                    0], a =
                    this.sheet[(
                        n +
                        1) *
                    (s +
                        1) + r +
                    0], u =
                    this.sheet[(
                        n +
                        0) *
                    (s +
                        1) + r +
                    1], c =
                    0;
            i > 0 && (this
                .cubeEdge[
                0] =
                o.edge0,
                this
                    .cubeEdge[
                1] =
                o.edge1,
                this
                    .cubeEdge[
                2] =
                o.edge2,
                this
                    .cubeEdge[
                3] =
                u.edge2,
                this
                    .cubeEdge[
                4] =
                a.edge0,
                c |= 31
            ), r >
            0 && (this
                .cubeEdge[
                5] =
                this
                    .strip[
                    n]
                    .edge0,
                this
                    .cubeEdge[
                6] =
                this
                    .strip[
                    n]
                    .edge1,
                this
                    .cubeEdge[
                7] =
                this
                    .strip[
                    n +
                    1]
                    .edge0,
                this
                    .cubeEdge[
                8] =
                this
                    .strip[
                    n]
                    .edge2,
                c |=
                480,
                i ==
                0 && (
                    this
                        .cubeEdge[
                    2
                    ] =
                    o
                        .edge2,
                    c |=
                    4)),
                n > 0 && (
                    this
                        .cubeEdge[
                    9] =
                    this
                        .face
                        .edge0,
                    this
                        .cubeEdge[
                    10
                    ] =
                    this
                        .face
                        .edge1,
                    this
                        .cubeEdge[
                    11
                    ] =
                    this
                        .face
                        .edge2,
                    c |=
                    3584,
                    i ==
                    0 && (
                        this
                            .cubeEdge[
                        0
                        ] =
                        o
                            .edge0,
                        c |=
                        1),
                    r ==
                    0 && (
                        this
                            .cubeEdge[
                        5
                        ] =
                        this
                            .strip[
                            n
                        ]
                            .edge0,
                        c |=
                        32)
                );
            for (let l =
                0; l <
                26; l++) {
                if (~this
                    .edgesMaybeCross >>
                    l & 1) {
                    this.cubeEdge[
                        l
                    ] =
                        fd;
                    continue
                }
                if (c >> l &
                    1) {
                    !this
                        .cubeHasCrossing &&
                        (this
                            .cubeEdge[
                            l
                        ]
                            .posNeg ||
                            this
                                .cubeEdge[
                                l
                            ]
                                .posNaN
                        ) &&
                        (this
                            .cubeHasCrossing = !
                            0
                        );
                    continue
                }
                let p = this
                    .findSurfaceCrossingEDI(
                        Er[l *
                        2
                        ],
                        Er[l *
                        2 +
                        1
                        ]
                    );
                this.cubeEdge[
                    l] =
                    p, N2(
                        p) && (
                        this
                            .cubeHasCrossing = !
                        0)
            }
        }
        saveEdges() {
            let {
                i: n,
                j: r,
                k: i,
                gridsize: s
            } = this;
            i < s - 1 && (
                this
                    .sheet[(n +
                        0
                    ) *
                    (s +
                        1) +
                    r +
                    0]
                    .edge0 =
                this
                    .cubeEdge[
                11],
                this
                    .sheet[(n +
                        0
                    ) *
                    (s +
                        1) +
                    r +
                    0]
                    .edge1 =
                this
                    .cubeEdge[
                17],
                this
                    .sheet[(n +
                        0
                    ) *
                    (s +
                        1) +
                    r +
                    0]
                    .edge2 =
                this
                    .cubeEdge[
                8]),
                r < s - 1 &&
                (this.strip[
                    n]
                    .edge0 =
                    this
                        .cubeEdge[
                    10],
                    this
                        .strip[
                        n]
                        .edge1 =
                    this
                        .cubeEdge[
                    12],
                    this
                        .strip[
                        n]
                        .edge2 =
                    this
                        .cubeEdge[
                    14]
                ), n <
                s - 1 && (
                    this
                        .face
                        .edge0 =
                    this
                        .cubeEdge[
                    15],
                    this
                        .face
                        .edge1 =
                    this
                        .cubeEdge[
                    13],
                    this
                        .face
                        .edge2 =
                    this
                        .cubeEdge[
                    16]
                ), i ==
                0 && (this
                    .sheet[(n +
                        0
                    ) *
                    (s +
                        1) +
                    r +
                    1]
                    .edge2 =
                    this
                        .cubeEdge[
                    3],
                    this
                        .sheet[(n +
                            1
                        ) *
                        (s +
                            1) +
                        r +
                        0]
                        .edge0 =
                    this
                        .cubeEdge[
                    4]),
                r == 0 && (
                    this
                        .strip[
                        n +
                        1]
                        .edge0 =
                    this
                        .cubeEdge[
                    7]),
                r == s -
                1 && (this
                    .sheet[
                    n *
                    (s +
                        1) +
                    s]
                    .edge2 =
                    this
                        .cubeEdge[
                    14]
                ), n ==
                s - 1 && (
                    this
                        .sheet[(s +
                            0
                        ) *
                        (s +
                            1) +
                        r]
                        .edge0 =
                    this
                        .cubeEdge[
                    16],
                    this
                        .strip[
                        s]
                        .edge0 =
                    this
                        .cubeEdge[
                    13])
        }
        findSurfaceCrossingEDI(
            n, r) {
            let i = this
                .cubeVertexValue
                .get(n),
                s = this
                    .cubeVertexValue
                    .get(r);
            if (i === 0 ||
                s === 0)
                return fd;
            let o = this
                .cubeVertex[
                n],
                a = this
                    .cubeVertex[
                    r];
            if (this
                .isInequality
            ) {
                let {
                    posNeg: u,
                    posNaN: c
                } = JR(this
                    .f,
                    o,
                    a,
                    i, s
                );
                return {
                    posNeg: u !==
                        void 0 ?
                        this
                            .pushPositionWithGradient(
                                ...
                                u
                            ) :
                        void 0,
                    posNaN: c !==
                        void 0 ?
                        this
                            .pushPositionNoGradient(
                                ...
                                c
                            ) :
                        void 0
                }
            } else {
                let u = ld(
                    this
                        .f,
                    o,
                    a,
                    i, s
                );
                return {
                    posNeg: u !==
                        void 0 ?
                        this
                            .pushPositionWithGradient(
                                ...
                                u
                            ) :
                        void 0
                }
            }
        }
        pushPositionWithGradient
            (n, r, i) {
            if (!(isFinite(
                n) &&
                isFinite(
                    r
                ) &&
                isFinite(
                    i)))
                return 0;
            let [s, o, a] =
                this.computeGradient(
                    n, r, i
                ), u =
                    Math.sqrt(
                        s * s +
                        o * o +
                        a * a);
            return s /= -u,
                o /= -u,
                a /= -u, zl(
                    s, o, a
                ) ? (
                    this
                        .normalFromGradient
                        .push(!
                            0),
                    this
                        ._pushPositionAndNormal(
                            n,
                            r,
                            i,
                            s,
                            o, a
                        )) :
                    this
                        .pushPositionNoGradient(
                            n, r, i)
        }
        pushPositionNoGradient(
            n, r, i) {
            return isFinite(
                n) &&
                isFinite(
                    r) &&
                isFinite(
                    i) ? (this
                        .allNormalsFromGradient = !
                        1, this
                            .normalFromGradient
                            .push(!
                                1),
                        this
                            ._pushPositionAndNormal(
                                n,
                                r,
                                i,
                                0,
                                0, 0
                            )) :
                0
        }
        _pushPositionAndNormal(
            n, r, i, s, o, a
        ) {
            return this
                .positions
                .push(n, r,
                    i), this
                        .uvs.push((
                            n -
                            this
                                .x
                                .min
                        ) /
                            this.x
                                .width,
                            (r - this
                                .y
                                .min
                            ) /
                            this.y
                                .width),
                this.normals
                    .push(s, o,
                        a), this
                            .positions
                            .length / 3
        }
        computeGradient(n, r,
            i) {
            let s = NaN,
                o = NaN,
                a = NaN;
            if (this
                .gradient &&
                ([s, o, a] =
                    this
                        .gradient(
                            n,
                            r, i
                        ),
                    isFinite(
                        s
                    ) &&
                    isFinite(
                        o
                    ) &&
                    isFinite(
                        a)))
                return [s,
                    o, a
                ];
            let u = .001 *
                Math.min(
                    this
                        .size.x,
                    this
                        .size.y,
                    this
                        .size.z
                ),
                c = this.f(
                    n, r, i
                );
            if (isFinite(
                s) || (s = (
                    this
                        .f(n +
                            u,
                            r,
                            i
                        ) -
                    c) /
                    u),
                isFinite(
                    s) || (s = (
                        c -
                        this
                            .f(n -
                                u,
                                r,
                                i
                            )
                    ) /
                        u),
                isFinite(
                    o) || (o = (
                        this
                            .f(n,
                                r +
                                u,
                                i
                            ) -
                        c) /
                        u),
                isFinite(
                    o) || (o = (
                        c -
                        this
                            .f(n,
                                r -
                                u,
                                i
                            )
                    ) /
                        u),
                isFinite(
                    a) || (a = (
                        this
                            .f(n,
                                r,
                                i +
                                u
                            ) -
                        c) /
                        u),
                isFinite(
                    a) || (a = (
                        c -
                        this
                            .f(n,
                                r,
                                i -
                                u
                            )
                    ) /
                        u),
                isFinite(
                    s) &&
                isFinite(
                    o) &&
                isFinite(a))
                return [s,
                    o, a
                ];
            let l = NaN,
                p = NaN,
                f = NaN,
                m = NaN,
                g = NaN,
                d = NaN,
                y = u / 2;
            return (!
                isFinite(
                    s
                ) ||
                !
                isFinite(
                    o)
            ) && (
                    l = (
                        this
                            .f(n +
                                y,
                                r +
                                y,
                                i
                            ) -
                        c) /
                    u,
                    isFinite(
                        l
                    ) ||
                    (l = (c -
                        this
                            .f(n -
                                y,
                                r -
                                y,
                                i
                            )
                    ) /
                        u),
                    p = (
                        this
                            .f(n +
                                y,
                                r -
                                y,
                                i
                            ) -
                        c) /
                    u,
                    isFinite(
                        p
                    ) ||
                    (p = (c -
                        this
                            .f(n -
                                y,
                                r +
                                y,
                                i
                            )
                    ) /
                        u),
                    isFinite(
                        l
                    ) &&
                    isFinite(
                        p
                    ) &&
                    (isFinite(
                        s
                    ) ||
                        (s = l +
                            p
                        ),
                        isFinite(
                            o
                        ) ||
                        (o = l -
                            p
                        )
                    )),
                (!isFinite(
                    o) ||
                    !
                    isFinite(
                        a)
                ) && (
                    f = (
                        this
                            .f(n,
                                r +
                                y,
                                i +
                                y
                            ) -
                        c) /
                    u,
                    isFinite(
                        f
                    ) ||
                    (f = (c -
                        this
                            .f(n,
                                r -
                                y,
                                i -
                                y
                            )
                    ) /
                        u),
                    m = (
                        this
                            .f(n,
                                r +
                                y,
                                i -
                                y
                            ) -
                        c) /
                    u,
                    isFinite(
                        m
                    ) ||
                    (m = (c -
                        this
                            .f(n,
                                r -
                                y,
                                i +
                                y
                            )
                    ) /
                        u),
                    isFinite(
                        f
                    ) &&
                    isFinite(
                        m
                    ) &&
                    (isFinite(
                        o
                    ) ||
                        (o = f +
                            m
                        ),
                        isFinite(
                            a
                        ) ||
                        (a = f -
                            m
                        )
                    )),
                (!isFinite(
                    a) ||
                    !
                    isFinite(
                        s)
                ) && (
                    g = (
                        this
                            .f(n +
                                y,
                                r,
                                i +
                                y
                            ) -
                        c) /
                    u,
                    isFinite(
                        g
                    ) ||
                    (g = (c -
                        this
                            .f(n -
                                y,
                                r,
                                i -
                                y
                            )
                    ) /
                        u),
                    d = (
                        this
                            .f(n -
                                y,
                                r,
                                i +
                                y
                            ) -
                        c) /
                    u,
                    isFinite(
                        d
                    ) ||
                    (d = (c -
                        this
                            .f(n +
                                y,
                                r,
                                i -
                                y
                            )
                    ) /
                        u),
                    isFinite(
                        g
                    ) &&
                    isFinite(
                        d
                    ) &&
                    (isFinite(
                        s
                    ) ||
                        (s = g -
                            d
                        ),
                        isFinite(
                            a
                        ) ||
                        (a = g +
                            d
                        )
                    )),
                [s, o, a]
        }
        generateTriangles() {
            for (let n =
                0; n <
                12; n++) {
                let r = kg[
                    n],
                    i = [],
                    s = 0,
                    o = KR[
                        n],
                    a = 0,
                    u = o[
                        0],
                    c = Math
                        .abs(
                            this
                                .cubeVertexValue
                                .get(
                                    u
                                )
                        );
                c > a &&
                    isFinite(
                        c
                    ) &&
                    (a = c);
                let l = o[
                    1],
                    p = Math
                        .abs(
                            this
                                .cubeVertexValue
                                .get(
                                    l
                                )
                        );
                p > a &&
                    isFinite(
                        p
                    ) &&
                    (a = p);
                let f = o[
                    2],
                    m = Math
                        .abs(
                            this
                                .cubeVertexValue
                                .get(
                                    f
                                )
                        );
                m > a &&
                    isFinite(
                        m
                    ) &&
                    (a = m);
                let g = o[
                    3],
                    d = Math
                        .abs(
                            this
                                .cubeVertexValue
                                .get(
                                    g
                                )
                        );
                d > a &&
                    isFinite(
                        d
                    ) &&
                    (a = d);
                let y = a *
                    Number
                        .EPSILON *
                    32;
                if (c <=
                    y) {
                    s |= 35;
                    let b =
                        this
                            .pushPositionWithGradient(
                                ...
                                this
                                    .cubeVertex[
                                u
                                ]
                            );
                    b !==
                        void 0 &&
                        i
                            .push(
                                b
                            )
                }
                if (p <=
                    y) {
                    s |= 21;
                    let b =
                        this
                            .pushPositionWithGradient(
                                ...
                                this
                                    .cubeVertex[
                                l
                                ]
                            );
                    b !==
                        void 0 &&
                        i
                            .push(
                                b
                            )
                }
                if (m <=
                    y) {
                    s |= 14;
                    let b =
                        this
                            .pushPositionWithGradient(
                                ...
                                this
                                    .cubeVertex[
                                f
                                ]
                            );
                    b !==
                        void 0 &&
                        i
                            .push(
                                b
                            )
                }
                if (d <=
                    y) {
                    s |= 56;
                    let b =
                        this
                            .pushPositionWithGradient(
                                ...
                                this
                                    .cubeVertex[
                                g
                                ]
                            );
                    b !==
                        void 0 &&
                        i
                            .push(
                                b
                            )
                }
                if (i
                    .length ===
                    4)
                    continue;
                let h;
                for (let b =
                    0; b <
                    4; b++
                ) {
                    let x =
                        o[
                        b];
                    if (this
                        .cubeVertexValue
                        .get(
                            x
                        ) >
                        y) {
                        h = this
                            .cubeVertex[
                            x
                        ];
                        break
                    }
                }
                if (h ===
                    void 0 &&
                    this
                        .isInequality
                )
                    for (let b =
                        0; b <
                        6; b++
                    ) {
                        if (s >>
                            b &
                            1
                        )
                            continue;
                        let {
                            posNeg: x,
                            posNaN: P
                        } =
                            this.cubeEdge[
                            r[
                            b]
                            ];
                        if (Lc(
                            x) &&
                            Lc(
                                P)
                        ) {
                            h = gs(this
                                .positions
                                .slice(
                                    (x -
                                        1) *
                                    3,
                                    x *
                                    3
                                ),
                                this
                                    .positions
                                    .slice(
                                        (P -
                                            1) *
                                        3,
                                        P *
                                        3
                                    ),
                                .5
                            );
                            break
                        }
                    }
                if (h ===
                    void 0)
                    for (let b =
                        0; b <
                        4; b++
                    ) {
                        let x =
                            o[
                            b];
                        if (!
                            isFinite(
                                this
                                    .cubeVertexValue
                                    .get(
                                        x
                                    )
                            )
                        ) {
                            h = this
                                .cubeVertex[
                                x
                            ];
                            break
                        }
                    }
                if (h ===
                    void 0 &&
                    s && i
                        .length >
                    0) {
                    let b;
                    for (let x =
                        0; x <
                        4; x++
                    ) {
                        let P =
                            o[
                            x];
                        if (this
                            .cubeVertexValue
                            .get(
                                P
                            ) <
                            -
                            y
                        ) {
                            b = this
                                .cubeVertex[
                                P
                            ];
                            break
                        }
                    }
                    if (b) {
                        let x =
                            i[
                            0],
                            P =
                                this
                                    .positions
                                    .slice(
                                        (x -
                                            1) *
                                        3,
                                        x *
                                        3
                                    );
                        h = gs(b,
                            P,
                            2
                        )
                    }
                }
                if (h !==
                    void 0
                ) {
                    if (this
                        .isInequality
                    ) {
                        let b = [],
                            x = [],
                            P = !
                                1;
                        for (
                            let M =
                                0; M <
                            6; M++
                        ) {
                            if (s >>
                                M &
                                1
                            )
                                continue;
                            let {
                                posNeg: I,
                                posNaN: E
                            } =
                                this.cubeEdge[
                                r[
                                M]
                                ],
                                v =
                                    Lc(
                                        I),
                                O =
                                    Lc(
                                        E);
                            v && b
                                .push(
                                    I
                                ),
                                O &&
                                x
                                    .push(
                                        E
                                    ),
                                v &&
                                O &&
                                (P = !
                                    0
                                )
                        }
                        if (
                            P) {
                            b.push(...
                                i
                            ),
                                this
                                    .pushTriangleFromCorners(
                                        x,
                                        h
                                    ),
                                this
                                    .pushTriangleFromCorners(
                                        b,
                                        h
                                    );
                            continue
                        }
                    }
                    for (let b =
                        0; b <
                        6; b++
                    ) {
                        if (s >>
                            b &
                            1
                        )
                            continue;
                        let {
                            posNeg: x,
                            posNaN: P
                        } =
                            this.cubeEdge[
                            r[
                            b]
                            ],
                            M =
                                x ||
                                P;
                        Lc(M) &&
                            i
                                .push(
                                    M
                                )
                    }
                    this.pushTriangleFromCorners(
                        i,
                        h
                    )
                }
            }
        }
        pushTriangleFromCorners(
            n, r) {
            if (n.length >=
                3) {
                let i = n[
                    0] - 1,
                    s = n[
                        1] - 1,
                    o = n[
                        2] - 1;
                this.pushTriangle(
                    i,
                    s,
                    o, r
                )
            }
            if (n.length ==
                4) {
                let i = n[
                    0] - 1,
                    s = n[
                        2] - 1,
                    o = n[
                        3] - 1;
                this.pushTriangle(
                    i,
                    s,
                    o, r
                )
            }
        }
        pushTriangle(n, r, i,
            s) {
            this.allNormalsFromGradient ||
                this
                    .fixBadNormals(
                        n, r, i,
                        s), this
                            .checkWindingOrder(
                                n, r, i
                            ) && ([
                                r, i
                            ] = [i,
                                    r
                                ]), this
                                    .triangles
                                    .push(n, r,
                                        i)
        }
        fixBadNormals(n, r, i,
            s) {
            let o = !this
                .normalFromGradient[
                n],
                a = !this
                    .normalFromGradient[
                    r],
                u = !this
                    .normalFromGradient[
                    i];
            if (!(o || a ||
                u))
                return;
            let c = this
                .positions,
                l = this
                    .normals,
                p = new Qe(
                    c[3 *
                    n], c[
                3 *
                n +
                1],
                    c[3 *
                    n +
                    2]),
                f = new Qe(
                    c[3 *
                    r], c[
                3 *
                r +
                1],
                    c[3 *
                    r +
                    2]),
                m = new Qe(
                    c[3 *
                    i], c[
                3 *
                i +
                1],
                    c[3 *
                    i +
                    2]),
                g = new Qe()
                    .subVectors(
                        m, p),
                d = new Qe()
                    .subVectors(
                        p, f);
            var y = g.cross(
                d);
            let h = new Qe()
                .subVectors(
                    p,
                    new Qe(
                        ...s
                    ));
            y.dot(h) < 0 &&
                y.multiply(-
                    1), y
                        .isFinite() &&
                (o && (l[3 * n +
                    0
                ] +=
                    y.x,
                    l[3 *
                    n +
                    1
                    ] +=
                    y.y,
                    l[3 *
                    n +
                    2
                    ] +=
                    y.z
                ),
                    a && (l[3 *
                        r +
                        0
                    ] +=
                        y.x,
                        l[3 *
                        r +
                        1
                        ] +=
                        y.y,
                        l[3 *
                        r +
                        2
                        ] +=
                        y.z
                    ),
                    u && (l[3 *
                        i +
                        0
                    ] +=
                        y.x,
                        l[3 *
                        i +
                        1
                        ] +=
                        y.y,
                        l[3 *
                        i +
                        2
                        ] +=
                        y.z)
                )
        }
        checkWindingOrder(n, r,
            i) {
            let s = this
                .positions,
                o = this
                    .normals,
                a = s[3 *
                    i] - s[3 *
                    n],
                u = s[3 *
                    i + 1] -
                    s[3 * n +
                    1],
                c = s[3 *
                    i + 2] -
                    s[3 * n +
                    2],
                l = s[3 *
                    n] - s[3 *
                    r],
                p = s[3 *
                    n + 1] -
                    s[3 * r +
                    1],
                f = s[3 *
                    n + 2] -
                    s[3 * r +
                    2],
                m = u * f -
                    c * p,
                g = c * l -
                    a * f,
                d = a * p -
                    u * l,
                y = o[3 *
                    n],
                h = o[3 *
                    n + 1],
                b = o[3 *
                    n + 2];
            return m * y +
                g * h + d *
                b < 0
        }
    };

    function $g(e) {
        let {
            triangles: t,
            normalDirHints: n
        } = e.triangulate(), {
            extraAttrCount: r
        } = e, i = e
            .getVertexCount(), s =
                new Array(i), o =
                new Array(i * 3),
            a = [], u = !1, c =
                new Array(i * 3), l =
                new Array(i * 2), p =
                new Array(i * r),
            f = [], m = 0;

        function g(y) {
            let h = e.getVertex(y);
            if (!h) return null;
            let b = n[y],
                x = b ? e
                    .hintedNormal(y,
                        b) : e.getNormal(y);
            x ? (c[3 * m] = x[0], c[
                3 * m + 1] =
                x[1], c[3 * m +
                2] = x[2]) :
                (a[m] = !0, u = !0,
                    c[3 * m] = 0, c[
                    3 * m + 1] =
                    0, c[3 * m +
                    2] = 0), o[3 *
                    m] = h[0], o[3 *
                    m + 1] = h[1],
                o[3 * m + 2] = h[2];
            let P = e.getUV(y);
            if (l[2 * m] = P[0], l[
                2 * m + 1] = P[
                1], r > 0)
                for (let M = 0; M <
                    r; M++) p[r *
                        m + M] = e
                            .getExtraAttr(y,
                                M);
            return m++
        }

        function d(y) {
            let h = s[y];
            return h === void 0 ? s[
                y] = g(y) : h
        }
        for (let y = 0; y < t
            .length; y += 3) {
            let h = t[y],
                b = t[y + 1],
                x = t[y + 2],
                P = d(h),
                M = d(b),
                I = d(x);
            if (P === null || M ===
                null || I === null)
                continue;
            f.push(P, M, I);
            let E = a[P],
                v = a[M],
                O = a[I];
            if (E || v || O) {
                let A = o,
                    N = c,
                    L = new Qe(A[3 *
                        P], A[
                    3 * P +
                    1], A[
                    3 * P +
                    2]),
                    z = new Qe(A[3 *
                        M], A[
                    3 * M +
                    1], A[
                    3 * M +
                    2]),
                    G = new Qe(A[3 *
                        I], A[
                    3 * I +
                    1], A[
                    3 * I +
                    2]),
                    $ = new Qe()
                        .subVectors(G,
                            L),
                    w = new Qe()
                        .subVectors(L,
                            z),
                    Y = $.cross(w);
                if (!Y.isFinite())
                    continue;
                E && (N[3 * P +
                    0] += Y.x,
                    N[3 * P +
                    1] += Y.y,
                    N[3 * P +
                    2] += Y.z),
                    v && (N[3 * M +
                        0] += Y
                            .x, N[3 *
                            M + 1
                            ] += Y
                            .y, N[3 *
                            M + 2
                            ] += Y.z
                    ), O && (N[
                        3 * I +
                        0] += Y
                            .x, N[3 *
                            I + 1
                            ] += Y
                            .y, N[3 *
                            I + 2
                            ] += Y.z
                    )
            }
        }
        if (o.length = m * 3, c
            .length = m * 3, l
                .length = m * 2, u)
            for (let y = 0; y <
                m; y++) {
                if (!a[y]) continue;
                let h = c[3 * y],
                    b = c[3 * y +
                        1],
                    x = c[3 * y +
                        2],
                    P = Math.sqrt(
                        h * h + b *
                        b + x * x);
                c[3 * y] = h / P, c[
                    3 * y + 1] =
                    b / P, c[3 * y +
                    2] = x / P
            }
        return bp(f, o, c, l, r, p,
            0), {
            positions: o,
            normals: c,
            faces: f,
            uvs: l,
            resolved: !0,
            extraAttrs: p
        }
    }
    var u0 = class {
        constructor({
            resolution: t,
            uRange: n,
            vRange: r,
            du: i,
            dv: s,
            extraAttrCount: o
        }) {
            this
                .normalDirHints = [];
            this
                .isVertexAtCreaseCache = [];
            this
                .triangles = [];
            this.edgeVertices =
                new Map;
            this.edgeNormalVertices =
                new Map;
            this.finiteVertices =
                new Map;
            this.resolution =
                t, this
                    .uRange = n,
                this
                    .vRange = r,
                this.du = i,
                this.dv = s,
                this
                    .extraAttrCount =
                o, this
                    .duSquared =
                i * i, this
                    .dvSquared =
                s * s
        }
        addVertex(t) {
            return this
                .normalDirHints
                .push(
                    void 0),
                this
                    .isVertexAtCreaseCache
                    .push(
                        void 0),
                this
                    ._addVertex(
                        t)
        }
        jumpAlongEdge(t, n) {
            let r = 0;
            if (t > n) {
                let u = t;
                t = n, n =
                    u, r = 1
            }
            let i = n * n +
                t,
                s = this
                    .edgeVertices
                    .get(i);
            if (s === null)
                return;
            if (s !==
                void 0)
                return [s[
                    r],
                s[1 -
                r
                ]
                ];
            let o = this
                .findJumpBetweenTwoSamples(
                    t, n);
            if (o ===
                void 0) {
                this.edgeVertices
                    .set(i,
                        null
                    );
                return
            }
            let a = [this
                .addVertex(
                    o[0]
                ),
            this
                .addVertex(
                    o[1]
                )
            ];
            return this
                .edgeVertices
                .set(i, a),
                [a[r], a[1 -
                    r]]
        }
        edgeNormalFeature(t,
            n) {
            let r = 0;
            if (t > n) {
                let u = t;
                t = n, n =
                    u, r = 1
            }
            let i = n * n +
                t,
                s = this
                    .edgeNormalVertices
                    .get(i);
            if (s !==
                void 0)
                return this
                    .flipEdgeNormalFeature(
                        s, r
                    );
            let o = this
                .findCreaseBetweenTwoSamples(
                    t, n),
                a = o ===
                    null ?
                    null : o
                        .type ===
                        "high-curvature" ?
                        {
                            type: "high-curvature",
                            pos: this
                                .addVertex(
                                    o
                                        .pos
                                )
                        } : {
                            type: "crease",
                            left: this
                                .addVertex(
                                    o
                                        .left
                                ),
                            right: this
                                .addVertex(
                                    o
                                        .right
                                )
                        };
            return this
                .edgeNormalVertices
                .set(i, a),
                this
                    .flipEdgeNormalFeature(
                        a, r)
        }
        flipEdgeNormalFeature(t,
            n) {
            return (t ==
                null ?
                void 0 :
                t.type
            ) ===
                "crease" ? {
                type: "crease",
                left: n ===
                    0 ?
                    t
                        .left :
                    t
                        .right,
                right: n ===
                    0 ?
                    t
                        .right :
                    t
                        .left
            } : t
        }
        findCreaseBetweenTwoSamples
            (t, n) {
            let s = this
                .getUV(t),
                o = this
                    .getUV(n),
                a = this
                    .getNormal(
                        t),
                u = this
                    .getNormal(
                        n),
                c = b => {
                    var P;
                    let x =
                        Jn(s,
                            o,
                            b
                        );
                    return (P =
                        this
                            .fn(
                                x)
                            .normal
                    ) !=
                        null ?
                        P :
                        [NaN,
                            NaN,
                            NaN
                        ]
                };
            if (!a || !u)
                return null;
            let l = o[0] -
                s[0],
                p = o[1] -
                    s[1],
                f = this.du,
                m = this.dv,
                g = (Math
                    .abs(f *
                        l) +
                    Math
                        .abs(m *
                            p)
                ) / (l *
                    l + p *
                    p),
                d = Py(0, a,
                    1, u, c,
                    .01, 2 *
                g, .9);
            if (d ===
                void 0)
                return null;
            if (typeof d ==
                "number")
                return d <
                    g || d >
                    1 - g ?
                    null : {
                        type: "high-curvature",
                        pos: this
                            .fn(Jn(s,
                                o,
                                d
                            ))
                    };
            let y = d[0],
                h = d[1];
            return y < g ||
                h > 1 - g ?
                null : (y -=
                    g, h +=
                    g, y <=
                    1e-8 &&
                    (y =
                        1e-8),
                    h >= 1 -
                    1e-8 &&
                    (h = 1 -
                        1e-8
                    ), {
                    type: "crease",
                    left: this
                        .fn(Jn(s,
                            o,
                            y
                        )),
                    right: this
                        .fn(Jn(s,
                            o,
                            h
                        ))
                })
        }
        isVertexAtCrease(t) {
            let n = this
                .isVertexAtCreaseCache[
                t];
            if (n !==
                void 0)
                return n;
            let r = this
                ._isVertexAtCrease(
                    t);
            return this
                .isVertexAtCreaseCache[
                t] = r,
                r
        }
        finiteAlongEdge(t, n) {
            if (t > n) {
                let a = t;
                t = n, n = a
            }
            let r = n * n +
                t,
                i = this
                    .finiteVertices
                    .get(r);
            if (i !==
                void 0)
                return i;
            let s = this
                .findFiniteBetweenTwoSamples(
                    t, n);
            if (s ===
                void 0)
                return;
            let o = this
                .addVertex(
                    s);
            return this
                .finiteVertices
                .set(r, o),
                o
        }
        pushTriangle(t, n, r) {
            this.isDegenerate(
                t, n, r
            ) ||
                this
                    .triangles
                    .push(t, n,
                        r)
        }
        getTriangles() {
            return this
                .triangles
        }
    },
        A2 = 1e-4,
        _2 = .99,
        Tp = .9999;

    function o0(e, t) {
        return !e || !t ? !0 : e[
            0] * t[0] + e[1] * t[
            1] + e[2] * t[2] < _2
    }
    var c0 = class extends u0 {
        hintVec(t, n) {
            let r = this
                .getUV(t),
                i = this
                    .getUV(n);
            return AD(ND(i,
                r),
                A2)
        }
        hintNormal1(t, n, r) {
            let i = this
                .hintVec(t,
                    n),
                s = this
                    .hintVec(t,
                        r);
            this.normalDirHints[
                t] = [i,
                    s
                ]
        }
        hintNormals2(t, n) {
            let r = this
                .hintVec(t,
                    n),
                i = a0(r);
            this.normalDirHints[
                t] = [
                    qg(r), i
                ], this
                    .normalDirHints[
                n] = [i,
                    qg(i)
                ]
        }
        hintNormals2Finite(t,
            n) {
            let r = this
                .hintVec(t,
                    n),
                i = qg(r);
            this.normalDirHints[
                t] =
                this
                    .normalDirHints[
                n] = [i,
                    a0(i)
                ]
        }
        hintNormalFirstBad(t,
            n) {
            let r = this
                .hintVec(t,
                    n);
            this.normalDirHints[
                t] = [
                    qg(r),
                    a0(r)
                ]
        }
        hintNormalSecondBad(t,
            n) {
            let r = this
                .hintVec(n,
                    t);
            this.normalDirHints[
                n] = [
                    w2(r),
                    L2(r)
                ]
        }
    },
        l0 = class extends c0 {
            oneJump(t, n, r, i) {
                let s = i[0],
                    o = i[1];
                this.pushTriangle(
                    s, r, t
                ), this
                    .pushTriangle(
                        o, n, r
                    ), this
                        .hintNormalFirstBad(
                            s, r),
                    this
                        .hintNormalSecondBad(
                            r, o)
            }
            oneJumpOneExtra(t, n, r,
                i, s) {
                let o = i[0],
                    a = i[1];
                this.pushTriangle(
                    o, r, t
                ), this
                    .pushTriangle(
                        o, s, r
                    ), this
                        .pushTriangle(
                            a, n, s
                        ), this
                            .hintNormalFirstBad(
                                o, r),
                    this
                        .hintNormalSecondBad(
                            r, a)
            }
            oneJumpOneExtra2(t, n,
                r, i, s) {
                let o = i[0],
                    a = i[1];
                this.pushTriangle(
                    a, n, r
                ), this
                    .pushTriangle(
                        a, r, s
                    ), this
                        .pushTriangle(
                            o, s, t
                        ), this
                            .hintNormalFirstBad(
                                o, r),
                    this
                        .hintNormalSecondBad(
                            r, a)
            }
            oneJumpTwoExtra(t, n, r,
                i, s, o) {
                let a = i[0],
                    u = i[1];
                this.pushTriangle(
                    a, o, t
                ), this
                    .pushTriangle(
                        a, s, o
                    ), this
                        .pushTriangle(
                            s, r, o
                        ), this
                            .pushTriangle(
                                u, n, s)
            }
            twoJumps(t, n, r, i,
                s) {
                let o = i[0],
                    a = i[1],
                    u = s[0],
                    c = s[1];
                this.pushTriangle(
                    o, r, t
                ), this
                    .pushTriangle(
                        o, c, r
                    ), this
                        .pushTriangle(
                            a, n, u
                        ), this
                            .hintNormals2(
                                o, c),
                    this
                        .hintNormals2(
                            u, a)
            }
            twoJumpsOneExtraPoint(t,
                n, r, i, s, o) {
                let a = i[0],
                    u = i[1],
                    c = s[0],
                    l = s[1];
                this.pushTriangle(
                    a, o, t
                ), this
                    .pushTriangle(
                        a, l, o
                    ), this
                        .pushTriangle(
                            l, r, o
                        ), this
                            .pushTriangle(
                                u, n, c
                            ), this
                                .hintNormals2(
                                    a, l),
                    this
                        .hintNormals2(
                            c, u)
            }
            oneExtraPoint(t, n, r,
                i) {
                this.pushTriangle(
                    i, r, t
                ), this
                    .pushTriangle(
                        i, n, r)
            }
            oneExtraPointOneVertexCrease
                (t, n, r, i) {
                let s = this
                    .copyVertex(
                        r);
                this.pushTriangle(
                    i, s, t
                ), this
                    .pushTriangle(
                        i, n, s
                    ), this
                        .hintNormal1(
                            s, t, n)
            }
            twoExtraPoints(t, n, r,
                i, s) {
                this.pushTriangle(
                    i, r, t
                ), this
                    .pushTriangle(
                        i, s, r
                    ), this
                        .pushTriangle(
                            i, n, s)
            }
            threeExtraPoints(t, n,
                r, i, s, o) {
                this.pushTriangle(
                    i, o, t
                ), this
                    .pushTriangle(
                        i, s, o
                    ), this
                        .pushTriangle(
                            i, n, s
                        ), this
                            .pushTriangle(
                                s, r, o)
            }
            oneEdgeJumpOneVertexCrease
                (t, n, r, i) {
                let s = i[0],
                    o = i[1],
                    a = this
                        .copyVertex(
                            r),
                    u = this
                        .copyVertex(
                            r);
                this.pushTriangle(
                    s, a, t
                ), this
                    .pushTriangle(
                        o, n, u
                    ), this
                        .hintNormals2(
                            u, o),
                    this
                        .hintNormals2(
                            s, a)
            }
            threeVertexCrease(t, n,
                r) {
                let i = this
                    .copyVertex(
                        t),
                    s = this
                        .copyVertex(
                            n),
                    o = this
                        .copyVertex(
                            r);
                this.pushTriangle(
                    i, s, o
                ), this
                    .hintNormals2(
                        i, s),
                    this
                        .hintNormalFirstBad(
                            o, i)
            }
            twoVertexCrease(t, n,
                r) {
                let i = this
                    .copyVertex(
                        t),
                    s = this
                        .copyVertex(
                            n);
                this.pushTriangle(
                    i, s, r
                ), this
                    .hintNormals2(
                        i, s)
            }
            oneVertexCrease(t, n,
                r) {
                let i = this
                    .copyVertex(
                        t);
                this.pushTriangle(
                    i, n, r
                ), this
                    .hintNormal1(
                        i, n, r)
            }
            pushTrianglesBasedOnJumps
                (t, n, r) {
                let i = this
                    .jumpAlongEdge(
                        t, n),
                    s = this
                        .jumpAlongEdge(
                            n, r),
                    o = this
                        .jumpAlongEdge(
                            r, t);
                if (i && s &&
                    o) {
                    let y = this
                        .getUV(
                            t),
                        h = this
                            .getUV(
                                n),
                        b = this
                            .getUV(
                                r),
                        x = this
                            .addVertex(
                                this
                                    .fn(Jn(y,
                                        Jn(h,
                                            b,
                                            .5
                                        ),
                                        1e-4
                                    ))
                            ),
                        P = this
                            .addVertex(
                                this
                                    .fn(Jn(h,
                                        Jn(b,
                                            y,
                                            .5
                                        ),
                                        1e-4
                                    ))
                            ),
                        M = this
                            .addVertex(
                                this
                                    .fn(Jn(b,
                                        Jn(y,
                                            h,
                                            .5
                                        ),
                                        1e-4
                                    ))
                            ),
                        I = this
                            .jumpAlongEdge(
                                x, P
                            ),
                        E = this
                            .jumpAlongEdge(
                                P, M
                            ),
                        v = this
                            .jumpAlongEdge(
                                M, x
                            );
                    if (I &&
                        E && v)
                        return;
                    t = x, n =
                        P, r =
                        M, i =
                        I, s =
                        E, o = v
                }
                let a = this
                    .getNormal(
                        t),
                    u = this
                        .getNormal(
                            n),
                    c = this
                        .getNormal(
                            r),
                    l = this
                        .isVertexAtCrease(
                            t),
                    p = this
                        .isVertexAtCrease(
                            n),
                    f = this
                        .isVertexAtCrease(
                            r),
                    m, g, d;
                if (!l && !p &&
                    !i && o0(a,
                        u)) {
                    let y = this
                        .edgeNormalFeature(
                            t, n
                        );
                    y !==
                        null &&
                        (y.type ===
                            "high-curvature" ?
                            m =
                            y
                                .pos :
                            i = [
                                y
                                    .left,
                                y
                                    .right
                            ])
                }
                if (!p && !f &&
                    !s && o0(u,
                        c)) {
                    let y = this
                        .edgeNormalFeature(
                            n, r
                        );
                    y !==
                        null &&
                        (y.type ===
                            "high-curvature" ?
                            g =
                            y
                                .pos :
                            s = [
                                y
                                    .left,
                                y
                                    .right
                            ])
                }
                if (!f && !l &&
                    !o && o0(c,
                        a)) {
                    let y = this
                        .edgeNormalFeature(
                            r, t
                        );
                    y !==
                        null &&
                        (y.type ===
                            "high-curvature" ?
                            d =
                            y
                                .pos :
                            o = [
                                y
                                    .left,
                                y
                                    .right
                            ])
                }
                i && s ? d ?
                    this
                        .twoJumpsOneExtraPoint(
                            t, n, r,
                            i, s, d
                        ) : this
                            .twoJumps(t,
                                n, r, i,
                                s) :
                    s && o ? m ?
                        this
                            .twoJumpsOneExtraPoint(
                                n, r, t,
                                s, o, m
                            ) : this
                                .twoJumps(n,
                                    r, t, s,
                                    o) :
                        o && i ? g ?
                            this
                                .twoJumpsOneExtraPoint(
                                    r, t, n,
                                    o, i, g
                                ) : this
                                    .twoJumps(r,
                                        t, n, o,
                                        i) : i ?
                            f ? this
                                .oneEdgeJumpOneVertexCrease(
                                    t, n, r,
                                    i) :
                                g && d ?
                                    this
                                        .oneJumpTwoExtra(
                                            t, n, r,
                                            i, g, d
                                        ) : g ?
                                        this
                                            .oneJumpOneExtra(
                                                t, n, r,
                                                i, g) :
                                        d ? this
                                            .oneJumpOneExtra2(
                                                t, n, r,
                                                i, d) :
                                            this
                                                .oneJump(t,
                                                    n, r, i
                                                ) : s ?
                                l ? this
                                    .oneEdgeJumpOneVertexCrease(
                                        n, r, t,
                                        s) :
                                    d && m ?
                                        this
                                            .oneJumpTwoExtra(
                                                n, r, t,
                                                s, d, m
                                            ) : d ?
                                            this
                                                .oneJumpOneExtra(
                                                    n, r, t,
                                                    s, d) :
                                            m ? this
                                                .oneJumpOneExtra2(
                                                    n, r, t,
                                                    s, m) :
                                                this
                                                    .oneJump(n,
                                                        r, t, s
                                                    ) : o ?
                                    p ? this
                                        .oneEdgeJumpOneVertexCrease(
                                            r, t, n,
                                            o) :
                                        m && g ?
                                            this
                                                .oneJumpTwoExtra(
                                                    r, t, n,
                                                    o, m, g
                                                ) : m ?
                                                this
                                                    .oneJumpOneExtra(
                                                        r, t, n,
                                                        o, m) :
                                                g ? this
                                                    .oneJumpOneExtra2(
                                                        r, t, n,
                                                        o, g) :
                                                    this
                                                        .oneJump(r,
                                                            t, n, o
                                                        ) : l &&
                                                            p && f ?
                                        this
                                            .threeVertexCrease(
                                                t, n, r
                                            ) : l &&
                                                p ? this
                                                    .twoVertexCrease(
                                                        t, n, r
                                                    ) : p &&
                                                        f ? this
                                                            .twoVertexCrease(
                                                                n, r, t
                                                            ) : f &&
                                                                l ? this
                                                                    .twoVertexCrease(
                                                                        r, t, n
                                                                    ) : l ?
                                            g ? this
                                                .oneExtraPointOneVertexCrease(
                                                    n, r, t,
                                                    g) :
                                                this
                                                    .oneVertexCrease(
                                                        t, n, r
                                                    ) : p ?
                                                d ? this
                                                    .oneExtraPointOneVertexCrease(
                                                        r, t, n,
                                                        d) :
                                                    this
                                                        .oneVertexCrease(
                                                            n, r, t
                                                        ) : f ?
                                                    m ? this
                                                        .oneExtraPointOneVertexCrease(
                                                            t, n, r,
                                                            m) :
                                                        this
                                                            .oneVertexCrease(
                                                                r, t, n
                                                            ) : m &&
                                                                g && d ?
                                                        this
                                                            .threeExtraPoints(
                                                                t, n, r,
                                                                m, g, d
                                                            ) : m &&
                                                                g ? this
                                                                    .twoExtraPoints(
                                                                        t, n, r,
                                                                        m, g) :
                                                            g && d ?
                                                                this
                                                                    .twoExtraPoints(
                                                                        n, r, t,
                                                                        g, d) :
                                                                d && m ?
                                                                    this
                                                                        .twoExtraPoints(
                                                                            r, t, n,
                                                                            d, m) :
                                                                    m ? this
                                                                        .oneExtraPoint(
                                                                            t, n, r,
                                                                            m) : g ?
                                                                        this
                                                                            .oneExtraPoint(
                                                                                n, r, t,
                                                                                g) : d ?
                                                                            this
                                                                                .oneExtraPoint(
                                                                                    r, t, n,
                                                                                    d) :
                                                                            this
                                                                                .pushTriangle(
                                                                                    t, n, r)
            }
            oneNonFinite(t, n, r) {
                let i = this
                    .finiteAlongEdge(
                        n, r),
                    s = this
                        .finiteAlongEdge(
                            t, r);
                s !== void 0 &&
                    i !==
                    void 0 && (
                        this
                            .pushTrianglesBasedOnJumps(
                                i,
                                t, n
                            ),
                        this
                            .pushTrianglesBasedOnJumps(
                                i,
                                s, t
                            ),
                        this
                            .hintNormals2Finite(
                                i, s
                            ))
            }
            twoNonFinite(t, n, r) {
                let i = this
                    .finiteAlongEdge(
                        t, n),
                    s = this
                        .finiteAlongEdge(
                            t, r);
                i !== void 0 &&
                    s !==
                    void 0 && (
                        this
                            .pushTrianglesBasedOnJumps(
                                t,
                                i, s
                            ),
                        this
                            .hintNormals2Finite(
                                i, s
                            ))
            }
            pushTriangles(t, n, r) {
                let i = this
                    .allowVertex(
                        t),
                    s = this
                        .allowVertex(
                            n),
                    o = this
                        .allowVertex(
                            r);
                i && s && o ?
                    this
                        .pushTrianglesBasedOnJumps(
                            t, n, r
                        ) : i &&
                            s ? this
                                .oneNonFinite(
                                    t, n, r
                                ) : s &&
                                    o ? this
                                        .oneNonFinite(
                                            n, r, t
                                        ) : o &&
                                            i ? this
                                                .oneNonFinite(
                                                    r, t, n
                                                ) : i ?
                        this
                            .twoNonFinite(
                                t, n, r
                            ) : s ?
                            this
                                .twoNonFinite(
                                    n, r, t
                                ) : o &&
                            this
                                .twoNonFinite(
                                    r, t, n)
            }
        },
        Pp = class extends l0 {
            triangulate() {
                let t = this
                    .resolution,
                    {
                        uRange: n,
                        vRange: r,
                        fn: i
                    } = this,
                    s = [n.min,
                    r.min
                    ],
                    o = [n.max,
                    r.max
                    ],
                    a = t - 1,
                    u =
                        new Array(
                            t * t);
                u[0] = this
                    .addVertex(
                        i(s));
                for (let c =
                    1; c <=
                    a; c++) u[
                        c] = this
                            .addVertex(
                                i(by(s, o,
                                    [c / a,
                                        0
                                    ]
                                ))),
                        u[t * c] =
                        this
                            .addVertex(
                                i(by(s, o,
                                    [0, c /
                                        a
                                    ]
                                )));
                for (let c =
                    1; c <=
                    a; c++)
                    for (let l =
                        1; l <=
                        a; l++
                    ) {
                        let p =
                            u[(l -
                                1) *
                            t +
                            (c -
                                1)
                            ],
                            f =
                                u[l *
                                t +
                                (c -
                                    1)
                                ],
                            m =
                                u[(l -
                                    1) *
                                t +
                                c
                                ],
                            g =
                                this
                                    .addVertex(
                                        i(by(s, o,
                                            [c / a,
                                            l /
                                            a
                                            ]
                                        ))
                                    );
                        u[l * t +
                            c
                        ] =
                            g, (c +
                                l
                            ) %
                                2 ===
                                0 ?
                                (this
                                    .pushTriangles(
                                        p,
                                        g,
                                        f
                                    ),
                                    this
                                        .pushTriangles(
                                            p,
                                            m,
                                            g
                                        )
                                ) :
                                (this
                                    .pushTriangles(
                                        p,
                                        m,
                                        f
                                    ),
                                    this
                                        .pushTriangles(
                                            m,
                                            g,
                                            f
                                        )
                                )
                    }
                return {
                    triangles: this
                        .getTriangles(),
                    normalDirHints: this
                        .normalDirHints
                }
            }
        };

    function L2(e) {
        let t = e[0] * Math.SQRT1_2,
            n = e[1] * Math.SQRT1_2;
        return [t + n, n - t]
    }

    function qg(e) {
        let t = e[0] * Math.SQRT1_2,
            n = e[1] * Math.SQRT1_2;
        return [t - n, t + n]
    }

    function w2(e) {
        return [e[1], -e[0]]
    }

    function a0(e) {
        return [-e[1], e[0]]
    }
    var sN = 80;
    var p0 = class extends Pp {
        constructor(n, r, i, s,
            o, a) {
            let u = i
                .width /
                1e8,
                c = s
                    .width /
                    1e8;
            super({
                resolution: o,
                uRange: i,
                vRange: s,
                du: u,
                dv: c,
                extraAttrCount: a
            });
            this
                .vertices = [];
            this.fn = n => {
                let r =
                    this
                        ._fn(
                            n
                        ),
                    i =
                        this
                            .tangentInForced(
                                n,
                                [this
                                    .du,
                                    0
                                ],
                                r
                            ),
                    s =
                        this
                            .tangentInForced(
                                n,
                                [0, this
                                    .dv
                                ],
                                r
                            ),
                    o =
                        kl(i,
                            s
                        );
                return {
                    uv: n,
                    f: r,
                    normal: o,
                    dfEast: i,
                    dfNorth: s
                }
            };
            this._fn = l =>
                n(l[0], l[
                    1]),
                this.xmin =
                r.xmin * 6 -
                r.xmax * 5,
                this.xmax =
                r.xmax * 6 -
                r.xmin * 5,
                this.ymin =
                r.ymin * 6 -
                r.ymax * 5,
                this.ymax =
                r.ymax * 6 -
                r.ymin * 5,
                this.zmin =
                r.zmin * 6 -
                r.zmax * 5,
                this.zmax =
                r.zmax * 6 -
                r.zmin * 5,
                this
                    .distThresh =
                ((r.xmax - r
                    .xmin
                ) *
                    1e-6) **
                2
        }
        getVertexCount() {
            return this
                .vertices
                .length
        }
        getUV(n) {
            return this
                .vertices[n]
                .uv
        }
        getNormal(n) {
            return this
                .vertices[n]
                .normal
        }
        _addVertex(n) {
            return this
                .vertices
                .push(n) - 1
        }
        copyVertex(n) {
            return this
                .addVertex(
                    this
                        .vertices[
                    n])
        }
        getF(n) {
            return this
                .vertices[n]
                .f
        }
        getDfNorth(n) {
            return this
                .vertices[n]
                .dfNorth
        }
        getDfEast(n) {
            return this
                .vertices[n]
                .dfEast
        }
        insidePaddedDomain(n) {
            return this
                .zmin <= n[
                2] && n[
                2] <=
                this.zmax &&
                this.ymin <=
                n[1] && n[
                1] <= this
                    .ymax &&
                this.xmin <=
                n[0] && n[
                0] <= this
                    .xmax
        }
        tangentInForced(n, r,
            i) {
            let s = Ef(n,
                r);
            return LT(this
                ._fn(s),
                i)
        }
        _isVertexAtCrease(n) {
            let r = this
                .getUV(n),
                i = this
                    .getDfEast(
                        n),
                s = this
                    .getDfNorth(
                        n),
                o = this
                    .getF(n),
                a = this
                    .tangentInForced(
                        r, [-
                            this
                                .du,
                        0
                    ], o);
            if (wT(a, i) /
                Math.sqrt(
                    Gl(a) *
                    Gl(i)) >
                -Tp) return !
                    0;
            let c = this
                .tangentInForced(
                    r, [0, -
                        this
                            .dv
                ], o);
            return wT(s,
                c) / Math
                    .sqrt(Gl(
                        s) * Gl(
                            c)
                    ) > -Tp
        }
        hintedNormal(n, r) {
            let i = this
                .getUV(n),
                s = this
                    .getF(n),
                o = kl(this
                    .tangentInForced(
                        i,
                        r[
                        0],
                        s),
                    this
                        .tangentInForced(
                            i,
                            r[
                            1],
                            s));
            return zl(...
                o) ? o :
                this
                    .getNormal(
                        n)
        }
        getVertex(n) {
            if (this
                .allowVertex(
                    n))
                return this
                    .getF(n)
        }
        getExtraAttr(n, r) {
            return this
                .vertices[n]
                .f[3 + r]
        }
        findJumpBetweenTwoSamples
            (n, r) {
            let i = this
                .getUV(n),
                s = this
                    .getF(n),
                o = 0,
                a = this
                    .getUV(r),
                u = this
                    .getF(r),
                c = 1,
                l = m =>
                    this._fn(Jn(
                        i,
                        a, m
                    ));
            if (!isFinite(s[
                0]) || !
                isFinite(s[
                    1]) || !
                isFinite(s[
                    2]) || !
                isFinite(u[
                    0]) || !
                isFinite(u[
                    1]) || !
                isFinite(u[
                    2]))
                return;
            let f = Py(o, s,
                c, u, l,
                (this
                    .xmax -
                    this
                        .xmin
                ) *
                1e-6, 0,
                0);
            if (f) return [
                this
                    .fn(Jn(i,
                        a,
                        ys(f[
                            0],
                            0,
                            1e-5
                        )
                    )),
                this
                    .fn(Jn(i,
                        a,
                        ys(f[
                            1],
                            1,
                            1e-5
                        )
                    ))
            ]
        }
        clip(n) {
            return this
                .insidePaddedDomain(
                    n) ? n :
                [NaN, NaN,
                    NaN
                ]
        }
        findFiniteBetweenTwoSamples
            (n, r) {
            let i = this
                .getUV(n),
                s = this
                    .getF(n),
                o = this
                    .getUV(r),
                a = this
                    .getF(r),
                u = l =>
                    this.clip(
                        this
                            ._fn(Jn(i,
                                o,
                                l
                            ))),
                c = xy(0,
                    this
                        .clip(
                            s), 1,
                    this
                        .clip(
                            a), u);
            if (c !==
                void 0)
                return this
                    .fn(Jn(i,
                        o,
                        c
                    ))
        }
        allowVertex(n) {
            return this
                .insidePaddedDomain(
                    this
                        .getF(n)
                )
        }
        isDegenerate(n, r, i) {
            let s = this
                .getF(n),
                o = this
                    .getF(r);
            if (xa(s, o) <
                this
                    .distThresh)
                return !0;
            let a = this
                .getF(i);
            return xa(o,
                a) < this
                    .distThresh ||
                xa(s, a) <
                this
                    .distThresh
        }
    };

    function wc(e, t, n, r, i, s) {
        let o = new p0(e, t, n, r,
            i, s);
        return $g(o)
    }
    var {
        floor: F2
    } = Math;

    function f0(e) {
        let t = [];
        for (let n of e) t.push(...
            n), t.push(NaN, NaN,
                NaN);
        return t
    }

    function Fc(e, t, n, r) {
        (n === void 0 || isNaN(
            n)) && (n = m0(t.min, t
                .max)), n = rr(F2(n), 2,
                    2e3);
        let {
            xmin: i,
            xmax: s,
            ymin: o,
            ymax: a,
            zmin: u,
            zmax: c
        } = r.viewport;
        u != null || (u = lr.zmin),
            c != null || (c = lr
                .zmax);
        let l = Xg(e, {
            min: t.min,
            max: t.max,
            nInitialSamples: n,
            xtolerance: (s -
                i) /
                1e3,
            ytolerance: (a -
                o) /
                1e3,
            ztolerance: (c -
                u) /
                1e3,
            map: p => p
        });
        return f0(l.segments)
    }

    function Yg(e, t, n, r) {
        let i = r.degreeMode ? Math
            .PI / 180 : 1;
        return Fc(s => {
            let o = e(s),
                a = o[0],
                u = o[1],
                c = o[2];
            return [a * xn(
                u *
                i),
            a * Kt(
                u *
                i),
                c
            ]
        }, t, n, r)
    }

    function d0(e, t, n, r) {
        let i = r.degreeMode ? Math
            .PI / 180 : 1;
        return Fc(s => {
            let o = e(s),
                a = o[0],
                u = o[1],
                c = o[2];
            return [a * Kt(
                c *
                i) *
                xn(u *
                    i),
            a * Kt(
                c *
                i) *
            Kt(u *
                i),
            a * xn(
                c *
                i)
            ]
        }, t, n, r)
    }

    function y0(e, t) {
        return {
            type: "linear",
            s: e,
            t
        }
    }

    function oN(e, t) {
        return {
            type: "logarithmic",
            s: e,
            t
        }
    }

    function aN(e, t) {
        return {
            type: "exponential",
            s: e,
            t
        }
    }

    function g0() {
        return y0(1, 0)
    }

    function V2([e, t], [n, r]) {
        let i = (r - n) / (t - e),
            s = (n + r) / 2 - i * (
                t + e) / 2;
        return y0(i, s)
    }

    function B2([e, t], [n, r]) {
        let i = (r - n) / (Math.log(
            t) - Math.log(
                e)),
            s = (Math.log(t) * n -
                Math.log(e) * r) / (
                    Math.log(t) - Math
                        .log(e));
        return oN(i, s)
    }

    function G2([e, t], [n, r]) {
        let i = (Math.log(r) - Math
            .log(n)) / (t - e),
            s = (t * Math.log(n) -
                e * Math.log(r)) / (
                    t - e);
        return aN(i, s)
    }

    function h0(e, t, n) {
        switch (e) {
            case "linear":
                return V2(t, n);
            case "logarithmic":
                return B2(t, n);
            case "exponential":
                return G2(t, n);
            default: {
                let r = e;
                throw new Error(
                    "Unexpected scale type: " +
                    r)
            }
        }
    }

    function b0({
        type: e,
        s: t,
        t: n
    }, r) {
        switch (e) {
            case "linear":
                return t * r + n;
            case "logarithmic":
                return t * Math.log(
                    r) + n;
            case "exponential":
                return Math.exp(t *
                    r + n);
            default:
                let i = e;
                throw new Error(
                    "Unexpected scale type: " +
                    i)
        }
    }

    function x0(e, t, n, r) {
        switch (e) {
            case "linear":
                return k2(t, n, r);
            case "logarithmic":
                return Math.pow(t,
                    1 - r) *
                    Math.pow(n, r);
            case "exponential":
                return r === 0 ? t :
                    r === 1 ? n :
                        Math.log((1 -
                            r) * Math
                                .exp(t) +
                            r * Math
                                .exp(n));
            default:
                let i = e;
                throw new Error(
                    "Unexpected scale type: " +
                    i)
        }
    }

    function k2(e, t, n) {
        return (1 - n) * e + n * t
    }

    function P0({
        type: e,
        s: t,
        t: n
    }) {
        switch (e) {
            case "linear":
                return y0(1 / t, -
                    n / t);
            case "logarithmic":
                return aN(1 / t, -
                    n / t);
            case "exponential":
                return oN(1 / t, -
                    n / t);
            default:
                let r = e;
                throw new Error(
                    "Unexpected scale type: " +
                    r)
        }
    }

    function T0(e) {
        switch (e) {
            case "linear":
                return "linear";
            case "logarithmic":
                return "exponential";
            case "exponential":
                return "logarithmic";
            default:
                let t = e;
                throw new Error(
                    "Unexpected scale type: " +
                    t)
        }
    }

    function Zg({
        width: e,
        height: t
    }) {
        return {
            left: 0,
            right: e,
            top: 0,
            bottom: t
        }
    }

    function Wg({
        xmin: e,
        xmax: t,
        ymin: n,
        ymax: r
    }) {
        return {
            left: e,
            right: t,
            bottom: n,
            top: r
        }
    }
    var Ou = class e {
        constructor(t, n) {
            this.xScale = t,
                this
                    .yScale = n
        }
        static fromRects(t, n, {
            xAxisScale: r,
            yAxisScale: i
        }) {
            return new e(h0(
                r, [t
                    .left,
                t
                    .right
            ], [n
                .left,
            n
                .right
            ]),
                h0(i, [t.bottom,
                t
                    .top
                ], [n
                    .bottom,
                n
                    .top
                ]))
        }
        static fromRectsInverse(
            t, n, {
                xAxisScale: r,
                yAxisScale: i
            }) {
            return e
                .fromRects(
                    n, t, {
                    xAxisScale: T0(
                        r
                    ),
                    yAxisScale: T0(
                        i
                    )
                })
        }
        inverse() {
            return new e(P0(
                this
                    .xScale
            ),
                P0(this
                    .yScale
                ))
        }
        mapX(t) {
            return b0(this
                .xScale,
                t)
        }
        mapY(t) {
            return b0(this
                .yScale,
                t)
        }
        mapPoint({
            x: t,
            y: n
        }) {
            return {
                x: this
                    .mapX(
                        t),
                y: this
                    .mapY(n)
            }
        }
        mapCoordinatePair([t,
            n]) {
            return [this
                .mapX(
                    t), this
                        .mapY(n)
            ]
        }
        mapRect({
            top: t,
            bottom: n,
            left: r,
            right: i
        }) {
            return {
                left: this
                    .mapX(
                        r),
                right: this
                    .mapX(
                        i),
                bottom: this
                    .mapY(
                        n),
                top: this
                    .mapY(t)
            }
        }
        interpolateX(t, n, r) {
            return x0(this
                .xScale
                .type,
                t, n, r)
        }
        interpolateY(t, n, r) {
            return x0(this
                .yScale
                .type,
                t, n, r)
        }
        dangerouslyGetXScaleFactor
            () {
            if (this.xScale
                .type !==
                "linear")
                throw new Error(
                    `Cannot get scale factor a '${this.xScale.type}' scale`
                );
            return this
                .xScale.s
        }
        dangerouslyGetYScaleFactor
            () {
            if (this.yScale
                .type !==
                "linear")
                throw new Error(
                    `Cannot get scale factor a '${this.yScale.type}' scale`
                );
            return this
                .yScale.s
        }
    };
    var I0 = class extends Pp {
        constructor(n, r, i, s,
            o, a = [0, 1, 2]
        ) {
            let u = r
                .width /
                1e8,
                c = i
                    .width /
                    1e8;
            super({
                resolution: o,
                uRange: r,
                vRange: i,
                du: u,
                dv: c,
                extraAttrCount: 0
            });
            this
                .vertices = [];
            this.fn = n => {
                let r =
                    this
                        ._fn(
                            n
                        ),
                    i =
                        this
                            .tangentInForcedDf(
                                n,
                                [this
                                    .du,
                                    0
                                ],
                                r
                            ),
                    s =
                        this
                            .tangentInForcedDf(
                                n,
                                [0, this
                                    .dv
                                ],
                                r
                            ),
                    o =
                        kl([this.du,
                            0,
                            i
                        ],
                            [0, this
                                .dv,
                                s
                            ]
                        );
                return {
                    uv: n,
                    f: r,
                    normal: [
                        o[this
                            .perm0
                        ],
                        o[this
                            .perm1
                        ],
                        o[this
                            .perm2
                        ]
                    ],
                    dfEast: i,
                    dfNorth: s
                }
            };
            this._fn = l =>
                n(l[0], l[
                    1]),
                this
                    .paddedOutputDomain =
                new ee(s
                    .min -
                    5 * s
                        .width,
                    s.max +
                    5 * s
                        .width),
                this
                    .jumpTolerance =
                s.width /
                1e3, this
                    .perm0 = a[
                0], this
                    .perm1 = a[
                1], this
                    .perm2 = a[
                2]
        }
        getVertexCount() {
            return this
                .vertices
                .length
        }
        getUV(n) {
            return this
                .vertices[n]
                .uv
        }
        getNormal(n) {
            return this
                .vertices[n]
                .normal
        }
        _addVertex(n) {
            return this
                .vertices
                .push(n) - 1
        }
        copyVertex(n) {
            return this
                .addVertex(
                    this
                        .vertices[
                    n])
        }
        getF(n) {
            return this
                .vertices[n]
                .f
        }
        getDfNorth(n) {
            return this
                .vertices[n]
                .dfNorth
        }
        getDfEast(n) {
            return this
                .vertices[n]
                .dfEast
        }
        tangentInForcedDf(n, r,
            i) {
            let s = Ef(n,
                r);
            return this._fn(
                s) - i
        }
        tangentInForced(n, r,
            i) {
            let s = Ef(n,
                r);
            return [r[0], r[
                1],
            this
                ._fn(
                    s) - i
            ]
        }
        getExtraAttr() {
            throw new Error(
                "Unexpected getExtraAttr call in explicit-surface.ts"
            )
        }
        _isVertexAtCrease(n) {
            let r = this
                .getUV(n),
                i = this
                    .getDfEast(
                        n),
                s = this
                    .getDfNorth(
                        n),
                o = this
                    .getF(n),
                a = this
                    .tangentInForcedDf(
                        r, [-
                            this
                                .du,
                        0
                    ], o);
            if ((-this
                .duSquared +
                a * i) /
                Math.sqrt((
                    this
                        .duSquared +
                    a *
                    a) *
                    (this
                        .duSquared +
                        i *
                        i)
                ) > -Tp)
                return !0;
            let l = this
                .tangentInForcedDf(
                    r, [0, -
                        this
                            .dv
                ], o);
            return (-this
                .dvSquared +
                s * l) /
                Math.sqrt((
                    this
                        .dvSquared +
                    s *
                    s) *
                    (this
                        .dvSquared +
                        l *
                        l)
                ) > -Tp
        }
        hintedNormal(n, r) {
            let i = this
                .getUV(n),
                s = this
                    .getF(n),
                o = kl(this
                    .tangentInForced(
                        i,
                        r[
                        0],
                        s),
                    this
                        .tangentInForced(
                            i,
                            r[
                            1],
                            s));
            return zl(...
                o) ? [o[this
                    .perm0
                ],
                o[this
                    .perm1
                ],
                o[this
                    .perm2
                ]
            ] : this
                .getNormal(
                    n)
        }
        getVertex(n) {
            if (!this
                .allowVertex(
                    n))
                return;
            let r = this
                .getF(n),
                i = this
                    .getUV(n);
            return [this
                .perm0 ===
                2 ? r :
                i[this
                    .perm0
                ],
            this
                .perm1 ===
                2 ? r :
                i[this
                    .perm1
                ],
            this
                .perm2 ===
                2 ? r :
                i[this
                    .perm2
                ]
            ]
        }
        findJumpBetweenTwoSamples
            (n, r) {
            let i = this
                .getUV(n),
                s = this
                    .getF(n),
                o = 0,
                a = this
                    .getUV(r),
                u = this
                    .getF(r),
                c = 1,
                l = f =>
                    this._fn(Jn(
                        i,
                        a, f
                    ));
            if (!isFinite(
                s) || !
                isFinite(u))
                return;
            let p = qD(o, s,
                c, u, l,
                this
                    .jumpTolerance
            );
            if (p) return [
                this
                    .fn(Jn(i,
                        a,
                        ys(p[
                            0],
                            0,
                            1e-5
                        )
                    )),
                this
                    .fn(Jn(i,
                        a,
                        ys(p[
                            1],
                            1,
                            1e-5
                        )
                    ))
            ]
        }
        findFiniteBetweenTwoSamples
            (n, r) {
            let i = this
                .getUV(n),
                s = this
                    .getF(n),
                o = this
                    .getUV(r),
                a = this
                    .getF(r),
                u = p => {
                    let f =
                        this
                            ._fn(
                                p
                            );
                    return f <
                        this
                            .paddedOutputDomain
                            .min ||
                        f >
                        this
                            .paddedOutputDomain
                            .max ?
                        NaN :
                        f
                },
                c = p => u(
                    Jn(i, o,
                        p)),
                l = si(0,
                    this
                        .paddedOutputDomain
                        .min <
                        s && s <
                        this
                            .paddedOutputDomain
                            .max ?
                        s : NaN,
                    1, this
                        .paddedOutputDomain
                        .min <
                        a && a <
                        this
                            .paddedOutputDomain
                            .max ?
                    a : NaN,
                    c);
            if (l !==
                void 0)
                return this
                    .fn(Jn(i,
                        o,
                        l
                    ))
        }
        allowVertex(n) {
            let r = this
                .getF(n);
            return this
                .paddedOutputDomain
                .min < r &&
                r < this
                    .paddedOutputDomain
                    .max
        }
        isDegenerate(n, r, i) {
            let s = this
                .getUV(n),
                o = this
                    .getUV(r),
                a = this
                    .getUV(i),
                u = this
                    .uRange
                    .width *
                    1e-6,
                c = this
                    .vRange
                    .width *
                    1e-6;
            return Math.abs(
                s[0] -
                o[0]) <
                u && Math
                    .abs(s[1] -
                        o[1]) <
                c || Math
                    .abs(o[0] -
                        a[0]) <
                u && Math
                    .abs(o[1] -
                        a[1]) <
                c || Math
                    .abs(a[0] -
                        s[0]) <
                u && Math
                    .abs(a[1] -
                        s[1]) <
                c
        }
    };

    function jg(e, t, n, r, i, s = [
        0, 1, 2
    ]) {
        let o = new I0(e, t, n, r,
            i, s);
        return $g(o)
    }

    function fN(e, t, n, r) {
        let i = H2(e, t, n, r);
        return f0(i)
    }

    function H2(e, t, n, r) {
        return new D0(e, t, new ee(n
            .xmin, n.xmax),
            new ee(n.ymin, n
                .ymax), new ee(n
                    .zmin, n.zmax),
            r).run()
    }
    var U2 = {},
        D0 = class extends xp {
            constructor(n, r, i, s,
                o, a) {
                super(Ug, i, s,
                    o, a);
                this.f = n;
                this.g = r;
                this
                    .vertexFGZs = {};
                this
                    .vertexZeroF = {};
                this
                    .vertexZeroG = {};
                this.threshF =
                    0;
                this.threshG =
                    0;
                this.cubeID = 0;
                this.edgesMaybeCrossF =
                    0;
                this.edgesMaybeCrossG =
                    0;
                this.tetEdgeCrossings =
                    new Array(
                        26);
                this.edgeFGZs =
                    new Array(
                        26);
                this.edgeCrossings =
                    new Map;
                this.allFGZs =
                    new Map
            }
            setAt(n, r, i, s, o) {
                let a = this.f(
                    i, s, o
                ),
                    u = this.g(
                        i, s, o
                    );
                n.set(r, a, u)
            }
            run() {
                return this
                    .loopOverUnitCubes(
                        this
                            .onEachCube
                            .bind(
                                this
                            )),
                    this
                        .traceCurves()
            }
            onEachCube() {
                this.cubeID =
                    nN(this.i,
                        this.j,
                        this.k),
                    this
                        .pruneEdges(),
                    this
                        .edgesMaybeCrossF &&
                    this
                        .edgesMaybeCrossG &&
                    (this
                        .setVertexPositions(),
                        this
                            .setVertexZeros(),
                        this
                            .setEdgeCrossings(),
                        this
                            .insertCurveSegmentsFromCube()
                    )
            }
            pruneEdges() {
                this.edgesMaybeCrossF =
                    0, this
                        .edgesMaybeCrossG =
                    0;
                for (let n =
                    0; n <
                    26; n++) {
                    let r = Er[
                        n *
                        2],
                        i = Er[
                            n *
                            2 +
                            1],
                        s = this
                            .cubeVertexValue
                            .getX(
                                r),
                        o = this
                            .cubeVertexValue
                            .getY(
                                r),
                        a = this
                            .cubeVertexValue
                            .getX(
                                i),
                        u = this
                            .cubeVertexValue
                            .getY(
                                i);
                    !(s > 0 &&
                        a > 0 ||
                        s < 0 &&
                        a < 0
                    ) && (
                            isFinite(
                                s
                            ) ||
                            isFinite(
                                a)
                        ) && (
                            this
                                .edgesMaybeCrossF |=
                            1 << n),
                        !(o > 0 &&
                            u > 0 ||
                            o < 0 &&
                            u < 0
                        ) && (
                            isFinite(
                                o
                            ) ||
                            isFinite(
                                u)
                        ) && (
                            this
                                .edgesMaybeCrossG |=
                            1 << n)
                }
            }
            setVertexZeros() {
                let n = 0,
                    r = 0;
                for (let o =
                    0; o <
                    9; o++) {
                    let a = this
                        .cubeVertexValue
                        .getX(
                            o),
                        u = this
                            .cubeVertexValue
                            .getY(
                                o),
                        c = Math
                            .abs(a),
                        l = Math
                            .abs(u);
                    c > n &&
                        isFinite(
                            c
                        ) &&
                        (n = c),
                        l > r &&
                        isFinite(
                            c
                        ) &&
                        (r = l)
                }
                let i = this
                    .threshF =
                    n * Number
                        .EPSILON *
                    32,
                    s = this
                        .threshG =
                        r * Number
                            .EPSILON *
                        32;
                for (let o =
                    0; o <
                    9; o++) {
                    let a = this
                        .cubeVertexValue
                        .getX(
                            o),
                        u = this
                            .cubeVertexValue
                            .getY(
                                o),
                        c = Math
                            .abs(a),
                        l = Math
                            .abs(u);
                    if (this
                        .vertexZeroF[
                        o] =
                        c <= i,
                        this
                            .vertexZeroG[
                        o] =
                        l <= s,
                        c <=
                        i &&
                        l <= s
                    ) {
                        let p =
                            this
                                .cubeVertex[
                            o
                            ],
                            f =
                                this
                                    .createFGZ(
                                        rN(this
                                            .cubeID,
                                            o
                                        ),
                                        p
                                    );
                        this.vertexFGZs[
                            o
                        ] =
                            f
                    } else this
                        .vertexFGZs[
                        o] =
                        void 0
                }
            }
            getEdgeCrossings(n) {
                let r = this
                    .edgesMaybeCrossF >>
                    n & 1,
                    i = this
                        .edgesMaybeCrossG >>
                        n & 1;
                if (!r && !i)
                    return U2;
                let s = pd(this
                    .cubeID,
                    n),
                    o = this
                        .edgeCrossings
                        .get(s);
                if (o !==
                    void 0)
                    return o;
                let a = this
                    .getEdgeCrossingsUncached(
                        n, r, i
                    );
                return this
                    .edgeCrossings
                    .set(s, a),
                    a
            }
            getEdgeCrossingsUncached
                (n, r, i) {
                let s = Er[n *
                    2],
                    o = Er[n *
                        2 + 1],
                    a = this
                        .cubeVertexValue
                        .getX(s),
                    u = this
                        .cubeVertexValue
                        .getY(s),
                    c = this
                        .cubeVertexValue
                        .getX(o),
                    l = this
                        .cubeVertexValue
                        .getY(o),
                    p = this
                        .cubeVertex[
                        s],
                    f = this
                        .cubeVertex[
                        o],
                    m = !r ||
                        a === 0 ||
                        c === 0 ?
                        void 0 : ld(
                            this.f,
                            p, f, a,
                            c),
                    g = !i ||
                        u === 0 ||
                        l === 0 ?
                        void 0 : ld(
                            this.g,
                            p, f, u,
                            l),
                    d = this
                        .threshF;
                !m && g && Math
                    .abs(a) <=
                    d && Math
                        .abs(c) <=
                    d && Math
                        .abs(this.f(
                            g[
                            0],
                            g[
                            1],
                            g[2]
                        )) <=
                    d && (m =
                        g);
                let y = this
                    .threshG;
                return !g &&
                    m && Math
                        .abs(u) <=
                    y && Math
                        .abs(l) <=
                    y && Math
                        .abs(this.g(
                            m[
                            0],
                            m[
                            1],
                            m[2]
                        )) <=
                    y && (g =
                        m), {
                    f: m,
                    g
                }
            }
            getTriangleCrossing(n) {
                let r = r0(this
                    .cubeID,
                    n),
                    i = this
                        .allFGZs
                        .get(r);
                if (i !==
                    void 0)
                    return i;
                let s = this
                    .getTriangleCrossingUncached(
                        n);
                return this
                    .allFGZs
                    .set(r, s),
                    s
            }
            createFGZ(n, r) {
                let i = this
                    .allFGZs
                    .get(n);
                if (i) return i;
                let s = {
                    id: n,
                    pos: r,
                    connections: [],
                    visited:
                        !1
                };
                return this
                    .allFGZs
                    .set(n, s),
                    s
            }
            getTriangleCrossingUncached
                (n) {
                let r = [],
                    i = [],
                    s = n0[n];
                for (let a =
                    0; a <
                    3; a++) {
                    let u = s[
                        a];
                    if (this
                        .vertexFGZs[
                        u])
                        return null;
                    this.vertexZeroF[
                        u
                    ] &&
                        r.push(
                            this
                                .cubeVertex[
                            u
                            ]
                        ),
                        this
                            .vertexZeroG[
                        u
                        ] &&
                        i.push(
                            this
                                .cubeVertex[
                            u
                            ]
                        )
                }
                let o = t0[n];
                for (let a =
                    0; a <
                    3; a++) {
                    let u = o[
                        a],
                        c = this
                            .tetEdgeCrossings[
                            u];
                    if (this
                        .edgeFGZs[
                        u
                    ] ||
                        !c)
                        continue;
                    let l = c.f,
                        p = c.g,
                        f = Er[
                            2 *
                            u],
                        m = Er[
                            2 *
                            u +
                            1];
                    l && !this
                        .vertexZeroF[
                        f
                    ] &&
                        !this
                            .vertexZeroF[
                        m
                        ] &&
                        r.push(
                            l),
                        p && !
                        this
                            .vertexZeroG[
                        f
                        ] &&
                        !this
                            .vertexZeroG[
                        m
                        ] &&
                        i.push(
                            p)
                }
                if (r.length ===
                    2 && i
                        .length ===
                    2) {
                    let a = q2(
                        r[
                        0],
                        r[
                        1],
                        i[
                        0],
                        i[1]
                    );
                    return a ? {
                        id: r0(this
                            .cubeID,
                            n
                        ),
                        pos: a,
                        connections: [],
                        visited:
                            !
                            1
                    } : null
                } else return null
            }
            setEdgeCrossings() {
                for (let n =
                    0; n <
                    26; n++) {
                    let r = this
                        .getEdgeCrossings(
                            n),
                        i = r.f,
                        s = r.g,
                        o = Er[
                            n *
                            2],
                        a = Er[
                            n *
                            2 +
                            1];
                    if (this
                        .vertexFGZs[
                        o
                    ] ||
                        this
                            .vertexFGZs[
                        a])
                        this
                            .tetEdgeCrossings[
                            n] =
                            void 0,
                            this
                                .edgeFGZs[
                            n] =
                            void 0;
                    else if (
                        i &&
                        this
                            .vertexZeroG[
                        o
                        ] &&
                        this
                            .vertexZeroG[
                        a]
                    ) {
                        let u =
                            this
                                .createFGZ(
                                    pd(this
                                        .cubeID,
                                        n
                                    ),
                                    i
                                );
                        this.edgeFGZs[
                            n
                        ] =
                            u,
                            this
                                .tetEdgeCrossings[
                            n
                            ] =
                            void 0
                    } else if (
                        s &&
                        this
                            .vertexZeroF[
                        o
                        ] &&
                        this
                            .vertexZeroF[
                        a]
                    ) {
                        let u =
                            this
                                .createFGZ(
                                    pd(this
                                        .cubeID,
                                        n
                                    ),
                                    s
                                );
                        this.edgeFGZs[
                            n
                        ] =
                            u,
                            this
                                .tetEdgeCrossings[
                            n
                            ] =
                            void 0
                    } else if (
                        i &&
                        s && xa(
                            i, s
                        ) <
                        1e-8) {
                        let u =
                            this
                                .createFGZ(
                                    pd(this
                                        .cubeID,
                                        n
                                    ),
                                    i
                                );
                        this.edgeFGZs[
                            n
                        ] =
                            u,
                            this
                                .tetEdgeCrossings[
                            n
                            ] =
                            void 0
                    } else this
                        .edgeFGZs[
                        n] =
                        void 0,
                        this
                            .tetEdgeCrossings[
                        n] =
                        r
                }
            }
            insertCurveSegmentsFromCube
                () {
                for (let n =
                    0; n <
                    12; n++)
                    this
                        .insertCurveSegmentsFromTetrahedron(
                            n)
            }
            insertCurveSegmentsFromTetrahedron
                (n) {
                let r = [],
                    i = tN[n];
                for (let l =
                    0; l <
                    4; l++) {
                    let p = this
                        .getTriangleCrossing(
                            i[l]
                        );
                    p && r.push(
                        p)
                }
                let s = [],
                    o = kg[n];
                for (let l =
                    0; l <
                    6; l++) {
                    let p = this
                        .edgeFGZs[
                        o[l]
                    ];
                    p && s.push(
                        p)
                }
                let a = [],
                    u = [Er[o[
                        0] *
                        2],
                    Er[o[
                    0] *
                    2 +
                    1],
                    Er[o[
                    3] *
                    2],
                    Er[o[
                    3] *
                    2 +
                    1]
                    ];
                for (let l of
                    u) {
                    let p = this
                        .vertexFGZs[
                        l];
                    p && a.push(
                        p)
                }
                let c = [...a,
                ...s,
                ...r
                ];
                switch (c
                    .length) {
                    case 0:
                    case 1:
                        break;
                    case 2:
                        this.connectCrossings(
                            c[
                            0],
                            c[
                            1]
                        );
                        break;
                    case 3:
                        r.length ===
                            2 &&
                            this
                                .connectCrossings(
                                    r[
                                    0],
                                    r[
                                    1]
                                );
                        break;
                    case 4:
                        r.length ===
                            4 &&
                            (this
                                .connectCrossings(
                                    r[
                                    0],
                                    r[
                                    1]
                                ),
                                this
                                    .connectCrossings(
                                        r[
                                        2],
                                        r[
                                        3]
                                    )
                            );
                        break;
                    default:
                        throw new Error(
                            "Programming error: 5 is impossible."
                        )
                }
            }
            connectCrossings(n, r) {
                n.connections
                    .some(i => i
                        .id ===
                        r.id) ||
                    r
                        .connections
                        .some(i => i
                            .id ===
                            n.id) ||
                    n
                        .connections
                        .length >=
                    2 || r
                        .connections
                        .length >=
                    2 || (n
                        .connections
                        .push(
                            r), r
                                .connections
                                .push(n)
                    )
            }
            traceCurves() {
                let n = {
                    xtolerance: this
                        .size
                        .x *
                        .1,
                    ytolerance: this
                        .size
                        .y *
                        .1,
                    ztolerance: this
                        .size
                        .z *
                        .1,
                    map: i =>
                        i
                },
                    r = new xs(
                        n);
                for (let i of
                    this
                        .allFGZs
                        .values())
                    i && !i
                        .visited &&
                        i
                            .connections
                            .length ===
                        1 && this
                            .traceCurve(
                                r, i);
                for (let i of
                    this
                        .allFGZs
                        .values())
                    i && !i
                        .visited &&
                        this
                            .traceCurve(
                                r, i);
                return r
                    .finish()
                    .segments
            }
            traceCurve(n, r) {
                let i = r;
                for (; ;) {
                    n.addPoint(r
                        .pos
                    ), r
                        .visited = !
                        0;
                    let s;
                    for (let o of
                        r
                            .connections)
                        o
                            .visited ||
                            (s = o);
                    if (!s)
                        break;
                    r = s
                }
                i.connections
                    .length ===
                    2 && n
                        .addPoint(i
                            .pos), n
                                .breakSegment()
            }
        },
        [Jg, uN, E0] = [new Qe,
        new Qe, new Qe
        ],
        cN = new Qe,
        [M0, v0, lN] = [new Qe,
        new Qe, new Qe
        ],
        [Qg, pN, Kg] = [new Qe,
        new Qe, new Qe
        ];

    function q2(e, t, n, r) {
        Jg.set(e[0], e[1], e[2]), uN
            .set(t[0], t[1], t[2]),
            E0.set(n[0], n[1], n[
                2]), cN.set(r[0], r[1],
                    r[2]), M0
                        .subVectors(uN, Jg), v0
                            .subVectors(cN, E0), lN
                                .subVectors(E0, Jg), Qg
                                    .crossVectors(M0, v0),
            pN.crossVectors(lN, v0);
        let i = Qg.dot(pN) / Qg.dot(
            Qg);
        return 0 <= i && i <= 1 ? (
            Kg.addVectors(Jg, M0
                .multiply(i)), [
                Kg.x, Kg.y, Kg.z
            ]) : null
    }

    function eh(e, t, n, r) {
        let i = [],
            s = [],
            o = [],
            a = [],
            {
                xmin: u,
                xmax: c,
                ymin: l,
                ymax: p,
                zmin: f,
                zmax: m
            } = n,
            g, d, y;
        switch (r) {
            case "z":
                g = {
                    xmin: u,
                    xmax: c,
                    ymin: l,
                    ymax: p
                }, d = (P,
                    M) => [P[M], P[
                        M + 1],
                        f, P[M], P[
                    M + 1],
                        m
                    ], y = (P, M) =>
                        e(P, M, 0);
                break;
            case "y":
                g = {
                    xmin: u,
                    xmax: c,
                    ymin: f,
                    ymax: m
                }, d = (P,
                    M) => [P[M], l,
                    P[M + 1], P[
                    M], p,
                    P[M + 1]
                    ], y = (P, M) =>
                        e(P, 0, M);
                break;
            case "x":
                g = {
                    xmin: f,
                    xmax: m,
                    ymin: l,
                    ymax: p
                }, d = (P,
                    M) => [u, P[M +
                        1], P[
                        M], c, P[M +
                        1], P[M]
                    ], y = (P, M) =>
                        e(0, M, P);
                break
        }
        let h = Zg({
            width: 500,
            height: 500
        }),
            b = {
                ...g,
                mathToPixels: Ou
                    .fromRects(Wg(
                        g), h, {
                        xAxisScale: "linear",
                        yAxisScale: "linear"
                    }),
                tolerance: Xs
            },
            x = ud(y, b);
        for (let P of x.segments)
            for (let M = 0; M < P
                .length / 2; M++) {
                let [I, E, v, O, A,
                    N
                ] = d(P, 2 * M);
                if (i.push(I, E, v,
                    O, A, N), o
                        .push(I, E, O,
                            A), t) {
                    let L = t(I, E,
                        v),
                        z = t(O, A,
                            N);
                    s.push(L[0], L[
                        1],
                        L[2]), s
                            .push(z[0],
                                z[1], z[
                            2])
                } else s.push(0, 0,
                    0), s.push(
                        0, 0, 0);
                if (M > 0) {
                    let L = i
                        .length /
                        3 - 4;
                    a.push(L, L + 1,
                        L + 2),
                        a.push(L +
                            2, L +
                        1, L + 3
                        )
                }
            }
        return bp(a, i, s, o, 0, [],
            .7), {
            positions: i,
            normals: s,
            faces: a,
            uvs: o,
            resolved: x
                .resolved,
            extraAttrs: []
        }
    }
    var {
        floor: dN
    } = Math, mN = 1e4, th = 5, yN =
            (e, t, n) => ({
                x: e,
                y: t,
                z: n
            }), gN = (e, t, n) => ({
                x: n,
                y: e,
                z: t
            }), hN = (e, t, n) => ({
                x: e,
                y: n,
                z: t
            }), nh = class {
                constructor() {
                    this.xmin = lr
                        .xmin;
                    this.xmax = lr
                        .xmax;
                    this.ymin = lr
                        .ymin;
                    this.ymax = lr
                        .ymax;
                    this.zmin = lr
                        .zmin;
                    this.zmax = lr
                        .zmax
                }
            }, $2 = 0;

    function fi() {
        return "result_" + $2++
    }

    function Y2() {
        return {
            zeros: {
                x: [],
                y: []
            },
            extrema: {
                x: [],
                y: []
            },
            intercept: {
                x: [],
                y: []
            }
        }
    }

    function IN(e) {
        return {
            graphMode: 15,
            error: e,
            segments: []
        }
    }

    function O0(e, t) {
        let n = e[0] + t.min * e[1],
            r = e[0] + t.max * e[1],
            i = {
                zeros: {
                    x: [],
                    y: []
                },
                intercept: {
                    x: [],
                    y: []
                },
                extrema: {
                    x: [],
                    y: []
                }
            };
        if (!isFinite(n) || !
            isFinite(r)) return {
                segments: [],
                poi: i,
                resolved: !0
            };
        let s = [
            [t.min, n, t.max, r]
        ],
            o = -e[0] / e[1];
        return !isNaN(o) && o >= t
            .min && o <= t.max && (i
                .zeros.x.push(o), i
                    .zeros.y.push(0)),
            0 >= t.min && 0 <= t
                .max && (i.intercept.x
                    .push(0), i
                        .intercept.y.push(e[
                            0])), {
            segments: s,
            poi: i,
            resolved: !0
        }
    }

    function X2(e, t) {
        let n = O0(e[0], t),
            r = O0(e[1], t);
        return n.segments.length &&
            r.segments.length && n
                .segments[0].length ===
            4 && r.segments[0]
                .length === 4 ? {
            segments: [
                [n.segments[
                    0][
                    1],
                r
                    .segments[
                0][
                1],
                n
                    .segments[
                0][
                3],
                r
                    .segments[
                0][
                3]
                ]
            ],
            resolved: !0
        } : {
            segments: [],
            resolved: !0
        }
    }

    function Z2(e, t) {
        let n = e(t);
        return {
            segments: [
                [...n, ...n]
            ],
            resolved: !0
        }
    }

    function bN(e, t, n) {
        let {
            mappedFn: r,
            jumpTolerance: i,
            screen: s
        } = n, [o, a] = e, [u, c] =
                t, l = pa(o, u), p = r(l),
            f = s.height;
        if (!(a < 0 && c < 0 && (
            a >= p || c >= p
        )) && !(a > f && c >
            f && (a <= p || c <=
                p))) return Hl(
                    o, a, l, p, u,
                    c, r, i)
    }
    var S0 = (e, t, n) => {
        let {
            fn: r,
            mappedFn: i,
            jumpTolerance: s,
            accumulator: o
        } = n;
        if (!isFinite(s) || s <=
            0) return;
        let a = bN(e, t, n);
        if (!a) return;
        let u = (t[0] - e[0]) /
            10,
            c = [-u, u],
            l;
        for (let p = 0; p < c
            .length; p++) {
            let f = e[0] + c[p],
                m = i(f);
            isFinite(m) || ([f,
                m
            ] = e, f =
                e[0], m = e[
                1]);
            let g = t[0] + c[p],
                d = i(g);
            if (isFinite(d) ?
                l = g : [g, d] =
                t, bN([f, m], [
                    g, d
                ], n)) {
                let [y, h] = a;
                o.addPoint([y,
                    r(y)
                ]), o
                    .breakSegment(),
                    o.addPoint([
                        h,
                        r(h)
                    ]);
                return
            }
        }
        return l
    },
        C0 = class {
            constructor(t, n, r) {
                let i = s => n
                    .mathToPixels
                    .mapY(t(s));
                this.derivative =
                    r, this
                        .accumulator =
                    new cd(n, t,
                        r), this
                            .fn = t,
                    this
                        .mathToPixels =
                    n
                        .mathToPixels,
                    this
                        .mappedFn =
                    i, this
                        .jumpTolerance =
                    n
                        .tolerance ||
                    0, this
                        .screen = n
                        .screen
            }
        };

    function xN(e, t, n, r) {
        let i = n,
            s = e(i),
            o = t.mapY(s);
        return r > 0 && !isFinite(
            o) && (i = n + r, s = e(
                i), o = t.mapY(
                    s)), r > 0 && !
                    isFinite(o) && (i = n -
                        r, s = e(i), o = t
                            .mapY(s)), [i, s, o]
    }

    function N0(e, t, n) {
        let r = new C0(e, t, n),
            {
                mathToPixels: i,
                mappedFn: s
            } = r,
            o = t.nInitialSamples,
            [a, u, c] = xN(e, i, t
                .min, 0);
        isFinite(c) && r.accumulator
            .addPoint([a, u]);
        for (var l = 1; l <
            o; l++) {
            let p = i.interpolateX(t
                .min, t.max, l /
            (o - 1)),
                f = l === o - 1 ?
                    0 : Math.abs(a -
                        p) / 10,
                [m, g, d] = xN(e, i,
                    p, f);
            if (isFinite(d) &&
                isFinite(c)) {
                let y = S0([a, c], [
                    m, d
                ], r);
                y !== void 0 && (m =
                    y, g = e(m),
                    d = i.mapY(
                        g)), r
                            .accumulator
                            .addPoint([m,
                                g])
            } else if (isFinite(
                d) && !isFinite(c)
            ) {
                let y = si(a, c, m,
                    d, s);
                if (y !== void 0) {
                    y !== m && r
                        .accumulator
                        .addPoint([
                            y,
                            e(y)
                        ]);
                    let h = S0([y,
                        s(y)
                    ], [m,
                        d],
                        r);
                    h !== void 0 &&
                        (m = h, g =
                            e(m),
                            d = i
                                .mapY(g)
                        ), r
                            .accumulator
                            .addPoint([
                                m, g
                            ])
                }
            } else if (!isFinite(
                d) && isFinite(c)) {
                let y = si(a, c, m,
                    d, s);
                if (y !== void 0) {
                    let h = S0([a,
                        c],
                        [y, s(
                            y)],
                        r);
                    h !== void 0 &&
                        (y = h),
                        y !== a && r
                            .accumulator
                            .addPoint([
                                y,
                                e(y)
                            ]), r
                                .accumulator
                                .breakSegment()
                }
            }
            a = m, u = g, c = d
        }
        return r.accumulator
            .finish()
    }

    function W2(e) {
        let {
            fn: t,
            min: n,
            max: r
        } = e, i = Math.floor(n),
            s = Math.ceil(r), o = !
                0;
        s - i + 1 > mN && (s = i + (
            mN - 1), o = !1);
        let a = [];
        for (let u = i; u <=
            s; u++) {
            let c = t(u);
            !isFinite(u) || !
                isFinite(c) || a
                    .push([u, c])
        }
        return {
            segments: a,
            resolved: o
        }
    }

    function j2(e, t, n, r) {
        let i = t.min,
            s = t.max - t.min,
            o = t.rtoleranceMath,
            a = Math.floor(s / (Math
                .PI / n)),
            u, c, l;

        function p(f, m) {
            let g = m % 2 === 0 ?
                1 : -1;
            if (!r && g === -1)
                return !1;
            let d = m * (Math.PI /
                n),
                y = [i, i + 1, i +
                    2, i + 3
                ],
                h = !1;
            for (let b = 0, x = y
                .length; b <
                x; b++) {
                let P = f(y[b]),
                    M = f(y[b] + d);
                if (isFinite(P) &&
                    isFinite(M) && (
                        h = !0),
                    isFinite(P) !==
                    isFinite(M) ||
                    Math.abs(P - g *
                        M) > o)
                    return !1
            }
            return !!h
        }
        for (u = 1; u <= a; u++)
            if (p(e, u)) {
                for (l = u, c =
                    2; c * u <=
                    a; c++) p(e, c *
                        u) || (l =
                            void 0);
                if (l) break
            } return l ? l * (Math
                .PI / n) : null
    }

    function EN(e) {
        return [e[1] * Math.cos(e[
            0]), e[1] * Math
                .sin(e[0])
        ]
    }

    function Xg(e, t) {
        if (t.max < t.min) return {
            segments: [],
            resolved: !0
        };
        if (t.parameterTransform) {
            let p = t
                .parameterTransform,
                f = e;
            e = m => f(p(m))
        }
        let {
            xtolerance: n,
            ytolerance: r,
            ztolerance: i,
            map: s
        } = t, o = new xs({
            xtolerance: n,
            ytolerance: r,
            ztolerance: i,
            map: s
        }), a = 10, u = t.min,
            c = e(u);
        isFinite(c[0]) && isFinite(
            c[1]) && o.addPoint(
                c);
        let l = t.nInitialSamples;
        for (let p = 1; p <
            l; p++) {
            let f = p / (l - 1),
                m = (1 - f) * t
                    .min + f * t.max,
                g = e(m);
            md(e, u, c, m, g, a, o,
                t.screen), u =
                m, c = g
        }
        return o.finish()
    }

    function J2(e, t) {
        if (e.length !== t.length)
            return !1;
        for (let n = 0; n < e
            .length; n++)
            if (e[n] !== t[n])
                return !1;
        return !0
    }

    function md(e, t, n, r, i, s, o,
        a) {
        if (r === t) return;
        let {
            xtolerance: u,
            ytolerance: c,
            ztolerance: l,
            map: p
        } = o, f = pa(t, r), m = e(
            f), g = p(n), d = p(
                i), y = p(m), h =
                isFinite(g[0]) &&
                isFinite(g[1]) && (g
                    .length === 2 ||
                    isFinite(g[2])), b =
                isFinite(d[0]) &&
                isFinite(d[1]) && (d
                    .length === 2 ||
                    isFinite(d[2])), x =
                isFinite(y[0]) &&
                isFinite(y[1]) && (y
                    .length === 2 ||
                    isFinite(y[2]));
        if (s === 0 || f === t ||
            f === r) {
            o.breakSegment(), b && o
                .addPoint(i);
            return
        }
        if (!(!h && !b)) {
            if (h !== b) {
                let P = t,
                    M = r,
                    I = n,
                    E = i;
                for (; t !== f &&
                    f !== r;) x ==
                        h ? (t = f, n =
                            m, g = y,
                            h = x) : (
                        r = f, i =
                        m, d = y,
                        b = x), f =
                        t + (r - t) / 2,
                        m = e(f), y = p(
                            m), x =
                        isFinite(y[
                            0]) && isFinite(
                                y[1]) && (y
                                    .length ===
                                    2 ||
                                    isFinite(y[
                                        2]));
                h ? (md(e, P, I, t,
                    n, s -
                1, o, a
                ), o
                    .breakSegment()
                ) : (o
                    .breakSegment(),
                    o.addPoint(
                        i), md(
                            e, r, i,
                            M, E,
                            s - 1,
                            o, a));
                return
            }
            if (h && x && b) {
                let P = J2(g, d),
                    M = Rs(y[0], y[
                        1], y[
                        2] || 0, g[
                    0], g[
                    1], g[2] ||
                    0, d[0], d[
                    1], d[
                    2] || 0),
                    I = M > .2 &&
                        M < .8 && Math
                            .abs(y[0] - (g[
                                0] +
                                M * (d[
                                    0] -
                                    g[0]
                                ))) <=
                        u && Math.abs(y[
                            1] - (g[
                                1] +
                                M * (d[
                                    1] -
                                    g[1]
                                ))) <=
                        c && (g
                            .length ===
                            2 || Math
                                .abs(y[2] -
                                    (g[2] +
                                        M *
                                        (d[2] -
                                            g[
                                            2]
                                        )
                                    )
                                ) <= l);
                if (P || I || a &&
                    Q2(g, y, d, a)
                ) {
                    o.addPoint(i);
                    return
                }
            }
            md(e, t, n, f, m, s - 1,
                o, a), md(e, f,
                    m, r, i, s - 1,
                    o, a)
        }
    }

    function Q2(e, t, n, {
        width: r,
        height: i
    }) {
        return e[0] < 0 && n[0] <
            0 && (e[0] >= t[0] || n[
                0] >= t[0]) || e[
                0] > r && n[0] > r && (
                e[0] <= t[0] || n[
                0] <= t[0]) || e[
                1] < 0 && n[1] < 0 && (
                e[1] >= t[1] || n[
                1] >= t[1]) || e[
                1] > i && n[1] > i && (
                e[1] <= t[1] || n[
                1] <= t[1])
    }

    function K2() {
        return qi({
            positions: [],
            normals: [],
            faces: [],
            uvs: [],
            resolved: !0,
            extraAttrs: []
        })
    }

    function A0(e, t, n, r, i, {
        isInequality: s
    }) {
        let o = e.fn,
            a;
        return t && !t.includes(
            "z") ? a = eh(o, n, r,
                "z") : t && !t
                    .includes("x") ? a = eh(
                        o, n, r, "x") : t &&
                            !t.includes("y") ? a =
        eh(o, n, r, "y") : a =
        iN(o, n, r, i, {
            isInequality: s
        }), qi(a)
    }

    function PN(e, t, n, r, i) {
        let s = wc(e, t, n, r, i,
            0);
        return qi(s)
    }

    function ek(e, t, n, r, i, s) {
        let o = s ? Math.PI / 180 :
            1,
            a = e.fn,
            u = wc((c, l) => {
                let [p, f, m] =
                    a(c, l);
                return [p * xn(
                    f *
                    o),
                p * Kt(
                    f *
                    o),
                    m, p, f
                ]
            }, t, n, r, i, 2);
        return qi(u)
    }

    function tk(e, t, n, r, i, s) {
        let o = s ? Math.PI / 180 :
            1,
            a = e.fn,
            u = wc((c, l) => {
                let [p, f, m] =
                    a(c, l);
                return [p * Kt(
                    m *
                    o) *
                    xn(f *
                        o),
                p * Kt(
                    m *
                    o) *
                Kt(f *
                    o),
                p * xn(
                    m *
                    o),
                    p, f, m
                ]
            }, t, n, r, i, 3);
        return qi(u)
    }

    function nk(e, t, n) {
        let r = e.fn,
            i = jg((s, o) => r(s,
                o), new ee(t.xmin, t
                    .xmax), new ee(t
                        .ymin, t.ymax),
                new ee(t.zmin, t
                    .zmax), n);
        return qi(i)
    }

    function rk(e, t, n) {
        let r = e.fn,
            i = jg((s, o) => r(s,
                o), new ee(t.ymin, t
                    .ymax), new ee(t
                        .zmin, t.zmax),
                new ee(t.xmin, t
                    .xmax), n, [2,
                0, 1
            ]);
        return qi(i)
    }

    function ik(e, t, n) {
        let r = e.fn,
            i = jg((s, o) => r(o,
                s), new ee(t.zmin, t
                    .zmax), new ee(t
                        .xmin, t.xmax),
                new ee(t.ymin, t
                    .ymax), n, [1,
                2, 0
            ]);
        return qi(i)
    }

    function sk(e, t, n, r, i, s) {
        let o = s ? Math.PI / 180 :
            1,
            a = e.fn,
            u = wc((c, l) => [c *
                xn(l * o), c *
            Kt(l * o), a(c,
                l)
            ], t, n, r, i, 0);
        return qi(u)
    }

    function ok(e, t, n, r, i, s) {
        let o = s ? Math.PI / 180 :
            1,
            a = e.fn,
            u = wc((c, l) => {
                let p = a(c, l);
                return [p * xn(
                    c *
                    o),
                p * Kt(
                    c *
                    o),
                    l, p
                ]
            }, t, n, r, i, 1);
        return qi(u)
    }

    function ak(e, t, n, r, i, s) {
        let o = s ? Math.PI / 180 :
            1,
            a = e.fn,
            u = wc((c, l) => {
                let p = a(c, l);
                return [p * Kt(
                    l *
                    o) *
                    xn(c *
                        o),
                p * Kt(
                    l *
                    o) *
                Kt(c *
                    o),
                p * xn(
                    l *
                    o),
                    p
                ]
            }, t, n, r, i, 1);
        return qi(u)
    }

    function qi(e) {
        let {
            positions: t,
            normals: n,
            faces: r,
            uvs: i,
            extraAttrs: s,
            resolved: o
        } = e;
        return {
            guid: fi(),
            positions: new Float32Array(
                t),
            normals: new Float32Array(
                n),
            faces: new Uint32Array(
                r),
            uvs: new Float32Array(
                i),
            resolved: o,
            extraAttrs: new Float32Array(
                s)
        }
    }

    function TN(e) {
        for (let t of e)
            if (t !== 0) return !1;
        return !0
    }

    function MN(e, t) {
        let {
            min: n,
            max: r,
            mathToPixels: i,
            nInitialSamples: s
        } = t, o = i.interpolateX(n,
            r, 0), a = e(o), u =
                TN(a), c = !1, l = [];
        for (var p = 1; p <
            s; p++) {
            let f = i.interpolateX(
                n, r, p / (s -
                    1)),
                m = e(f),
                g = TN(m);
            if (u) {
                o = f, a = m, g || (
                    u = !1);
                continue
            }
            if (g) {
                c ? (u = !0, c = !
                    1) : c = !0;
                continue
            }
            let d = HD(o, a, f, m,
                e);
            d !== void 0 && l.push(
                d), o = f, a = m
        }
        return l
    }

    function vN(e) {
        if (!e) return !1;
        let t = e.viewport.xmin,
            n = e.viewport.xmax,
            r = e.viewport.ymin,
            i = e.viewport.ymax;
        return !(!isFinite(t) || !
            isFinite(n) || n <=
            t || !isFinite(r) ||
            !isFinite(i) || i <=
            r || !isFinite(e
                .screen.width
            ) || e.screen
                .width <= 0 || !
            isFinite(e.screen
                .height) || e
                    .screen.height <= 0)
    }

    function m0(e, t) {
        let n = t - e;
        return 1 + Math.ceil(n / (
            n / 1e3))
    }
    var Xs = .001,
        Cu = new Ou(g0(), g0());

    function Ip(e, t, n) {
        var z, G, $, w, Y, de, re,
            ie, Z;
        let {
            viewport: r,
            screen: i,
            xAxisScale: s,
            yAxisScale: o,
            degreeMode: a
        } = e, u = a ? Math.PI /
            180 : 1, c = e.viewport
                .xmin, l = e.viewport
                    .xmax, p = e.viewport
                        .ymin, f = e.viewport
                            .ymax, m = (z = e
                                .viewport.zmin) !=
                                null ? z : lr.zmin, g =
                (G = e.viewport.zmax) !=
                    null ? G : lr.zmax, d =
                (($ = t.domain) ==
                    null ? void 0 : $
                    .type) === "2d", {
                        uMin: y,
                        uMax: h,
                        vMin: b,
                        vMax: x
                    } = ((w = t.domain) ==
                        null ? void 0 : w
                        .type) === "2d" ? t
                    .domain : {
                    uMin: 0,
                    uMax: 1,
                    vMin: 0,
                    vMax: 1
                };
        var P = t.lineWidth;
        if (t.willConvertTo3D || P >
            3) {
            let Re = t
                .willConvertTo3D ?
                200 : e.screen
                    .width;
            var M = P * (l - c) /
                Re;
            let Ne = t
                .willConvertTo3D ?
                200 : e.screen
                    .height;
            var I = P * (f - p) /
                Ne;
            c -= M, l += M, p -= I,
                f += I
        }
        let v = 1 / 4,
            O = t.domainBound,
            A, N = Ou.fromRects(Wg(
                r), Zg(i), {
                xAxisScale: s,
                yAxisScale: o
            }),
            L = {
                xmin: c,
                xmax: l,
                ymin: p,
                ymax: f,
                zmin: m,
                zmax: g
            };
        switch (t.graphMode) {
            case 1:
                switch (A = Dn(Xi([
                    p, f
                ]), O), A
                    .type) {
                    case "empty":
                        return !1;
                    case "interval":
                        p = A
                            .bounds[
                            0],
                            f = A
                                .bounds[
                            1]
                }
                let Re = Math.max(
                    th, 1 + Math
                        .ceil(Math
                            .abs(N
                                .mapY(
                                    f
                                ) -
                                N
                                    .mapY(
                                        p
                                    )
                            ) /
                            v)),
                    Ne = new Ou(N
                        .yScale, N
                        .xScale);
                return {
                    min: p, max: f,
                    tolerance:
                        v,
                    nInitialSamples:
                        Re,
                    mathToPixels:
                        Ne,
                    screen: {
                        width: i
                            .height,
                        height: i
                            .width
                    }
                };
            case 2: {
                switch (A = Dn(Xi([
                    c, l
                ]), O), A
                    .type) {
                    case "empty":
                        return !1;
                    case "interval":
                        c = A
                            .bounds[
                            0],
                            l = A
                                .bounds[
                            1]
                }
                let Te = Math.max(
                    th, 1 + Math
                        .ceil(Math
                            .abs(N
                                .mapX(
                                    l
                                ) -
                                N
                                    .mapX(
                                        c
                                    )
                            ) /
                            v));
                return {
                    min: c,
                    max: l,
                    tolerance: v,
                    nInitialSamples: Te,
                    mathToPixels: N,
                    screen: i
                }
            }
            case 6: {
                let Te = e
                    .degreeMode ?
                    Math.PI / 180 :
                    1;
                if (((Y = t
                    .domain) ==
                    null ?
                    void 0 : Y
                        .type) !==
                    "1d")
                    throw new Error(
                        "Expected polar graph to have domain"
                    );
                let {
                    min: Me,
                    max: ve
                } = t.domain;
                switch (A = Dn(Xi([
                    Me,
                    ve
                ]), O), A
                    .type) {
                    case "empty":
                        return !1;
                    case "interval":
                        Me = A
                            .bounds[
                            0],
                            ve = A
                                .bounds[
                            1]
                }
                let Q = Math.max(th,
                    1 + Math
                        .min(Math
                            .ceil(
                                Te *
                                Math
                                    .abs(
                                        ve -
                                        Me
                                    ) /
                                (2 * Math
                                    .PI
                                ) *
                                1e3
                            ),
                            12e3)),
                    U = Math.abs(N
                        .mapX(l) - N
                            .mapX(c)),
                    xe = Math.abs(N
                        .mapY(f) - N
                            .mapY(p)),
                    le = Math.hypot(
                        U, xe),
                    _e = Math.hypot(
                        l - c, f - p
                    ) / le,
                    Ze = {
                        min: Me,
                        max: ve,
                        screen: i,
                        nInitialSamples: Q,
                        xtolerance: v,
                        ytolerance: v,
                        rtoleranceMath: _e,
                        map: ([me,
                            te]) =>
                            N
                                .mapCoordinatePair(
                                    EN([me,
                                        te])
                                )
                    };
                if (!t.domain
                    .isExplicit) {
                    let me = j2(n,
                        Ze, Te,
                        t
                            .operator ===
                        "=");
                    me && (Ze.max =
                        Ze.min +
                        me, Ze
                            .nInitialSamples =
                        Math
                            .max(th,
                                1 +
                                Math
                                    .min(
                                        Math
                                            .ceil(
                                                Te *
                                                Math
                                                    .abs(
                                                        Ze
                                                            .max -
                                                        Ze
                                                            .min
                                                    ) /
                                                (2 * Math
                                                    .PI
                                                ) *
                                                1e3
                                            ),
                                        12e3
                                    )
                            ))
                }
                return Ze
            }
            case 5:
            case 100:
            case 101:
            case 102: {
                let Te = {
                    min: 0,
                    max: 1
                },
                    {
                        min: Me,
                        max: ve
                    } = ((de = t
                        .domain
                    ) ==
                        null ?
                        void 0 : de
                            .type) ===
                        "1d" ? t
                            .domain : Te;
                switch (A = Dn(Xi([
                    Me,
                    ve
                ]), O), A
                    .type) {
                    case "empty":
                        return !1;
                    case "interval":
                        Me = A
                            .bounds[
                            0],
                            ve = A
                                .bounds[
                            1]
                }
                let Q;
                return (!isFinite(
                    Me) || !
                    isFinite(ve)
                ) && (Q =
                    DN, Me = rh(
                        Me),
                    ve = rh(ve)
                    ), {
                    min: Me,
                    max: ve,
                    screen: i,
                    nInitialSamples: m0(
                        Me,
                        ve),
                    xtolerance: v,
                    ytolerance: v,
                    ztolerance: v,
                    parameterTransform: Q,
                    map: ([U,
                        xe]) =>
                        N
                            .mapCoordinatePair(
                                [U,
                                    xe]
                            )
                }
            }
            case 8:
                return {
                    xmin: c, xmax:
                        l, ymin: p,
                    ymax: f,
                    mathToPixels:
                        N,
                    tolerance: v
                };
            case 106:
                return {
                    ...L, u: new ee(
                        c, l),
                    v: new ee(p,
                        f)
                };
            case 120:
            case 122:
            case 107:
                return {
                    ...L, u: new ee(
                        p, f),
                    v: new ee(m,
                        g)
                };
            case 121:
            case 123:
            case 108:
                return {
                    ...L, u: new ee(
                        c, l),
                    v: new ee(m,
                        g)
                };
            case 109:
                return {
                    ...L, u: new ee(
                        y, d ?
                        h : lr
                            .xmax),
                    v: new ee(b,
                        d ? x :
                            2 * Math
                                .PI)
                };
            case 124:
            case 110: {
                let {
                    min: Te,
                    max: Me
                } = ((re = t
                    .domain) ==
                    null ? void 0 :
                    re.type) ===
                    "1d" ? t.domain : {
                        min: 0,
                        max: 2 *
                            Math.PI
                    };
                return {
                    ...L,
                    u: new ee(Te,
                        Me),
                    v: new ee(m, g)
                }
            }
            case 211: {
                let {
                    min: Te,
                    max: Me
                } = ((ie = t
                    .domain) ==
                    null ? void 0 :
                    ie.type) ===
                    "1d" ? t.domain : {
                        min: 0,
                        max: 2 *
                            Math
                                .PI / u
                    };
                return {
                    ...{
                        xmin: Te,
                        xmax: Me,
                        ymin: m,
                        ymax: g
                    },
                    u: new ee(Te,
                        Me),
                    v: new ee(m, g),
                    mathToPixels: Cu,
                    tolerance: Xs
                }
            }
            case 212: {
                let Te = d ? h : 2 *
                    Math.PI / u,
                    Me = d ? x :
                        Math.PI / u;
                return {
                    ...{
                        xmin: y,
                        xmax: Te,
                        ymin: b,
                        ymax: Me
                    },
                    u: new ee(y,
                        Te),
                    v: new ee(b,
                        Me),
                    mathToPixels: Cu,
                    tolerance: Xs
                }
            }
            case 215:
            case 214:
                return {
                    ...{
                        xmin: y,
                        xmax: h,
                        ymin: b,
                        ymax: x
                    }, u: new ee(y,
                        h), v:
                        new ee(b,
                            b),
                    mathToPixels:
                        Cu,
                    tolerance:
                        Xs
                };
            case 213: {
                let Te = d ? h : lr
                    .xmax,
                    Me = d ? x : 2 *
                        Math.PI / u;
                return {
                    ...{
                        xmin: y,
                        xmax: Te,
                        ymin: b,
                        ymax: Me
                    },
                    u: new ee(y,
                        Te),
                    v: new ee(b,
                        Me),
                    mathToPixels: Cu,
                    tolerance: Xs
                }
            }
            case 111:
                return {
                    ...L, u: new ee(
                        y, d ?
                        h : 2 *
                        Math
                            .PI / u
                    ), v:
                        new ee(b,
                            d ? x :
                                Math
                                    .PI / u)
                };
            case 117:
            case 118:
            case 119:
            case 129:
            case 130:
            case 103:
            case 104:
            case 105:
            case 112:
            case 126:
            case 113:
            case 127:
            case 210:
            case 114:
            case 115:
            case 116:
                return {
                    ...L, u: new ee(
                        y, h),
                    v: new ee(b,
                        x)
                };
            case 200:
            case 201:
            case 202:
            case 206:
            case 205:
            case 203:
            case 204:
            case 207:
            case 208: {
                if (t.graphMode ===
                    200 && (t
                        .slice_coordinate ===
                        "z" || t
                            .slice_coordinate ===
                        "_implicit")
                ) return {
                    xmin: c,
                    xmax: l,
                    ymin: p,
                    ymax: f,
                    mathToPixels: N,
                    tolerance: Xs
                };
                if (t.graphMode ===
                    201 && (t
                        .slice_coordinate ===
                        "x" || t
                            .slice_coordinate ===
                        "_implicit")
                ) return {
                    ...{
                        xmin: p,
                        xmax: f,
                        ymin: m,
                        ymax: g
                    },
                    mathToPixels: Cu,
                    tolerance: Xs
                };
                if (t.graphMode ===
                    202 && (t
                        .slice_coordinate ===
                        "y" || t
                            .slice_coordinate ===
                        "_implicit")
                ) return {
                    ...{
                        xmin: c,
                        xmax: l,
                        ymin: m,
                        ymax: g
                    },
                    mathToPixels: Cu,
                    tolerance: Xs
                };
                let {
                    min: Te,
                    max: Me
                } = ((Z = t
                    .domain) ==
                    null ? void 0 :
                    Z.type) ===
                    "1d" ? t.domain : {
                        min: 0,
                        max: 2 *
                            Math.PI
                    };
                return {
                    x: new ee(c, l),
                    y: new ee(p, f),
                    z: new ee(m, g),
                    t: new ee(Te,
                        Me),
                    u: new ee(y, h),
                    v: new ee(b, x)
                }
            }
            case 209:
                return t
                    .slice_coordinate ===
                    "z" ? {
                    xmin: c,
                    xmax: l,
                    ymin: p,
                    ymax: f,
                    mathToPixels: N,
                    tolerance: Xs
                } : t
                    .slice_coordinate ===
                    "x" ? {
                    ...{
                        xmin: p,
                        xmax: f,
                        ymin: m,
                        ymax: g
                    },
                    mathToPixels: Cu,
                    tolerance: Xs
                } : t
                    .slice_coordinate ===
                    "y" ? {
                    ...{
                        xmin: c,
                        xmax: l,
                        ymin: m,
                        ymax: g
                    },
                    mathToPixels: Cu,
                    tolerance: Xs
                } : t
                    .slice_coordinate ===
                    "_implicit" ? {
                    ...L,
                    u: new ee(c,
                        l),
                    v: new ee(p,
                        f)
                } : !1;
            default:
                return !1
        }
    }

    function DN(e) {
        return Math.sinh(10 * e) / (
            1 - e * e)
    }

    function rh(e) {
        if (e === 1 / 0) return 1;
        if (e === -1 / 0) return -1;
        let t = Math.asinh(e);
        return 2 * t / (10 + Math
            .sqrt(100 + 4 * t *
                t))
    }

    function ih(e) {
        let {
            viewState: t,
            graphInfo: n,
            compiled: r,
            maxOverride: i,
            showPoint: s
        } = e, o = r.fn, a = Ip(t,
            n, o), u;
        if (!a) u = {
            segments: [],
            resolved: !0
        };
        else {
            let {
                min: p,
                max: f
            } = a;
            u = W2({
                fn: o,
                min: Math
                    .max(p,
                        0),
                max: i !==
                    void 0 ?
                    Math
                        .min(i,
                            f) :
                    f
            })
        }
        let {
            points: c,
            droppedIndices: l
        } = yd(u.segments);
        return {
            segments: [c],
            droppedIndices: l,
            graphMode: 3,
            color: n.color,
            style: n.pointStyle,
            poi: Us(u.segments),
            resolved: u.resolved,
            showPoint: s
        }
    }

    function uk(e) {
        switch (e) {
            case 120:
            case 122:
                return 107;
            case 121:
            case 123:
                return 108;
            case 124:
                return 110;
            case 126:
                return 112;
            case 127:
                return 113;
            default:
                return e
        }
    }

    function SN(e, t, n) {
        let r = n ? Math.PI / 180 :
            1;
        switch (e) {
            case 114:
                return t;
            case 115: {
                let [i, s, o] = t;
                return [i * xn(s *
                    r), i *
                Kt(s * r), o
                ]
            }
            case 116: {
                let [i, s, o] = t;
                return [i * Kt(o *
                    r) * xn(
                        s * r),
                i * Kt(o *
                    r) * Kt(
                        s * r),
                i * xn(o *
                    r)
                ]
            }
            default:
                return [0, 0, 0]
        }
    }

    function _a(e) {
        var d, y, h, b, x, P, M, I,
            E;
        let {
            viewState: t,
            graphInfo: n,
            compiled: r,
            derivative: i
        } = e, s = r.fn, {
            degreeMode: o
        } = t, a = o ? Math.PI /
            180 : 1, u = Ip(t, n,
                s), c, l, p, f = uk(n
                    .graphMode), m = t
                        .xAxisScale ===
                        "linear" && t
                            .yAxisScale ===
                        "linear";
        if (!u) c = {
            segments: [],
            resolved: !0
        };
        else {
            switch (f) {
                case 1:
                case 2:
                    let v = i ? i
                        .fn :
                        void 0;
                    c = n
                        .isLinear &&
                        m && mo(n
                            .linearCoefficients
                        ) ? O0(n
                            .linearCoefficients,
                            u) : N0(
                                s, u, v
                            );
                    break;
                case 6:
                    c = Xg(G => [G,
                        s(G)
                    ], u);
                    break;
                case 8:
                    c = ud(s, u);
                    break;
                case 5:
                    u.max === u
                        .min ? c =
                    Z2(s, u
                        .min) : c =
                    n
                        .isLinear &&
                        m && mo(n
                            .linearCoefficients
                        ) ? X2(n
                            .linearCoefficients,
                            u) : Xg(
                                s, u);
                    break;
                case 100:
                case 101:
                case 102:
                    let O = r.fn,
                        {
                            min: A,
                            max: N
                        } = ((d = n
                            .domain
                        ) ==
                            null ?
                            void 0 :
                            d.type
                        ) ===
                            "1d" ? n
                                .domain : {
                                min: 0,
                                max: 1
                            };
                    if (!isFinite(
                        A) || !
                        isFinite(N)
                    ) {
                        A = rh(A),
                            N = rh(
                                N);
                        let G = O;
                        O = $ => G(
                            DN(
                                $)
                        )
                    }
                    let L = new ee(
                        A, N),
                        z = [];
                    switch (f) {
                        case 100:
                            z = Fc(O,
                                L,
                                n
                                    .resolution,
                                t
                            );
                            break;
                        case 101:
                            z = Yg(O,
                                L,
                                n
                                    .resolution,
                                t
                            );
                            break;
                        case 102:
                            z = d0(O,
                                L,
                                n
                                    .resolution,
                                t
                            );
                            break
                    }
                    return {
                        graphMode:
                            100,
                        guid:
                            fi(),
                        points:
                            z,
                        color: n
                            .color,
                        thickness:
                            n
                                .lineWidth
                    };
                case 112:
                case 113:
                case 130:
                case 103:
                case 104:
                case 105:
                case 106:
                case 107:
                case 108:
                case 109:
                case 110:
                case 111: {
                    let G = u,
                        {
                            u: $,
                            v: w
                        } = G,
                        Y = f ===
                            112 || f ===
                            113,
                        de = n
                            .graphMode ===
                            122 || n
                                .graphMode ===
                            123,
                        re = Y ?
                            dd : de ?
                                2 : sN,
                        {
                            resolution: ie
                        } = n,
                        Z = ie ===
                            void 0 ||
                            isNaN(ie) ?
                            re : rr(dN(
                                ie),
                                2, 100),
                        Re = Xi([$
                            .min,
                        $
                            .max
                        ]).type !==
                            "empty" &&
                            Xi([w.min, w
                                .max
                            ]).type !==
                            "empty",
                        Ne;
                    switch (Re &&
                    f) {
                        case 103: {
                            let ve =
                                r
                                    .fn;
                            Ne = PN(ve,
                                G,
                                $,
                                w,
                                Z
                            );
                            break
                        }
                        case 130: {
                            Ne = PN((Q,
                                U) => {
                                let [
                                    xe,
                                    le
                                ] =
                                    r.fn(Q,
                                        U);
                                return [xe,
                                    le,
                                    0
                                ]
                            },
                                G,
                                $,
                                w,
                                Z
                            );
                            break
                        }
                        case 104:
                            Ne = ek(r,
                                G,
                                $,
                                w,
                                Z,
                                o
                            );
                            break;
                        case 105:
                            Ne = tk(r,
                                G,
                                $,
                                w,
                                Z,
                                o
                            );
                            break;
                        case 106:
                            Ne = nk(r,
                                G,
                                Z
                            );
                            break;
                        case 107:
                            Ne = rk(r,
                                G,
                                Z
                            );
                            break;
                        case 108:
                            Ne = ik(r,
                                G,
                                Z
                            );
                            break;
                        case 109:
                            Ne = sk(r,
                                G,
                                $,
                                w,
                                Z,
                                o
                            );
                            break;
                        case 110:
                            Ne = ok(r,
                                G,
                                $,
                                w,
                                Z,
                                o
                            );
                            break;
                        case 111:
                            Ne = ak(r,
                                G,
                                $,
                                w,
                                Z,
                                o
                            );
                            break;
                        case 112:
                        case 113:
                            Ne = A0(r,
                                e
                                    .dependencies,
                                e
                                    .gradient,
                                u,
                                Z, {
                                isInequality: (
                                    y =
                                    e
                                        .isImplicit3dInequality
                                ) !=
                                    null ?
                                    y :
                                    !
                                    1
                            }
                            );
                            break;
                        case !1:
                            Ne =
                                K2();
                            break
                    }
                    let Te = n
                        .graphMode ===
                        113 || n
                            .graphMode ===
                        127;
                    return {
                        meshData: Ne,
                        resolved: Ne
                            .resolved,
                        color: n
                            .color,
                        fillOpacity: Te ?
                            1 : (h =
                                n
                                    .fillOpacity
                            ) !=
                                null ?
                                h : 1,
                        uvRange: [$,
                            w
                        ],
                        uvArgs: (b =
                            ss[n
                                .graphMode]
                        ) !=
                            null ?
                            b : [],
                        extraMeshArgs: (
                            x =
                            Vc[n
                                .graphMode]
                        ) !=
                            null ?
                            x : [],
                        graphMode: f,
                        compiled: r,
                        restrictionShader: e
                            .restrictionShader3d
                    }
                }
                case 200:
                case 201:
                case 202:
                case 211:
                case 206:
                case 205:
                case 203:
                case 204:
                case 213:
                case 207:
                case 208:
                case 212:
                case 214:
                case 215:
                case 209: {
                    let G = (Q, U,
                        xe) => {
                        let le =
                            (Rd,
                                Nd) => {
                                let Yc =
                                    xe(Rd,
                                        Nd
                                    );
                                return isNaN(
                                    Yc[
                                    0]
                                ) ||
                                    isNaN(
                                        Yc[
                                        1]
                                    ) ||
                                    isNaN(
                                        Yc[
                                        2]
                                    ) ?
                                    NaN :
                                    Q(Rd,
                                        Nd
                                    )
                            },
                            K =
                                t
                                    .viewport,
                            {
                                xmin: _e,
                                xmax: Ze,
                                ymin: me,
                                ymax: te,
                                zmin: pt,
                                zmax: Ro
                            } =
                                K,
                            Ba =
                                (_e +
                                    Ze
                                ) /
                                2,
                            ku =
                                (me +
                                    te
                                ) /
                                2,
                            $c =
                                (pt +
                                    Ro
                                ) /
                                2,
                            Od =
                                Ze -
                                _e,
                            Cd =
                                te -
                                me,
                            _h =
                                Ro -
                                pt,
                            CM =
                                ud(le, {
                                    ...
                                    U,
                                    map3d: (Rd,
                                        Nd
                                    ) => {
                                        let [
                                            Yc,
                                            RM,
                                            NM
                                        ] =
                                            xe(Rd,
                                                Nd);
                                        return isNaN(
                                            Yc
                                        ) ||
                                            isNaN(
                                                RM
                                            ) ||
                                            isNaN(
                                                NM
                                            ) ?
                                            [NaN,
                                                NaN,
                                                NaN
                                            ] :
                                            [(Yc -
                                                Ba) /
                                                Od,
                                            (RM -
                                                ku
                                            ) /
                                            Cd,
                                            (NM -
                                                $c
                                            ) /
                                            _h
                                            ]
                                    }
                                });
                        return {
                            segments: CM
                                .segments,
                            resolved: CM
                                .resolved,
                            graphMode: 8,
                            color: n
                                .color,
                            lineWidth: n
                                .lineWidth,
                            lineOpacity: n
                                .lineOpacity,
                            listIndex: n
                                .listIndex,
                            operator: n
                                .operator,
                            compiled: r,
                            poi: {}
                        }
                    },
                        $ = r.fn,
                        w = (P = n
                            .slice_value
                        ) !=
                            null ? P :
                            0,
                        Y = (M = n
                            .slice_coordinate
                        ) !=
                            null ? M :
                            "",
                        de = u,
                        re, ie, Z,
                        Re = !0,
                        Ne = (Q,
                            U) => {
                            let le =
                                G(Q, u,
                                    (me,
                                        te) => {
                                        let {
                                            x: pt,
                                            y: Ro,
                                            z: Ba
                                        } =
                                            U(me, te,
                                                Q(me,
                                                    te
                                                )
                                            );
                                        return [pt,
                                            Ro,
                                            Ba
                                        ]
                                    }
                                ),
                                K =
                                    n
                                        .lineWidth,
                                _e =
                                    ah(le,
                                        t,
                                        K,
                                        w
                                    ),
                                Ze =
                                    _e
                                        .points;
                            for (let me =
                                0; me <
                                Ze
                                    .length /
                                3; me++
                            ) {
                                let te =
                                    Ze[3 *
                                    me
                                    ],
                                    pt =
                                        Ze[3 *
                                        me +
                                        1
                                        ],
                                    Ro =
                                        Ze[3 *
                                        me +
                                        2
                                        ],
                                    {
                                        x: Ba,
                                        y: ku,
                                        z: $c
                                    } =
                                        U(te,
                                            pt,
                                            Ro
                                        );
                                Ze[3 *
                                    me] =
                                    Ba,
                                    Ze[3 *
                                    me +
                                    1
                                    ] =
                                    ku,
                                    Ze[3 *
                                    me +
                                    2
                                    ] =
                                    $c
                            }
                            return _e
                        },
                        Te = (Q,
                            U) => {
                            let
                                xe = [];
                            for (let _e =
                                0; _e <
                                Q
                                    .segments
                                    .length; _e++
                            ) {
                                let Ze =
                                    Q
                                        .segments[
                                    _e
                                    ];
                                for (
                                    let me =
                                        0; me <
                                    Ze
                                        .length /
                                    2; me++
                                ) {
                                    let te =
                                        Ze[2 *
                                        me
                                        ],
                                        pt =
                                            Ze[2 *
                                            me +
                                            1
                                            ];
                                    xe.push(U(te,
                                        pt
                                    ))
                                }
                                _e < Q
                                    .segments
                                    .length -
                                    1 &&
                                    xe
                                        .push(
                                            [NaN,
                                                NaN,
                                                0
                                            ]
                                        )
                            }
                            let le =
                                n
                                    .lineWidth,
                                K =
                                    t
                                        .viewport;
                            return uh(
                                xe,
                                K,
                                le
                            )
                        },
                        Me = u,
                        ve = (Q,
                            U) => {
                            var le;
                            let xe =
                                G(Q, Me,
                                    U
                                );
                            return Re =
                                (le =
                                    xe
                                        .resolved
                                ) !=
                                    null ?
                                    le :
                                    !0,
                                Te(xe,
                                    U
                                )
                        };
                    switch (f) {
                        case 200: {
                            if (Y ===
                                "z")
                                return Ne(
                                    (U,
                                        xe) =>
                                        $(U,
                                            xe) -
                                        w,
                                    yN
                                );
                            if (Y ===
                                "_implicit"
                            ) {
                                let U =
                                    n
                                        .slice_function
                                        .fn;
                                Z = ve((K,
                                    _e) =>
                                    U(K, _e,
                                        $(K,
                                            _e)
                                    ),
                                    (K,
                                        _e) => [
                                            K,
                                            _e,
                                            $(K,
                                                _e)
                                        ]
                                );
                                break
                            }
                            let Q =
                                Y ===
                                "x";
                            re = Q ?
                                de
                                    .y :
                                de
                                    .x,
                                ie =
                                Q ?
                                    U => [
                                        w,
                                        U,
                                        $(w,
                                            U)
                                    ] :
                                    U => [
                                        U,
                                        w,
                                        $(U,
                                            w)
                                    ],
                                Z =
                                Fc(ie,
                                    re,
                                    n
                                        .resolution,
                                    t
                                );
                            break
                        }
                        case 201: {
                            if (Y ===
                                "x")
                                return Ne(
                                    (U,
                                        xe) =>
                                        $(U,
                                            xe) -
                                        w,
                                    gN
                                );
                            if (Y ===
                                "_implicit"
                            ) {
                                let U =
                                    n
                                        .slice_function
                                        .fn;
                                Z = ve((K,
                                    _e) =>
                                    U($(K,
                                        _e),
                                        K,
                                        _e
                                    ),
                                    (K,
                                        _e) => [
                                            $(K,
                                                _e),
                                            K,
                                            _e
                                        ]
                                );
                                break
                            }
                            let Q =
                                Y ===
                                "y";
                            re = Q ?
                                de
                                    .z :
                                de
                                    .y,
                                ie =
                                Q ?
                                    U => [
                                        $(w,
                                            U),
                                        w,
                                        U
                                    ] :
                                    U => [
                                        $(U,
                                            w),
                                        U,
                                        w
                                    ],
                                Z =
                                Fc(ie,
                                    re,
                                    n
                                        .resolution,
                                    t
                                );
                            break
                        }
                        case 202: {
                            if (Y ===
                                "y")
                                return Ne(
                                    (U,
                                        xe) =>
                                        $(U,
                                            xe) -
                                        w,
                                    hN
                                );
                            if (Y ===
                                "_implicit"
                            ) {
                                let U =
                                    n
                                        .slice_function
                                        .fn;
                                Z = ve((K,
                                    _e) =>
                                    U(K, $(K,
                                        _e
                                    ),
                                        _e
                                    ),
                                    (K,
                                        _e) => [
                                            K,
                                            $(K,
                                                _e),
                                            _e
                                        ]
                                );
                                break
                            }
                            let Q =
                                Y ===
                                "x";
                            re = Q ?
                                de
                                    .z :
                                de
                                    .x,
                                ie =
                                Q ?
                                    U => [
                                        w,
                                        $(w,
                                            U),
                                        U
                                    ] :
                                    U => [
                                        U,
                                        $(U,
                                            w),
                                        w
                                    ],
                                Z =
                                Fc(ie,
                                    re,
                                    n
                                        .resolution,
                                    t
                                );
                            break
                        }
                        case 209: {
                            let Q =
                                r
                                    .fn;
                            if (Y ===
                                "x")
                                return Ne(
                                    (U,
                                        xe) =>
                                        Q(w, U,
                                            xe
                                        ),
                                    gN
                                );
                            if (Y ===
                                "y")
                                return Ne(
                                    (U,
                                        xe) =>
                                        Q(U, w,
                                            xe
                                        ),
                                    hN
                                );
                            if (Y ===
                                "z")
                                return Ne(
                                    (U,
                                        xe) =>
                                        Q(U, xe,
                                            w
                                        ),
                                    yN
                                );
                            if (Y ===
                                "_implicit"
                            ) {
                                let {
                                    resolution: U
                                } =
                                    n,
                                    xe = U ===
                                        void 0 ||
                                        isNaN(
                                            U
                                        ) ?
                                        dd :
                                        rr(dN(
                                            U),
                                            2,
                                            100
                                        );
                                Z = fN(r.fn,
                                    n
                                        .slice_function
                                        .fn,
                                    u,
                                    xe
                                );
                                break
                            } else
                                throw new Error(
                                    "Programming Error: unexpected slice coordinate"
                                )
                        }
                        case 206:
                        case 205: {
                            let Q =
                                Y ===
                                "z";
                            re = Q ?
                                de
                                    .t :
                                de
                                    .z,
                                ie =
                                Q ?
                                    U => [
                                        $(U,
                                            w),
                                        U,
                                        w
                                    ] :
                                    U => [
                                        $(w,
                                            U),
                                        w,
                                        U
                                    ],
                                Z =
                                Yg(ie,
                                    re,
                                    n
                                        .resolution,
                                    t
                                );
                            break
                        }
                        case 211: {
                            let Q =
                                r
                                    .fn,
                                U;
                            switch (
                            Y) {
                                case "x":
                                    U = (me,
                                        te) =>
                                        Q(me,
                                            te
                                        ) *
                                        xn(me *
                                            a
                                        ) -
                                        w;
                                    break;
                                case "y":
                                    U = (me,
                                        te) =>
                                        Q(me,
                                            te
                                        ) *
                                        Kt(me *
                                            a
                                        ) -
                                        w;
                                    break;
                                case "r":
                                    U = (me,
                                        te) =>
                                        Q(me,
                                            te
                                        ) -
                                        w;
                                    break;
                                case "_implicit":
                                    let Ze =
                                        n
                                            .slice_function
                                            .fn;
                                    U = (me,
                                        te) =>
                                        Ze(Q(me,
                                            te) *
                                            xn(me *
                                                a
                                            ),
                                            Q(me,
                                                te
                                            ) *
                                            Kt(me *
                                                a
                                            ),
                                            te,
                                            Q(me,
                                                te
                                            ),
                                            me
                                        );
                                    break;
                                default:
                                    throw new Error(
                                        "Programming Error: bad slice"
                                    )
                            }
                            let xe =
                                Y ===
                                "x",
                                le =
                                    Y ===
                                    "y",
                                K =
                                    (Ze,
                                        me) => [
                                            xe ?
                                                w :
                                                Q(Ze,
                                                    me
                                                ) *
                                                xn(Ze *
                                                    a
                                                ),
                                            le ?
                                                w :
                                                Q(Ze,
                                                    me
                                                ) *
                                                Kt(Ze *
                                                    a
                                                ),
                                            me
                                        ],
                                _e =
                                    G(U, Me,
                                        K
                                    );
                            Z = Te(_e,
                                K
                            ),
                                Re =
                                (I = _e
                                    .resolved
                                ) !=
                                    null ?
                                    I :
                                    !0;
                            break
                        }
                        case 213: {
                            let Q =
                                Y ===
                                "x",
                                U =
                                    Y ===
                                    "y",
                                xe =
                                    Y ===
                                    "z",
                                le =
                                    r
                                        .fn,
                                K;
                            switch (
                            Y) {
                                case "x":
                                    K = (te,
                                        pt) =>
                                        te *
                                        xn(pt *
                                            a
                                        ) -
                                        w;
                                    break;
                                case "y":
                                    K = (te,
                                        pt) =>
                                        te *
                                        Kt(pt *
                                            a
                                        ) -
                                        w;
                                    break;
                                case "z":
                                    K = (te,
                                        pt) =>
                                        le(te,
                                            pt
                                        ) -
                                        w;
                                    break;
                                case "_implicit":
                                    let me =
                                        n
                                            .slice_function
                                            .fn;
                                    K = (te,
                                        pt) =>
                                        me(te *
                                            xn(pt *
                                                a
                                            ),
                                            te *
                                            Kt(pt *
                                                a
                                            ),
                                            le(te,
                                                pt
                                            ),
                                            te,
                                            pt
                                        );
                                    break;
                                default:
                                    throw new Error(
                                        "Programming Error: bad slice"
                                    )
                            }
                            let _e =
                                (me,
                                    te) => [
                                        Q ?
                                            w :
                                            me *
                                            xn(te *
                                                a
                                            ),
                                        U ?
                                            w :
                                            me *
                                            Kt(te *
                                                a
                                            ),
                                        xe ?
                                            w :
                                            le(me,
                                                te
                                            )
                                    ],
                                Ze =
                                    G(K, Me,
                                        _e
                                    );
                            Z = Te(Ze,
                                _e
                            );
                            break
                        }
                        case 212: {
                            let Q =
                                Y ===
                                "x",
                                U =
                                    Y ===
                                    "y",
                                xe =
                                    Y ===
                                    "z",
                                le =
                                    r
                                        .fn,
                                K;
                            switch (
                            Y) {
                                case "x":
                                    K = (te,
                                        pt) =>
                                        le(te,
                                            pt
                                        ) *
                                        Kt(pt *
                                            a
                                        ) *
                                        xn(te *
                                            a
                                        ) -
                                        w;
                                    break;
                                case "y":
                                    K = (te,
                                        pt) =>
                                        le(te,
                                            pt
                                        ) *
                                        Kt(pt *
                                            a
                                        ) *
                                        Kt(te *
                                            a
                                        ) -
                                        w;
                                    break;
                                case "z":
                                    K = (te,
                                        pt) =>
                                        le(te,
                                            pt
                                        ) *
                                        xn(pt *
                                            a
                                        ) -
                                        w;
                                    break;
                                case "rho":
                                    K = (te,
                                        pt) =>
                                        le(te,
                                            pt
                                        ) -
                                        w;
                                    break;
                                case "_implicit":
                                    let me =
                                        n
                                            .slice_function
                                            .fn;
                                    K = (te,
                                        pt) =>
                                        me(le(te,
                                            pt
                                        ) *
                                            Kt(pt *
                                                a
                                            ) *
                                            Kt(te *
                                                a
                                            ),
                                            le(te,
                                                pt
                                            ) *
                                            Kt(pt *
                                                a
                                            ) *
                                            xn(te *
                                                a
                                            ),
                                            le(te,
                                                pt
                                            ) *
                                            xn(pt *
                                                a
                                            ),
                                            le(te,
                                                pt
                                            ),
                                            te,
                                            pt
                                        );
                                    break;
                                default:
                                    throw new Error(
                                        "Programming Error: bad slice"
                                    )
                            }
                            let _e =
                                (me,
                                    te) => [
                                        Q ?
                                            w :
                                            le(me,
                                                te
                                            ) *
                                            Kt(te *
                                                a
                                            ) *
                                            xn(me *
                                                a
                                            ),
                                        U ?
                                            w :
                                            le(me,
                                                te
                                            ) *
                                            Kt(te *
                                                a
                                            ) *
                                            Kt(me *
                                                a
                                            ),
                                        xe ?
                                            w :
                                            le(me,
                                                te
                                            ) *
                                            xn(te *
                                                a
                                            )
                                    ],
                                Ze =
                                    G(K, Me,
                                        _e
                                    );
                            Z = Te(Ze,
                                _e
                            ),
                                Re =
                                (E = Ze
                                    .resolved
                                ) !=
                                    null ?
                                    E :
                                    !0;
                            break
                        }
                        case 215:
                        case 214: {
                            let Q =
                                f ===
                                    214 ?
                                    r
                                        .fn :
                                    (xe,
                                        le) => {
                                        let [
                                            K,
                                            _e
                                        ] =
                                            r.fn(xe,
                                                le);
                                        return [K,
                                            _e,
                                            0
                                        ]
                                    },
                                U;
                            switch (
                            Y) {
                                case "x":
                                    U = (le,
                                        K) =>
                                        Q(le,
                                            K
                                        )[
                                        0
                                        ] -
                                        w;
                                    break;
                                case "y":
                                    U = (le,
                                        K) =>
                                        Q(le,
                                            K
                                        )[
                                        1
                                        ] -
                                        w;
                                    break;
                                case "z":
                                    U = (le,
                                        K) =>
                                        Q(le,
                                            K
                                        )[
                                        2
                                        ] -
                                        w;
                                    break;
                                case "u":
                                    U = (le,
                                        K) =>
                                        le -
                                        w;
                                    break;
                                case "v":
                                    U = (le,
                                        K) =>
                                        K -
                                        w;
                                    break;
                                case "_implicit":
                                    let xe =
                                        n
                                            .slice_function
                                            .fn;
                                    U = (le,
                                        K) => {
                                        let [
                                            _e,
                                            Ze,
                                            me
                                        ] =
                                            Q(le,
                                                K);
                                        return xe(
                                            _e,
                                            Ze,
                                            me,
                                            le,
                                            K
                                        )
                                    };
                                    break;
                                default:
                                    throw new Error(
                                        "Programming Error: bad slice"
                                    )
                            }
                            Z = ve(U,
                                Q
                            );
                            break
                        }
                        case 203:
                        case 204: {
                            let Q =
                                Y ===
                                "r";
                            re = Q ?
                                de
                                    .v :
                                de
                                    .u,
                                ie =
                                Q ?
                                    U => [
                                        w,
                                        U,
                                        $(w,
                                            U)
                                    ] :
                                    U => [
                                        U,
                                        w,
                                        $(U,
                                            w)
                                    ],
                                Z =
                                Yg(ie,
                                    re,
                                    n
                                        .resolution,
                                    t
                                );
                            break
                        }
                        case 207:
                        case 208: {
                            let Q =
                                Y ===
                                "theta";
                            re = Q ?
                                de
                                    .v :
                                de
                                    .u,
                                ie =
                                Q ?
                                    U => [
                                        $(w,
                                            U),
                                        w,
                                        U
                                    ] :
                                    U => [
                                        $(U,
                                            w),
                                        U,
                                        w
                                    ],
                                Z =
                                d0(ie,
                                    re,
                                    n
                                        .resolution,
                                    t
                                );
                            break
                        }
                    }
                    return {
                        graphMode: 100,
                        guid: fi(),
                        points: Z,
                        resolved: Re,
                        color: n
                            .color,
                        thickness: n
                            .lineWidth
                    }
                }
                default:
                    throw new Error(
                        "Programming Error: unexpected graphmode " +
                        f)
            }
            p = c.poi
        }
        if ((!p || p.zeros.x
            .length + p.extrema
                .x.length + p
                    .intercept.x
                .length > 250) && (
                p = Y2()), f === 1)
            for (let v in p) {
                if (!p
                    .hasOwnProperty(
                        v))
                    continue;
                let O = v;
                l = p[O].y, p[O].y =
                    p[O].x, p[O].x =
                    l
            }
        let g = {
            segments: c
                .segments,
            resolved: c
                .resolved,
            graphMode: f,
            color: n.color,
            style: n.lineStyle,
            lineWidth: n
                .lineWidth,
            lineOpacity: n
                .lineOpacity,
            listIndex: n
                .listIndex,
            operator: n
                .operator,
            poi: p,
            compiled: r
        };
        if (f === 6) {
            let v = u;
            g.sampledDomain = {
                min: v.min,
                max: v.max
            }
        }
        return c.fillSegments && (g
            .fillSegments = c
                .fillSegments), g
    }

    function ck(e, t, n) {
        let r, i, s, o, a = [],
            u = null;
        switch (n) {
            case 6:
                u = EN;
                break;
            case 1:
                u = function (c) {
                    return [c[
                        1],
                    c[0]
                    ]
                };
                break
        }
        for (r = 0; r < e
            .length; r++)
            for (o = e[r], i =
                0; i < o
                    .length; i += 2)
                s = [o[i], o[i +
                    1]], u && (s = u(
                        s)), a.push(s[0], s[
                            1]);
        for (r = t.length - 1; r >=
            0; r--)
            for (o = t[r], i = o
                .length - 2; i >=
                0; i -= 2) s = [o[
                    i], o[i + 1]
                ], u && (s = u(s)),
                    a.push(s[0], s[1]);
        return a
    }

    function sh(e, t, n) {
        let r = l => l[l.length -
            2],
            i = [],
            s = 0,
            o = 0,
            a = [],
            u = [],
            c = -1 / 0;
        for (; ;) {
            for (; o < e.length && !
                (e[o].length >= 2);)
                o += 1;
            for (; s < t.length && !
                (t[s].length >= 2);)
                s += 1;
            (o >= e.length || e[o][
                0] > c) && (s >= t
                    .length || t[s][0] >
                    c) && (a.length >
                        0 && u.length > 0 &&
                        i.push(ck(a, u, n)),
                        a = [], u = [], c =
                        Math.max(c, o < e
                            .length ? r(e[
                                o]) : 1 / 0
                        ), c = Math.max(
                            c, s < t
                                .length ? r(t[
                                    s]) : 1 / 0)
                );
            let l = !1;
            if (o < e.length && e[o]
            [0] <= c && (c =
                Math.max(c, r(e[
                    o])), a
                        .push(e[o]),
                o += 1, l = !0),
                s < t.length && t[s]
                [0] <= c && (c =
                    Math.max(c, r(t[
                        s])), u
                            .push(t[s]),
                    s += 1, l = !0),
                !l) break
        }
        return i
    }

    function yd(e) {
        let t = [],
            n = {};
        for (let r = 0; r < e
            .length; r++) {
            let i = e[r],
                [s, o] = i;
            !isNaN(s) && !isNaN(o) ?
                t.push(i) : n[r] = !
                0
        }
        return {
            points: t,
            droppedIndices: n
        }
    }
    var ss = {
        [8]: ["x", "y"],
        [106]: ["x", "y"],
        [120]: ["y", "z"],
        [122]: ["y", "z"],
        [107]: ["y", "z"],
        [121]: ["x", "z"],
        [123]: ["x", "z"],
        [108]: ["x", "z"],
        [109]: ["r", "theta"],
        [124]: ["theta", "z"],
        [110]: ["theta", "z"],
        [111]: ["theta", "phi"],
        [130]: ["u", "v"],
        [103]: ["u", "v"],
        [104]: ["u", "v"],
        [105]: ["u", "v"],
        [126]: ["x", "y"],
        [112]: ["x", "y", "z"],
        [113]: ["x", "y", "z"],
        [127]: ["x", "y"],
        [201]: ["y", "z"],
        [202]: ["x", "z"],
        [200]: ["x", "y"],
        [206]: ["theta", "z"],
        [205]: ["theta", "z"],
        [211]: ["theta", "z"],
        [203]: ["r", "theta"],
        [204]: ["r", "theta"],
        [213]: ["r", "theta"],
        [207]: ["theta", "phi"],
        [208]: ["theta", "phi"],
        [212]: ["theta", "phi"],
        [214]: ["u", "v"],
        [215]: ["u", "v"],
        [209]: ["x", "y", "z"],
        [210]: ["x", "y", "z"]
    },
        Vc = {
            [110]: ["r"],
            [111]: ["rho"],
            [104]: ["r", "theta"],
            [105]: ["rho", "theta",
                "phi"
            ]
        };

    function lk(e) {
        return !e || e[0].type ===
            "none" && e[1].type ===
            "none" ? "NONE" : e[1]
                .type === "none" ? "X" :
            e[0].type === "none" ?
                "Y" : "XY"
    }

    function ON(e, t) {
        var n = lk(t);
        switch (e) {
            case "NONE":
                return "NONE";
            case "AUTO":
                return n;
            case "XY":
                return n;
            case "X":
                return n === "X" ||
                    n === "XY" ?
                    "X" : "NONE";
            case "Y":
                return n === "Y" ||
                    n === "XY" ?
                    "Y" : "NONE";
            default:
                return "NONE"
        }
    }
    var pk = (e, t) => {
        let n = e.segments[0],
            r = t.segments[0],
            i = [
                [...n, ...r]
            ];
        return {
            ...e,
            segments: i
        }
    };

    function fk(e) {
        let {
            viewState: t,
            graphInfo: n,
            compiled: r,
            derivative: i,
            bounds: s
        } = e, o = Bs(n), a = Dn(n
            .domainBound, Xi(s));
        if (!gi(a)) return o
            .domainBound = a, o
                .lineStyle =
            "SOLID", _a({
                graphInfo: o,
                viewState: t,
                compiled: r,
                derivative: i
            })
    }

    function Ru(e) {
        let {
            viewState: t,
            graphInfo: n,
            compiled: r,
            bounds: i,
            included: s,
            showPoint: o
        } = e, a = Bs(n), u = Dn(n
            .domainBound, Xi(i));
        if (!gi(u)) return a
            .domainBound = u, a
                .pointStyle = s ?
                "POINT" : "OPEN",
            ih({
                graphInfo: a,
                viewState: t,
                compiled: r,
                showPoint: o,
                maxOverride: void 0
            })
    }

    function NN(e) {
        let {
            viewState: t,
            graphInfo: n,
            compiled: r,
            bounds: i,
            maxOverride: s,
            showPoint: o
        } = e, [a, u] = i, c = [],
            l;
        a = Math.ceil(a), u = Math
            .floor(u);
        let p = s !== void 0 ? s :
            1 / 0;
        if (a === -1 / 0 && u >= p)
            l = Ru({
                bounds: [a, p],
                included: !0,
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: o
            }), c.push(l);
        else if (a === -1 / 0 && u <
            1 / 0) l = Ru({
                bounds: [a, u],
                included: !0,
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: o
            }), c.push(l), c.push(
                Ru({
                    bounds: [u +
                        1, p
                    ],
                    included: !
                        1,
                    viewState: t,
                    graphInfo: n,
                    compiled: r,
                    showPoint: o
                }));
        else if (a > -1 / 0 && u >=
            p) l = Ru({
                bounds: [a, p],
                included: !0,
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: o
            }), c.push(Ru({
                bounds: [-
                    1 /
                    0,
                a -
                1
                ],
                included: !
                    1,
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: o
            })), c.push(l);
        else {
            l = Ru({
                bounds: [a,
                    u
                ],
                included: !
                    0,
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: o
            });
            let f = Ru({
                bounds: [-
                    1 /
                    0,
                a -
                1
                ],
                included: !
                    1,
                viewState: t,
                graphInfo: n,
                compiled: r,
                showPoint: o
            }),
                m = Ru({
                    bounds: [u +
                        1, p
                    ],
                    included: !
                        1,
                    viewState: t,
                    graphInfo: n,
                    compiled: r,
                    showPoint: o
                });
            c.push(l);
            let g;
            f && m && (g = pk(f, m),
                c.push(g))
        }
        return {
            cdfTopBranch: l,
            topBranches: c
        }
    }
    var AN = e => {
        let {
            viewState: t,
            graphInfo: n,
            compiled: r,
            derivative: i,
            bounds: s
        } = e, [o, a] = s, u =
                fk({
                    bounds: [o,
                        a
                    ],
                    viewState: t,
                    graphInfo: n,
                    compiled: r,
                    derivative: i
                }), c = [_a({
                    viewState: t,
                    graphInfo: n,
                    compiled: r,
                    derivative: i
                })];
        return {
            cdfTopBranch: u,
            topBranches: c
        }
    };

    function dte(e) {
        switch (e) {
            case "LOOP_FORWARD":
                return "dcg-icon-arrow-one-way";
            case "LOOP_FORWARD_REVERSE":
                return "dcg-icon-arrow-two-way";
            case "PLAY_ONCE":
                return "dcg-icon-arrow-once";
            case "PLAY_INDEFINITELY":
                return "dcg-icon-arrow-infinite"
        }
    }

    function gd(e, t) {
        let n = {};
        for (let r in t) t
            .hasOwnProperty(r) && (
                _o(e[r], t[r]) || (
                    n[r] = t[r]));
        return n
    }

    function ch(e, t) {
        let n, r = {};
        for (let i in t) t
            .hasOwnProperty(i) && (
                _o(e[i], t[i]) || (
                    r[i] = t[i], n =
                    r));
        return n
    }

    function hte(e, t) {
        t || (t = {});
        let n = {};
        for (let r in e) e
            .hasOwnProperty(r) && !t
                .hasOwnProperty(r) && (
                n[r] = Bs(e[r]));
        for (let r in t) t
            .hasOwnProperty(r) && (
                n[r] = t[r]);
        return n
    }

    function xte({
        from: e,
        to: t,
        props: n
    }) {
        for (var r in n) n[r] && e
            .hasOwnProperty(r) && (
                t[r] = Bs(e[r]))
    }

    function Pte(e, t) {
        for (var n in e) e
            .hasOwnProperty(n) && (
                t[n] = e[n])
    }

    function LN(e, t) {
        let n = {};
        for (var r in t) t
            .hasOwnProperty(r) && (
                n[r] = e[r]);
        return n
    }

    function Tte(e) {
        let t = {};
        for (let n in e) e
            .hasOwnProperty(n) && (
                t[n] = !0);
        return t
    }
    var dk = (r => (r.NONE = "NONE",
        r.POSITIVE =
        "POSITIVE", r.BOTH =
        "BOTH", r))(dk || {});
    var wN = {
        collapsed: !1,
        hidden: !1,
        secret: !1,
        readonly: !1,
        title: ""
    };

    function Mte(e) {
        return {
            ...wN,
            ...e
        }
    }

    function vte(e) {
        return gd(wN, e)
    }
    var FN = "**dcg_geo_folder**";
    var L0 = {
        show: !1,
        min: "",
        max: ""
    },
        w0 = {
            breadth: "",
            axisOffset: "",
            alignedAxis: "x",
            showBoxplotOutliers: !0,
            binAlignment: "center",
            dotplotXMode: "exact",
            histogramMode: ""
        },
        F0 = {
            enabled: !1,
            latex: ""
        };
    var VN = 4e3,
        lh = {
            polarDomain: {
                min: "",
                max: ""
            },
            parametricDomain: {
                min: "",
                max: ""
            },
            parametricDomain3Du: {
                min: "",
                max: ""
            },
            parametricDomain3Dv: {
                min: "",
                max: ""
            },
            parametricDomain3Dr: {
                min: "",
                max: ""
            },
            parametricDomain3Dphi: {
                min: "",
                max: ""
            },
            cdf: L0,
            colorLatex: "",
            description: "",
            fillOpacity: "",
            lineOpacity: "",
            pointOpacity: "",
            pointSize: "",
            movablePointSize: "",
            lineWidth: "",
            resolution: "",
            labelAngle: "",
            vizProps: w0,
            clickableInfo: F0
        },
        BN = {
            folderId: "",
            latex: "",
            color: "",
            showLabel: !1,
            showAngleLabel: !0,
            label: "",
            hidden: !1,
            secret: !1,
            readonly: !1,
            disableGraphInteractions:
                !1,
            dragMode: "AUTO",
            labelSize: "",
            labelOrientation: "default",
            suppressTextOutline: !1,
            interactiveLabel: !1,
            editableLabelMode: "NONE",
            residualVariable: "",
            isLogModeRegression: !1,
            pointStyle: "POINT",
            lineStyle: "SOLID",
            arrowMode: "DEFAULT",
            regressionParameters: {},
            displayEvaluationAsFraction:
                !1,
            slider: {},
            strictIntersection: !1,
            extendTo3D: !1,
            ...lh,
            points: void 0,
            lines: void 0,
            fill: void 0
        },
        GN = {
            hardMin: !1,
            hardMax: !1,
            animationPeriod: VN,
            loopMode: "LOOP_FORWARD_REVERSE",
            playDirection: 1,
            isPlaying: !1,
            min: "-10",
            max: "10",
            step: ""
        },
        kN = {
            hardMin: !1,
            hardMax: !1,
            animationPeriod: VN,
            loopMode: "LOOP_FORWARD_REVERSE",
            playDirection: 1,
            isPlaying: !1,
            min: `${lr.xmin}`,
            max: `${lr.xmax}`,
            step: ""
        };

    function Bte(e, t) {
        return {
            ...BN,
            ...e,
            slider: {
                ...t.is3d ? kN : GN,
                ...e.slider
            },
            cdf: {
                ...L0,
                ...e.cdf
            },
            vizProps: {
                ...w0,
                ...e.vizProps
            },
            clickableInfo: {
                ...F0,
                ...e.clickableInfo
            }
        }
    }

    function Gte(e, t) {
        var n = gd(BN, {
            ...e,
            slider: gd(t
                .is3d ?
                kN : GN,
                e.slider
            )
        }),
            r = ch(L0, e.cdf);
        r === void 0 ? delete n
            .cdf : n.cdf = r;
        var i = ch(w0, e.vizProps);
        i === void 0 ? delete n
            .vizProps : n.vizProps =
        i;
        var s = ch(F0, e
            .clickableInfo);
        return s === void 0 ?
            delete n.clickableInfo :
            n.clickableInfo = s, n
    }

    function mk(e) {
        return LN(e, lh)
    }

    function kte(e, t) {
        for (var n in lh)
            if (lh.hasOwnProperty(
                n) && e[n] !== t[n])
                return !1;
        return !0
    }

    function zte(e) {
        return {
            type: "statement",
            id: e.id,
            latex: e.latex,
            label: e.label,
            color: e.color,
            fill: e.fill,
            points: e.points,
            lines: e.lines,
            extendTo3D: e
                .extendTo3D,
            pointStyle: e
                .pointStyle,
            lineStyle: e.lineStyle,
            arrowMode: e.arrowMode,
            dragMode: e.dragMode,
            labelSize: e.labelSize,
            labelOrientation: e
                .labelOrientation,
            suppressTextOutline: e
                .suppressTextOutline,
            interactiveLabel: e
                .interactiveLabel,
            editableLabelMode: e
                .editableLabelMode,
            residualVariable: e
                .residualVariable,
            regressionParameters: e
                .regressionParameters,
            isLogModeRegression: e
                .isLogModeRegression,
            showLabel: e.showLabel,
            showAngleLabel: e
                .showAngleLabel,
            shouldGraph: e.hidden,
            slider: {
                min: e.slider
                    .hardMin ? e
                        .slider.min :
                    "",
                max: e.slider
                    .hardMax ? e
                        .slider.max :
                    "",
                softMin: e.slider
                    .hardMin ? "" :
                    e.slider.min,
                softMax: e.slider
                    .hardMax ? "" :
                    e.slider.max,
                step: e.slider.step,
                isPlayingOnce: e
                    .slider
                    .isPlaying && e
                        .slider
                        .loopMode ===
                    "PLAY_ONCE"
            },
            strictIntersection: e
                .strictIntersection,
            isInConstructionsFolder: e
                .folderId === FN,
            ...mk(e)
        }
    }
    var Pk = {};
    No(Pk, {
        LinearToSRGB: () =>
            bk,
        SRGBToLinear: () =>
            ph,
        colorString: () =>
            UN,
        colors: () => Bc,
        colors3d: () => xk,
        convertColorStringToLinearRGB: () =>
            B0,
        getDisplayColor: () =>
            sa,
        invertColor: () =>
            gk,
        isValidHexColor: () =>
            fh,
        mutateOpacity: () =>
            hk,
        normalizeColor: () =>
            V0,
        parseHex: () => qN,
        shadeColor: () => yk
    });

    function V0(e) {
        return fh(e) ? (e.match(
            /^#([A-Fa-f0-9]{3})$/g
        ) && (e = "#" +
            e[1] + e[1] + e[
            2] + e[2] +
            e[3] + e[3]), e
                .toLowerCase()) : e
    }

    function fh(e) {
        return typeof e ==
            "string" && (e.match(
                /^#([A-Fa-f0-9]{3})$/g
            ) || e.match(
                /^#([A-Fa-f0-9]{6})$/g
            ))
    }

    function yk(e, t) {
        if (e = V0(e), !fh(e))
            return e;
        t > 1 && (t = 1), t < -1 &&
            (t = -1);
        var n = parseInt(e.slice(1),
            16),
            r = t < 0 ? 0 : 255,
            i = t < 0 ? t * -1 : t,
            s = n >> 16,
            o = n >> 8 & 255,
            a = n & 255;
        return UN(Math.round((r -
            s) * i) + s,
            Math.round((r - o) *
                i) + o, Math
                    .round((r - a) *
                        i) + a)
    }

    function UN(e, t, n) {
        return "#" + (16777216 +
            Math.round(e) *
            65536 + Math.round(
                t) * 256 + Math
                    .round(n)).toString(
                        16).slice(1)
    }

    function gk(e) {
        if (e = V0(e), !fh(e))
            return e;
        let t = "0123456789abcdef";
        return "#" + e.slice(1)
            .split("").map(n => t[
                15 - t.indexOf(
                    n)]).join("")
    }

    function qN(e) {
        if (e = e.replace(/#/, ""),
            e.length === 3) var t =
                parseInt(e.slice(0,
                    1) + e
                        .slice(0, 1), 16
                ),
                n = parseInt(e
                    .slice(1, 2) + e
                        .slice(1, 2), 16
                ),
                r = parseInt(e
                    .slice(2, 3) + e
                        .slice(2, 3), 16
                );
        else if (e.length === 6) var
            t = parseInt(e
                .slice(0, 2), 16
            ),
            n = parseInt(e
                .slice(2, 4), 16
            ),
            r = parseInt(e
                .slice(4, 6), 16
            );
        else var t = 0,
            n = 0,
            r = 0;
        return {
            r: t,
            g: n,
            b: r
        }
    }

    function hk(e, t) {
        let n =
            /(rgba\([\d]+\,\ ?[\d]+\,\ ?[\d]+\,\ ?)[\d.]+(\))/;
        return e.match(n) ? e
            .replace(n,
                `$1${t}$2`) : e
    }

    function sa(e, t) {
        if (t && t
            .colorLatexValue) {
            var n = t
                .colorLatexValue;
            return Array.isArray(
                n) ? n[0] : n
        }
        return e.color
    }

    function ph(e) {
        return e < .04045 ? e *
            .0773993808 : Math.pow(
                e * .9478672986 +
                .0521327014, 2.4)
    }

    function bk(e) {
        return e < .0031308 ? e *
            12.92 : 1.055 * Math
                .pow(e, .41666) - .055
    }

    function B0(e) {
        let t = qN(e);
        return [ph(t.r / 255), ph(t
            .g / 255), ph(t
                .b / 255)]
    }
    var Bc = {
        RED: "#c74440",
        BLUE: "#2d70b3",
        GREEN: "#388c46",
        PURPLE: "#6042a6",
        ORANGE: "#fa7e19",
        BLACK: "#000000",
        GRAY: "#aaaaaa",
        FOCUS_OUTLINE: "#6a93d2"
    },
        xk = {
            RED: Bc.RED,
            BLUE: Bc.BLUE,
            GREEN: Bc.GREEN,
            ORANGE: Bc.ORANGE,
            PURPLE: Bc.PURPLE,
            GRAY: Bc.GRAY
        };

    function G0(e, t) {
        let n;
        switch (t) {
            case "solvedEquation":
                n = 2;
                break;
            case "baseComparator":
                n = 4;
                break;
            default:
                n = 1;
                break
        }
        return Math.floor(e / n)
    }

    function qte(e) {
        return 2 * Tk(e * .5)
    }

    function Tk(e) {
        return e <= 8 ? 3 * e : e >=
            16 ? 2 * e : e + 16
    }

    function YN(e) {
        let t = [];
        for (let r = 0; r < e
            .instructionsLength(); r++
        ) t.push(!1);
        let n = [];
        t[e.getReturnIndex()] = !0;
        for (let r = e
            .instructionsLength() -
            1; r >= 0; r--) {
            if (!t[r]) continue;
            let i = e
                .getInstruction(r);
            if (i.type === 2 && n
                .push(e.argNames[
                    r]), be(i))
                continue;
            let s = Pu(e, i) ? [i
                .args[1]
            ] : i.args;
            for (let o of s) t[
                o] = !0
        }
        return n
    }
    var Ep = class {
        constructor({
            enableGeometry: t,
            enable3d: n,
            beta3d: r,
            scales: i
        }) {
            this._isGeometry = !
                1;
            this._is3dProduct = !
                1;
            this._isBeta3d = !
                1;
            this._isGeometry =
                t, this
                    ._is3dProduct =
                n, this
                    ._isBeta3d =
                r, this
                    ._scales = i
        }
        isGeometryEnabled() {
            return this
                ._isGeometry
        }
        is3dProduct() {
            return this
                ._is3dProduct
        }
        is3dPolicy() {
            return !1
        }
        isBeta3d() {
            return this
                ._isBeta3d
        }
        areAllScalesLinear() {
            return this
                ._scales ?
                this._scales
                    .xAxisScale ===
                "linear" &&
                this._scales
                    .yAxisScale ===
                "linear" : !
                0
        }
        assignmentForbidden(t) {
            return t ===
                "x" || t ===
                "y" || t ===
                "theta" ||
                this
                    .substitutionForbidden(
                        t)
        }
        substitutionForbidden(
            t) {
            return t ===
                "index" ||
                t ===
                "dt" || t
                    .slice(0,
                        3) ===
                "tmp" || Ke
                    .hasOwnProperty(
                        t)
        }
        isValidSlider(t) {
            return t ===
                "x" || t ===
                "y" ? !0 : !
            (t.slice(0,
                3
            ) ===
                "ans" ||
                t.slice(
                    0, 6
                ) ===
                "idref_" ||
                this
                    .assignmentForbidden(
                        t))
        }
        sliderVariables(t) {
            return t
                .indexOf(
                    "theta"
                ) !== -
                1 && (t = t
                    .filter(
                        function (
                            n
                        ) {
                            return n !==
                                "r"
                        })),
                t.filter(
                    n => !(
                        this
                            .assignmentForbidden(
                                n
                            ) ||
                        n
                            .slice(
                                0,
                                3
                            ) ===
                        "ans" ||
                        n
                            .slice(
                                0,
                                6
                            ) ===
                        "idref_" ||
                        n[
                        0] ===
                        "_" ||
                        this
                            .isGeometryEnabled() &&
                        n[
                        0] ===
                        "$")
                )
        }
        tooManySliderVariables(
            t, n, r) {
            return r ? t
                .length >=
                1 : t
                    .length >=
                2 && n
                    .length >= 1
        }
        graphingEnabled() {
            return !0
        }
        ansEnabled() {
            return !1
        }
        dimensionVarsEnabled() {
            return !0
        }
        validRegressionParameter
            (t) {
            return t !==
                "x" && t !==
                "y"
        }
        validLHS(t) {
            return t !==
                "theta" && t
                    .slice(0,
                        6) !==
                "idref_"
        }
        unplottablePolarFunction
            (t, n) {
            return t !==
                "theta" ? !
            1 : n
                .indexOf(
                    "r") !==
            -1
        }
        validDoubleInequalitySymbol
            (t) {
            return t ===
                "x" || t ===
                "y"
        }
        validDoubleInequalityVariables
            (t) {
            return t
                .length >
                2 ? !1 : t
                    .every(this
                        .validDoubleInequalitySymbol
                    )
        }
        validExpressionVariables
            (t) {
            return t
                .length ===
                1 && t[
                0] === "x"
        }
        validSolvedVariable(t) {
            return t ===
                "x" || t ===
                "y" || t ===
                "r"
        }
        validImplicitVariables(
            t) {
            switch (t
                .length) {
                case 0:
                    return !
                        0;
                case 1:
                    return t[
                        0
                    ] ===
                        "x" ||
                        t[
                        0] ===
                        "y" ||
                        t[
                        0] ===
                        "r";
                case 2:
                    return t[
                        0
                    ] ===
                        "x" &&
                        t[
                        1] ===
                        "y" ||
                        t[
                        0] ===
                        "y" &&
                        t[
                        1] ===
                        "x" ||
                        t[
                        0] ===
                        "r" &&
                        t[
                        1] ===
                        "theta" ||
                        t[
                        0] ===
                        "theta" &&
                        t[
                        1] ===
                        "r";
                default:
                    return !
                        1
            }
        }
        graphableListVariables(
            t, n) {
            return t ===
                "x" || t ===
                "y" || t ===
                "r" || n ===
                "x" || n ===
                "y"
        }
        validParametricVariable(
            t) {
            return t === "t"
        }
        validParametricVariables
            (t) {
            return t
                .length ===
                1 && this
                    .validParametricVariable(
                        t[0])
        }
        validInequalityVariables
            (t) {
            switch (t
                .length) {
                case 1:
                    return t[
                        0
                    ] ===
                        "x" ||
                        t[
                        0] ===
                        "y" ||
                        t[
                        0] ===
                        "r";
                case 2:
                    return this
                        .validImplicitVariables(
                            t
                        );
                default:
                    return !
                        1
            }
        }
        validFirstColumnVariable
            (t) {
            return t !==
                "y" && t !==
                "r" && t !==
                "theta" && !
                t.match(
                    /y_(\d+)/
                )
        }
        validActionVariable(t) {
            return t ===
                "dt" ||
                t ===
                "index"
        }
        validCoordinateEquationSymbol
            (t) {
            return !1
        }
        complicatedPolarImplicit
            (t, n) {
            return t ===
                "theta" ||
                t === "r" &&
                n !== 1
        }
        graphMode(t, n, r) {
            if (n.length ===
                0) return t ===
                    "x" ?
                    1 :
                    t ===
                        "r" ?
                        6 :
                        t ===
                            "y" ?
                            2 : 10;
            let i = n[0];
            return i ===
                "y" ? 1 :
                t === "x" ?
                    1 : t ===
                        "r" && i ===
                        "theta" ?
                        6 : 2
        }
        functionDefinitionGraphMode
            (t, n) {
            return this
                .graphMode(
                    t, n)
        }
        tableableAsConstant(t) {
            return !(t ===
                "x" ||
                t ===
                "r" ||
                t ===
                "theta")
        }
        implicitIndependent(t) {
            return "x"
        }
        implicitDependency(t) {
            return t
                .length !==
                1 ? "y" : t[
                    0] ===
                    "y" ? "x" :
                t[0] ===
                    "theta" ?
                    "r" : "y"
        }
        disabledFeatures() {
            return []
        }
    };

    function Gc() {
        return new Ep({
            enableGeometry:
                !1,
            enable3d: !0,
            beta3d: !1,
            scales: {
                xAxisScale: "linear",
                yAxisScale: "linear"
            }
        })
    }
    var dh = class {
        constructor(t) {
            this._isBeta3d = !
                1;
            this._isBeta3d =
                t
        }
        isGeometryEnabled() {
            return !1
        }
        is3dProduct() {
            return !0
        }
        is3dPolicy() {
            return !0
        }
        isBeta3d() {
            return this
                ._isBeta3d
        }
        areAllScalesLinear() {
            return !0
        }
        graphingEnabled() {
            return !0
        }
        ansEnabled() {
            return !1
        }
        dimensionVarsEnabled() {
            return !1
        }
        substitutionForbidden(
            t) {
            return Gc()
                .substitutionForbidden(
                    t)
        }
        validInequalityVariables
            (t) {
            return this
                .validImplicitVariables(
                    t)
        }
        validFirstColumnVariable
            (t) {
            return Gc()
                .validFirstColumnVariable(
                    t)
        }
        validActionVariable(t) {
            return Gc()
                .validActionVariable(
                    t)
        }
        tableableAsConstant(t) {
            return Gc()
                .tableableAsConstant(
                    t)
        }
        implicitIndependent(t) {
            return Gc()
                .implicitIndependent(
                    t)
        }
        validRegressionParameter
            (t) {
            return Gc()
                .validRegressionParameter(
                    t)
        }
        assignmentForbidden(t) {
            return t ===
                "x" || t ===
                "y" || t ===
                "z" || t ===
                "r" || t ===
                "rho" ||
                t ===
                "theta" ||
                t ===
                "phi" ||
                this
                    .substitutionForbidden(
                        t)
        }
        sliderVariables(t) {
            return t.filter(
                n => !(
                    this
                        .assignmentForbidden(
                            n
                        ) ||
                    n
                        .slice(
                            0,
                            3
                        ) ===
                    "ans" ||
                    n
                        .slice(
                            0,
                            6
                        ) ===
                    "idref_" ||
                    n[
                    0] ===
                    "_")
            )
        }
        tooManySliderVariables(
            t, n, r) {
            return r ? this
                .isBeta3d() ?
                n.length >=
                1 : t
                    .length >=
                1 : n
                    .length >= 1
        }
        isValidSlider(t) {
            return !(t
                .slice(
                    0, 3
                ) ===
                "ans" ||
                t.slice(
                    0, 6
                ) ===
                "idref_" ||
                this
                    .assignmentForbidden(
                        t))
        }
        validLHS(t) {
            return t !==
                "phi" &&
                Gc()
                    .validLHS(t)
        }
        unplottablePolarFunction
            (t, n) {
            return !1
        }
        complicatedPolarImplicit
            (t, n) {
            return !1
        }
        validDoubleInequalitySymbol
            (t) {
            return hd(t)
        }
        validDoubleInequalityVariables
            (t) {
            return t.every(
                hd)
        }
        validExpressionVariables
            (t) {
            return t
                .length ===
                2 && t
                    .every(n =>
                        n ==
                        "x" ||
                        n == "y"
                    )
        }
        validSolvedVariable(t) {
            return hd(t) ||
                t === "r" ||
                t === "rho"
        }
        validImplicitVariables(
            t) {
            return t.every(
                hd)
        }
        graphableListVariables(
            t, n) {
            return t ===
                "x" || t ===
                "y" || t ===
                "z" || t ===
                "r" || t ===
                "rho" ||
                n === "x" ||
                n === "y"
        }
        validParametricVariable(
            t) {
            return t ===
                "t" || t ===
                "u" || t ===
                "v"
        }
        validParametricVariables
            (t) {
            return t
                .length ===
                1 && this
                    .validParametricVariable(
                        t[0]) ||
                t.length ===
                2 && t
                    .every(bd)
        }
        validCoordinateEquationSymbol
            (t) {
            return this
                .isBeta3d() ?
                t ===
                "rhothetaphi" ||
                t ===
                "rthetaz" :
                !1
        }
        functionDefinitionGraphMode
            (t, n) {
            if (n.length ===
                1) switch (
                n[0]) {
                    case "x":
                        return 121;
                    case "y":
                        return 120;
                    default:
                        return 10
                } else if (n
                    .length ===
                    2 && n
                        .every(
                            r =>
                                r ==
                                "x" ||
                                r ==
                                "y")
            )
                return 106;
            return 10
        }
        graphMode(t, n, r) {
            if (r != null ||
                (r = n), n
                    .length ===
                0) switch (
                t) {
                    case "z":
                        return r
                            .some(
                                i =>
                                    i ===
                                    "r" ||
                                    i ===
                                    "theta"
                            ) ?
                            109 :
                            106;
                    case "y":
                        return r
                            .includes(
                                "z"
                            ) ?
                            108 :
                            123;
                    case "x":
                        return r
                            .includes(
                                "z"
                            ) ?
                            107 :
                            122;
                    case "r":
                        return r
                            .indexOf(
                                "r"
                            ) >
                            -
                            1 ?
                            10 :
                            XN(
                                r);
                    case "rho":
                        return 111;
                    case "rthetaz":
                        return this
                            .isBeta3d() ?
                            115 :
                            10;
                    case "rhothetaphi":
                        return this
                            .isBeta3d() ?
                            116 :
                            10;
                    default:
                        return 10
                }
            switch (t) {
                case "z":
                    return n
                        .every(
                            i =>
                                i ==
                                "x" ||
                                i ==
                                "y"
                        ) ?
                        106 :
                        n
                            .every(
                                i =>
                                    i ==
                                    "r" ||
                                    i ==
                                    "theta"
                            ) ?
                            109 :
                            10;
                case "y":
                    return n
                        .every(
                            i =>
                                i ==
                                "x"
                        ) ?
                        r
                            .some(
                                i =>
                                    i ===
                                    "z"
                            ) ?
                            108 :
                            121 :
                        n
                            .every(
                                i =>
                                    i ==
                                    "x" ||
                                    i ==
                                    "z"
                            ) ?
                            108 :
                            10;
                case "x":
                    return n
                        .every(
                            i =>
                                i ==
                                "y"
                        ) ?
                        r
                            .some(
                                i =>
                                    i ===
                                    "z"
                            ) ?
                            107 :
                            120 :
                        n
                            .every(
                                i =>
                                    i ==
                                    "y" ||
                                    i ==
                                    "z"
                            ) ?
                            107 :
                            10;
                case "r":
                    return n
                        .every(
                            i =>
                                i ==
                                "theta"
                        ) ?
                        XN(
                            r) :
                        n
                            .every(
                                i =>
                                    i ==
                                    "theta" ||
                                    i ==
                                    "z"
                            ) ?
                            110 :
                            10;
                case "rho":
                    return n
                        .every(
                            i =>
                                i ==
                                "theta" ||
                                i ==
                                "phi"
                        ) ?
                        111 :
                        10;
                case "rthetaz":
                    return this
                        .isBeta3d() ?
                        n
                            .length ===
                            1 &&
                            n[
                            0] ===
                            "t" ?
                            101 :
                            n
                                .every(
                                    bd
                                ) ?
                                104 :
                                10 :
                        10;
                case "rhothetaphi":
                    return this
                        .isBeta3d() ?
                        n
                            .length ===
                            1 &&
                            n[
                            0] ===
                            "t" ?
                            102 :
                            n
                                .every(
                                    bd
                                ) ?
                                105 :
                                10 :
                        10;
                default:
                    return 10
            }
        }
        implicitDependency(t) {
            if (t.length !==
                2)
                return "z";
            let n = t[0] <
                t[1] ? t[
                0] + t[1] :
                t[1] + t[0];
            return n ===
                "xy" ? "z" :
                n === "xz" ?
                    "y" : n ===
                        "yz" ? "x" :
                        "z"
        }
        disabledFeatures() {
            return []
        }
    },
        hd = e => e === "x" || e ===
            "y" || e === "z",
        bd = e => e === "u" || e ===
            "v";

    function XN(e) {
        return e.some(n => hd(n) ||
            n === "r") ? 110 :
            124
    }
    D.Base.prototype.getGraphMode =
        function (e, t) {
            return 10
        };
    D.Base.prototype
        .graphmodeDependencies = Cs;

    function Cs(e, t) {
        let n = t.getDependencies();
        if (e.is3dProduct() &&
            t instanceof pn) {
            let r = new Set(YN(t
                ._chunk));
            return n.filter(i => r
                .has(i))
        } else return n
    }

    function Ik(e, t) {
        var n;
        return e && e
            .hasOwnProperty(
                "dragMode") ? e
                    .dragMode === "AUTO" ?
            n = t.defaultDragMode :
            n = e.dragMode : n = t
                .defaultDragMode, ON(n,
                    t.moveStrategy)
    }

    function ZN(e, t) {
        let n = e.is3dPolicy();
        if (t.isMovablePoint && !
            n && Ik(this.userData,
                t) !== "NONE")
            return 4;
        var r = Cs(e, t);
        switch (t.valueType) {
            case Kn:
            case V:
                if (n) {
                    if (r.length ===
                        0)
                        return 114;
                    if (e
                        .validParametricVariables(
                            r))
                        return r
                            .length ==
                            1 ?
                            100 :
                            La(103,
                                t)
                }
                return 10;
            case R:
            case Pt:
                return r.length ===
                    0 ? 3 : n && e
                        .validParametricVariables(
                            r) ? r
                                .length === 1 ?
                    5 : r.every(
                        bd) ? La(130,
                            t) : 10 : e
                                .validParametricVariables(
                                    r) ? 5 : 10;
            case T:
            case se:
                return !e
                    .is3dPolicy() &&
                    r.length === 1 ?
                    2 : n && r
                        .length === 2 &&
                        r.indexOf("x") >
                        -1 && r.indexOf(
                            "y") > -1 ?
                        La(106, t) : 10
        }
        if (r.length > 0) return 10;
        switch (t.valueType) {
            case Wn:
            case Dr:
                return 5;
            case jn:
            case Sr:
                return n ? 100 : 10;
            case sr:
            case Or:
                return n ? La(130,
                    t) : 10;
            case or:
            case Cr:
                return n ? La(103,
                    t) : 10;
            case Nt:
            case er:
                return n ? 119 : 10;
            case Se:
            case nr:
                return n ? 129 : 10;
            case In:
            case tr:
                return n ? 117 : 10;
            case Nn:
            case yr:
                return n ? 118 : 10;
            case Be:
            case Rn:
                return 16;
            case pe:
            case Fn:
                return 20;
            case ce:
            case Vn:
                return 21;
            case Ie:
            case Tn:
                return 17;
            case fe:
            case Bn:
                return 18;
            case Le:
            case Gn:
                return 19;
            case he:
            case kn:
                return this instanceof ze &&
                    this
                        .getDependencies()
                        .length === 1 ?
                    10 : 24;
            case Ge:
            case gn:
            case Ae:
            case hn:
                return 23;
            default:
                return 10
        }
    }
    D.Expression.prototype
        .getGraphMode = ZN;

    function WN(e, t) {
        var n = t._expression
            .getDependencies();
        if (n.length > 1) return 10;
        if (t._expression.isList &&
            t._expression.length ===
            0) return 10;
        var r = t._symbol;
        let i = t.getDependencies();
        return e.graphMode(r, n, i)
    }
    D.Equation.prototype
        .getGraphMode = D
            .CallAssignment.prototype
            .getGraphMode = D
                .BaseComparator.prototype
                .getGraphMode = D
                    .ComparatorChain.prototype
                    .getGraphMode = function (e,
                        t) {
            if (t.isError)
                return 10;
            var n = Cs(e, t);
            let r = t
                .getDependencies();
            if (e.is3dPolicy()) {
                let i = 10,
                    s = this
                        .type ===
                        "Equation" ||
                        this.type ===
                        "ComparatorChain" &&
                        this.symbols
                            .includes("=");
                return n.length >
                    0 && (r
                        .includes(
                            "z") ?
                        i = s ?
                            112 : 113 :
                        i = s ?
                            126 : 127),
                    La(i, t)
            }
            return t.isConstant ?
                10 : t instanceof D
                    .SolvedEquation ?
                    WN(e, t) : n
                        .length === 1 || n
                            .length === 2 ? 8 :
                        10
        };

    function U0(e) {
        var t;
        return e === 106 || e ===
            200 || e === 107 ||
            e === 201 || e ===
            108 || e === 202 ? ["x",
            "y", "z",
            "_implicit"
        ] : e === 110 || e ===
            211 ? ["x", "y", "z",
            "r", "theta",
            "_implicit"
        ] : e === 111 || e ===
            212 ? ["x", "y", "z",
            "rho", "theta",
            "phi", "_implicit"
        ] : e === 109 || e ===
            213 ? ["x", "y", "z",
            "r", "theta",
            "_implicit"
        ] : e === 103 || e ===
            214 || e === 130 ||
            e === 215 ? ["x", "y",
            "z", "u", "v",
            "_implicit"
        ] : e === 113 || e ===
            210 || e === 112 ||
            e === 209 ? ["x", "y",
            "z", "_implicit"
        ] : (t = ss[e]) !=
            null ? t : []
    }

    function La(e, t) {
        let n = U0(e),
            r = t._chunk;
        try {
            let s = Ra(r, n, {
                allowSlices:
                    !0
            })
                .getSliceVariablesOrImplicit();
            if (s.length !== 1)
                return e;
            let o = s[0];
            return n.indexOf(o) <
                0 ? 10 : zR(e, o)
        } catch (i) {
            return 10
        }
    }
    D.DoubleInequality.prototype
        .getGraphMode = function (e,
            t) {
            let n = t
                .getDependencies();
            return e.graphMode(t
                ._symbol, [], n)
        };
    D.Assignment.prototype
        .getGraphMode = function (e,
            t) {
            if (t instanceof D
                .SolvedEquation)
                return WN(e, t);
            if (this.isEquation(e,
                t)) return this
                    .asEquation()
                    .getGraphMode(e,
                        t);
            let n = Cs(e, t),
                r = this._symbol,
                i = t
                    .getDependencies();
            switch (t.valueType) {
                case T:
                case se:
                case We:
                    switch (n
                        .length) {
                        case 0: {
                            let o =
                                e
                                    .graphMode(
                                        r,
                                        [],
                                        i
                                    );
                            return e
                                .is3dPolicy() ?
                                La(o,
                                    t
                                ) :
                                o
                        }
                        case 1:
                            if (t
                                .valueType ===
                                se &&
                                !e
                                    .graphableListVariables(
                                        r,
                                        n[
                                        0]
                                    )
                            )
                                return 10;
                            if (this
                                .isSlider
                            )
                                return 10;
                            let s =
                                e
                                    .graphMode(
                                        r,
                                        n,
                                        i
                                    );
                            return e
                                .is3dPolicy() ?
                                La(s,
                                    t
                                ) :
                                s;
                        default:
                            return e
                                .is3dPolicy() ?
                                La(e.graphMode(
                                    r,
                                    n,
                                    i
                                ),
                                    t
                                ) :
                                10
                    }
                case V:
                    if (e
                        .assignmentForbidden(
                            r) || n
                                .length >
                            0 && !e
                                .validParametricVariables(
                                    n))
                        return 10;
                    switch (n
                        .length) {
                        case 0:
                            return 114;
                        case 1:
                            return 100;
                        case 2:
                            return 103;
                        default:
                            return 10
                    }
                default:
                    return ZN.call(
                        this, e,
                        t)
            }
        };
    D.CoordinateEquation.prototype
        .getGraphMode = function (e,
            t) {
            var n = Cs(e, t);
            let r = this
                ._concatenatedSymbol;
            if (t.valueType !== V)
                return 10;
            if (n.length > 0 && !e
                .validParametricVariables(
                    n)) return 10;
            switch (n.length) {
                case 0:
                    switch (r) {
                        case "rhothetaphi":
                            return 116;
                        case "rthetaz":
                            return 115;
                        default:
                            return 10
                    }
                case 1:
                    switch (r) {
                        case "rhothetaphi":
                            return 102;
                        case "rthetaz":
                            return 101;
                        default:
                            return 10
                    }
                case 2:
                    switch (r) {
                        case "rhothetaphi":
                            return 105;
                        case "rthetaz":
                            return 104;
                        default:
                            return 10
                    }
                default:
                    return 10
            }
        };
    D.FunctionDefinition.prototype
        .getGraphMode = function (e,
            t) {
            let n = e.is3dPolicy();
            if (this._argSymbols
                .length !== 1 && !n)
                return 10;
            if (this
                .recursionInfo) {
                let s =
                    t instanceof pn ?
                        t
                            .getRecursiveFunctionMetadata() :
                        void 0;
                if ((s == null ?
                    void 0 : s
                        .type) ===
                    "missing-non-recursive-branch"
                ) return 10;
                if ((s == null ?
                    void 0 : s
                        .recursiveStructure
                        .domainInfo[
                    this
                        ._symbol
                    ][0]
                ) === 1)
                    return 10
            }
            var r = e
                .functionDefinitionGraphMode(
                    this._symbol,
                    this._argSymbols
                ),
                i = Cs(e, t);
            switch (t.valueType) {
                case T:
                case se:
                    if (n) return r;
                    switch (i
                        .length) {
                        case 0:
                            return r;
                        case 1:
                            return i[
                                0
                            ] !==
                                this
                                    ._argSymbols[
                                0
                                ] ?
                                10 :
                                r;
                        default:
                            return 10
                    }
                    break;
                default:
                    return 10
            }
        };
    D.Regression.prototype
        .getGraphMode = function (e,
            t) {
            return this
                .isLhsSimple ? t
                    .isModelValid ? t
                        .model
                        .getDependencies()
                        .length !== 1 ? 10 :
                2 : 10 : 10
        };

    function q0(e, t) {
        return t.isError ? 10 : 11
    }
    D.Histogram.prototype
        .getGraphMode = q0;
    D.DotPlot.prototype
        .getGraphMode = q0;
    D.BoxPlot.prototype
        .getGraphMode = q0;
    D.Image.prototype.getGraphMode =
        function (e, t) {
            return this.userData
                .showPoints ? this
                    .center.isError ||
                    this.radianAngle
                        .isError || this
                            .width.isError ||
                    this.height
                        .isError || this
                            .opacity.isError ?
                10 : 3 : 10
        };

    function jN(e) {
        let t = 0,
            n = 0,
            r = [],
            i = Yr(e, e
                .getReturnIndex());
        for (let s = 0; s < e
            .instructionsLength(); s++
        ) {
            if (!i[s]) continue;
            let o = e
                .getInstruction(s);
            o.type === 25 ? r[s] =
                1 : o.type === 31 ||
                    o.type === 32 ? r[
                    s] = r[o.args[0]] +
            r[o.args[1]] : r[
            s] = 0, Pu(e, o) &&
                (t += 1, n += r[o
                    .args[0]])
        }
        return {
            numRestrictions: t,
            numEqualityRestrictions: n
        }
    }

    function Hc(e, t, n) {
        try {
            return Ek(e, t, n)
        } catch (r) {
            return r instanceof C ?
                r : J(r)
        }
    }

    function Ek(e, t, n) {
        var l, p;
        if (!e.is3dProduct() || n
            .isError) return n;
        if (!(n instanceof pn))
            return J(
                "Expected peel error to be checked on an IRExpression"
            );

        function r(f, m) {
            let g = m.filter(d => f
                .indexOf(d) < 0);
            if (g.length) return mP(
                g[0])
                .allowExport()
                .setDependencies(
                    g)
        }

        function i() {
            let f = yh(o),
                m = Mk(e, n);
            return r(f, m)
        }

        function s() {
            let f = JN(o),
                m = vk(e, n, o);
            return r(f, m)
        }
        let o = t.getGraphMode(e,
            n),
            a = n._chunk,
            {
                numRestrictions: u,
                numEqualityRestrictions: c
            } = jN(a);
        if (c !== 0)
            if (c === 1) {
                if (u !== c && !t
                    .isInequality())
                    return ax();
                let g = Ra(a, [], {
                    allowSlices:
                        !0
                })
                    .getSliceVariablesOrImplicit();
                if (g.length !== 1)
                    return Bo();
                let d = U0(o),
                    y = g[0];
                if (d.indexOf(y) <
                    0) return y ===
                        "_implicit" ?
                        Bo()
                            .allowExport() :
                        gP(y)
                            .allowExport()
                            .setDependencies(
                                [y])
            } else return ox();
        return (p = (l = i()) !=
            null ? l : s()) !=
            null ? p : n
    }

    function Mk(e, t) {
        let n = Cs(e, t);
        return t.getDependencies()
            .filter(i => n.indexOf(
                i) < 0)
    }

    function vk(e, t, n) {
        let r = Cs(e, t),
            i = new Set;
        if (t instanceof pn) {
            let o = t
                .getRestrictedFunctionForGLSL(
                    yh(n), Nu)
                .concrete;
            for (let a of o
                .getDependencies())
                r.indexOf(a) > -1 ||
                    i.add(a)
        }
        return [...i]
    }

    function yh(e) {
        var n;
        if (!ea(e)) return [];
        let t = Dk(e) ? ["x", "y",
            "z"
        ] : [];
        return e === 211 && t.push(
            "r"), e === 212 && t
                .push("rho"), t.push(...
                    (n = Vc[e]) !=
                        null ? n : []), t
                            .push(...JN(e).filter(
                                r => t.indexOf(
                                    r) < 0)), t
    }

    function Dk(e) {
        return Sk(e) || e == 200 ||
            e == 201 || e == 202 ||
            e == 211 || e == 212 ||
            e == 213 || e == 214 ||
            e == 215
    }

    function Sk(e) {
        if (!ea(e)) return !1;
        switch (e) {
            case 106:
            case 107:
            case 108:
            case 110:
            case 111:
            case 109:
            case 122:
            case 123:
            case 112:
            case 113:
            case 127:
            case 130:
            case 103:
            case 104:
            case 105:
            case 210:
                return !0;
            case 124:
            case 120:
            case 121:
            case 126:
            case 114:
            case 115:
            case 116:
            case 117:
            case 118:
            case 119:
            case 129:
            case 128:
            case 100:
            case 101:
            case 102:
            case 200:
            case 201:
            case 202:
            case 206:
            case 205:
            case 211:
            case 203:
            case 204:
            case 213:
            case 207:
            case 208:
            case 212:
            case 214:
            case 215:
            case 209:
                return !1;
            default:
                return !1
        }
    }

    function JN(e) {
        var t;
        return ea(e) ? (t = ss[
            e]) != null ? t : [] :
            []
    }

    function QN(e = void 0) {
        let {
            xmin: t,
            xmax: n,
            ymin: r,
            ymax: i,
            zmin: s,
            zmax: o
        } = e != null ? e : new nh,
            a = [t, r, o, t, i, o,
                n, i, o, n, r, o, t,
                r, s, t, i, s, n, i,
                s, n, r, s, t, r, s,
                t, r, o, t, i, o, t,
                i, s, n, r, s, n, r,
                o, n, i, o, n, i, s,
                n, r, s, n, r, o, t,
                r, o, t, r, s, n, i,
                s, n, i, o, t, i, o,
                t, i, s
            ], u = [0, 0, -1, 0, 0,
                -1, 0, 0, -1, 0, 0,
                -1, 0, 0, -1, 0, 0,
                -1, 0, 0, -1, 0, 0,
                -1, -1, 0, 0, -1, 0,
                0, -1, 0, 0, -1, 0,
                0, -1, 0, 0, -1, 0,
                0, -1, 0, 0, -1, 0,
                0, 0, -1, 0, 0, -1,
                0, 0, -1, 0, 0, -1,
                0, 0, -1, 0, 0, -1,
                0, 0, -1, 0, 0, -1,
                0
            ], c = [0, 0, 0, 1, 1,
                1, 1, 0, 0, 0, 0, 1,
                1, 1, 1, 0, 0, 0, 0,
                0, 0, 1, 0, 1, 1, 0,
                1, 0, 1, 1, 1, 1, 1,
                0, 1, 0, 0, 0, 0, 0,
                1, 1, 1, 1, 0, 1, 0,
                1
            ], l = [0, 1, 2, 0, 2,
                3, 4, 5, 6, 4, 6, 7,
                8, 9, 10, 8, 10, 11,
                12, 13, 14, 12, 14,
                15, 16, 17, 18, 16,
                18, 19, 20, 21, 22,
                20, 22, 23
            ];
        return {
            positions: new Float32Array(
                a),
            normals: new Float32Array(
                u),
            faces: new Uint16Array(
                l),
            uvs: new Float32Array(c)
        }
    }

    function KN(e, t) {
        let {
            mappedArgIndex: n,
            mappedReturnIndex: r,
            solutionIndex: i
        } = t, s = [], o = eu(e, n),
            a = Ck(e, o, r), u = i,
            c = e.NanOfType(e
                .getReturnType());
        for (let l = 0; l <=
            r; l++) {
            let p = e
                .getInstruction(l);
            if (l === n) {
                s.push(i);
                continue
            }
            if (!o[l] && !e
                .isInClosedBlock(l)
            ) {
                s.push(l);
                continue
            }
            if (be(p)) s.push(e
                .copyInstruction(
                    p));
            else {
                let f = Ok(s, p
                    .args);
                s.push(e.copyInstructionWithArgs(
                    p, f)), p
                        .type === 33 &&
                    a[l] && (u = e
                        .Piecewise([
                            f[
                            0],
                            u, c
                        ]))
            }
        }
        return u
    }

    function Ok(e, t) {
        let n = [];
        for (let r of t) n.push(e[
            r]);
        return n
    }

    function Ck(e, t, n) {
        let r = [];
        for (let i = 0; i < n; i++)
            r.push(!1);
        r[n] = t[n];
        for (let i = n; i >=
            0; i--) {
            if (!r[i] || !t[i])
                continue;
            let s = e
                .getInstruction(i);
            if (s.type === 33) r[s
                .args[1]] = !0;
            else if (!be(s))
                for (let o of s
                    .args) r[o] = !0
        }
        return r
    }

    function eA(e, t) {
        try {
            return Rk(e, t)
        } catch (n) {
            return n instanceof D
                .Base ? n : J(n)
        }
    }

    function $0(e, t) {
        try {
            let n = new pn(t),
                r = Nc({}, n),
                i = [];
            for (let o = 0; o < r
                .length; o++) i
                    .push(T);
            let s = _g({
                policy: e,
                frame: {},
                argNames: r,
                argTypes: i,
                selection: void 0
            });
            return s.chunk = t, t
                .fuseBroadcast(),
                tA({
                    policy: e,
                    ctx: s,
                    isInequality:
                        !1,
                    allowSolvingIn3D:
                        !0
                }, t)
        } catch (n) {
            return n instanceof D
                .Base ? n : J(n)
        }
    }

    function Rk({
        policy: e,
        frame: t
    }, n) {
        let r = !1;
        if (n instanceof ja) {
            let d = n._lhs,
                y = d._symbol;
            if (!t[y] && !e
                .assignmentForbidden(
                    y) && (r = !0, d
                        .args.length > 1
                )) {
                let h = tn([y]);
                throw h.silent = !0,
                h
            }
        }
        let i = n.asComparator(),
            s = Nc(t, i),
            o = [];
        for (let d = 0; d < s
            .length; d++) o.push(T);
        let a = _g({
            policy: e,
            frame: t,
            argNames: s,
            argTypes: o,
            selection: void 0
        }),
            {
                chunk: u
            } = a,
            c = i.getOperator(),
            l = c !== "=",
            p = Ee(a, i.args[0]),
            f = Ee(a, i.args[1]);
        switch (lu(u, e, i, [p, f]),
        c) {
            case "<":
                u.Less([p, f]);
                break;
            case ">":
                u.Greater([p, f]);
                break;
            case "<=":
                u.LessEqual([p, f]);
                break;
            case ">=":
                u.GreaterEqual([p,
                    f]);
                break;
            case "=":
                u.Equal([p, f]);
                break
        }
        if (u.fuseBroadcast(), u
            .isConstant())
            return new pn(u);
        let g = u.getInstruction(p)
            .type !== 2 || Nc(t, i
                .args[1]).indexOf(u
                    .argNames[p]) !== -
            1;
        if (!rs.plotImplicits && g)
            throw IP();
        return Rr[c].direction === -
            1 ? u.Subtract([f, p]) :
            u.Subtract([p, f]), u
                .fuseBroadcast(), tA({
                    policy: e,
                    ctx: a,
                    isInequality: l,
                    allowSolvingIn3D:
                        !1,
                    maybeBaseCase: r
                }, u)
    }

    function tA({
        policy: e,
        ctx: t,
        isInequality: n,
        allowSolvingIn3D: r,
        maybeBaseCase: i
    }, s) {
        let o = s.getLiveArgNames();
        if (o.length === 0) throw J(
            `Unexpected: non-constant node with dependencies: ${o}`
        );
        if (o.length === 1 && !n &&
            !rs
                .plotSingleVariableImplicitEquations
        ) return TP();
        let a = g => g === "x" ||
            g === "y" || g === "z";
        if (e.is3dPolicy() ? !o
            .every(a) : o.length > 2
        ) return tn(e
            .sliderVariables(
                o))
            .setDependencies(o);
        if (n && !e
            .validInequalityVariables(
                o)) return xP()
                    .setDependencies(o);
        let {
            localFrames: u,
            effectiveOrder: c,
            variableOfInterest: l
        } = Nk(t, n);
        if (e
            .complicatedPolarImplicit(
                l, c)) return EP()
                    .setDependencies(o);
        if (!e
            .validImplicitVariables(
                o)) {
            let g = rc();
            return i && (g
                .silent = !0), g
        }
        if (e.is3dPolicy() && r &&
            c !== 1) return Bo();
        if (c > 2 || e
            .is3dPolicy() && !r)
            return new pn(s);
        let p = [],
            f = [],
            m = 1;
        for (let g = 0; g < u
            .length; g++) {
            let d = u[g],
                y = Ak(d, n);
            m = y.length;
            for (let b of y) {
                let x = d.chunk
                    .copy();
                if (x
                    .setReturnIndex(
                        b), d
                        .isRestrictedPolynomial
                ) {
                    let {
                        mappedArgIndex: P,
                        mappedReturnIndex: M
                    } = d;
                    x.setReturnIndex(
                        KN(x, {
                            mappedArgIndex: P,
                            mappedReturnIndex: M,
                            solutionIndex: x
                                .getReturnIndex()
                        }))
                }
                x.fuseBroadcast(), p
                    .push(new pn(x))
            }
            let h = !1;
            for (let b of d
                .coefficients) {
                let x = d.chunk
                    .getInstruction(
                        b);
                x.type === 1 && x
                    .value !== 0 &&
                    (h = !0)
            }
            if (s.argNames
                .length !== 2 || h)
                f.push(void 0);
            else {
                let b = d.chunk
                    .copy(),
                    x = d
                        .coefficients
                        .slice();
                b.List(x);
                let P = W(s
                    .getReturnType()
                ) ? s
                    .elementAt(g) :
                    s.copy(),
                    I = P.argNames
                        .indexOf(l) ===
                        0 ? 1 : 0,
                    E = P
                        .getReturnIndex();
                P.Add([I, P.Multiply(
                    [P.Constant(
                        0
                    ),
                        E
                    ])]), f
                        .push({
                            coefficients: b,
                            restriction: P
                        })
            }
        }
        return new D.SolvedEquation(
            l, new D.List(p), f,
            m)
    }

    function Nk(e, t) {
        let n = e.chunk,
            r = e.policy,
            i = n.argNames,
            s = W(n
                .getReturnType()),
            o = [];
        e: for (let a = 0; a < i
            .length; a++) {
            let u = i[a],
                c = i.length >
                    1 && !r
                        .validSolvedVariable(
                            u);
            o[a] = {
                localFrames: [],
                effectiveOrder: 0,
                variableOfInterest: u
            };
            let l = !t;
            if (c) {
                o[a].effectiveOrder =
                    1 / 0;
                continue
            }
            let p = s ? n
                .getConstantListLength() :
                1;
            if (p == null)
                throw new Error(
                    "Programming error: cannot solve a variable-length list expression"
                );
            for (let f = 0; f <
                p; f++) {
                let m = s ? n
                    .elementAt(
                        f) : n;
                if (m
                    .polynomialOrder(
                        u, {
                        allowRestriction: l,
                        allowClosedBlockReferences:
                            !
                            1
                    }) > 2
                ) {
                    o[a].effectiveOrder =
                        1 / 0;
                    continue e
                }
                let d = m
                    .getPolynomialCoefficients(
                        u);
                o[a].localFrames
                    .push(d), o[
                        a]
                        .effectiveOrder =
                    Math.max(o[
                        a]
                        .effectiveOrder,
                        d
                            .coefficients
                            .length -
                        1)
            }
        }
        if (i.length === 1)
            return o[0];
        if (i.length === 2 && !i
            .includes("z"))
            return i[0] === "y" && (
                o = [o[1], o[0]]
            ), o[0]
                .effectiveOrder ===
                0 ? o[1] : o[1]
                    .effectiveOrder ===
                    0 ? o[0] : o[o[0]
                        .effectiveOrder <
                        o[1]
                            .effectiveOrder ?
                        0 : 1];
        {
            let a = o.filter(c => c
                .effectiveOrder ===
                1);
            if (a.length > 0)
                return a[0];
            let u = o.filter(c => c
                .effectiveOrder ===
                2);
            return u.length > 0 ? u[
                0] : o[0]
        }
    }

    function Ak(e, t) {
        return t ? Lk(e) : _k(e)
    }

    function _k({
        chunk: e,
        coefficients: t
    }) {
        let [n, r, i] = t, s = e
            .Constant(De(0, 1)), o =
                e.Constant(NaN);
        if (i === void 0) {
            r === void 0 && (r = s);
            let a = e.Negative([e
                .Divide([n,
                    r
                ])
            ]),
                u = e.Equal([r, s]);
            return [e.Piecewise([u,
                o, a
            ])]
        } else {
            let a = e.Constant(De(2,
                1)),
                u = e.Multiply([a,
                    i]),
                c = e.Negative([r]),
                l = e.Subtract([e
                    .Multiply([
                        r, r
                    ]), e
                        .Multiply([
                            a, e
                                .Multiply(
                                    [u,
                                        n]
                                )
                        ])
                ]),
                p = e.Equal([i, s]),
                f = e
                    .getInstruction(l);
            if (f.type === 1 && q(f
                .value) === 0)
                return [e.Piecewise(
                    [p, o, e
                        .Divide(
                            [c,
                                u]
                        )
                    ])];
            {
                let m = e
                    .SyntheticNativeFunction(
                        "sqrt", [l]
                    ),
                    g = e.Less([r,
                        s]),
                    d = e.Greater([
                        r, s
                    ]),
                    y = e.Divide([e
                        .Add([c,
                            m]),
                        u
                    ]),
                    h = e.Divide([e
                        .Subtract(
                            [c,
                                m]
                        ), u
                    ]),
                    b = e.Negative([
                        e
                            .Divide(
                                [n,
                                    r]
                            )
                    ]);
                return [e.Piecewise(
                    [p, e
                        .Piecewise(
                            [g, b,
                                o
                            ]
                        ),
                        h
                    ]), e
                        .Piecewise([
                            p, e
                                .Piecewise(
                                    [d, b,
                                        o
                                    ]
                                ),
                            y
                        ])
                ]
            }
        }
    }

    function Lk({
        chunk: e,
        coefficients: t
    }) {
        let [n, r, i] = t, s = e
            .Constant(De(0, 1));
        i === void 0 && (i = s),
            r === void 0 && (r = s),
            n === void 0 && (n = s);
        let o = e.Constant(De(2,
            1)),
            a = e.Constant(NaN),
            u = e.Constant(De(1e305,
                1)),
            c = e.Negative([u]),
            l = e.Multiply([o, i]),
            p = e.Negative([r]),
            f = e.Subtract([e
                .Multiply([r,
                    r]), e
                        .Multiply([o, e
                            .Multiply(
                                [l,
                                    n]
                            )
                        ])
            ]),
            m = e
                .SyntheticNativeFunction(
                    "sqrt", [f]),
            g = e.Divide([e.Add([p,
                m
            ]), l]),
            d = e.Divide([e
                .Subtract([p,
                    m]), l
            ]),
            y = e.Negative([e
                .Divide([n, r])
            ]),
            h = e.Equal([i, s]),
            b = e.Greater([i, s]),
            x = e.Equal([r, s]),
            P = e.Greater([r, s]),
            M = e.Less([r, s]),
            I = e.Greater([n, s]),
            E = e.Less([f, s]);
        return [e.Piecewise([h, e
            .Piecewise([
                M,
                y, a
            ]), e
                .Piecewise([
                    b,
                    d, a
                ])
        ]), e.Piecewise([h,
            e.Piecewise(
                [x, e
                    .Piecewise(
                        [I, c,
                            a
                        ]
                    ),
                    a
                ]), e
                    .Piecewise([
                        b, e
                            .Piecewise(
                                [E, c,
                                    a
                                ]
                            ),
                        g
                    ])
        ]), e.Piecewise([h,
            e.Piecewise(
                [x, e
                    .Piecewise(
                        [I, u,
                            a
                        ]
                    ),
                    a
                ]), e
                    .Piecewise([
                        b, e
                            .Piecewise(
                                [E, u,
                                    a
                                ]
                            ),
                        d
                    ])
        ]), e.Piecewise([h,
            e.Piecewise(
                [P, y,
                    a]),
            e.Piecewise(
                [b, g,
                    a])
        ])]
    }
    var {
        abs: Au,
        min: Y0,
        max: X0
    } = Math;

    function Z0(e, t) {
        let {
            xmin: n,
            xmax: r,
            ymin: i,
            ymax: s,
            zmin: o,
            zmax: a
        } = t, u = [
            [n, i, a],
            [n, s, a],
            [r, s, a],
            [r, i, a],
            [n, i, o],
            [n, s, o],
            [r, s, o],
            [r, i, o]
        ], c = [
            [0, 1],
            [1, 2],
            [2, 3],
            [3, 0],
            [4, 5],
            [5, 6],
            [6, 7],
            [7, 4],
            [0, 4],
            [1, 5],
            [2, 6],
            [3, 7]
        ], l = [];
        for (let [v, O] of c) {
            let A = u[v],
                N = u[O],
                L = e(...A),
                z = e(...N),
                G = L / (L - z);
            0 <= G && G <= 1 && l
                .push(gs(A, N, G))
        }
        if (l.length < 3) return;
        let p = Y0(...l.map(v => v[
            0])),
            f = X0(...l.map(v => v[
                0])),
            m = Y0(...l.map(v => v[
                1])),
            g = X0(...l.map(v => v[
                1])),
            d = Y0(...l.map(v => v[
                2])),
            y = X0(...l.map(v => v[
                2])),
            h = e(n, i, o),
            b = (e(r, i, o) - h) / (
                r - n),
            x = (e(n, s, o) - h) / (
                s - i),
            P = (e(n, i, a) - h) / (
                a - o),
            M, I, E;
        return Au(P) >= Au(b) && Au(
            P) >= Au(x) ? (M = (
                v, O) => [v, O,
                    o - (h + b * (
                        v - n) +
                        x * (O - i)
                    ) / P
                ], I = new ee(p, f),
                E = new ee(m, g)) :
            Au(x) >= Au(P) && Au(
                x) >= Au(b) ? (M = (v,
                    O) => [v, i - (
                        h + b * (v -
                            n) + P *
                        (O - o)) /
                        x, O
                    ], I = new ee(p, f),
                    E = new ee(d, y)) :
                (M = (v, O) => [n - (h +
                    x * (v -
                        i) + P * (
                            O - o)
                ) / b, v, O
                ], I = new ee(m, g),
                    E = new ee(d, y)), {
            explicitPlane: M,
            u: I,
            v: E
        }
    }

    function gh(e, t) {
        let n = [],
            r = [],
            i = [],
            s = [],
            o = Z0(e, t);
        if (o) {
            let {
                explicitPlane: a,
                u,
                v: c
            } = o;
            n.push(...a(u.min, c
                .min), ...a(
                    u.max, c.min
                ), ...a(u
                    .min, c.max
                ), ...a(u
                    .max, c.max)
            );
            let l = new Qe(n[0], n[
                1], n[2]),
                p = new Qe(n[3], n[
                    4], n[5]),
                f = new Qe(n[6], n[
                    7], n[8]),
                m = new Qe()
                    .subVectors(f, l),
                g = new Qe()
                    .subVectors(l, p),
                d = m.cross(g)
                    .normalize();
            r.push(d.x, d.y, d.z, d
                .x, d.y, d.z, d
                .x, d.y, d.z, d
                .x, d.y, d.z), i
                    .push(0, 0, 0, 1, 1,
                        0, 1, 1), s
                            .push(0, 1, 2, 3, 2,
                                1)
        }
        return {
            positions: n,
            normals: r,
            faces: s,
            uvs: i,
            resolved: !0,
            extraAttrs: []
        }
    }
    var Fk = !1,
        Nu = 256,
        xh = D.List;

    function dr() {
        return {}
    }

    function Uc(e, t, n) {
        let r = 1 / 0;
        for (let s of t) {
            let o = e[s];
            Array.isArray(o) && o
                .length < r && (r =
                    o.length)
        }
        let i = 1;
        return n ===
            "solvedEquation" ? i =
        2 : n ===
        "baseComparator" && (i =
            4), i * r
    }

    function wa(e, t, n) {
        return Array.isArray(e) ? e[
            G0(t, n)] : e
    }

    function Vk(e, t) {
        var n = t.viewport.xmax - t
            .viewport.xmin,
            r = t.viewport.ymax - t
                .viewport.ymin;
        let i = as(n, r),
            s = as(30, 30),
            o = Math.round(2 - Math
                .log(i / s) / Math
                    .LN10);
        if (o <= 0) return Math
            .round(e) + "";
        {
            let a = Math.pow(10, o);
            return Math.round(e *
                a) / a + ""
        }
    }

    function Bk(e, t) {
        var n = t.viewport.xmax - t
            .viewport.xmin,
            r = t.viewport.ymax - t
                .viewport.ymin;
        let i = n * r,
            s = 30 * 30,
            o = Math.round(2 - Math
                .log(i / s) / Math
                    .LN10);
        if (o <= 0) return Math
            .round(e) + "";
        {
            let a = Math.pow(10, o);
            return Math.round(e *
                a) / a + ""
        }
    }

    function Gk(e, t) {
        return t.degreeMode ? Math
            .round(e / (Math.PI /
                180) * 10) / 10 +
            "\xB0" : Math.round(e *
                100) / 100 + ""
    }

    function _u(e, t, n) {
        let r = G0(t, n),
            i = e.userData
                .lineStyle,
            s = wa(e.metaData
                .computedLineWidth,
                t, n),
            o = wa(e.metaData
                .computedLineOpacity,
                t, n),
            a = wa(e.metaData
                .computedFillOpacity,
                t, n),
            u = e.metaData
                .colorLatexValue ? wa(e
                    .metaData
                    .colorLatexValue, t,
                    n) : e.userData
                .color,
            c = wa(e.metaData
                .computedResolution,
                t, n);
        return {
            listIndex: r,
            style: i,
            lineWidth: s,
            lineOpacity: o,
            fillOpacity: a,
            color: u,
            resolution: c
        }
    }
    D.Base.prototype._graph = kk;

    function kk(e, t, n, r, i, s) {
        var m, g, d;
        if (t instanceof D
            .SolvedEquation) {
            let y = this._graph(e, t
                ._expression, n,
                r, i, t
                    .branchMultiplier ===
                    2 ?
                "solvedEquation" :
                void 0),
                h = fA(this, t, n,
                    e);
            return h && (y || (
                y = []), Array
                    .prototype.push
                    .apply(y, h)), y
        }

        function o(y) {
            let h = y
                .editableLabelMode;
            return h === "TEXT" ||
                h === "MATH"
        }

        function a(y, h) {
            return "colorLatex" in
                y && Zk(y
                    .colorLatex) ? y
                .colorLatex : h
        }
        let u = t.getExpressionType(
            r.graphMode, t
            .valueType),
            c = YE(u, {
                points: this
                    .userData
                    .points,
                lines: this
                    .userData
                    .lines,
                fill: this
                    .userData
                    .fill
            }),
            l = {
                lineOpacity: "computedLineOpacity",
                lineWidth: "computedLineWidth",
                color: "colorLatexValue",
                fillOpacity: "fillOpacity",
                resolution: "resolution"
            },
            p = (y, h) => {
                let b = Uc(this
                    .metaData,
                    Object.keys(
                        y).map(
                            P => l[
                                P]),
                    s),
                    x = [];
                return xh.wrap(t)
                    .eachElement((P,
                        M) => {
                        if (M >=
                            b)
                            return;
                        let I =
                            this
                                .getGraphInfo(
                                    e,
                                    P
                                );
                        I.graphMode =
                            r
                                .graphMode;
                        let E =
                            _u(this,
                                M,
                                s
                            );
                        I.listIndex =
                            E
                                .listIndex,
                            I
                                .style =
                            E
                                .style,
                            "lineWidth" in
                            y &&
                            (I.lineWidth =
                                E
                                    .lineWidth
                            ),
                            "lineOpacity" in
                            y &&
                            (I.lineOpacity =
                                E
                                    .lineOpacity
                            ),
                            "fillOpacity" in
                            y &&
                            (I.fillOpacity =
                                E
                                    .fillOpacity
                            ),
                            "color" in
                            y &&
                            (I.color =
                                a(this
                                    .userData,
                                    E
                                        .color
                                )
                            ),
                            "resolution" in
                            y &&
                            (I.resolution =
                                E
                                    .resolution
                            ),
                            x
                                .push(
                                    ...
                                    h(P,
                                        I)
                                )
                    }), x
            },
            f = r.graphMode;
        switch (f) {
            case 4: {
                let {
                    points: b,
                    droppedIndices: x
                } = yd([t
                    .asValue()]),
                    P = this
                        .userData
                        .shouldGraph &&
                        c.points, M =
                        this.userData
                            .showLabel && !
                        P;
                return P ? [{
                    segments: [
                        b
                    ],
                    graphMode: f,
                    droppedIndices: x,
                    color: sa(
                        this
                            .userData,
                        this
                            .metaData
                    ),
                    style: this
                        .userData
                        .pointStyle,
                    showLabel:
                        !!
                        this
                            .userData
                            .showLabel,
                    labelSize: this
                        .metaData
                        .computedLabelSize,
                    labelAngle: this
                        .metaData
                        .computedLabelAngle,
                    labelOrientation: this
                        .userData
                        .labelOrientation,
                    pointOpacity: this
                        .metaData
                        .computedPointOpacity,
                    pointSize: this
                        .metaData
                        .computedMovablePointSize,
                    suppressTextOutline: this
                        .userData
                        .suppressTextOutline,
                    editableLabel: o(
                        this
                            .userData
                    ),
                    labels: this
                        .computedLabels ||
                        [],
                    poi: Us(
                        b),
                    movablePointInfo: []
                }] : M ? [{
                    segments: [
                        b
                    ],
                    graphMode: 3,
                    color: sa(
                        this
                            .userData,
                        this
                            .metaData
                    ),
                    style: this
                        .userData
                        .pointStyle,
                    showLabel:
                        !!
                        this
                            .userData
                            .showLabel,
                    nakedLabel:
                        !0,
                    labelSize: this
                        .metaData
                        .computedLabelSize,
                    labelAngle: this
                        .metaData
                        .computedLabelAngle,
                    labelOrientation: this
                        .userData
                        .labelOrientation,
                    pointOpacity: this
                        .metaData
                        .computedPointOpacity,
                    suppressTextOutline: this
                        .userData
                        .suppressTextOutline,
                    editableLabel: o(
                        this
                            .userData
                    ),
                    labels: this
                        .computedLabels ||
                        [],
                    poi: Us(
                        b),
                    showPoint:
                        !1
                }] : []
            }
            case 3: {
                let b = [],
                    x = this
                        .userData
                        .shouldGraph &&
                        c.points,
                    P = this
                        .userData
                        .shouldGraph &&
                        c.lines,
                    M = [
                        "colorLatexValue"
                    ];
                x && M.push(
                    "computedPointOpacity",
                    "computedPointSize"
                ), (this
                    .userData
                    .showLabel ||
                    x) && M
                        .push(
                            "computedLabelSize",
                            "computedLabelAngle"
                        );
                let I = Uc(this
                    .metaData,
                    M, s),
                    E = xh.wrap(t)
                        .asValue();
                Xr(E), E.length >
                    I && (E.length =
                        I);
                let v = this
                    .userData
                    .showLabel && !
                    x && !P,
                    O = yd(E);
                if (this.userData
                    .showLabel || x
                ) {
                    let A = {
                        segments: [
                            O
                                .points
                        ],
                        graphMode: f,
                        droppedIndices: O
                            .droppedIndices,
                        color: this
                            .metaData
                            .colorLatexValue ||
                            this
                                .userData
                                .color,
                        style: this
                            .userData
                            .pointStyle,
                        showLabel:
                            !!
                            this
                                .userData
                                .showLabel,
                        showPoint: x,
                        labelSize: this
                            .metaData
                            .computedLabelSize,
                        labelAngle: this
                            .metaData
                            .computedLabelAngle,
                        labelOrientation: this
                            .userData
                            .labelOrientation,
                        pointSize: this
                            .metaData
                            .computedPointSize,
                        pointOpacity: this
                            .metaData
                            .computedPointOpacity,
                        suppressTextOutline: this
                            .userData
                            .suppressTextOutline,
                        interactiveLabel:
                            !!
                            this
                                .userData
                                .interactiveLabel,
                        editableLabel: o(
                            this
                                .userData
                        ),
                        nakedLabel: v,
                        labels: this
                            .computedLabels ||
                            [],
                        poi: Us(
                            E)
                    };
                    e.is3dPolicy() ?
                        b.push(...
                            $k(A)) :
                        b.push(A)
                }
                if (P) {
                    let A = this
                        .metaData
                        .computedLineWidth,
                        N = {
                            segments: aA(
                                E
                            ),
                            graphMode: 5,
                            color: sa(
                                this
                                    .userData,
                                this
                                    .metaData
                            ),
                            style: this
                                .userData
                                .lineStyle,
                            lineWidth: A,
                            lineOpacity: this
                                .metaData
                                .computedLineOpacity,
                            poi: dr()
                        };
                    b.push(rA(e, N,
                        n, A
                    ))
                }
                return b
            }
            case 114:
            case 115:
            case 116: {
                let b = [],
                    x = this
                        .userData
                        .shouldGraph &&
                        c.points,
                    P = this
                        .userData
                        .shouldGraph &&
                        c.lines,
                    M = [
                        "colorLatexValue"
                    ];
                x && M.push(
                    "computedPointOpacity",
                    "computedPointSize"
                );
                let I = xh.wrap(t)
                    .asValue();
                Xr(I);
                let {
                    degreeMode: E
                } = n, v = I.map(
                    N => SN(f,
                        N, E)),
                    O = Uc(this
                        .metaData,
                        M, s), A =
                        Math.min(v
                            .length, O);
                if (x)
                    for (let N =
                        0; N <
                        A; N++) {
                        let {
                            color: L,
                            fillOpacity: z
                        } = _u(this,
                            N, s
                        ),
                            G = wa(
                                this
                                    .metaData
                                    .computedPointSize,
                                N, s
                            );
                        b.push({
                            graphMode: 114,
                            position: v[
                                N
                            ],
                            radius: .02 *
                                G,
                            guid: fi(),
                            color: L,
                            fillOpacity: z
                        })
                    }
                if (P) {
                    let N = wa(this
                        .metaData
                        .computedLineWidth,
                        0, s),
                        {
                            color: L
                        } = _u(this,
                            0, s);
                    b.push({
                        graphMode: 100,
                        points: uh(
                            v,
                            n
                                .viewport,
                            N
                        ),
                        thickness: N,
                        guid: fi(),
                        color: L
                    })
                }
                return b
            }
            case 117: {
                let b = this
                    .metaData
                    .colorLatexValue ?
                    !Array.isArray(
                        this
                            .metaData
                            .colorLatexValue
                    ) : !0,
                    x = this
                        .metaData
                        .computedFillOpacity,
                    P = [],
                    M = [],
                    I = [],
                    E = [],
                    v = [],
                    [O, A, N] = [
                        new Qe,
                        new Qe,
                        new Qe
                    ],
                    [L, z, G] = [
                        new Qe,
                        new Qe,
                        new Qe
                    ],
                    $ = (Y, de, re,
                        ie, Z, Re,
                        Ne, Te, Me
                    ) => {
                        if (L.set(Y,
                            de,
                            re),
                            z.set(
                                ie,
                                Z,
                                Re),
                            G.set(
                                Ne,
                                Te,
                                Me),
                            !L
                                .isFinite() ||
                            !z
                                .isFinite() ||
                            !G
                                .isFinite()
                        )
                            return;
                        let ve = P
                            .length /
                            3;
                        P.push(L.x,
                            L.y,
                            L.z,
                            z.x,
                            z.y,
                            z.z,
                            G.x,
                            G.y,
                            G.z
                        ), O
                            .subVectors(
                                L, G
                            ), A
                                .subVectors(
                                    z, L
                                ), N
                                    .crossVectors(
                                        O, A
                                    ), M
                                        .push(N
                                            .x,
                                            N.y,
                                            N.z,
                                            N.x,
                                            N.y,
                                            N.z,
                                            N.x,
                                            N.y,
                                            N.z
                                        ), I
                                            .push(
                                                ve,
                                                ve +
                                                1,
                                                ve +
                                                2),
                            E.push(
                                0,
                                0,
                                0,
                                1,
                                1, 0
                            )
                    },
                    w = () => {
                        let Y = {
                            guid: fi(),
                            resolved:
                                !
                                0,
                            positions: new Float32Array(
                                P
                            ),
                            normals: new Float32Array(
                                M
                            ),
                            faces: new Uint32Array(
                                I
                            ),
                            uvs: new Float32Array(
                                E
                            ),
                            extraAttrs: new Float32Array(
                                []
                            )
                        };
                        return v
                            .length &&
                            (Y.colors =
                                new Float32Array(
                                    v
                                )
                            ), Y
                    };
                if (t.valueType ===
                    tr && !Array
                        .isArray(x)) {
                    let Y = this
                        .metaData
                        .computedFillOpacity,
                        de = "";
                    if (b) {
                        let re = (
                            m =
                            this
                                .metaData
                                .colorLatexValue
                        ) !=
                            null ?
                            m : this
                                .userData
                                .color;
                        de = a(this
                            .userData,
                            re)
                    }
                    return p({
                        color:
                            !
                            0
                    }, (re,
                        ie
                    ) => {
                        if (re
                            .valueType ===
                            In
                        ) {
                            let [
                                [Z, Re,
                                    Ne
                                ],
                                [Te, Me,
                                    ve
                                ],
                                [Q, U,
                                    xe
                                ]
                            ] =
                                re
                                    .asValue();
                            if ($(Z, Re,
                                Ne,
                                Te,
                                Me,
                                ve,
                                Q,
                                U,
                                xe
                            ),
                                !
                                b
                            ) {
                                let [
                                    le,
                                    K,
                                    _e
                                ] =
                                    B0(ie
                                        .color);
                                v.push(le,
                                    K,
                                    _e,
                                    le,
                                    K,
                                    _e,
                                    le,
                                    K,
                                    _e
                                )
                            }
                        }
                        return []
                    }), [{
                        meshData: w(),
                        color: de,
                        fillOpacity: Y !=
                            null ?
                            Y :
                            1,
                        graphMode: 117
                    }]
                }
                return p({
                    color: !
                        0,
                    fillOpacity:
                        !0
                }, (Y,
                    de) => {
                    var U;
                    let [
                        [re, ie,
                            Z
                        ],
                        [Re, Ne,
                            Te
                        ],
                        [Me, ve,
                            Q
                        ]
                    ] = Y
                        .asValue();
                    return P = [],
                        M = [],
                        I = [],
                        E = [],
                        $(re,
                            ie,
                            Z,
                            Re,
                            Ne,
                            Te,
                            Me,
                            ve,
                            Q
                        ),
                        [{
                            meshData: w(),
                            color: a(
                                this
                                    .userData,
                                de
                                    .color
                            ),
                            fillOpacity: (
                                U =
                                de
                                    .fillOpacity
                            ) !=
                                null ?
                                U :
                                1,
                            graphMode: 117
                        }]
                })
            }
            case 119: {
                let b = this
                    .metaData
                    .colorLatexValue ?
                    !Array.isArray(
                        this
                            .metaData
                            .colorLatexValue
                    ) : !0;
                if (t.valueType ===
                    er && b && !
                    Array.isArray(
                        this
                            .metaData
                            .computedLineWidth
                    )) {
                    let x = (g =
                        this
                            .metaData
                            .colorLatexValue
                    ) !=
                        null ? g :
                        this
                            .userData
                            .color,
                        P = this
                            .metaData
                            .computedLineWidth,
                        M = [];
                    return p({
                        color:
                            !
                            0
                    },
                        I => {
                            if (I
                                .valueType ===
                                Nt
                            ) {
                                let [
                                    [E, v,
                                        O
                                    ],
                                    [A, N,
                                        L
                                    ]
                                ] =
                                    I
                                        .asValue();
                                M.push(E,
                                    v,
                                    O,
                                    A,
                                    N,
                                    L,
                                    NaN,
                                    NaN,
                                    NaN
                                )
                            }
                            return []
                        }), [{
                            graphMode: 119,
                            guid: fi(),
                            points: M,
                            color: x,
                            thickness: P !=
                                null ?
                                P :
                                1
                        }]
                }
                return p({
                    color: !
                        0,
                    lineWidth:
                        !0
                }, (x,
                    P) => {
                    let {
                        lineWidth: M,
                        color: I
                    } = P, E
                            = x
                                .asValue(),
                        [
                            [v, O,
                                A
                            ],
                            [N, L,
                                z
                            ]
                        ] =
                            E;
                    return uA(
                        v,
                        O,
                        A,
                        N,
                        L,
                        z
                    ) ?
                        [] :
                        [{
                            graphMode: 119,
                            guid: fi(),
                            points: [
                                v,
                                O,
                                A,
                                N,
                                L,
                                z
                            ],
                            color: I,
                            thickness: M
                        }]
                })
            }
            case 129:
                let y = this
                    .metaData
                    .colorLatexValue ?
                    !Array.isArray(
                        this
                            .metaData
                            .colorLatexValue
                    ) : !0;
                if (t.valueType ===
                    nr && y && !
                    Array.isArray(
                        this
                            .metaData
                            .computedLineWidth
                    )) {
                    let b = (d =
                        this
                            .metaData
                            .colorLatexValue
                    ) !=
                        null ? d :
                        this
                            .userData
                            .color,
                        x = this
                            .metaData
                            .computedLineWidth,
                        P = [];
                    return p({
                        color:
                            !
                            0
                    },
                        M => {
                            if (M
                                .valueType ===
                                Se
                            ) {
                                let [
                                    [I, E,
                                        v
                                    ],
                                    [O, A,
                                        N
                                    ]
                                ] =
                                    M
                                        .asValue();
                                P.push(O,
                                    A,
                                    N,
                                    I +
                                    O,
                                    E +
                                    A,
                                    v +
                                    N
                                )
                            }
                            return []
                        }), [{
                            graphMode: 129,
                            guid: fi(),
                            points: P,
                            color: b,
                            thickness: x !=
                                null ?
                                x :
                                1
                        }]
                }
                return p({
                    color: !
                        0,
                    lineWidth:
                        !0
                }, (b,
                    x) => {
                    let {
                        lineWidth: P,
                        color: M
                    } = x, I
                            = b
                                .asValue(),
                        [
                            [E, v,
                                O
                            ],
                            [A, N,
                                L
                            ]
                        ] =
                            I;
                    return uA(
                        E,
                        v,
                        O,
                        A,
                        N,
                        L
                    ) ?
                        [] :
                        [{
                            graphMode: 129,
                            guid: fi(),
                            points: [
                                A,
                                N,
                                L,
                                E +
                                A,
                                v +
                                N,
                                O +
                                L
                            ],
                            color: M,
                            thickness: P
                        }]
                });
            case 118:
                return p({
                    color: !
                        0,
                    resolution:
                        !0,
                    fillOpacity:
                        !0
                }, (b,
                    x) => {
                    let {
                        color: P,
                        fillOpacity: M
                    } = x, I
                            = b
                                .asValue(),
                        [
                            [E, v,
                                O
                            ],
                            A
                        ] =
                            I,
                        N =
                            Math
                                .abs(
                                    A
                                );
                    return isNaN(
                        E
                    ) ||
                        isNaN(
                            v
                        ) ||
                        isNaN(
                            O
                        ) ||
                        isNaN(
                            A
                        ) ?
                        [] :
                        [{
                            graphMode: 118,
                            position: [
                                E,
                                v,
                                O
                            ],
                            radius: [
                                N,
                                N,
                                N
                            ],
                            guid: fi(),
                            color: P,
                            fillOpacity: M !=
                                null ?
                                M :
                                1
                        }]
                });
            case 5:
            case 100:
            case 101:
            case 102: {
                let b = this
                    .userData,
                    x = this
                        .metaData,
                    P = [],
                    M = p({
                        color: !
                            0,
                        lineOpacity:
                            !0,
                        lineWidth:
                            !0,
                        resolution:
                            !0
                    }, (E,
                        v) => {
                        var A;
                        let O =
                            E
                                .getDependencies();
                        if (O
                            .length ===
                            0 &&
                            !ca(E
                                .valueType
                            )
                        ) {
                            let {
                                points: N,
                                droppedIndices: L
                            } =
                                yd([E
                                    .asValue()]);
                            return [{
                                segments: [
                                    N
                                ],
                                graphMode: 3,
                                droppedIndices: L,
                                color: sa(
                                    b,
                                    x
                                ),
                                style: b
                                    .lineStyle,
                                showPoint:
                                    !
                                    1,
                                poi: Us(
                                    N)
                            }]
                        } else {
                            let N =
                                E
                                    .getCompiledFunction(
                                        O
                                    );
                            v.domain =
                                (A = N
                                    .domain
                                ) !=
                                    null ?
                                    A :
                                    {
                                        type: "1d",
                                        min: this
                                            .metaData
                                            .evaluatedDomainMin,
                                        max: this
                                            .metaData
                                            .evaluatedDomainMax
                                    };
                            let L =
                                _a({
                                    viewState: n,
                                    graphInfo: v,
                                    compiled: N
                                });
                            return [rA(e,
                                L,
                                n,
                                v
                                    .lineWidth
                            )]
                        }
                    }),
                    I = [];
                for (let E of M)
                    E && I.push(E);
                if (c.fill)
                    if (I.forEach((
                        E, v
                    ) => {
                        let {
                            color: O,
                            fillOpacity: A,
                            listIndex: N
                        } =
                            _u(this, v,
                                s
                            );
                        P.push({
                            segments: E
                                .segments,
                            color: O,
                            fillOpacity: A,
                            listIndex: N,
                            graphMode: 7,
                            poi: dr()
                        })
                    }), c.lines)
                        I = I
                            .concat(P);
                    else return P;
                return I
            }
            case 20:
                return p({
                    lineOpacity:
                        !0,
                    lineWidth:
                        !0,
                    color: !
                        0
                }, (b,
                    x) => {
                    let [
                        [P,
                            M],
                        I
                    ] = b
                        .asValue();
                    return isNaN(
                        P
                    ) ||
                        isNaN(
                            M
                        ) ||
                        isNaN(
                            I
                        ) ?
                        [] :
                        [{
                            segments: [
                                [P, M,
                                    I
                                ]
                            ],
                            resolved:
                                !
                                0,
                            graphMode: x
                                .graphMode,
                            color: x
                                .color,
                            style: x
                                .lineStyle,
                            lineWidth: x
                                .lineWidth,
                            lineOpacity: x
                                .lineOpacity,
                            listIndex: x
                                .listIndex,
                            operator: x
                                .operator,
                            poi: dr()
                        }]
                });
            case 21:
                return p({
                    color: !
                        0,
                    lineWidth:
                        !0,
                    lineOpacity:
                        !0
                }, (b,
                    x) => {
                    let P =
                        Gy(b
                            .asValue());
                    if (!P)
                        return [];
                    let
                        M = [];
                    return P
                        .type ===
                        "arc" ?
                        M
                            .push({
                                graphMode: f,
                                segments: [
                                    [P.center[
                                        0
                                    ],
                                    P
                                        .center[
                                    1
                                    ],
                                    P
                                        .radius,
                                    P
                                        .startAngle,
                                    P
                                        .endAngle
                                    ]
                                ],
                                color: x
                                    .color,
                                style: x
                                    .lineStyle,
                                lineWidth: x
                                    .lineWidth,
                                lineOpacity: x
                                    .lineOpacity,
                                listIndex: x
                                    .listIndex,
                                operator: r
                                    .operator,
                                poi: dr()
                            }) :
                        P
                            .type ===
                            "rays" ?
                            M
                                .push({
                                    graphMode: 19,
                                    segments: [
                                        [P.start1[
                                            0
                                        ],
                                        P
                                            .start1[
                                        1
                                        ],
                                        P
                                            .end1[
                                        0
                                        ],
                                        P
                                            .end1[
                                        1
                                        ]
                                        ]
                                    ],
                                    color: x
                                        .color,
                                    style: x
                                        .lineStyle,
                                    lineWidth: x
                                        .lineWidth,
                                    lineOpacity: x
                                        .lineOpacity,
                                    listIndex: x
                                        .listIndex,
                                    operator: r
                                        .operator,
                                    poi: dr()
                                }, {
                                    graphMode: 19,
                                    segments: [
                                        [P.start2[
                                            0
                                        ],
                                        P
                                            .start2[
                                        1
                                        ],
                                        P
                                            .end2[
                                        0
                                        ],
                                        P
                                            .end2[
                                        1
                                        ]
                                        ]
                                    ],
                                    color: x
                                        .color,
                                    style: x
                                        .lineStyle,
                                    lineWidth: x
                                        .lineWidth,
                                    lineOpacity: x
                                        .lineOpacity,
                                    listIndex: x
                                        .listIndex,
                                    operator: r
                                        .operator,
                                    poi: dr()
                                }) :
                            M
                                .push({
                                    graphMode: 17,
                                    segments: [
                                        [P.start[
                                            0
                                        ],
                                        P
                                            .start[
                                        1
                                        ],
                                        P
                                            .end[
                                        0
                                        ],
                                        P
                                            .end[
                                        1
                                        ]
                                        ]
                                    ],
                                    color: x
                                        .color,
                                    style: x
                                        .lineStyle,
                                    lineWidth: x
                                        .lineWidth,
                                    lineOpacity: x
                                        .lineOpacity,
                                    listIndex: x
                                        .listIndex,
                                    operator: r
                                        .operator,
                                    poi: dr()
                                }),
                        [...M,
                        ...
                        sA(M,
                            i
                        )
                        ]
                });
            case 17:
            case 18:
            case 19:
                return p({
                    color: !
                        0,
                    lineWidth:
                        !0,
                    lineOpacity:
                        !0
                }, (b,
                    x) => {
                    let [
                        [P,
                            M],
                        [I,
                            E]
                    ] = b
                        .asValue();
                    if (isNaN(
                        P
                    ) ||
                        isNaN(
                            M
                        ) ||
                        isNaN(
                            I
                        ) ||
                        isNaN(
                            E
                        )
                    )
                        return [];
                    let v = [],
                        O = {
                            segments: [
                                [P, M,
                                    I,
                                    E
                                ]
                            ],
                            resolved:
                                !
                                0,
                            graphMode: x
                                .graphMode,
                            color: x
                                .color,
                            style: x
                                .lineStyle,
                            arrowMode: x
                                .arrowMode,
                            lineWidth: x
                                .lineWidth,
                            lineOpacity: x
                                .lineOpacity,
                            listIndex: x
                                .listIndex,
                            operator: r
                                .operator,
                            poi: dr()
                        };
                    if (v
                        .push(
                            iA(e,
                                O,
                                n
                            )
                        ),
                        v
                            .push(
                                ...
                                sA([O],
                                    i
                                )
                            ),
                        this
                            .userData
                            .showLabel &&
                        r
                            .graphMode ===
                        17
                    ) {
                        let A =
                            x
                                .listIndex,
                            N =
                                this
                                    .computedLabels &&
                                this
                                    .computedLabels[
                                A ||
                                0
                                ];
                        v.push({
                            graphMode: 22,
                            objectType: 17,
                            segments: [
                                [P, M,
                                    I,
                                    E
                                ]
                            ],
                            color: x
                                .color,
                            listIndex: A,
                            showLabel:
                                !
                                0,
                            labelSize: this
                                .metaData
                                .computedLabelSize,
                            labelAngle: this
                                .metaData
                                .computedLabelAngle,
                            labelOrientation: this
                                .userData
                                .labelOrientation,
                            labels: N ?
                                [
                                    N] :
                                [Vk(as(I - P,
                                    E -
                                    M
                                ),
                                    n
                                )]
                        })
                    }
                    return v
                });
            case 24:
                return p({
                    lineOpacity:
                        !0,
                    lineWidth:
                        !0,
                    color: !
                        0
                }, (b,
                    x) => {
                    let [P,
                        M
                    ] = b
                        .asValue(),
                        [
                            [I,
                                E],
                            [v,
                                O]
                        ] = [
                                M,
                                [M[0] +
                                    P[
                                    0],
                                M[
                                1] +
                                P[
                                1]
                                ]
                            ];
                    if (isNaN(
                        v
                    ) ||
                        isNaN(
                            O
                        ) ||
                        isNaN(
                            I
                        ) ||
                        isNaN(
                            E
                        )
                    )
                        return [];
                    let A = {
                        segments: [
                            [I, E,
                                v,
                                O
                            ]
                        ],
                        resolved:
                            !
                            0,
                        graphMode: x
                            .graphMode,
                        color: x
                            .color,
                        style: x
                            .lineStyle,
                        arrowMode: x
                            .arrowMode,
                        lineWidth: x
                            .lineWidth,
                        lineOpacity: x
                            .lineOpacity,
                        listIndex: x
                            .listIndex,
                        operator: r
                            .operator,
                        poi: dr()
                    };
                    return [iA(e,
                        A,
                        n
                    )]
                });
            case 23:
                return p({
                    lineOpacity:
                        !0,
                    lineWidth:
                        !0,
                    color: !
                        0
                }, (b,
                    x) => {
                    let {
                        value: P,
                        valueType: M
                    } = b
                        .asTypedValue(),
                        [
                            [I,
                                E],
                            v,
                            O
                        ] =
                            P;
                    if (isNaN(
                        I
                    ) ||
                        isNaN(
                            E
                        ) ||
                        isNaN(
                            v
                        ) ||
                        isNaN(
                            O
                        )
                    )
                        return [];
                    let A =
                        x
                            .listIndex,
                        N =
                            M ===
                            Ae,
                        L =
                            N ?
                                O :
                                Math
                                    .abs(
                                        O
                                    ),
                        z = [];
                    if (z
                        .push({
                            graphMode: 23,
                            segments: [
                                [I, E,
                                    v,
                                    O,
                                    N ?
                                        1 :
                                        0
                                ]
                            ],
                            color: x
                                .color,
                            style: x
                                .lineStyle,
                            lineWidth: x
                                .lineWidth,
                            lineOpacity: x
                                .lineOpacity,
                            listIndex: A,
                            operator: r
                                .operator,
                            poi: dr()
                        }),
                        this
                            .userData
                            .showAngleLabel
                    ) {
                        let G =
                            this
                                .computedLabels &&
                            this
                                .computedLabels[
                            A ||
                            0
                            ];
                        z.push({
                            graphMode: 22,
                            objectType: 23,
                            segments: [
                                [I, E,
                                    v,
                                    O
                                ]
                            ],
                            color: x
                                .color,
                            listIndex: A,
                            showLabel:
                                !
                                0,
                            labelSize: this
                                .metaData
                                .computedLabelSize,
                            labelAngle: this
                                .metaData
                                .computedLabelAngle,
                            labelOrientation: this
                                .userData
                                .labelOrientation,
                            labels: G ?
                                [
                                    G] :
                                [Gk(L,
                                    n)]
                        })
                    }
                    return z
                });
            case 1:
            case 2:
            case 8:
            case 112:
            case 126:
            case 113:
            case 127:
            case 6:
            case 130:
            case 103:
            case 104:
            case 105:
            case 106:
            case 107:
            case 108:
            case 109:
            case 110:
            case 111:
            case 120:
            case 121:
            case 122:
            case 123:
            case 124: {
                let b = t
                    .valueType ===
                    T;
                return p({
                    lineOpacity:
                        !0,
                    lineWidth:
                        !0,
                    resolution:
                        !0,
                    fillOpacity:
                        !0,
                    color: !
                        0
                }, (x,
                    P) => {
                    var w,
                        Y,
                        de,
                        re,
                        ie,
                        Z,
                        Re,
                        Ne,
                        Te,
                        Me,
                        ve;
                    (r.graphMode ===
                        6 ||
                        r
                            .graphMode ===
                        110 ||
                        r
                            .graphMode ===
                        124
                    ) &&
                        (P.domain = {
                            type: "1d",
                            min: this
                                .metaData
                                .evaluatedDomainMin,
                            max: this
                                .metaData
                                .evaluatedDomainMax,
                            isExplicit: this
                                .metaData
                                .isExplicitDomain
                        });
                    let M =
                        (w = ss[r
                            .graphMode
                        ]) !=
                            null ?
                            w :
                            [],
                        I =
                            x
                                .getCompiledFunction(
                                    M
                                );
                    (r.graphMode ==
                        130 ||
                        r
                            .graphMode ==
                        103 ||
                        r
                            .graphMode ==
                        104 ||
                        r
                            .graphMode ==
                        105 ||
                        r
                            .graphMode ==
                        111 ||
                        r
                            .graphMode ==
                        109
                    ) &&
                        (P.domain =
                            (Y = I
                                .domain
                            ) !=
                                null ?
                                Y :
                                {
                                    type: "2d",
                                    uMin: this
                                        .metaData
                                        .evaluatedDomain3DMin1,
                                    uMax: this
                                        .metaData
                                        .evaluatedDomain3DMax1,
                                    vMin: this
                                        .metaData
                                        .evaluatedDomain3DMin2,
                                    vMax: this
                                        .metaData
                                        .evaluatedDomain3DMax2
                                });
                    let E = [],
                        v;
                    try {
                        v = x
                            .getCompiledDerivative()
                    } catch (
                    Q
                    ) { }
                    let O =
                        Uk(this,
                            x,
                            I,
                            n,
                            P,
                            v,
                            b
                        );
                    if (O)
                        return O;
                    let A =
                        $E(P
                            .graphMode),
                        N =
                            (de =
                                this
                                    .userData
                                    .extendTo3D
                            ) !=
                                null ?
                                de :
                                !1,
                        L =
                            A &&
                            !N,
                        z = !
                            e
                                .is3dPolicy() ||
                            L,
                        G =
                            (re =
                                this
                                    .userData
                                    .lines
                            ) !=
                                null ?
                                re :
                                z,
                        $ =
                            (ie =
                                this
                                    .userData
                                    .lines
                            ) !=
                                null ?
                                ie :
                                !L;
                    if (P
                        .graphMode ===
                        127 &&
                        !
                        N &&
                        ((Z = this
                            .userData
                            .lines
                        ) ==
                            null ||
                            Z
                        )
                    ) {
                        let Q =
                            (Re =
                                ss[P
                                    .graphMode]
                            ) !=
                                null ?
                                Re :
                                [],
                            U =
                                x
                                    ._chunk
                                    .copy();
                        U.GreaterEqual(
                            [U.getReturnIndex(),
                            U
                                .Constant(
                                    0
                                )
                            ]
                        );
                        let xe =
                            x
                                .getCompiledFunction(
                                    Q
                                ),
                            le =
                                0,
                            K =
                                n
                                    .viewport,
                            {
                                xmin: _e,
                                xmax: Ze,
                                ymin: me,
                                ymax: te
                            } =
                                K,
                            pt =
                                new ee(
                                    _e,
                                    Ze
                                ),
                            Ro =
                                new ee(
                                    me,
                                    te
                                ),
                            ku =
                                gh((Cd, _h,
                                    Lh
                                ) =>
                                    Lh -
                                    le,
                                    K
                                );
                        return [{
                            meshData: qi(
                                ku
                            ),
                            color: P
                                .color,
                            fillOpacity: (
                                Ne =
                                P
                                    .fillOpacity
                            ) !=
                                null ?
                                Ne :
                                1,
                            uvRange: [
                                pt,
                                Ro
                            ],
                            uvArgs: (
                                Te =
                                ss[P
                                    .graphMode]
                            ) !=
                                null ?
                                Te :
                                [],
                            extraMeshArgs: (
                                Me =
                                Vc[P
                                    .graphMode]
                            ) !=
                                null ?
                                Me :
                                [],
                            graphMode: 106,
                            compiled: xe,
                            restrictionShader: Wo(
                                U,
                                Nu
                            )
                        }]
                    }
                    if (A &&
                        (this
                            .userData
                            .lines ===
                            !
                            0 ?
                            (G = L,
                                $ = !
                                L
                            ) :
                            this
                                .userData
                                .lines ===
                            !
                            1 &&
                            (G = !
                                1,
                                $ = !
                                1
                            )
                        ),
                        $ &&
                        ea(P
                            .graphMode)
                    ) {
                        let Q =
                            yh(P
                                .graphMode);
                        if (P
                            .graphMode ===
                            113 ||
                            P
                                .graphMode ===
                            127
                        ) {
                            let {
                                positions: U,
                                normals: xe,
                                faces: le,
                                uvs: K
                            } =
                                QN(),
                                _e = {
                                    guid: fi(),
                                    isDomainCube:
                                        !
                                        0,
                                    resolved:
                                        !
                                        0,
                                    positions: U,
                                    normals: xe,
                                    faces: le,
                                    uvs: K,
                                    extraAttrs: new Float32Array(
                                        []
                                    )
                                },
                                Ze =
                                    x
                                        .toImplicitBool();
                            E.push({
                                meshData: _e,
                                graphMode: 113,
                                color: P
                                    .color,
                                fillOpacity: 1,
                                uvRange: [
                                    new ee(
                                        0,
                                        1
                                    ),
                                    new ee(
                                        0,
                                        1
                                    )
                                ],
                                uvArgs: [],
                                extraMeshArgs: [],
                                compiled: I,
                                restrictionShader: Wo(
                                    Ze
                                        ._chunk,
                                    Nu
                                )
                            });
                            let me =
                                cR(Ze
                                    ._chunk,
                                    x
                                        ._chunk,
                                    Q
                                );
                            for (
                                let te of
                                me
                            ) {
                                let pt =
                                    nA(P, {
                                        concrete: new pn(
                                            te
                                                .value
                                        ),
                                        restriction: te
                                            .restriction &&
                                            Wo(te
                                                .restriction,
                                                Nu
                                            )
                                    },
                                        n
                                    );
                                E.push(
                                    pt)
                            }
                        } else {
                            let U =
                                x
                                    .getRestrictedFunctionForGLSL(
                                        Q,
                                        Nu
                                    ),
                                xe =
                                    nA(P,
                                        U,
                                        n
                                    );
                            E.push(
                                xe)
                        }
                    }
                    if (G &&
                        zk(this,
                            P
                        ),
                        !ea(P
                            .graphMode
                        )
                    ) {
                        let Q =
                            _a({
                                viewState: n,
                                graphInfo: P,
                                compiled: I,
                                derivative: v
                            }),
                            U =
                                dA(Aa(
                                    this),
                                    x
                                );
                        if (U &&
                            (Q.boundingBox =
                                U
                            ),
                            e
                                .is3dPolicy() &&
                            G &&
                            J0(Q
                                .graphMode)
                        ) {
                            let xe =
                                (ve =
                                    P
                                        .lineWidth
                                ) !=
                                    null ?
                                    ve :
                                    1;
                            E.push(ah(Q, n,
                                xe
                            ))
                        } else if (
                            Q
                                .fillSegments
                        ) {
                            let {
                                fillSegments: xe,
                                ...
                                le
                            } =
                                Q
                                ;
                            G || (le.lineWidth =
                                0
                            ),
                                E
                                    .push(
                                        le
                                    )
                        } else
                            G ||
                                (Q.lineWidth =
                                    0
                                ),
                                (G ||
                                    !
                                    ea(r
                                        .graphMode)
                                ) &&
                                E
                                    .push(
                                        Q
                                    );
                        P.graphMode ===
                            8 &&
                            P
                                .operator !==
                            "=" &&
                            E
                                .push({
                                    graphMode: 7,
                                    segments: Q
                                        .fillSegments,
                                    poi: dr(),
                                    listIndex: P
                                        .listIndex,
                                    color: P
                                        .color,
                                    fillOpacity: P
                                        .fillOpacity
                                })
                    }
                    return E
                })
            }
            case 200:
            case 201:
            case 202:
            case 206:
            case 205:
            case 211:
            case 203:
            case 204:
            case 213:
            case 207:
            case 208:
            case 212:
            case 214:
            case 215:
            case 209:
                return p({
                    color: !
                        0,
                    lineWidth:
                        !0,
                    lineOpacity:
                        !0,
                    resolution:
                        !0
                }, (b,
                    x) => {
                    var w;
                    switch (
                    f) {
                        case 206:
                        case 211:
                            x.domain = {
                                type: "1d",
                                min: this
                                    .metaData
                                    .evaluatedDomainMin,
                                max: this
                                    .metaData
                                    .evaluatedDomainMax,
                                isExplicit: this
                                    .metaData
                                    .isExplicitDomain
                            };
                            break;
                        case 203:
                        case 204:
                        case 213:
                        case 207:
                        case 208:
                        case 212:
                        case 214:
                        case 215:
                            x.domain = {
                                type: "2d",
                                uMin: this
                                    .metaData
                                    .evaluatedDomain3DMin1,
                                uMax: this
                                    .metaData
                                    .evaluatedDomain3DMax1,
                                vMin: this
                                    .metaData
                                    .evaluatedDomain3DMin2,
                                vMax: this
                                    .metaData
                                    .evaluatedDomain3DMax2
                            };
                            break
                    }
                    let P =
                        (w = ss[
                            f]) !=
                            null ?
                            w :
                            [],
                        M = {
                            allowSlices:
                                !
                                0
                        },
                        I =
                            Ra(b._chunk,
                                P,
                                M
                            ),
                        {
                            valueChunk: E,
                            slices: v
                        } =
                            I
                                .getValueAndRestrictionChunk(),
                        O =
                            E
                                .getCompiledFunction(
                                    P
                                ),
                        A =
                            v[
                            0],
                        N =
                            A
                                .type ===
                            "implicit",
                        L =
                            N ?
                                NaN :
                                A
                                    .value,
                        z =
                            N ?
                                "_implicit" :
                                A
                                    .variable,
                        G,
                        $ =
                            Y =>
                                _a({
                                    viewState: n,
                                    graphInfo: {
                                        ...
                                        x,
                                        slice_coordinate: z,
                                        slice_value: L,
                                        slice_function: Y
                                    },
                                    compiled: O
                                });
                    if (N) {
                        let Y = [
                            "x",
                            "y",
                            "z"
                        ],
                            de = [
                                "x",
                                "y",
                                "z",
                                "r",
                                "theta"
                            ],
                            re = [
                                "x",
                                "y",
                                "z",
                                "rho",
                                "theta",
                                "phi"
                            ],
                            ie = [
                                "x",
                                "y",
                                "z",
                                "u",
                                "v"
                            ],
                            Z =
                                A
                                    .sliceChunk;
                        switch (
                        f
                        ) {
                            case 200:
                            case 201:
                            case 202:
                                G = Z
                                    .getCompiledFunction(
                                        Y
                                    );
                                break;
                            case 211:
                            case 213:
                                G = Z
                                    .getCompiledFunction(
                                        de
                                    );
                                break;
                            case 212:
                                G = Z
                                    .getCompiledFunction(
                                        re
                                    );
                                break;
                            case 215:
                            case 214:
                                G = Z
                                    .getCompiledFunction(
                                        ie
                                    );
                                break;
                            case 209: {
                                let Re =
                                    (Me,
                                        ve) => {
                                        let Q =
                                            ve
                                                .getCompiledFunction(
                                                    Y
                                                ),
                                            U =
                                                Me
                                                    ._symbol,
                                            xe =
                                                Me
                                                    ._expression
                                                    .args,
                                            le = [];
                                        for (
                                            let K of
                                            xe
                                        ) {
                                            if (!
                                                (
                                                    K instanceof pn)
                                            )
                                                throw J(
                                                    "Programming Error: bad type");
                                            if (U ===
                                                "x"
                                            )
                                                O =
                                                    K
                                                        ._chunk
                                                        .getCompiledFunction(
                                                            ["y",
                                                                "z"
                                                            ]
                                                        ),
                                                    x
                                                        .graphMode =
                                                    201;
                                            else if (
                                                U ===
                                                "y"
                                            )
                                                O =
                                                    K
                                                        ._chunk
                                                        .getCompiledFunction(
                                                            ["x",
                                                                "z"
                                                            ]
                                                        ),
                                                    x
                                                        .graphMode =
                                                    202;
                                            else if (
                                                U ===
                                                "z"
                                            )
                                                O =
                                                    K
                                                        ._chunk
                                                        .getCompiledFunction(
                                                            ["x",
                                                                "y"
                                                            ]
                                                        ),
                                                    x
                                                        .graphMode =
                                                    200;
                                            else throw J(
                                                "Programming Error: bad lhs"
                                            );
                                            le.push($(
                                                Q))
                                        }
                                        return le
                                    },
                                    Ne =
                                        (Me,
                                            ve) => {
                                            let Q =
                                                n
                                                    .viewport,
                                                U =
                                                    ve
                                                        .getCompiledFunction(
                                                            Y
                                                        ),
                                                xe =
                                                    Me
                                                        .getCompiledFunction(
                                                            Y
                                                        )
                                                        .fn,
                                                le =
                                                    Z0(xe,
                                                        Q
                                                    );
                                            if (
                                                le) {
                                                let {
                                                    explicitPlane: K,
                                                    u: _e,
                                                    v: Ze
                                                } =
                                                    le
                                                    ;
                                                return x
                                                    .graphMode =
                                                    214,
                                                    O = {
                                                        args: ["u",
                                                            "v"
                                                        ],
                                                        source: "",
                                                        constants: [],
                                                        fn: K,
                                                        executionMetadata: {}
                                                    },
                                                    x
                                                        .domain = {
                                                        type: "2d",
                                                        uMin: _e
                                                            .min,
                                                        uMax: _e
                                                            .max,
                                                        vMin: Ze
                                                            .min,
                                                        vMax: Ze
                                                            .max
                                                    },
                                                    [$(
                                                        U)]
                                            } else
                                                return []
                                        };
                                if (Z
                                    .isImplicitPlane()
                                )
                                    return Ne(
                                        Z,
                                        E
                                    );
                                if (E
                                    .isImplicitPlane()
                                )
                                    return Ne(
                                        E,
                                        Z
                                    );
                                let Te =
                                    $0(e,
                                        E
                                    );
                                return Te instanceof D
                                    .SolvedEquation &&
                                    !
                                    Te
                                        .isError ?
                                    Re(Te,
                                        Z
                                    ) :
                                    (Te =
                                        $0(e,
                                            Z
                                        ),
                                        Te instanceof D
                                            .SolvedEquation &&
                                            !
                                            Te
                                                .isError ?
                                            Re(Te,
                                                E
                                            ) :
                                            [$(Z.getCompiledFunction(
                                                Y
                                            ))]
                                    )
                            }
                        }
                    }
                    return [$(
                        G)]
                });
            case 210:
                return p({
                    color: !
                        0,
                    fillOpacity:
                        !0,
                    resolution:
                        !0
                }, (b,
                    x) => {
                    var Me,
                        ve,
                        Q,
                        U,
                        xe,
                        le,
                        K,
                        _e;
                    let P =
                        (Me =
                            ss[
                            f]
                        ) !=
                            null ?
                            Me :
                            [],
                        M = {
                            allowSlices:
                                !
                                0
                        },
                        I =
                            Ra(b._chunk,
                                P,
                                M
                            ),
                        {
                            restrictionChunk: E,
                            slices: v
                        } =
                            I
                                .getSlicesAndRestrictionChunk(),
                        O =
                            E
                                .getCompiledFunction(
                                    P
                                );
                    if (v[0]
                        .type ===
                        "implicit"
                    ) {
                        let Ze =
                            v[
                                0]
                                .sliceChunk,
                            me;
                        try {
                            me = Ze
                                .copy()
                                .gradient(
                                    ["x",
                                        "y",
                                        "z"
                                    ]
                                )
                                .getCompiledFunction(
                                    ["x",
                                        "y",
                                        "z"
                                    ]
                                )
                                .fn
                        } catch (
                        Lh
                        ) { }
                        let te =
                            (ve =
                                x
                                    .resolution
                            ) !=
                                null ?
                                ve :
                                NaN;
                        isNaN
                            (
                                te) &&
                            (te =
                                dd
                            ),
                            te =
                            rr(te,
                                0,
                                100
                            );
                        let pt =
                            A0(Ze
                                .getCompiledFunction(
                                    P
                                ),
                                void 0,
                                me,
                                n
                                    .viewport,
                                te, {
                                isInequality:
                                    !
                                    1
                            }
                            ),
                            {
                                xmin: Ro,
                                xmax: Ba,
                                ymin: ku,
                                ymax: $c
                            } =
                                n
                                    .viewport,
                            Od =
                                new ee(
                                    Ro,
                                    Ba
                                ),
                            Cd =
                                new ee(
                                    ku,
                                    $c
                                );
                        return [{
                            meshData: pt,
                            color: x
                                .color,
                            fillOpacity: (
                                Q =
                                x
                                    .fillOpacity
                            ) !=
                                null ?
                                Q :
                                1,
                            uvRange: [
                                Od,
                                Cd
                            ],
                            uvArgs: (
                                U =
                                ss[x
                                    .graphMode]
                            ) !=
                                null ?
                                U :
                                [],
                            extraMeshArgs: (
                                xe =
                                Vc[x
                                    .graphMode]
                            ) !=
                                null ?
                                xe :
                                [],
                            graphMode: f,
                            compiled: O,
                            restrictionShader: Wo(
                                E,
                                Nu
                            )
                        }]
                    }
                    let A =
                        v[0]
                            .value,
                        N =
                            v[0]
                                .variable,
                        L =
                            n
                                .viewport,
                        {
                            xmin: z,
                            xmax: G,
                            ymin: $,
                            ymax: w,
                            zmin: Y,
                            zmax: de
                        } =
                            L,
                        re,
                        ie,
                        Z;
                    switch (
                    N) {
                        case "x":
                            re = new ee(
                                $,
                                w
                            ),
                                ie =
                                new ee(
                                    Y,
                                    de
                                ),
                                Z =
                                (Ze, me,
                                    te
                                ) =>
                                    Ze -
                                    A;
                            break;
                        case "y":
                            re = new ee(
                                z,
                                G
                            ),
                                ie =
                                new ee(
                                    Y,
                                    de
                                ),
                                Z =
                                (Ze, me,
                                    te
                                ) =>
                                    me -
                                    A;
                            break;
                        case "z":
                            re = new ee(
                                z,
                                G
                            ),
                                ie =
                                new ee(
                                    $,
                                    w
                                ),
                                Z =
                                (Ze, me,
                                    te
                                ) =>
                                    te -
                                    A;
                            break;
                        default:
                            return []
                    }
                    let Re =
                        gh(Z,
                            L
                        );
                    return [{
                        meshData: qi(
                            Re
                        ),
                        color: x
                            .color,
                        fillOpacity: (
                            le =
                            x
                                .fillOpacity
                        ) !=
                            null ?
                            le :
                            1,
                        uvRange: [
                            re,
                            ie
                        ],
                        uvArgs: (
                            K =
                            ss[x
                                .graphMode]
                        ) !=
                            null ?
                            K :
                            [],
                        extraMeshArgs: (
                            _e =
                            Vc[x
                                .graphMode]
                        ) !=
                            null ?
                            _e :
                            [],
                        graphMode: f,
                        compiled: O,
                        restrictionShader: Wo(
                            E,
                            Nu
                        )
                    }]
                });
            case 16: {
                let b = [],
                    x = this
                        .userData
                        .lines ===
                        void 0 ? !0 :
                        this.userData
                            .lines,
                    P = this
                        .userData
                        .fill ===
                        void 0 ? !0 :
                        this.userData
                            .fill;
                if (!P && !x)
                    return b;
                let M = Uc(this
                    .metaData, [
                    "computedLineOpacity",
                    "computedLineWidth",
                    "colorLatexValue",
                    "fillOpacity"
                ], s),
                    I = t.asValue();
                W(t.valueType) || (
                    I = [I]);
                for (let E = 0; E <
                    I.length; E++) {
                    if (E > M - 1)
                        continue;
                    let v = I[E];
                    if (!v.length)
                        continue;
                    let O = this
                        .getGraphInfo(
                            e, t),
                        {
                            listIndex: A,
                            lineWidth: N,
                            lineOpacity: L,
                            fillOpacity: z,
                            color: G
                        } = _u(this,
                            E, s);
                    this.userData
                        .shouldOmitLastPolygonSegment ||
                        (v = [...v,
                        v[0]
                        ]), Xr(v);
                    let $ = aA(v);
                    if ($.length &&
                        (P && b
                            .push({
                                segments: $,
                                graphMode: 7,
                                poi: dr(),
                                color: G,
                                fillOpacity: z,
                                style: O
                                    .style,
                                listIndex: A
                            }), x &&
                            b.push({
                                segments: $,
                                graphMode: 5,
                                poi: dr(),
                                color: G,
                                style: this
                                    .userData
                                    .lineStyle,
                                lineWidth: N,
                                lineOpacity: L,
                                listIndex: A
                            }),
                            Fk &&
                            this
                                .userData
                                .showLabel
                        )) {
                        let w = this
                            .computedLabels &&
                            this
                                .computedLabels[
                            A ||
                            0];
                        b.push({
                            graphMode: 22,
                            objectType: 16,
                            segments: $,
                            color: G,
                            listIndex: A,
                            showLabel:
                                !
                                0,
                            labelSize: this
                                .metaData
                                .computedLabelSize,
                            labelAngle: this
                                .metaData
                                .computedLabelAngle,
                            labelOrientation: this
                                .userData
                                .labelOrientation,
                            labels: w ?
                                [
                                    w] :
                                [Bk(dI(v),
                                    n
                                )]
                        })
                    }
                }
                return b
            }
            case 7:
            case 11:
            case 10:
            case 15:
            case 22:
            case 128:
                return !1;
            default:
                let h = f;
                throw new Error(
                    `Unexpected graphMode: ${h}`
                )
        }
    }

    function nA(e, t, n) {
        var c, l, p;
        let r = (c = ss[e
            .graphMode]) !=
            null ? c : [],
            i = t.concrete
                .getCompiledFunction(r),
            s, o, a = !1;
        if (e.graphMode === 112 || e
            .graphMode === 126 || e
                .graphMode === 113) {
            e.operator !== "=" && (
                a = !0);
            try {
                s = t.concrete
                    .gradient(["x",
                        "y", "z"
                    ])._chunk, o = s
                        .getCompiledFunction(
                            ["x", "y",
                                "z"
                            ]).fn
            } catch (f) { }
        }
        if (e.graphMode === 112 &&
            o && s) {
            let f = Hk(i.fn, o, s, n
                .viewport);
            if (f) return {
                graphMode: 118,
                position: f
                    .center,
                radius: f.radii,
                guid: fi(),
                color: e.color,
                restrictionShader: t
                    .restriction,
                fillOpacity: (
                    l = e
                        .fillOpacity
                ) !=
                    null ? l : 1
            }
        }
        let u = e.graphMode;
        if ((u === 112 || u ===
            113 || u === 127 ||
            u === 106 || u ===
            107 || u === 108) &&
            t.concrete._chunk
                .isLinearIn(["x", "y",
                    "z"
                ])) {
            let f = n.viewport,
                m, g, d;
            switch (u) {
                case 106:
                    m = (b, x, P) =>
                        P - i.fn(b,
                            x), g =
                        new ee(f
                            .xmin, f
                            .xmax),
                        d = new ee(f
                            .ymin, f
                            .ymax);
                    break;
                case 107:
                    m = (b, x, P) =>
                        b - i.fn(x,
                            P), g =
                        new ee(f
                            .ymin, f
                            .ymax),
                        d = new ee(f
                            .zmin, f
                            .zmax);
                    break;
                case 108:
                    m = (b, x, P) =>
                        x - i.fn(b,
                            P), g =
                        new ee(f
                            .xmin, f
                            .xmax),
                        d = new ee(f
                            .zmin, f
                            .zmax);
                    break;
                case 112:
                case 113:
                case 127:
                    m = i.fn, g =
                        new ee(f
                            .xmin, f
                            .xmax),
                        d = new ee(f
                            .ymin, f
                            .ymax);
                    break
            }
            let y = qi(gh(m, f)),
                h = u === 113 ||
                    u === 127;
            return u === 127 && (u =
                113), {
                meshData: y,
                color: e.color,
                fillOpacity: h ?
                    1 : (p = e
                        .fillOpacity
                    ) !=
                        null ? p :
                        1,
                uvRange: [g, d],
                uvArgs: [],
                extraMeshArgs: [],
                graphMode: u,
                compiled: i,
                restrictionShader: t
                    .restriction
            }
        }
        return _a({
            viewState: n,
            graphInfo: e,
            compiled: i,
            restrictionShader3d: t
                .restriction,
            isImplicit3dInequality: a,
            gradient: o,
            dependencies: t
                .concrete
                ._dependencies
        })
    }

    function zk(e, t) {
        var r, i, s;
        if ($E(t.graphMode))
            switch (t.graphMode) {
                case 121:
                case 123: {
                    t.graphMode = 2,
                        t
                            .willConvertTo3D = !
                        0, (r = t
                            .lineWidth
                        ) !=
                        null || (t
                            .lineWidth =
                            1);
                    break
                }
                case 120:
                case 122: {
                    t.graphMode = 1,
                        t
                            .willConvertTo3D = !
                        0, (i = t
                            .lineWidth
                        ) !=
                        null || (t
                            .lineWidth =
                            1);
                    break
                }
                case 124:
                    let {
                        min: o, max:
                        a
                    } = ((s = t
                        .domain
                    ) ==
                        null ?
                        void 0 : s
                            .type) ===
                        "1d" ? t
                            .domain : {
                            min: 0,
                            max: 2 *
                                Math
                                    .PI
                        };
                    t.graphMode = 6,
                        t.domain = {
                            type: "1d",
                            min: o,
                            max: a,
                            isExplicit: e
                                .metaData
                                .isExplicitDomain
                        };
                    break;
                case 126:
                    t.graphMode = 8;
                    break
            }
    }

    function Hk(e, t, n, r) {
        if (r.zmin === void 0 || r
            .zmax === void 0)
            return;
        let i = n.argNames.indexOf(
            "x"),
            s = n.argNames.indexOf(
                "y"),
            o = n.argNames.indexOf(
                "z");
        if (i === -1 || s === -1 ||
            o === -1) return;
        let a = n.getInstruction(n
            .getReturnIndex());
        if (a.type !== 38 || a.args
            .length !== 3) return;
        let [u, c, l] = a.args, p =
            Lr(n, i, {
                allowRestriction:
                    !1,
                allowClosedBlockReferences:
                    !1
            }), f = Lr(n, s, {
                allowRestriction:
                    !1,
                allowClosedBlockReferences:
                    !1
            }), m = Lr(n, o, {
                allowRestriction:
                    !1,
                allowClosedBlockReferences:
                    !1
            });
        if (en(p, u) !== 1 || en(f,
            c) !== 1 || en(m,
                l) !== 1 || en(f, u) !==
            0 || en(m, u) !== 0 ||
            en(p, c) !== 0 || en(m,
                c) !== 0 || en(p,
                    l) !== 0 || en(f, l) !==
            0) return;
        let {
            xmin: g,
            ymin: d,
            zmin: y,
            xmax: h,
            ymax: b,
            zmax: x
        } = r, P = t(g, d, y), M =
                t(h, b, x), I = .5 * (M[
                    0] - P[0]) / (h -
                        g), E = .5 * (M[1] - P[
                            1]) / (b - d), v =
                .5 * (M[2] - P[2]) / (
                    x - y), O = (g * M[
                        0] - h * P[0]) / (M[
                            0] - P[0]), A = (d *
                                M[1] - b * P[1]) / (
                                    M[1] - P[1]), N = (
                                        y * M[2] - x * P[2]
                                    ) / (M[2] - P[2]),
            L = -e(O, A, N), z =
                Math.sqrt(L / I), G =
                Math.sqrt(L / E), $ =
                Math.sqrt(L / v);
        if (!(!isFinite(O) || !
            isFinite(A) || !
            isFinite(N) || !
            isFinite(z) || !
            isFinite(G) || !
            isFinite($) || z ===
            0 || G === 0 ||
            $ === 0)) return {
                center: [O, A, N],
                radii: [z, G, $]
            }
    }

    function Uk(e, t, n, r, i, s,
        o) {
        let a = e.metaData
            .evaluatedCDFMin,
            u = e.metaData
                .evaluatedCDFMax,
            c = Aa(e),
            l = dA(c, t),
            p = c && c.discrete;
        if (a !== void 0 && u !==
            void 0 && !isNaN(a) && !
            isNaN(u) && o) {
            let f = [];
            if (p) {
                let m = {
                    viewState: r,
                    graphInfo: i,
                    compiled: n,
                    bounds: [a,
                        u
                    ],
                    maxOverride: oA(
                        c, t
                    ),
                    showPoint: e
                        .userData
                        .shouldGraph
                },
                    g = NN(m),
                    d = g
                        .cdfTopBranch,
                    y = g
                        .topBranches;
                if (y.forEach(
                    function (
                        h) {
                        !h || !
                            l ||
                            (h.boundingBox =
                                l
                            )
                    }), y.every(
                        h => h !==
                            void 0) && (
                        f = y, d &&
                        d.segments[
                            0]
                            .length)) {
                    let h = [];
                    d.segments[0]
                        .forEach(
                            function (
                                b) {
                                !
                                    isNaN
                                        (b[
                                            0]) &&
                                    !
                                    isNaN(
                                        b[
                                        1]
                                    ) &&
                                    h
                                        .push(
                                            [b[0],
                                                0,
                                            b[
                                            0],
                                            b[
                                            1]
                                            ]
                                        )
                            }), f
                                .push({
                                    graphMode: 5,
                                    segments: h,
                                    boundingBox: l,
                                    poi: dr(),
                                    color: i
                                        .color
                                })
                }
            } else {
                let g = AN({
                    viewState: r,
                    graphInfo: i,
                    compiled: n,
                    derivative: s,
                    bounds: [
                        a,
                        u
                    ]
                }),
                    d = g
                        .cdfTopBranch,
                    y = g
                        .topBranches;
                if (y.forEach(
                    function (
                        h) {
                        !h || !
                            l ||
                            (h.boundingBox =
                                l
                            )
                    }), f = y,
                    d && d.segments
                        .length) {
                    let h, b;
                    for (let x =
                        0; x < d
                            .segments
                            .length; x++
                    ) {
                        let P = d
                            .segments[
                            x];
                        if (P
                            .length >=
                            4) {
                            h = P[
                                0];
                            break
                        }
                    }
                    for (let x = d
                        .segments
                        .length -
                        1; x >=
                        0; x--) {
                        let P = d
                            .segments[
                            x];
                        if (P
                            .length >=
                            4) {
                            b = P[P.length -
                                2
                            ];
                            break
                        }
                    }
                    if (h !==
                        void 0 &&
                        b !==
                        void 0 &&
                        isFinite(
                            h) &&
                        isFinite(b)
                    ) {
                        let x = sh(d
                            .segments,
                            [
                                [h, 0,
                                    b,
                                    0
                                ]
                            ], d
                            .graphMode
                        );
                        f.push({
                            graphMode: 7,
                            segments: x,
                            poi: dr(),
                            color: i
                                .color
                        })
                    }
                }
            }
            return f
        } else if (p) {
            let f = ih({
                viewState: r,
                graphInfo: i,
                compiled: n,
                showPoint: e
                    .userData
                    .shouldGraph,
                maxOverride: oA(
                    c, t
                )
            });
            return l && (f
                .boundingBox = l
            ), [f]
        } else return
    }

    function cA(e) {
        return qk(e) || J0(e) || lA(
            e)
    }

    function qk(e) {
        return e === 3
    }

    function W0(e, t) {
        let n = t != null ? t : {};
        if (!Array.isArray(e))
            return () => e;
        let r = Object.keys(n)
            .length === 0 ? e : e
                .filter((i, s) => !n[
                    s]);
        return i => r[i]
    }

    function $k(e) {
        var s, o;
        let t = e.droppedIndices,
            n = W0((s = e
                .pointSize) !=
                null ? s : 1, t),
            r = W0(e.color, t),
            i = W0((o = e
                .pointOpacity
            ) != null ? o :
                1, t);
        return e.segments[0].map(([
            a, u
        ], c) => ({
            graphMode: 114,
            position: [
                a,
                u, 0
            ],
            radius: .02 *
                n(c),
            guid: fi(),
            color: r(c),
            fillOpacity: i(
                c)
        }))
    }

    function rA(e, t, n, r) {
        return e.is3dPolicy() && J0(
            t.graphMode) ? ah(t,
                n, r != null ? r : 1
            ) : t
    }

    function J0(e) {
        switch (e) {
            case 1:
            case 2:
            case 6:
            case 8:
            case 5:
                return !0;
            default:
                return !1
        }
    }

    function ah(e, t, n, r = 0) {
        var o;
        let i = pA(e, t, r),
            s = uh(i, t.viewport,
                n);
        return {
            graphMode: 128,
            guid: fi(),
            points: s,
            resolved: e.resolved,
            color: e.color,
            thickness: (o = e
                .lineWidth) !=
                null ? o : 1
        }
    }

    function iA(e, t, n) {
        return e.is3dPolicy() && lA(
            t.graphMode) ? Yk(t,
                n) : t
    }

    function lA(e) {
        switch (e) {
            case 17:
            case 24:
                return !0;
            default:
                return !1
        }
    }

    function Yk(e, t) {
        var r;
        let n = pA(e, t);
        return {
            graphMode: e
                .graphMode === 17 ?
                119 : e
                    .graphMode === 24 ?
                    129 : 128,
            guid: fi(),
            points: Xk(n),
            color: e.color,
            thickness: (r = e
                .lineWidth) !=
                null ? r : 1
        }
    }

    function Xk(e) {
        let t = [];
        for (let [n, r, i] of e) t
            .push(n, r, i);
        return t
    }

    function pA(e, t, n = 0) {
        function r(s, o) {
            if (e.graphMode === 1)
                return [o, s];
            if (e.graphMode === 6) {
                let a = t
                    .degreeMode ?
                    s * Math.PI /
                    180 : s;
                return [o * Math
                    .cos(a), o *
                Math.sin(a)
                ]
            } else return [s, o]
        }
        let i = [];
        for (let s = 0; s < e
            .segments.length; s++) {
            let o = e.segments[s];
            for (let a = 0; a < o
                .length / 2; a++) {
                let [u, c] = r(o[2 *
                    a], o[
                2 * a +
                1]);
                i.push([u, c, n])
            }
            s < e.segments.length -
                1 && i.push([NaN,
                    NaN, 0
                ])
        }
        return i
    }

    function uh(e, t, n) {
        if (t.zmin === void 0 || t
            .zmax === void 0)
            return [];
        let {
            xmin: r,
            xmax: i,
            ymin: s,
            ymax: o,
            zmin: a,
            zmax: u
        } = t, c = i - r, l = o - s,
            p = u - a, f = n / 200,
            m = [], g = 1e-4;
        for (let h = 0; h < e
            .length; h++) {
            let b = e[h];
            if (isFinite(b[0]) &&
                isFinite(b[1]) &&
                isFinite(b[2])) {
                let x = m[m.length -
                    1];
                x !== void 0 && Math
                    .abs(b[0] - x[
                        0]) < g *
                    c && Math.abs(b[
                        1] - x[
                        1]) < g *
                    l && Math.abs(b[
                        2] - x[
                        2]) < g *
                    p || m.push(b)
            } else m.push(void 0)
        }
        let d = [],
            y = m.length;
        for (let h = 0; h <
            y; h++) {
            let b = m[h];
            if (!b) {
                d.push(NaN, NaN,
                    NaN);
                continue
            }
            let [x, P, M] = b, I =
                m[h - 1], E = m[h +
                    1];
            if (I && E) {
                let [v, O, A] = I, [
                    N, L, z
                ] = E, G = (x - v) /
                    c, $ = (N - x) /
                        c, w = (P - O) /
                            l, Y = (L - P) /
                                l, de = (M -
                                    A) / p, re = (
                                        z - M) / p,
                    ie = po(G, w,
                        de), Z = po(
                            $, Y, re);
                if (($ * G + Y * w +
                    re * de) / (
                        ie * Z) <
                    .7 && ie > f &&
                    Z > f) {
                    let Ne = .5 * (
                        f / ie),
                        Te = .5 * (
                            f / Z),
                        Me = Ks(v,
                            x, 1 -
                        Ne),
                        ve = Ks(O,
                            P, 1 -
                        Ne),
                        Q = Ks(A, M,
                            1 - Ne),
                        U = Ks(x, N,
                            Te),
                        xe = Ks(P,
                            L, Te),
                        le = Ks(M,
                            z, Te);
                    d.push(Me, ve,
                        Q), d
                            .push(Ks(Me,
                                x,
                                .5),
                                Ks(ve,
                                    P,
                                    .5),
                                Ks(Q, M,
                                    .5)
                            ), d
                                .push(x, P,
                                    M), d
                                        .push(Ks(x,
                                            U,
                                            .5),
                                            Ks(P,
                                                xe,
                                                .5),
                                            Ks(M,
                                                le,
                                                .5)
                                        ), d
                                            .push(U, xe,
                                                le)
                } else d.push(x, P,
                    M)
            } else d.push(x, P, M)
        }
        return d
    }

    function Ks(e, t, n) {
        return (1 - n) * e + n * t
    }

    function Zk(e) {
        return e.startsWith(
            "shader:")
    }

    function bh(e, t, n) {
        return {
            resolved: !0,
            graphMode: t,
            segments: n,
            operator: e.operator,
            poi: dr(),
            color: e.color,
            style: "DASHED",
            lineWidth: 1,
            lineOpacity: .5,
            isIntersectionExtension:
                !0
        }
    }

    function sA(e, t) {
        var r, i;
        if (!t) return [];
        let n = [];
        for (let s of e)
            if (s.graphMode ===
                17) {
                let o = t[(r = s
                    .listIndex
                ) !=
                    null ? r : 0
                ];
                if (!o) continue;
                let a = 0,
                    u, c = 1,
                    l, [p, f, m,
                        g] = s.segments[
                        0];
                for (let d = 0; d <
                    o.length; d++) {
                    let [y, h] = o[
                        d], b =
                            Rs(y, h, 0,
                                p, f, 0,
                                m, g, 0
                            );
                    b < a && (a = b,
                        u = d),
                        s
                            .graphMode ===
                        17 && b >
                        c && (c = b,
                            l = d)
                }
                u !== void 0 && n
                    .push(bh(s, 17,
                        [
                            [p, f,
                                o[
                                u]
                                [
                                0],
                                o[
                                u]
                                [
                                1]
                            ]
                        ])), l !==
                        void 0 && n
                            .push(bh(s, 17,
                                [
                                    [m, g,
                                        o[
                                        l]
                                        [
                                        0],
                                        o[
                                        l]
                                        [
                                        1]
                                    ]
                                ]))
            } else if (s
                .graphMode === 21) {
                let o = t[(i = s
                    .listIndex
                ) != null ?
                    i : 0];
                if (!o) continue;
                let [a, u, c, l, p] = s
                    .segments[0], f =
                        p - l + (p < l ? 1 :
                            -1) * 2 * Math
                            .PI, m = [];
                for (let g of o) {
                    let [d, y] = g, h =
                        Math.atan2(y -
                            u, d - a),
                        b = BM(h, l, f);
                    0 < b && b < 1 && m
                        .push(b)
                }
                if (m.length) {
                    m.push(0, 1), m
                        .sort();
                    let g = 0,
                        d = 0;
                    for (let b = 0; b <
                        m.length -
                        1; b++) {
                        let x = m[b +
                            1] - m[b];
                        (g === void 0 ||
                            x > g) && (
                                g = x, d = b
                            )
                    }
                    let y = m[d],
                        h = m[d + 1];
                    y > 0 && n.push(bh(
                        s, 21, [
                        [a, u,
                            c,
                            l,
                            l +
                            y *
                            f
                        ]
                    ])), h <
                    1 && n.push(bh(
                        s, 21, [
                        [a, u,
                            c,
                            p,
                            p -
                            (1 -
                                h) *
                            f
                        ]
                    ]))
                }
            }
        return n
    }

    function Wk() {
        throw new Error(
            "Programming error: this function is not expected to be called"
        )
    }

    function fA(e, t, n, r) {
        let i = [];
        for (let s = 0; s < t
            .otherVariableSolutionData
            .length; s++) {
            let o = t
                .otherVariableSolutionData[
                s];
            if (!o) continue;
            let {
                coefficients: a,
                restriction: u
            } = o, c = a.argNames[
                0];
            if (c !== "x" && c !==
                "y") continue;
            let l = a
                .getCompiledFunction()
                .fn,
                p, f;
            c === "y" ? (p = 1, f =
                2) : (p = 2, f =
                    1);
            let m = void 0,
                {
                    listIndex: g,
                    style: d,
                    lineWidth: y,
                    lineOpacity: h,
                    color: b
                } = _u(e, s, m),
                x = Ip(n, {
                    graphMode: p,
                    domainBound: Xn(),
                    lineWidth: y,
                    operator: "="
                }, Wk);
            if (!x) continue;
            let P = MN(l, x);
            for (let M of P) {
                let I = new pn(u
                    .substituteConstantArguments({
                        [c]: M
                    })),
                    E = e
                        .getGraphInfo(r,
                            I);
                E = {
                    ...E,
                    graphMode: f,
                    lineWidth: y
                };
                let O = e._graph(r,
                    I, n, E,
                    void 0, t
                        .branchMultiplier ===
                        2 ?
                    "solvedEquation" :
                    void 0);
                if (mo(O))
                    for (let A of O)
                        i.push({
                            ...
                            A,
                            listIndex: g,
                            style: d,
                            lineWidth: y,
                            lineOpacity: h,
                            color: b
                        })
            }
        }
        return i.length > 0 ? i : !1
    }
    D.Base.prototype.tryGraph =
        function (e, t, n, r) {
            var i, s;
            try {
                let o = this.graph(
                    e, t, n, r);
                if (Array.isArray(
                    o))
                    for (let a of o)
                        "compiled" in
                            a && ((i = a
                                .compiled
                            ) !=
                                null &&
                                i
                                    .executionMetadata
                                    .recursionTerminationStatus
                            ) && (a
                                .recursionTerminationStatus =
                                (s = a
                                    .compiled
                                ) ==
                                    null ?
                                    void 0 :
                                    s
                                        .executionMetadata
                                        .recursionTerminationStatus
                            );
                return o
            } catch (o) {
                let a =
                    o instanceof D
                        .Error ? o
                            .getError() : J(
                                o)
                                .getError();
                return [IN(a)]
            }
        };
    D.Base.prototype.graph =
        function (e, t, n, r) {
            let i = this
                .getGraphInfo(e, t);
            return this._graph(e, t,
                n, i, r)
        };
    D.BaseComparator.prototype
        .graph = function (e, t, n) {
            let r = this
                .getGraphInfo(e, t),
                i = r.graphMode,
                s =
                    "baseComparator",
                o = this.userData
                    .lines === void 0 ?
                    !0 : this.userData
                        .lines;
            if (i === 8 || i ===
                112 || i === 113 ||
                i === 127 || i ===
                210) return this
                    ._graph(e, t, n,
                        r);
            if (i === 10 || !(
                t instanceof D
                    .SolvedEquation
            )) return !1;
            let a = this
                .getOperator(),
                u = [],
                c = [],
                l = !0;
            t._expression
                .eachElement(
                    function (y) {
                        u.push(y
                            .getCompiledFunction());
                        try {
                            c.push(y
                                .getCompiledDerivative())
                        } catch (
                        h) {
                            l = !1
                        }
                    }), l || (c =
                        void 0);
            let p = [],
                f = [-1, 0, 0, 1],
                m = Uc(this
                    .metaData, [
                    "computedLineWidth",
                    "computedLineOpacity",
                    "computedFillOpacity",
                    "colorLatexValue"
                ], s),
                g = Math.min(u
                    .length, m);
            for (let y = 0; y <
                g; y++) {
                let h = this
                    .getGraphInfo(e,
                        t
                            ._expression
                            .args[y]);
                h.graphMode = i;
                let {
                    listIndex: b,
                    style: x,
                    color: P,
                    lineWidth: M,
                    lineOpacity: I,
                    fillOpacity: E
                } = _u(this, y, s);
                h.listIndex = b, h
                    .style = x, h
                        .color = P, r
                            .graphMode ===
                        6 && (h
                            .domain = {
                            type: "1d",
                            min: this
                                .metaData
                                .evaluatedDomainMin,
                            max: this
                                .metaData
                                .evaluatedDomainMax,
                            isExplicit: this
                                .metaData
                                .isExplicitDomain
                        });
                let v = _a({
                    viewState: n,
                    graphInfo: h,
                    compiled: u[
                        y
                    ],
                    derivative: c ?
                        c[
                        y] :
                        void 0
                });
                v.lineWidth = M, v
                    .lineOpacity =
                    I, v
                        .fillOpacity =
                    E, v.operator =
                    Qu(Rr[a]
                        .inclusive,
                        f[y % 4]),
                    o || (v
                        .lineWidth =
                        0), p.push(
                            v)
            }
            for (let y = 0; y <
                g; y += 4) {
                let h = sh(p[y + 1]
                    .segments,
                    p[y + 2]
                        .segments, i
                );
                p.push({
                    graphMode: 7,
                    listIndex: p[
                        y
                    ]
                        .listIndex,
                    segments: h,
                    poi: dr(),
                    fillOpacity: p[
                        y
                    ]
                        .fillOpacity,
                    color: p[
                        y
                    ]
                        .color
                })
            }
            let d = fA(this, t, n,
                e);
            if (d) {
                for (let y of d) y
                    .operator = Qu(
                        Rr[a]
                            .inclusive,
                        0);
                Array.prototype.push
                    .apply(p, d)
            }
            return p
        };
    D.DoubleInequality.prototype
        .graph = function (e, t, n) {
            let r = this
                .getGraphInfo(e, t);
            if (r.graphMode === 10)
                return !1;
            let i = [],
                s = Qu(Rr[this
                    ._operators[
                    0]]
                    .inclusive, 0),
                o = Qu(Rr[this
                    ._operators[
                    1]]
                    .inclusive, 0),
                a = this.userData,
                u = this.metaData,
                c = a.lines ===
                    void 0 ? !0 : a
                    .lines,
                l = [
                    "colorLatexValue",
                    "computedFillOpacity"
                ];
            c && l.push(
                "computedLineWidth",
                "computedLineOpacity"
            );
            let p = Uc(u, l),
                f = t._expressions;
            return Xr(f), xh
                .eachArgs(f, (m,
                    g) => {
                    let d = g;
                    if (d >= p)
                        return;
                    m[0].userData =
                        m[1]
                            .userData =
                        a, m[0]
                            .metaData =
                        m[1]
                            .metaData =
                        u;
                    let y =
                        void 0,
                        {
                            color: h,
                            lineWidth: b,
                            lineOpacity: x,
                            fillOpacity: P
                        } = _u(
                            this,
                            d, y
                        ),
                        M = this
                            ._graph(
                                e,
                                m[
                                0],
                                n, r
                            )[
                            0];
                    M.listIndex =
                        d, M
                            .operator =
                        s, M
                            .color =
                        h, M
                            .lineWidth =
                        b, M
                            .lineOpacity =
                        x, i
                            .push(
                                M);
                    let I = this
                        ._graph(
                            e,
                            m[
                            1],
                            n, r
                        )[
                        0];
                    I.listIndex =
                        d, I
                            .operator =
                        o, I
                            .color =
                        h, I
                            .lineWidth =
                        b, I
                            .lineOpacity =
                        x, i
                            .push(
                                I);
                    let E = M
                        .segments,
                        v = I
                            .segments;
                    Xr(E), Xr(
                        v);
                    let O = sh(
                        E,
                        v, M
                        .graphMode
                    );
                    c || (M.lineWidth =
                        0, I
                            .lineWidth =
                        0),
                        i.push({
                            graphMode: 7,
                            listIndex: M
                                .listIndex,
                            segments: O,
                            lineOpacity: x,
                            fillOpacity: P,
                            poi: dr(),
                            color: h
                        })
                }), i
        };
    D.Regression.prototype.graph =
        function (e, t, n) {
            let r = this
                .getGraphInfo(e, t);
            return this._graph(e, t
                .model, n, r)
        };

    function Q0(e, t) {
        let n = 1 / 0,
            r = -1 / 0,
            i = 1 / 0,
            s = -1 / 0;
        for (let a of t)
            for (var o = 0; o < a
                .length; o += 2) {
                let u = a[o],
                    c = a[o + 1];
                u < n && (n = u),
                    u > r && (r =
                        u), c < i && (
                            i = c), c >
                            s && (s = c)
            }
        if (isFinite(n) && isFinite(
            i)) return {
                type: e,
                xmin: n,
                ymin: i,
                xmax: r,
                ymax: s
            }
    }

    function dA(e, t) {
        if (!e || !(
            t instanceof pn))
            return;
        let n = t._chunk,
            r = n.getInstruction(n
                .getReturnIndex());
        if (r.type !== 37) return;
        let i = e.discrete ?
            "discreteDistribution" :
            "continuousDistribution";
        if (e.symbol ===
            "binomialdist" && r
                .symbol === "binompdf"
        ) {
            let s = ln(n, r.args[
                1]),
                o = ln(n, r.args[
                    2]),
                a = Fy(o * s, s, o);
            return {
                type: i,
                xmin: 0,
                xmax: s,
                ymin: 0,
                ymax: a
            }
        }
        if (e.symbol ===
            "poissondist" && r
                .symbol === "poissonpdf"
        ) {
            let s = ln(n, r.args[
                1]),
                o = Math.max(Yl(Math
                    .floor(s), s
                ), Yl(Math
                    .ceil(s), s
                ));
            return {
                type: i,
                xmin: 0,
                xmax: 2.5 * s,
                ymin: 0,
                ymax: o
            }
        }
        if (e.symbol ===
            "normaldist" && r
                .symbol === "normalpdf"
        ) {
            let s = ln(n, r.args[
                1]),
                o = ln(n, r.args[
                    2]),
                a = rI(s, s, o);
            return {
                type: i,
                xmin: s - 2 * Math
                    .abs(o),
                xmax: s + 2 * Math
                    .abs(o),
                ymin: 0,
                ymax: a
            }
        }
        if (e.symbol ===
            "uniformdist" && r
                .symbol === "uniformpdf"
        ) {
            let s = ln(n, r.args[
                1]),
                o = ln(n, r.args[
                    2]),
                a = (s + o) / 2,
                u = o - s,
                c = oI(a, s, o);
            return {
                type: i,
                xmin: s - u / 3,
                xmax: o + u / 3,
                ymin: 0,
                ymax: c
            }
        }
        if (e.symbol === "tdist" &&
            r.symbol === "tpdf") {
            let s = ln(n, r.args[
                1]),
                o = wy(0, s);
            return {
                type: i,
                xmin: -3,
                xmax: 3,
                ymin: 0,
                ymax: o
            }
        }
    }

    function oA(e, t) {
        if (e === void 0 || e
            .symbol !==
            "binomialdist" || !(
                t instanceof pn))
            return;
        let n = t._chunk,
            r = n.getInstruction(n
                .getReturnIndex());
        if (r.type === 37 && r
            .symbol === "binompdf")
            return ln(n, r.args[1])
    }

    function mA(e, t, n) {
        let r = {};
        n -= .5 * t;
        for (var i = e.length -
            1; i >= 0; i--) {
            let s = e[i],
                o = Math.floor((s -
                    n) / t);
            r[o] ? r[o].data.push(
                s) : r[o] = {
                    id: o,
                    data: [s],
                    min: o * t + n,
                    max: o * t + n +
                        t,
                    center: o * t +
                        n + t / 2
                }
        }
        return r
    }
    D.Histogram.prototype.graph =
        function (e, t, n) {
            let r = this
                .getGraphInfo(e, t),
                i = t.args[0]
                    .asValue(),
                s = t.args[1]
                    .asValue(),
                o = this.userData
                    .vizProps && this
                        .userData.vizProps
                        .binAlignment ===
                    "left" ? s / 2 : 0;
            Xr(i);
            let a = mA(i, s, o),
                u = 1;
            this.userData
                .vizProps && this
                    .userData.vizProps
                    .histogramMode ===
                "density" ? u = 1 /
                (i.length * s) :
                this.userData
                    .vizProps && this
                        .userData.vizProps
                        .histogramMode ===
                "relative" && (u =
                    1 / i.length);
            let c = [],
                l = [];
            for (let f in a) {
                let m = a[f],
                    g = m.data
                        .length;
                l.push([m.min, 0 *
                    u, m
                    .min,
                g * u, m
                    .max,
                g * u, m
                    .max,
                0 * u
                ]);
                let d = 0;
                a[m.id + 1] && (d =
                    a[m.id + 1]
                        .data.length
                );
                let y = [m.min, 0 *
                    u, m.min,
                g * u, m
                    .max, g * u
                ];
                d < g && y.push(m
                    .max, d * u
                ), c.push(y)
            }
            let p = Q0("histogram",
                l);
            return p && s && (p
                .binWidth = s),
                [{
                    segments: l,
                    graphMode: 7,
                    boundingBox: p,
                    poi: dr(),
                    color: r
                        .color,
                    fillOpacity: .4
                }, {
                    segments: c,
                    graphMode: 2,
                    poi: {
                        zeros: {
                            x: [],
                            y: []
                        },
                        extrema: {
                            x: [],
                            y: []
                        },
                        intercept: {
                            x: [],
                            y: []
                        }
                    },
                    color: r
                        .color
                }]
        };
    D.DotPlot.prototype.graph =
        function (e, t, n) {
            let r = this
                .getGraphInfo(e, t),
                i = t.args[1]
                    .asValue(),
                s = this.userData
                    .vizProps && this
                        .userData.vizProps
                        .binAlignment ===
                    "left" ? i / 2 : 0,
                o = t.args[0]
                    .asValue();
            Xr(o);
            let a = mA(o, i, s),
                u = !1,
                c, l = [];
            for (let h in a) {
                let b = a[h];
                for (var p = b.data
                    .length -
                    1; p >=
                    0; p--) b
                        .center !== b
                            .data[p] && (
                            u = !0)
            }
            if (this.userData
                .vizProps && this
                    .userData.vizProps
                    .dotplotXMode ===
                "exact")
                for (let h in a) {
                    c = a[h].data, c
                        .reverse();
                    for (let x =
                        0; x < c
                            .length; x++
                    ) l.push([c[
                        x],
                    x +
                    1
                    ])
                } else
                for (let h in
                    a) {
                    let b = a[
                        h];
                    c = b.data;
                    for (let x =
                        0; x <
                        c
                            .length; x++
                    ) l
                        .push([b.center,
                        x +
                        1
                        ])
                }
            let f = Q0("dotplot",
                l);
            f && i && (f.ymin = 0, f
                .xmin -= .5 * i,
                f.xmax += .5 *
                i, f.binWidth =
                i);
            let {
                computedPointOpacity: m,
                computedPointSize: g
            } = this.metaData, d =
                    wa(m, 0), y = this
                        .userData
                        .pointSize ? wa(g,
                            0) : 14;
            return [{
                segments: [
                    l],
                graphMode: 3,
                boundingBox: f,
                poi: Us(l),
                color: r
                    .color,
                style: this
                    .userData
                    .pointStyle,
                pointSize: y,
                pointOpacity: d,
                showPoint: !
                    0,
                needsDotplotXMode: u
            }]
        };
    D.BoxPlot.prototype.graph =
        function (e, t, n) {
            let r = this
                .getGraphInfo(e, t),
                i = this.metaData
                    .evaluatedAxisOffset,
                s = this.metaData
                    .evaluatedBreadth,
                o = t.args[0]
                    .asValue();
            if (Xr(o), isNaN(s) ||
                isNaN(i)) return !1;
            let a = Math.min.apply(
                null, o),
                u = Math.max.apply(
                    null, o),
                c = Ic(o, 1),
                l = Ic(o, 2),
                p = Ic(o, 3),
                f = i,
                m = f - s / 2,
                g = f + s / 2,
                d = s / 10,
                y = [];
            if (this.userData
                .vizProps
                .showBoxplotOutliers
            ) {
                let P = p - c,
                    M = c - 1.5 * P,
                    I = p + 1.5 * P;
                a = 1 / 0, u = -1 /
                    0, o.forEach(
                        function (
                            E) {
                            M <= E &&
                                E <
                                a &&
                                (a =
                                    E),
                                u <
                                E &&
                                E <=
                                I &&
                                (u =
                                    E),
                                (E < M ||
                                    E >
                                    I
                                ) &&
                                y
                                    .push(
                                        [E,
                                            f]
                                    )
                        })
            }
            let h = [
                [c, m, p, m, p,
                    g, c, g, c,
                    m
                ],
                [l, m, l, g],
                [c, f, a, f],
                [p, f, u, f],
                [a, f - d, a,
                    f + d
                ],
                [u, f - d, u,
                    f + d
                ]
            ];
            if (this.userData
                .vizProps && this
                    .userData.vizProps
                    .alignedAxis === "y"
            ) {
                for (let P of h)
                    for (var b =
                        0; b < P
                            .length; b +=
                        2) {
                        let M = P[
                            b];
                        P[b] = P[b +
                            1],
                            P[b +
                            1] = M
                    }
                for (let P of y) {
                    let M = P[0];
                    P[0] = P[1], P[
                        1] = M
                }
            }
            let x = [{
                segments: h,
                graphMode: 5,
                boundingBox: Q0(
                    "boxplot",
                    h
                        .concat(
                            y
                        )
                ),
                poi: dr(),
                color: r
                    .color
            }];
            return y.length && x
                .push({
                    segments: [
                        y],
                    graphMode: 3,
                    color: r
                        .color,
                    style: "OPEN",
                    showPoint: !
                        0,
                    poi: Us(y)
                }), x
        };

    function jk(e) {
        return Array.prototype
            .concat.apply([], e)
    }
    D.Table.prototype
        .isValueDraggable =
        function (e, t, n) {
            if (!e.columns[t]
                .isIndependent)
                return !1;
            let i = this.columns[t]
                .values,
                s = i && i[n];
            return !!(s && isFinite(
                s.asValue()
            ) && s
                .getDependencies()
                .length === 0)
        };
    D.Table.prototype.graph =
        function (e, t, n) {
            let r = {};
            if (t.columns[0]
                .isError) return r;
            let s = t.columns[0]
                .values;
            for (let o = 1; o < this
                .columns.length; o++
            ) {
                let a = t.columns[
                    o];
                if (a.isError)
                    continue;
                let u = this
                    .columns[o]
                    .header
                    .userData,
                    c = this
                        .columns[o]
                        .header
                        .metaData;
                if (u.hidden)
                    continue;
                let l = Uc(c, [
                    "colorLatexValue",
                    "computedPointSize",
                    "computedPointOpacity"
                ]),
                    p = u.dragMode,
                    f = p === "X" ||
                        p === "XY",
                    m = p === "Y" ||
                        p === "XY",
                    g = !!u.points,
                    d = !!u.lines,
                    y = [],
                    h = [],
                    b = [],
                    x = [],
                    P = [],
                    M = [],
                    I = 1 / 0,
                    E = -1 / 0,
                    v = 1 / 0,
                    O = -1 / 0,
                    A = {};
                for (let L = 0; L <
                    s.length; L++) {
                    let z = s[L],
                        G = a
                            .values[L];
                    if (!z || !G ||
                        !isFinite(z
                            .asValue()
                        ) || !
                        isFinite(G
                            .asValue()
                        )) {
                        A[L] = !0,
                            d && (M
                                .length >
                                1 &&
                                P
                                    .push(
                                        M
                                    ),
                                M = []
                            );
                        continue
                    }
                    let $ = z
                        .asValue(),
                        w = G
                            .asValue();
                    if (g) {
                        if (L >= l)
                            continue;
                        let Y = f &&
                            this
                                .isValueDraggable(
                                    t,
                                    0, L
                                ),
                            de =
                                m &&
                                this
                                    .isValueDraggable(
                                        t,
                                        o, L
                                    );
                        Y || de ? (b
                            .push(
                                [$,
                                    w]
                            ),
                            x
                                .push({
                                    index: L,
                                    dragX: Y,
                                    dragY: de
                                })
                        ) :
                            h.push([$,
                                w
                            ])
                    }
                    d && M.push([$,
                        w
                    ]), $ < I &&
                        (I = $), $ >
                        E && (E =
                            $), w < v &&
                        (v = w), w >
                        O && (O = w)
                }
                let N = {
                    type: "table",
                    xmin: I,
                    xmax: E,
                    ymin: v,
                    ymax: O
                };
                b.length && y.push({
                    graphMode: 4,
                    segments: [
                        b
                    ],
                    color: c
                        .colorLatexValue ||
                        u
                            .color,
                    tableId: u
                        .tableId,
                    poi: Us(
                        b),
                    movablePointInfo: x,
                    boundingBox: N,
                    pointOpacity: c
                        .computedPointOpacity,
                    pointSize: c
                        .computedMovablePointSize
                }), h.length &&
                    y.push({
                        segments: [
                            h
                        ],
                        droppedIndices: A,
                        graphMode: 3,
                        showPoint:
                            !0,
                        poi: Us(
                            h),
                        color: c
                            .colorLatexValue ||
                            u
                                .color,
                        pointSize: c
                            .computedPointSize,
                        pointOpacity: c
                            .computedPointOpacity,
                        style: u
                            .pointStyle,
                        tableId: u
                            .tableId,
                        boundingBox: N
                    }), (P.length ||
                        M.length) &&
                    (P.push(M), y
                        .push({
                            segments: P
                                .map(
                                    jk
                                ),
                            graphMode: 5,
                            poi: dr(),
                            color: sa(
                                u,
                                c
                            ),
                            style: u
                                .lineStyle,
                            lineWidth: Array
                                .isArray(
                                    c
                                        .computedLineWidth
                                ) ?
                                c
                                    .computedLineWidth[
                                0
                                ] :
                                c
                                    .computedLineWidth,
                            lineOpacity: Array
                                .isArray(
                                    c
                                        .computedLineOpacity
                                ) ?
                                c
                                    .computedLineOpacity[
                                0
                                ] :
                                c
                                    .computedLineOpacity,
                            tableId: u
                                .tableId,
                            boundingBox: N
                        })), y
                            .length && (r[u
                                .id] =
                                y)
            }
            return r
        };

    function Jk(e, t, n) {
        return e ? t === 0 && n ===
            0 ? e[2].type !==
            "none" || e[3].type !==
        "none" : t !== 0 &&
            n !== 0 ? e[0].type !==
            "none" && e[1].type !==
        "none" : t !== 0 ? e[0]
            .type !== "none" : n !==
                0 ? e[1].type !==
        "none" : !1 : !1
    }
    D.Image.prototype.graph =
        function (e, t, n) {
            let r = [];
            if (t.center
                .valueType !== R ||
                t.center
                    .getDependencies()
                    .length !== 0 || !t
                        .radianAngle
                        .isConstant || !t
                            .width.isConstant ||
                !t.height
                    .isConstant || !t
                        .opacity.isConstant)
                return r;
            let i = [],
                s = [],
                o = t.width
                    .asValue() / 2,
                a = t.height
                    .asValue() / 2,
                u = t.radianAngle
                    .asValue();
            for (var c = -1; c <=
                1; c++)
                for (var l = -
                    1; l <= 1; l++
                ) {
                    let [p, f] = t
                        .center
                        .asValue(),
                        m = [p + c *
                            o * Math
                                .cos(
                                    u) + l *
                                    a * Math
                                        .sin(u),
                        f - c *
                        o * Math
                            .sin(
                                u) + l *
                                a * Math
                                    .cos(u)
                        ];
                    Jk(t.moveStrategy,
                        c, l) &&
                        (i.push(m),
                            s.push([c,
                                l
                            ]))
                }
            return r.push({
                segments: [
                    i],
                scaleFactors: [
                    s
                ],
                graphMode: 4,
                color: sa(
                    this
                        .userData,
                    this
                        .metaData
                ),
                style: this
                    .userData
                    .style,
                poi: Us(i),
                movablePointInfo: [],
                pointOpacity: 1
            }), r
        };

    function aA(e) {
        let t = [],
            n = [];
        for (let [r, i] of e) !
            isNaN(r) && !isNaN(i) ?
            t.push(r, i) : (t
                .length >= 4 && n
                    .push(t), t = []);
        return t.length >= 4 && n
            .push(t), n
    }

    function uA(...e) {
        return e.some(t => isNaN(t))
    }

    function Qk(e) {
        return e.isError ? e
            .getError() : e
                .asValue() === void 0 ?
            "" : +e.asValue()
    }

    function Kk(e, t, n) {
        let r = [];
        for (var i = 0; i < t
            .columns.length; i++) {
            let s = n.columns[i],
                o = s.isError ? [] :
                    s.values.map(Qk),
                a = {
                    dependent: !s
                        .isIndependent,
                    discrete: !!s
                        .isIndependent,
                    values: o
                };
            s.isError && (a.error =
                s.getError()), r
                    .push(a)
        }
        return {
            column_data: r
        }
    }

    function ez(e, t, n) {
        let r = {
            variables: [],
            errorMap: {},
            dimensions: {}
        };
        if (e
            .areAllScalesLinear() || (r
                .errorMap.scale = !0
            ), n.center
                .isError && (r.errorMap
                    .center = !0), n
                        .radianAngle.isError &&
            (r.errorMap.angle = !0),
            n.width.isError && (r
                .errorMap.width = !0
            ), n.height
                .isError && (r.errorMap
                    .height = !0), n
                        .opacity.isError && (r
                            .errorMap
                            .opacity = !0),
            Object.keys(r.errorMap)
                .length > 0) return r
                    .variables = t
                        .getSliderVariables(
                            e, n), r;
        r.dimensions.x = [], r
            .dimensions.y = [], r
                .dimensions
                .radianAngle = [], r
                    .dimensions.width = [],
            r.dimensions
                .height = [], r.dimensions
                    .opacity = [];
        let i = [n.center, n
            .radianAngle, n
            .width, n.height, n
            .opacity
        ];
        return i.some(o => o && o
            .valueType && W(o
                .valueType)) &&
            (r.is_concrete_list = !
                0), D.List.eachArgs(
                    i,
                    function (o) {
                        let a = o[0]
                            .asValue(),
                            u = +o[1]
                                .asValue(),
                            c = Math
                                .atan2(Math
                                    .sin(u),
                                    Math
                                        .cos(u)
                                );
                        r.dimensions.x
                            .push(+a[
                                0]), r
                                    .dimensions
                                    .y.push(+a[
                                        1]), r
                                            .dimensions
                                            .radianAngle
                                            .push(c), r
                                                .dimensions
                                                .width.push(
                                                    +o[2]
                                                        .asValue()
                                                ), r
                                                    .dimensions
                                                    .height
                                                    .push(+o[3]
                                                        .asValue()
                                                    ), r
                                                        .dimensions
                                                        .opacity
                                                        .push(Math
                                                            .max(0,
                                                                Math
                                                                    .min(
                                                                        1,
                                                                        +
                                                                        o[
                                                                            4]
                                                                            .asValue()
                                                                    )
                                                            ))
                    }), (e
                        .graphingEnabled() ?
                        t.getGraphMode(e,
                            n) : 10) !== 10 && (
                r.is_graphable = !0
            ), n.moveStrategy &&
            (r.move_strategy = n
                .moveStrategy), t
                    .center && (t.center
                        .type ===
                        "Identifier" ? (r
                            .center_reference_id =
                            t.center
                                .referencedStatementId,
                            r
                                .center_reference_symbol =
                            t.center._symbol
                    ) : t.center
                        .type ===
                    "ParenSeq" && n
                        .center
                        .valueType === R &&
                    (r.center_is_point_literal = !
                        0)), r
    }

    function tz(e, t, n) {
        let r = n.handler,
            i = n.minStep,
            s = {},
            o = {};
        for (let p of r
            .getDependencies())
            e.validActionVariable(
                p) || (s[p] = !0);
        for (let p of i
            .getDependencies())
            o[p] = !0;
        let a;
        if (xo(i)) a = {
            status: "error",
            error: i.getError()
        };
        else {
            let p = i.asValue();
            typeof p == "number" &&
                !isNaN(p) && p >=
                0 ? a = {
                    status: "valid",
                    value: p
                } : a = {
                    status: "error",
                    error: eP()
                        .getError()
                }
        }
        let u = Object.keys(s);
        u.length > 0 && (r = tn(u)
            .setDependencies(r
                .getDependencies()
            ));
        let c;
        r.isError && !tM(e, r) ?
            c = {
                status: "error",
                error: r.getError()
            } : r.isEmptyAction ?
                c = {
                    status: "empty"
                } : c = {
                    status: "maybe-valid"
                };
        let l = {
            handler: c,
            minStep: a,
            variables: []
        };
        return Fu(l, e, {
            ...s,
            ...o
        }), l
    }

    function nz() {
        return {
            operator: "=",
            variables: []
        }
    }

    function yA(e, t, n, r) {
        var c;
        if (Gs(n)) return Kk(e, n,
            r);
        if (rd(n)) return ez(e, n,
            r);
        let i = nz();
        if (n instanceof D.Ticker)
            return e
                .graphingEnabled() ?
                tz(e, n, r) : (i
                    .error = J(
                        "Ticker without graphing"
                    )
                        .getError(), i);
        if (e.is3dProduct()) {
            let l = e,
                p = n.getGraphMode(
                    l, r);
            if ((p === 100 || p ===
                101 || p ===
                102 || p === 5
            ) && r
                .getDependencies()
                .length === 1) {
                let f = r
                    .getDependencies()[
                    0];
                (f === "u" || f ===
                    "v" || f === "t"
                ) && (i
                    .internal_domain_dependency =
                    f)
            }
        }
        if ((c = n.parseOptions) !=
            null && c.selection) {
            let l = r
                .getCursorContext();
            if (l) i
                .cursor_context = {
                ...l,
                selection: n
                    .parseOptions
                    .selection
            };
            else if (xo(r)) {
                let p = iz(e, t, n);
                p && (i.cursor_context = {
                    ...p,
                    selection: n
                        .parseOptions
                        .selection
                })
            }
        }
        if (n instanceof cr &&
            r instanceof pn ? i
                .recursion = r
                    .getRecursiveFunctionMetadata() :
            n instanceof cr &&
            r instanceof C && r
                .recursionMetadata && (i
                    .recursion = r
                        .recursionMetadata),
            n instanceof wi && (i
                .recursion_base_case = {
                symbol: n
                    ._symbol,
                argValue: n
                    .specifiedArg
                    .valid ? n
                        .specifiedArg
                    .argValue :
                    void 0
            }), r.isError && !(
                n instanceof D
                    .FunctionDefinition &&
                !r.blocksExport) &&
            !r.silent) {
            i.error = r.getError(),
                i.variables = n
                    .getSliderVariables(
                        e, r), i
                            .is_single_identifier =
                n instanceof D
                    .Identifier, r
                        .actionValue && (i
                            .action_value =
                            ZE(r
                                .actionValue)
                );
            let l = K0(e, t, n, r);
            return Object.keys(l)
                .length > 0 && (i
                    .geometry = K0(
                        e, t, n, r)
                ), i
        }
        if (r.valueType === Ut && r
            .getDependencies()
            .length === 0) {
            let l = r.asValue();
            i.rgb_value = xc(l[0],
                l[1], l[2])
                .formatHex()
        }
        r.valueType === rt && r
            .getDependencies()
            .length === 0 && (i
                .action_value = ZE(r
                    .asValue())), r
                        .moveStrategy && (i
                            .move_strategy = r
                                .moveStrategy, i
                                    .default_drag_mode =
                            r.defaultDragMode),
            n.isInequality() && (i
                .is_inequality = !0
            ), i.operator = n
                .getOperator(),
            r instanceof D
                .SolvedEquation ? r
                    ._expression
                    .asValue() !== !0 && r
                        ._expression
                        .asValue() !== !1 && (i
                            .assignment = r
                                ._symbol) :
                n instanceof D
                    .Assignment && (n
                        ._symbol.startsWith(
                            "_") || (i
                                .assignment = n
                                    ._symbol)),
            n instanceof D
                .FunctionDefinition && (
                i
                    .function_definition =
                n._symbol);
        let s = e
            .graphingEnabled() ? n
                .getGraphMode(e, r) :
            10;
        if (e.graphingEnabled() && e
            .is3dPolicy() && !ea(
                s) && !cA(s) && (s =
                    10), s !== 10 && (i
                        .is_graphable = !0,
                        i.expression_type =
                        n.getExpressionType(
                            s, r.valueType),
                        e.is3dPolicy() && (i
                            .expression_type ===
                            "SINGLE_POINT" ?
                            i
                                .expression_type =
                            "POINT3D" : i
                                .expression_type ===
                            "POINT_LIST" &&
                            (i.expression_type =
                                "POINT3D_LIST"
                            )), r
                                .valueType && ca(r
                                    .valueType) && (
                            i.map_type = r
                                .valueType), r
                                    .isShadeBetween() &&
                        (i.is_shade_between = !
                            0), i
                                .expression_type !==
                            "POINT3D" && i
                                .expression_type !==
                        "POINT3D_LIST")) {
            let l = n.tableInfo(e,
                r);
            l && (i.is_tableable = !
                0, i
                    .table_info = l)
        }
        if (r.valueType !==
            void 0 && W(r
                .valueType) && (i
                    .is_concrete_list = !
                    0, r.valueType ===
                    Zn && r
                        .getDependencies()
                        .length === 0)) {
            let l = r.asValue();
            l && (i.rgb_value = l
                .map(p => xc(p[
                    0],
                    p[1], p[
                2])
                    .formatHex()
                ))
        }
        if (i.variables = i
            .is_graphable ? [] : n
                .getSliderVariables(e,
                    r), i
                        .is_single_identifier =
            n instanceof D
                .Identifier, r
                .isTypedConstant) {
            let l = r
                .asTypedValue();
            i.typed_constant_value =
                l, (l.valueType ===
                    T || l
                        .valueType ===
                    ge) && (i
                        .constant_value =
                        l.value), rz(l
                            .valueType) && (
                    i.geometry = K0(
                        e, t, n, r))
        }
        let o = r
            .getEvaluationInfo();
        if (o && i.operator ===
            "=" && !n.isConstant &&
            !n.isFunction && !(
                n instanceof D
                    .RecursiveFunctionBaseCase
            ) && r.valueType !==
            ge && r.valueType !==
            Ln && !(n instanceof D
                .Equation) && !(
                    n instanceof D
                        .ComparatorChain) &&
            (i.is_evaluable = !0, i
                .zero_values = o),
            r instanceof D
                .OptimizedRegression) {
            let l = r,
                p = {};
            for (var a in l
                .parameters) l
                    .parameters
                    .hasOwnProperty(
                        a) && (p[ur(a)] = +l
                            .parameters[a]
                            .asValue());
            i.is_regression = !0, i
                .regression = {
                parameters: p,
                residualVariable: ur(
                    l
                        .residualVariable
                ),
                residualSuggestionId: l
                    .residualSuggestionId,
                shouldSuggestLogMode: l
                    .shouldSuggestLogMode,
                isLinear: l
                    .isLinear,
                statistics: l
                    .statistics,
                parameterWarning: l
                    .parameterWarning
            }
        }
        let u = Aa(n);
        return u && u.discrete && (i
            .is_discrete_distribution = !
            0), i
    }

    function rz(e) {
        switch (e) {
            case R:
            case Pt:
            case fe:
            case Bn:
            case Ie:
            case Tn:
            case Le:
            case Gn:
            case he:
            case kn:
            case pe:
            case Fn:
            case ce:
            case Vn:
            case Be:
            case Rn:
            case Ge:
            case gn:
            case Ae:
            case hn:
            case Ue:
            case mr:
                return !0;
            default:
                return !1
        }
    }

    function K0(e, t, n, r) {
        let i = {};
        r.valueType !== void 0 && (i
            .valueType = r
                .valueType), i
                    .valueType && oe(i
                        .valueType, R) && e
                            .graphingEnabled() && n
                                .getGraphMode(e, r) ===
                4 && (i
                    .isMovablePoint = !0
            );
        let {
            identifier: s,
            listAccess: o,
            assignmentRhsReference: a,
            tree: u
        } = jy(n);
        if (s && (i.identifier = s),
            o && (i.listAccess = o),
            a && (i
                .assignmentRhsReference =
                a), u && (i.call =
                    u, r.valueType &&
                    oe(r.valueType,
                        Ue) &&
                    n instanceof cr)) {
            let l = n._expression;
            i.transformation_preview_info = {
                type: u.symbol,
                args: l.args
                    .slice(1)
                    .map(p => p
                        .tryGetConcreteTree(
                            e, t
                        )
                        .asTypedValue()
                    )
            }
        }
        let c = r.moveStrategy && r
            .moveStrategy[0];
        return c &&
            "initialValue" in c && c
                .initialValue !==
            void 0 && (i
                .gliderParameter = c
                    .initialValue), i
    }

    function iz(e, t, n) {
        let r = n.parseOptions;
        if (!(r != null && r
            .selection)) return;
        let {
            start: i,
            end: s,
            input: o
        } = r.selection;
        if (o.trim() === "")
            return {
                type: "empty",
                allowedTypes: [Ht]
            };
        let a = "\\cursor",
            u = o.slice(0, i) + a +
                " " + o.slice(s),
            c = {
                input: u,
                start: i,
                end: i + a.length
            },
            l = Vs(u, {
                ...n
                    .parseOptions,
                selection: c
            });
        return l.isError ? l
            .getCursorContext() :
            mp({
                policy: e,
                frame: t,
                selection: c
            }, l).getCursorContext()
    }

    function Fu(e, t, n) {
        let r = e.variables;
        if (r && r.length) {
            let i = {};
            for (let s of r) i[
                s] = !0;
            for (let s in n) i[
                s] = !0;
            n = i
        }
        e.variables = t
            .sliderVariables(Object
                .keys(n))
    }

    function tM(e, t) {
        if (t.blocksExport) return !
            1;
        let n = t.getDependencies();
        if (n.length === 0) return !
            1;
        for (let r of n)
            if (!e
                .validActionVariable(
                    r)) return !1;
        return !0
    }
    var k = class {
        constructor(t, n, r,
            i) {
            this.policy = t,
                this
                    .rawTree =
                r, this
                    .concreteTree =
                i, this
                    .evaluationState =
                yA(t, n, r,
                    i)
        }
        exportTo(t, n) {
            this.rawTree
                .exportTo(t,
                    this
                        .concreteTree,
                    n)
        }
        graph(t, n) {
            return this
                .rawTree
                .tryGraph(
                    this
                        .policy,
                    this
                        .concreteTree,
                    t, n)
        }
        getGraphMode() {
            return this
                .policy
                .graphingEnabled() ?
                this.rawTree
                    .getGraphMode(
                        this
                            .policy,
                        this
                            .concreteTree
                    ) : 10
        }
        getGraphInfo() {
            return this
                .rawTree
                .getGraphInfo(
                    this
                        .policy,
                    this
                        .concreteTree
                )
        }
        shouldIntersect() {
            if (!this
                .evaluationState
                .is_graphable ||
                !this
                    .rawTree
                    .userData
                    .shouldGraph ||
                !rs
                    .pointsOfInterest
            ) return !1;
            var t = this
                .getGraphMode();
            return t ===
                1 || t === 2
        }
    };
    var F = function () { };
    F.version = "1.2.6";
    F._myIndexOf = function (t) {
        var n = this.length,
            r;
        for (r = 0; r < n; ++r)
            if (this[r] === t)
                return r;
        return -1
    };
    F.myIndexOf = Array.prototype
        .indexOf ? Array.prototype
        .indexOf : F._myIndexOf;
    F.precision = 4;
    F.largeArray = 50;
    F.compile = function () {
        var e = Array.prototype
            .slice.call(
                arguments),
            t = e.pop();
        return t =
            "return function (" +
            e.join(",") +
            ") {" + t + "}",
            new Function([
                "numeric"
            ], t)(F)
    };
    F._dim = function (t) {
        for (var
            n = []; typeof t ==
            "object";) n.push(t
                .length), t = t[
                0];
        return n
    };
    F.dim = function (t) {
        var n, r;
        return typeof t ==
            "object" ? (n = t[
                0], typeof n ==
                    "object" ? (r =
                        n[0],
                        typeof r ==
                            "object" ? F
                                ._dim(t) : [
                            t
                                .length,
                            n.length
                        ]) : [t
                            .length
                ]) : []
    };
    F.mapreduce = function (t, n) {
        return F.compile("x",
            "accum", "_s",
            "_k",
            'if(typeof accum === "undefined") accum = ' +
            n +
            `;
if(typeof x === "number") { var xi = x; ` +
            t + `; return accum; }
if(typeof _s === "undefined") _s = numeric.dim(x);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i,xi;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) {
        accum = arguments.callee(x[i],accum,_s,_k+1);
    }    return accum;
}
for(i=_n-1;i>=1;i-=2) { 
    xi = x[i];
    ` + t + `;
    xi = x[i-1];
    ` + t + `;
}
if(i === 0) {
    xi = x[i];
    ` + t + `
}
return accum;`)
    };
    F.mapreduce2 = function (t, n) {
        return F.compile("x", `var n = x.length;
var i,xi;
` + n + `
for(i=n-1;i!==-1;--i) { 
    xi = x[i];
    ` + t + `
}
return accum;`)
    };
    F.rep = function (t, n, r) {
        typeof r ==
            "undefined" && (r =
                0);
        var i = t[r],
            s = Array(i),
            o;
        if (r === t.length -
            1) {
            for (o = i - 2; o >=
                0; o -= 2) s[o +
                    1] = n, s[
                    o] = n;
            return o === -1 && (
                s[0] = n), s
        }
        for (o = i - 1; o >=
            0; o--) s[o] = F
                .rep(t, n, r + 1);
        return s
    };
    F.dotMMsmall = function (t, n) {
        var r, i, s, o, a, u, c,
            l, p, f, m, g, d, y;
        for (o = t.length, a = n
            .length, u = n[0]
                .length, c = Array(
                    o), r = o -
                    1; r >= 0; r--) {
            for (l = Array(u),
                p = t[r], s =
                u - 1; s >=
                0; s--) {
                for (f = p[a -
                    1] * n[
                    a - 1][
                    s], i =
                    a - 2; i >=
                    1; i -= 2)
                    m = i - 1,
                        f += p[i] *
                        n[i][s] + p[
                        m] * n[
                        m][s];
                i === 0 && (f +=
                    p[0] *
                    n[0][s]
                ), l[
                s] = f
            }
            c[r] = l
        }
        return c
    };
    F._getCol = function (t, n, r) {
        var i = t.length,
            s;
        for (s = i - 1; s >
            0; --s) r[s] = t[s][
                n
            ], --s, r[s] = t[s][
            n
            ];
        s === 0 && (r[0] = t[0][
            n
        ])
    };
    F.dotMMbig = function (t, n) {
        var r = F._getCol,
            i = n.length,
            s = Array(i),
            o = t.length,
            a = n[0].length,
            u = new Array(o),
            c, l = F.dotVV,
            p, f, m, g;
        for (--i, --o, p =
            o; p !== -1; --p) u[
                p] = Array(a);
        for (--a, p = a; p !== -
            1; --p)
            for (r(n, p, s), f =
                o; f !== -1; --f
            ) g = 0, c = t[
                f], u[f][
                p] = l(c, s);
        return u
    };
    F.dotMV = function (t, n) {
        var r = t.length,
            i = n.length,
            s, o = Array(r),
            a = F.dotVV;
        for (s = r - 1; s >=
            0; s--) o[s] = a(t[
                s], n);
        return o
    };
    F.dotVM = function (t, n) {
        var r, i, s, o, a, u, c,
            l, p, f, m, g, d, y,
            h, b, x, P, M;
        for (o = t.length, a =
            n[0].length, c =
            Array(a), s = a -
            1; s >= 0; s--) {
            for (f = t[o - 1] *
                n[o - 1][s], i =
                o - 2; i >=
                1; i -= 2) m =
                    i - 1, f += t[
                    i] * n[i][s] +
                    t[m] * n[m][s];
            i === 0 && (f += t[
                0] * n[
                0][s]), c[
                s] = f
        }
        return c
    };
    F.dotVV = function (t, n) {
        var r, i = t.length,
            s, o = t[i - 1] * n[
                i - 1];
        for (r = i - 2; r >=
            1; r -= 2) s = r -
                1, o += t[r] * n[
                r] + t[s] * n[s];
        return r === 0 && (o +=
            t[0] * n[0]), o
    };
    F.dot = function (t, n) {
        var r = F.dim;
        switch (r(t).length *
        1e3 + r(n).length) {
            case 2002:
                return n
                    .length <
                    10 ? F
                        .dotMMsmall(
                            t, n) :
                    F.dotMMbig(
                        t, n);
            case 2001:
                return F.dotMV(
                    t, n);
            case 1002:
                return F.dotVM(
                    t, n);
            case 1001:
                return F.dotVV(
                    t, n);
            case 1e3:
                return F.mulVS(
                    t, n);
            case 1:
                return F.mulSV(
                    t, n);
            case 0:
                return t * n;
            default:
                throw new Error(
                    "numeric.dot only works on vectors and matrices"
                )
        }
    };
    F.diag = function (t) {
        var n, r, i, s = t
            .length,
            o = Array(s),
            a;
        for (n = s - 1; n >=
            0; n--) {
            for (a = Array(s),
                r = n + 2, i =
                s - 1; i >=
                r; i -= 2) a[
                    i] = 0, a[i -
                    1] = 0;
            for (i > n && (a[
                i] = 0), a[
                n] = t[n],
                i = n - 1; i >=
                1; i -= 2) a[
                    i] = 0, a[i -
                    1] = 0;
            i === 0 && (a[0] =
                0), o[n] = a
        }
        return o
    };
    F.getDiag = function (e) {
        var t = Math.min(e
            .length, e[0]
            .length),
            n, r = Array(t);
        for (n = t - 1; n >=
            1; --n) r[n] = e[n][
                n
            ], --n, r[n] = e[n][
            n
            ];
        return n === 0 && (r[
            0] = e[0][0]), r
    };
    F.identity = function (t) {
        return F.diag(F.rep([t],
            1))
    };
    F.pointwise = function (t, n,
        r) {
        typeof r ==
            "undefined" && (r =
                "");
        var i = [],
            s, o = /\[i\]$/,
            a, u = "",
            c = !1;
        for (s = 0; s < t
            .length; s++) o
                .test(t[s]) ? (a =
                    t[s].substring(
                        0, t[s]
                            .length - 3
                    ), u = a) :
                a = t[s], a ===
                "ret" && (c = !0), i
                    .push(a);
        return i[t.length] =
            "_s", i[t.length +
            1] = "_k", i[t
                .length + 2] =
            'if(typeof _s === "undefined") _s = numeric.dim(' +
            u + `);
if(typeof _k === "undefined") _k = 0;
var _n = _s[_k];
var i` + (c ? "" : ", ret = Array(_n)") +
            `;
if(_k < _s.length-1) {
    for(i=_n-1;i>=0;i--) ret[i] = arguments.callee(` + t.join(
                ",") + `,_s,_k+1);
    return ret;
}
` + r + `
for(i=_n-1;i!==-1;--i) {
    ` + n + `
}
return ret;`, F.compile.apply(null, i)
    };
    F.pointwise2 = function (t, n,
        r) {
        typeof r ==
            "undefined" && (r =
                "");
        var i = [],
            s, o = /\[i\]$/,
            a, u = "",
            c = !1;
        for (s = 0; s < t
            .length; s++) o
                .test(t[s]) ? (a =
                    t[s].substring(
                        0, t[s]
                            .length - 3
                    ), u = a) :
                a = t[s], a ===
                "ret" && (c = !0), i
                    .push(a);
        return i[t.length] =
            "var _n = " + u + `.length;
var i` + (c ? "" : ", ret = Array(_n)") + `;
` + r + `
for(i=_n-1;i!==-1;--i) {
` + n + `
}
return ret;`, F.compile.apply(null, i)
    };
    F._biforeach = function e(t, n,
        r, i, s) {
        if (i === r.length -
            1) {
            s(t, n);
            return
        }
        var o, a = r[i];
        for (o = a - 1; o >=
            0; o--) e(
                typeof t ==
                    "object" ? t[
                o] : t,
                typeof n ==
                    "object" ? n[
                o] : n, r, i +
            1, s)
    };
    F._biforeach2 = function e(t, n,
        r, i, s) {
        if (i === r.length - 1)
            return s(t, n);
        var o, a = r[i],
            u = Array(a);
        for (o = a - 1; o >=
            0; --o) u[o] = e(
                typeof t ==
                    "object" ? t[
                o] : t,
                typeof n ==
                    "object" ? n[
                o] : n, r, i +
            1, s);
        return u
    };
    F._foreach = function e(t, n, r,
        i) {
        if (r === n.length -
            1) {
            i(t);
            return
        }
        var s, o = n[r];
        for (s = o - 1; s >=
            0; s--) e(t[s], n,
                r + 1, i)
    };
    F._foreach2 = function e(t, n,
        r, i) {
        if (r === n.length - 1)
            return i(t);
        var s, o = n[r],
            a = Array(o);
        for (s = o - 1; s >=
            0; s--) a[s] = e(t[
                s], n, r +
            1, i);
        return a
    };
    F.ops2 = {
        add: "+",
        sub: "-",
        mul: "*",
        div: "/",
        mod: "%",
        and: "&&",
        or: "||",
        eq: "===",
        neq: "!==",
        lt: "<",
        gt: ">",
        leq: "<=",
        geq: ">=",
        band: "&",
        bor: "|",
        bxor: "^",
        lshift: "<<",
        rshift: ">>",
        rrshift: ">>>"
    };
    F.opseq = {
        addeq: "+=",
        subeq: "-=",
        muleq: "*=",
        diveq: "/=",
        modeq: "%=",
        lshifteq: "<<=",
        rshifteq: ">>=",
        rrshifteq: ">>>=",
        bandeq: "&=",
        boreq: "|=",
        bxoreq: "^="
    };
    F.mathfuns = ["abs", "acos",
        "asin", "atan", "ceil",
        "cos", "exp", "floor",
        "log", "round", "sin",
        "sqrt", "tan", "isNaN",
        "isFinite"
    ];
    F.mathfuns2 = ["atan2", "pow",
        "max", "min"
    ];
    F.ops1 = {
        neg: "-",
        not: "!",
        bnot: "~",
        clone: ""
    };
    F.mapreducers = {
        any: ["if(xi) return true;",
            "var accum = false;"
        ],
        all: ["if(!xi) return false;",
            "var accum = true;"
        ],
        sum: ["accum += xi;",
            "var accum = 0;"
        ],
        prod: ["accum *= xi;",
            "var accum = 1;"
        ],
        norm2Squared: [
            "accum += xi*xi;",
            "var accum = 0;"
        ],
        norminf: [
            "accum = max(accum,abs(xi));",
            "var accum = 0, max = Math.max, abs = Math.abs;"
        ],
        norm1: ["accum += abs(xi);",
            "var accum = 0, abs = Math.abs;"
        ],
        sup: ["accum = max(accum,xi);",
            "var accum = -Infinity, max = Math.max;"
        ],
        inf: ["accum = min(accum,xi);",
            "var accum = Infinity, min = Math.min;"
        ]
    };
    (function () {
        var e, t;
        for (e = 0; e < F
            .mathfuns2
            .length; ++e) t = F
                .mathfuns2[e], F
                    .ops2[t] = t;
        for (e in F.ops2)
            if (F.ops2
                .hasOwnProperty(
                    e)) {
                t = F.ops2[e];
                var n, r, i =
                    "";
                F.myIndexOf
                    .call(F
                        .mathfuns2,
                        e) !== -
                    1 ? (i =
                        "var " +
                        t +
                        " = Math." +
                        t + `;
`, n = function (s, o, a) {
                            return s +
                                " = " +
                                t +
                                "(" +
                                o +
                                "," +
                                a +
                                ")"
                        }, r =
                        function (
                            s, o
                        ) {
                            return s +
                                " = " +
                                t +
                                "(" +
                                s +
                                "," +
                                o +
                                ")"
                        }) : (
                    n =
                    function (
                        s,
                        o, a
                    ) {
                        return s +
                            " = " +
                            o +
                            " " +
                            t +
                            " " +
                            a
                    }, F
                        .opseq
                        .hasOwnProperty(
                            e +
                            "eq"
                        ) ?
                        r =
                        function (
                            s, o
                        ) {
                            return s +
                                " " +
                                t +
                                "= " +
                                o
                        } : r =
                        function (
                            s, o
                        ) {
                            return s +
                                " = " +
                                s +
                                " " +
                                t +
                                " " +
                                o
                        }), F[
                        e + "VV"
                        ] = F
                            .pointwise2(
                                ["x[i]",
                                    "y[i]"
                                ], n(
                                    "ret[i]",
                                    "x[i]",
                                    "y[i]"
                                ), i
                            ), F[e +
                            "SV"] =
                    F
                        .pointwise2(
                            ["x",
                                "y[i]"
                            ], n(
                                "ret[i]",
                                "x",
                                "y[i]"
                            ), i
                        ), F[e +
                        "VS"] =
                    F
                        .pointwise2(
                            ["x[i]",
                                "y"
                            ], n(
                                "ret[i]",
                                "x[i]",
                                "y"
                            ), i
                        ), F[
                        e] = F
                            .compile(`var n = arguments.length, i, x = arguments[0], y;
var VV = numeric.` + e + "VV, VS = numeric." +
                                e +
                                "VS, SV = numeric." +
                                e + `SV;
var dim = numeric.dim;
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof x === "object") {
      if(typeof y === "object") x = numeric._biforeach2(x,y,dim(x),0,VV);
      else x = numeric._biforeach2(x,y,dim(x),0,VS);
  } else if(typeof y === "object") x = numeric._biforeach2(x,y,dim(y),0,SV);
  else ` + r("x", "y") + `
}
return x;
`), F[t] = F[e], F[e + "eqV"] = F
                        .pointwise2(
                            ["ret[i]",
                                "x[i]"
                            ], r(
                                "ret[i]",
                                "x[i]"
                            ), i
                        ), F[e +
                        "eqS"] =
                    F
                        .pointwise2(
                            ["ret[i]",
                                "x"
                            ], r(
                                "ret[i]",
                                "x"
                            ), i
                        ), F[e +
                        "eq"] =
                    F.compile(`var n = arguments.length, i, x = arguments[0], y;
var V = numeric.` + e + "eqV, S = numeric." +
                        e + `eqS
var s = numeric.dim(x);
for(i=1;i!==n;++i) { 
  y = arguments[i];
  if(typeof y === "object") numeric._biforeach(x,y,s,0,V);
  else numeric._biforeach(x,y,s,0,S);
}
return x;
`)
            } for (e = 0; e < F
                .mathfuns2
                .length; ++e) t = F
                    .mathfuns2[e],
                    delete F.ops2[t];
        for (e = 0; e < F
            .mathfuns.length; ++
            e) t = F.mathfuns[
                e], F.ops1[t] = t;
        for (e in F.ops1) F.ops1
            .hasOwnProperty(
                e) && (i = "", t = F
                    .ops1[e], F
                        .myIndexOf.call(
                            F.mathfuns,
                            e) !== -1 &&
                    Math
                        .hasOwnProperty(
                            t) && (i =
                                "var " + t +
                                " = Math." +
                                t + `;
`), F[e + "eqV"] = F.pointwise2([
                                    "ret[i]"
                                ],
                                    "ret[i] = " +
                                    t +
                                    "(ret[i]);",
                                    i), F[e +
                                    "eq"] = F
                                        .compile("x",
                                            'if(typeof x !== "object") return ' +
                                            t + `x
var i;
var V = numeric.` + e + `eqV;
var s = numeric.dim(x);
numeric._foreach(x,s,0,V);
return x;
`), F[e + "V"] = F.pointwise2(["x[i]"],
                                                "ret[i] = " +
                                                t +
                                                "(x[i]);", i
                                            ), F[e] = F
                                                .compile("x",
                                                    'if(typeof x !== "object") return ' +
                                                    t + `(x)
var i;
var V = numeric.` + e + `V;
var s = numeric.dim(x);
return numeric._foreach2(x,s,0,V);
`));
        for (e = 0; e < F
            .mathfuns.length; ++
            e) t = F.mathfuns[
                e], delete F.ops1[
                t];
        for (e in F.mapreducers)
            F.mapreducers
                .hasOwnProperty(
                    e) && (t = F
                        .mapreducers[e],
                        F[e + "V"] = F
                            .mapreduce2(t[
                                0], t[1]),
                        F[e] = F
                            .compile("x",
                                "s", "k", t[
                                1] + `if(typeof x !== "object") {    xi = x;
` + t[0] + `
    return accum;
}if(typeof s === "undefined") s = numeric.dim(x);
if(typeof k === "undefined") k = 0;
if(k === s.length-1) return numeric.` +
                                e + `V(x);
var xi;
var n = x.length, i;
for(i=n-1;i!==-1;--i) {
   xi = arguments.callee(x[i]);
` + t[0] + `
}
return accum;
`))
    })();
    F.inv = function (d) {
        var n = F.dim(d),
            r = Math.abs,
            i = n[0],
            s = n[1],
            o = F.clone(d),
            a, u, c = F
                .identity(i),
            l, p, f, m, g, d;
        for (m = 0; m < s; ++
            m) {
            var y = -1,
                h = -1;
            for (f = m; f !==
                i; ++f) g = r(o[
                    f][m]), g >
                    h && (y = f, h =
                        g);
            for (u = o[y], o[
                y] = o[m], o[
                m] = u, p = c[
                y], c[y] = c[m],
                c[m] = p, d = u[
                m], g =
                m; g !== s; ++g)
                u[g] /= d;
            for (g = s -
                1; g !== -1; --g
            ) p[g] /= d;
            for (f = i -
                1; f !== -1; --f
            )
                if (f !== m) {
                    for (a = o[
                        f],
                        l = c[
                        f], d =
                        a[m],
                        g = m +
                        1; g !==
                        s; ++g)
                        a[g] -=
                            u[g] *
                            d;
                    for (g = s -
                        1; g >
                        0; --g)
                        l[g] -=
                            p[g] *
                            d, --g,
                            l[g] -=
                            p[g] *
                            d;
                    g === 0 && (
                        l[
                        0] -=
                        p[
                        0] *
                        d)
                }
        }
        return c
    };
    F.det = function (t) {
        var n = F.dim(t);
        if (n.length !== 2 || n[
            0] !== n[1])
            throw new Error(
                "numeric: det() only works on square matrices"
            );
        var r = n[0],
            i = 1,
            s, o, a, u = F
                .clone(t),
            c, l, p, f, m, g, d;
        for (o = 0; o < r -
            1; o++) {
            for (a = o, s = o +
                1; s < r; s++)
                Math.abs(u[s][
                    o]) > Math
                        .abs(u[a][o]) &&
                    (a = s);
            for (a !== o && (f =
                u[a], u[a] =
                u[o], u[o] =
                f, i *= -1),
                c = u[o], s =
                o + 1; s <
                r; s++) {
                for (l = u[s],
                    p = l[o] /
                    c[o], a =
                    o + 1; a <
                    r - 1; a +=
                    2) m = a +
                        1, l[a] -=
                        c[a] * p, l[
                        m] -= c[
                        m] * p;
                a !== r && (l[
                    a] -= c[
                    a] *
                    p)
            }
            if (c[o] === 0)
                return 0;
            i *= c[o]
        }
        return i * u[o][o]
    };
    F.transpose = function (t) {
        var n, r, i = t.length,
            s = t[0].length,
            o = Array(s),
            a, u, c;
        for (r = 0; r < s; r++)
            o[r] = Array(i);
        for (n = i - 1; n >=
            1; n -= 2) {
            for (u = t[n], a =
                t[n - 1], r =
                s - 1; r >=
                1; --r) c = o[
                    r], c[n] = u[r],
                    c[n - 1] = a[r],
                    --r, c = o[r],
                    c[n] = u[r], c[
                    n - 1] = a[
                    r];
            r === 0 && (c = o[
                0], c[n] =
                u[0], c[n -
                1] = a[
                0])
        }
        if (n === 0) {
            for (a = t[0], r =
                s - 1; r >=
                1; --r) o[r][
                    0] = a[r], --r,
                    o[r][0] = a[r];
            r === 0 && (o[0][
                0] = a[0])
        }
        return o
    };
    F.negtranspose = function (t) {
        var n, r, i = t.length,
            s = t[0].length,
            o = Array(s),
            a, u, c;
        for (r = 0; r < s; r++)
            o[r] = Array(i);
        for (n = i - 1; n >=
            1; n -= 2) {
            for (u = t[n], a =
                t[n - 1], r =
                s - 1; r >=
                1; --r) c = o[
                    r], c[n] = -u[
                    r], c[n - 1] = -
                    a[r], --r, c =
                    o[r], c[n] = -u[
                    r], c[n -
                    1] = -a[r];
            r === 0 && (c = o[
                0], c[n] = -
                u[0], c[n -
                1] = -a[
                0])
        }
        if (n === 0) {
            for (a = t[0], r =
                s - 1; r >=
                1; --r) o[r][
                    0] = -a[r], --r,
                    o[r][0] = -a[r];
            r === 0 && (o[0][
                0] = -a[0])
        }
        return o
    };
    F.norm2 = function (t) {
        return Math.sqrt(F
            .norm2Squared(t)
        )
    };
    F.linspace = function (t, n, r) {
        if (typeof r ==
            "undefined" && (r =
                Math.max(Math
                    .round(n -
                        t) + 1,
                    1)), r < 2)
            return r === 1 ? [
                t] : [];
        var i, s = Array(r);
        for (r--, i = r; i >=
            0; i--) s[i] = (i *
                n + (r - i) * t
            ) / r;
        return s
    };
    F.getBlock = function (t, n, r) {
        var i = F.dim(t);

        function s(o, a) {
            var u, c = n[a],
                l = r[a] - c,
                p = Array(l);
            if (a === i.length -
                1) {
                for (u = l; u >=
                    0; u--) p[
                        u] = o[u +
                        c];
                return p
            }
            for (u = l; u >=
                0; u--) p[u] =
                    s(o[u + c], a +
                        1);
            return p
        }
        return s(t, 0)
    };
    F.setBlock = function (t, n, r,
        i) {
        var s = F.dim(t);

        function o(a, u, c) {
            var l, p = n[c],
                f = r[c] - p;
            if (c === s.length -
                1)
                for (l = f; l >=
                    0; l--) a[
                        l + p] =
                        u[l];
            for (l = f; l >=
                0; l--) o(a[l +
                    p], u[
                l], c + 1)
        }
        return o(t, i, 0), t
    };
    F.getRange = function (t, n, r) {
        var i = n.length,
            s = r.length,
            o, a, u = Array(i),
            c, l;
        for (o = i - 1; o !== -
            1; --o)
            for (u[o] = Array(
                s), c = u[o],
                l = t[n[o]], a =
                s - 1; a !== -
                1; --a) c[a] =
                    l[r[a]];
        return u
    };
    F.blockMatrix = function (t) {
        var n = F.dim(t);
        if (n.length < 4)
            return F
                .blockMatrix([
                    t]);
        var r = n[0],
            i = n[1],
            s, o, a, u, c;
        for (s = 0, o = 0, a =
            0; a < r; ++a) s +=
                t[a][0].length;
        for (u = 0; u < i; ++u)
            o += t[0][u][0]
                .length;
        var l = Array(s);
        for (a = 0; a < s; ++a)
            l[a] = Array(o);
        var p = 0,
            f, m, g, d, y;
        for (a = 0; a < r; ++
            a) {
            for (f = o, u = i -
                1; u !== -1; --u
            )
                for (c = t[a][
                    u], f -= c[
                        0]
                        .length, g =
                    c.length -
                    1; g !== -
                    1; --g)
                    for (y = c[
                        g],
                        m = l[
                        p +
                        g],
                        d = y
                            .length -
                        1; d !==
                        -1; --d)
                        m[f +
                            d] = y[
                            d];
            p += t[a][0].length
        }
        return l
    };
    F.tensor = function (t, n) {
        if (typeof t ==
            "number" ||
            typeof n == "number"
        ) return F.mul(t,
            n);
        var r = F.dim(t),
            i = F.dim(n);
        if (r.length !== 1 || i
            .length !== 1)
            throw new Error(
                "numeric: tensor product is only defined for vectors"
            );
        var s = r[0],
            o = i[0],
            a = Array(s),
            u, c, l, p;
        for (c = s - 1; c >=
            0; c--) {
            for (u = Array(o),
                p = t[c], l =
                o - 1; l >=
                3; --l) u[l] =
                    p * n[l], --l,
                    u[l] = p * n[l],
                    --l, u[l] = p *
                    n[l], --l, u[
                    l] = p * n[l];
            for (; l >= 0;) u[
                l] = p * n[l],
                --l;
            a[c] = u
        }
        return a
    };
    F.epsilon =
        2220446049250313e-31;
    F.LU = function (e, t) {
        t = t || !1;
        var n = Math.abs,
            r, i, s, o, a, u, c,
            l, p, f = e.length,
            m = f - 1,
            g = new Array(f);
        for (t || (e = F.clone(
            e)), s = 0; s <
            f; ++s) {
            for (c = s, u = e[
                s], p = n(u[s]),
                i = s + 1; i <
                f; ++i) o = n(e[
                    i][s]), p <
                    o && (p = o, c =
                        i);
            for (g[s] = c, c !=
                s && (e[s] = e[
                    c], e[
                    c] = u, u =
                    e[s]), a =
                u[s], r = s +
                1; r < f; ++r)
                e[r][s] /= a;
            for (r = s + 1; r <
                f; ++r) {
                for (l = e[r],
                    i = s +
                    1; i < m; ++
                    i) l[i] -=
                        l[s] * u[i],
                        ++i, l[i] -=
                        l[s] * u[i];
                i === m && (l[
                    i] -= l[
                    s] *
                    u[i])
            }
        }
        return {
            LU: e,
            P: g
        }
    };
    F.LUsolve = function (t, n) {
        var r, i, s = t.LU,
            o = s.length,
            a = F.clone(n),
            u = t.P,
            c, l, p, f;
        for (r = o - 1; r !== -
            1; --r) a[r] = n[r];
        for (r = 0; r < o; ++r)
            for (c = u[r], u[
                r] !== r && (f =
                    a[r], a[r] =
                    a[c], a[c] =
                    f), l = s[
                    r], i = 0; i <
                r; ++i) a[r] -=
                    a[i] * l[i];
        for (r = o - 1; r >=
            0; --r) {
            for (l = s[r], i =
                r + 1; i < o; ++
                i) a[r] -= a[
                    i] * l[i];
            a[r] /= l[r]
        }
        return a
    };
    F.solve = function (t, n, r) {
        return F.LUsolve(F.LU(t,
            r), n)
    };
    var On = F;

    function sz(e, t) {
        let n = e.length,
            r = t.length,
            i = 0,
            s = 0;
        for (let a = r - n; a <
            r; a++) i += e[a + n -
                r] * t[a], s += e[
                a + n - r] * e[a +
                n - r];
        let o = i / s;
        for (let a = r - n; a <
            r; a++) t[a] = 2 * o *
                e[a + n - r] - t[a]
    }

    function oz(e, t, n) {
        let r = e.length,
            i = t.length,
            s = 0,
            o = 0;
        for (let u = i - r; u <
            i; u++) s += e[u + r -
                i] * t[u][n], o +=
                e[u + r - i] * e[u + r -
                i];
        let a = s / o;
        for (let u = i - r; u <
            i; u++) t[u][n] = 2 *
                a * e[u + r - i] - t[u][
                n
                ]
    }

    function az(e, t, n, r) {
        let i = Array(e.length - t);
        if (i.length === 1)
            return i[0] = 1, i;
        if (r === 0) {
            i[0] = 1;
            for (let o = 1; o < i
                .length; o++) i[o] =
                    0;
            return i
        }
        let s = e[t][n] < 0 ? -1 :
            1;
        i[0] = e[t][n] + s * Math
            .sqrt(r);
        for (let o = t + 1; o < e
            .length; o++) i[o - t] =
                e[o][n];
        return i
    }

    function uz(e, t, n) {
        let r = 0;
        for (; t < e.length; t++)
            r += e[t][n] * e[t][n];
        return r
    }

    function Ph(e, t) {
        if (!t || !t.mutateInput) {
            let s = e;
            e = Array(e.length);
            for (let o = 0; o < s
                .length; o++) e[o] =
                    s[o].slice()
        }
        let n = Math.min(e.length,
            e[0].length),
            r = Array(n),
            i = [];
        for (let s = 0; s <
            n; s++) {
            let o = -1 / 0,
                a = s;
            for (let c = s; c < e[s]
                .length; c++) {
                let l = uz(e, s, c);
                l > o && (o = l, a =
                    c)
            }
            if (r[s] = a, a !== s)
                for (let c = 0; c <
                    e.length; c++) {
                    let l = e[c][a];
                    e[c][a] = e[c][
                        s], e[c]
                        [s] = l
                }
            let u = az(e, s, s, o);
            for (let c = s; c < e[s]
                .length; c++) oz(u,
                    e, c);
            i.push(u)
        }
        return {
            reflectors: i,
            r: e,
            p: r
        }
    }

    function gA(e, t, n) {
        let {
            reflectors: r,
            r: i,
            p: s
        } = e, o = t.slice();
        for (let c = 0; c < r
            .length; c++) sz(r[c],
                o);
        for (let c = r.length; c <
            i[0].length; c++) o[c] =
                0;
        o.length = i[0].length;
        let a = Math.pow(2, -52),
            u = n.regularize ? a *
                Math.abs(i[0][0]) * Math
                    .max(i.length, i[0]
                        .length) : 0;
        for (let c = r.length -
            1; c >= 0; c--) {
            let l = i[c];
            if (Math.abs(l[c]) <= u)
                o[c] = 0;
            else {
                for (let p = c +
                    1; p < r
                        .length; p++) o[
                            c] -= o[p] *
                            l[p];
                o[c] /= l[c]
            }
        }
        for (let c = s.length -
            1; c >= 0; c--)
            if (s[c] !== c) {
                let l = o[c];
                o[c] = o[s[c]], o[s[
                    c]] = l
            } return o
    }

    function cz(e, t, n) {
        let r = Array(e.r[0]
            .length);
        for (let s = 0; s < r
            .length; s++) r[s] =
                Array(t[0].length);
        let i = Array(t.length);
        for (let s = 0; s < t[0]
            .length; s++) {
            for (let a = 0; a < t
                .length; a++) i[a] =
                    t[a][s];
            let o = gA(e, i, n);
            for (let a = 0; a < o
                .length; a++) r[a][
                    s] = o[a]
        }
        return r
    }

    function qc(e, t, n) {
        return Array.isArray(t[0]) ?
            cz(e, t, n) : gA(e, t,
                n)
    }

    function lz(e) {
        let t = e.r,
            n = Math.min(t.length,
                t[0].length),
            r = t[0][0],
            i = t[n - 1][n - 1];
        return r === 0 ? 1 / 0 :
            Math.abs(r / i)
    }

    function hA(e) {
        let t = Math.pow(2, -52);
        return Math.max(e.r.length,
            e.r[0].length) * t *
            lz(e) < 1
    }
    var pz = Math.pow(2, -52);

    function Ih(e) {
        for (let t of e)
            for (let n of t)
                if (!En(n)) return !
                    1;
        return !0
    }

    function fz(e) {
        let t = [];
        for (let n of e) t.push(n
            .slice());
        return t
    }

    function xA(e) {
        let {
            numRows: t,
            numCols: n
        } = Th(e), r = [];
        for (let i = 0; i < n; i++)
            r.push([]);
        for (let i = 0; i < t; i++)
            for (let s = 0; s <
                n; s++) r[s].push(e[
                    i][s]);
        return r
    }

    function Th(e) {
        let t = e.length,
            n = t > 0 ? e[0]
                .length : 0;
        return {
            numRows: t,
            numCols: n
        }
    }

    function dz() {
        throw new Error(
            "Matrix dimension mismatch"
        )
    }

    function nM(e, t) {
        let n = Th(e),
            r = Th(t);
        n.numCols !== r.numRows &&
            dz();
        let i = [];
        for (let s = 0; s < n
            .numRows; s++) {
            let o = [];
            for (let a = 0; a < r
                .numCols; a++) {
                let u = De(0, 1);
                for (let c = 0; c <
                    e[s].length; c++
                ) u = us(u, cs(
                    e[s][c],
                    t[c][a]
                ));
                o.push(u)
            }
            i.push(o)
        }
        return i
    }

    function PA(e) {
        let t = fz(e);
        return yz(t), t
    }

    function mz(e) {
        let t = 0;
        for (let n of e)
            for (let r of n) {
                let i = Math.abs(q(
                    r));
                if (!isFinite(i))
                    return NaN;
                i > t && (t = i)
            }
        return t
    }

    function bA(e) {
        for (let t = 0; t < e
            .length; t++)
            for (let n = 0; n < e[t]
                .length; n++) e[t][
                    n] = NaN
    }

    function yz(e) {
        let {
            numRows: t,
            numCols: n
        } = Th(e), r = mz(e);
        if (!isFinite(r)) return bA(
            e), {
            determinant: NaN,
            rank: 0
        };
        let i = Math.max(t, n) * r *
            pz,
            s = De(1, 1),
            o = 0,
            a = 0;
        for (; o < t && a < n;) {
            let u = o,
                c = Math.abs(q(e[o][
                    a
                ]));
            for (let p = o + 1; p <
                t; p++) {
                let f = Math.abs(q(
                    e[p][a]
                ));
                (!isFinite(f) || f >
                    c) && (c = f,
                        u = p)
            }
            if (!isFinite(c))
                return bA(e), {
                    determinant: NaN,
                    rank: 0
                };
            if (c === 0) {
                s = De(0, 1), a +=
                    1;
                continue
            }
            if (!En(e[u][a]) && c <
                i) {
                for (let p = o; p <
                    t; p++) e[o][
                        p] = 0;
                s = 0, a += 1;
                continue
            }
            if (u !== o) {
                s = hi(s);
                let p = e[o];
                e[o] = e[u], e[u] =
                    p
            }
            for (let p = 0; p <
                t; p++) {
                if (p === o)
                    continue;
                let f = Ji(e[p][a],
                    e[o][a]);
                e[p][a] = De(0, 1);
                for (let m = a +
                    1; m < n; m++)
                    e[p][m] = ji(e[
                        p][m],
                        cs(f, e[o][
                            m]))
            }
            let l = e[o][a];
            s = cs(s, l), e[o][a] =
                De(1, 1);
            for (let p = a + 1; p <
                n; p++) e[o][p] =
                    Ji(e[o][p], l);
            o += 1, a += 1
        }
        return {
            rank: o,
            determinant: o === t &&
                o === n ? s : De(0,
                    1)
        }
    }

    function Mh(e, t) {
        let n = [];
        for (let r = 0; r < t; r++)
            n.push(e);
        return n
    }

    function Bu(e, t) {
        let n = Vu(e, t),
            r = 0;
        for (let i of n) {
            let s = i;
            r += s * s
        }
        return r / n.length
    }

    function Vu(e, t) {
        return e.apply(void 0, t)
    }

    function Eh(e, t) {
        let n = [];
        for (let r of e) {
            let i = r.apply(void 0,
                t);
            n.push(i)
        }
        return n
    }

    function TA(e, t) {
        let n = [];
        for (let r = 0; r < e
            .length; r++) t[r] && n
                .push(e[r]);
        return n
    }

    function rM(e, t, n) {
        let r = [];
        for (let i = 0, s = 0; i < e
            .length; i++) {
            let o = 0;
            n[i] && (o = t[s], s +=
                1), r.push(e[
                    i] + o)
        }
        return r
    }

    function oM(e, t) {
        let n = t.solution.map(u =>
            Math.abs(u) < 1e-6 ?
                0 : u),
            r = t.solution.map(() =>
                0),
            i = Bu(e, n),
            s = Vu(e, n),
            o = Vu(e, r),
            a = 0;
        for (let u = 0; u < s
            .length; u++) {
            let c = o[u] * 1e-15;
            a += Math.abs(s[u] *
                c) + c * c
        }
        return a /= s.length,
            isFinite(a) || (a = 0),
            isFinite(t.MSE) && !
                isFinite(i) ? t : i <= t
                    .MSE + a ? {
                solution: n,
                MSE: i
            } : t
    }

    function aM(e, t) {
        if (!Ih(t) || !Ih([e]))
            return;
        let n = xA(t),
            r = nM([e], n)[0],
            i = nM(t, n);
        for (let c = 0; c < r
            .length; c++) i[c].push(
                hi(r[c]));
        let s = PA(i);
        if (!Ih(s)) return;
        let o = [],
            a = r.length,
            u = 0;
        for (let c of s)
            for (; u < a;)
                if (q(c[u]) === 1) {
                    o.push(c[c.length -
                        1]), u++;
                    break
                } else o.push(De(0,
                    1)), u++;
        for (; u < a;) o.push(De(0,
            1)), u++;
        return o
    }

    function uM(e, t) {
        let n = Mh(0, t.length),
            r = Eh(t, n),
            i = Ph(On.transpose(
                r), {
                mutateInput: !0
            });
        for (var s = 0; s <
            2; s++) {
            let c = Vu(e, n),
                l = On.neg(qc(i,
                    c, {
                    regularize:
                        !1
                }));
            n = On.add(n, l)
        }
        let o = Bu(e, n);
        if (hA(i)) return {
            solution: n,
            MSE: o
        };
        let a = Mh(0, t.length);
        for (var s = 0; s <
            2; s++) {
            let l = Vu(e, a),
                p = On.neg(qc(i,
                    l, {
                    regularize:
                        !0
                }));
            a = On.add(a, p)
        }
        let u = Bu(e, a);
        return .999 * u <= o ? {
            solution: a,
            MSE: u
        } : {
            solution: n,
            MSE: o
        }
    }

    function iM(e, t, n, r) {
        let i = r.maxIterations,
            s = r.linearSubset ||
                Mh(!1, n.length),
            o = On.not(s),
            a = TA(t, s),
            u = TA(t, o),
            c = 2,
            l = .1,
            p = n,
            f = 0,
            m = .001,
            g;
        if (On.any(s)) {
            let h = On.transpose(Eh(
                a, p)),
                b = Ph(h);
            g = {
                Jv: h,
                F: b
            };
            let x = Vu(e, p),
                P = On.neg(qc(b,
                    x, {
                    regularize:
                        !0
                }));
            p = rM(p, P, s)
        }
        let d = !1,
            y = Bu(e, p);
        for (; f < i && !d &&
            isFinite(y);) {
            let h = Vu(e, p),
                b = Eh(u, p),
                x = On.transpose(b),
                P, M;
            if (g) {
                let {
                    F: v,
                    Jv: O
                } = g;
                P = On.dot(b, On
                    .sub(h, On
                        .dot(O,
                            qc(v,
                                h, {
                                regularize:
                                    !
                                    0
                            }
                            )
                        ))),
                    M = On.dot(b, On
                        .sub(x, On
                            .dot(O,
                                qc(v,
                                    x, {
                                    regularize:
                                        !
                                        0
                                }
                                )
                            )))
            } else P = On.dot(b, h),
                M = On.dot(b, x);
            let I = p,
                E = !1;
            for (; f < i && !d && !
                E;) {
                f += 1;
                let v = On.add(M, On
                    .diag(Mh(m,
                        u
                            .length
                    ))),
                    O = On.neg(On
                        .solve(v, P,
                            !0));
                I = rM(p, O, o), d =
                    On.all(On.eq(I,
                        p));
                let A;
                if (g) {
                    let L = On
                        .transpose(
                            Eh(a, I)
                        ),
                        z = Ph(L);
                    A = {
                        Jv: L,
                        F: z
                    };
                    let G = Vu(e,
                        I),
                        $ = On.neg(
                            qc(z,
                                G, {
                                regularize:
                                    !
                                    0
                            }));
                    I = rM(I, $, s)
                }
                let N = Bu(e, I);
                E = N < y, E ? (p =
                    I, y = N,
                    g = A, m *=
                    l) : (m =
                        Math.max(m,
                            1e-64),
                        m *= c)
            }
        }
        return {
            solution: p,
            MSE: y
        }
    }
    var sM = [18.9, .105, .0113,
        .089, 4.414, .373, .06,
        .149, 1.84, 9.26, 5, .7,
        .2, 1.13, 2.61, 1, .007,
        30, 120, 1500, 4e-4,
        7.23, -1, -.0081, -.03,
        -28.6, -1.71, -.4, -
        6.94, -.777, -500
    ],
        hz = function (e) {
            let t = e * 503 % sM
                .length;
            return sM[t]
        },
        bz = function (e) {
            let t = [];
            for (let n = 0; n < sM
                .length; n++) {
                let r = [];
                for (let i = 0; i <
                    e; i++) n ===
                        0 && e !== 1 ?
                        r[i] = 0 : n ===
                            1 && e !== 1 ?
                            r[i] = 1 : r[
                            i] = hz(n * e +
                                i);
                t.push(r)
            }
            return t
        },
        IA = function (e, t, n, r,
            i) {
            let s = [];
            for (let a of n) s
                .push({
                    soln: iM(e,
                        t,
                        a, i
                    ),
                    initialGuess: a
                });
            s.sort(function (a, u) {
                return isNaN(
                    a
                        .soln
                        .MSE
                ) ?
                    1 :
                    isNaN(u
                        .soln
                        .MSE
                    ) ?
                        -1 : a
                            .soln
                            .MSE - u
                                .soln
                            .MSE
            });
            let o = [];
            for (let a = 0; a <
                r; a++) o.push(s[a]
                    .initialGuess);
            return o
        };

    function xz(e, t, n, r) {
        if (!t || gi(t)) return e;
        let i = t.bounds;
        return i[0] === -1 / 0 && i[
            1] === 1 / 0 ? e :
            i[0] === -1 / 0 ? i[1] -
                Math.exp(-e) : i[1] ===
                    1 / 0 ? i[0] + Math.exp(
                        e) : n / (r - 1) *
                        i[1] + (r - 1 - n) / (
                            r - 1) * i[0]
    }
    var EA = [3, 5, 7, 11, 13, 17,
        19
    ];

    function Pz(e, t) {
        let n = [];
        for (let i = 0; i < e
            .length; i++) {
            let s = e[i],
                o = [];
            for (let a = 0; a < s
                .length; a++) {
                var r = EA[a % EA
                    .length] *
                    i % e.length;
                o.push(xz(s[a], t[
                    a], r, e
                    .length
                ))
            }
            n.push(o)
        }
        return n
    }

    function MA(e, t, n) {
        n || (n = {});
        let {
            linearSubset: r,
            bounds: i,
            preferredInitialGuess: s
        } = n, o = bz(t.length);
        i && (o = Pz(o, i));
        let a = IA(e, t, o, 5, {
            maxIterations: 3,
            linearSubset: r
        }),
            u = IA(e, t, a, 1, {
                maxIterations: 60,
                linearSubset: r
            }),
            c = iM(e, t, u[0], {
                maxIterations: 250,
                linearSubset: r
            });
        if (!s) return c;
        let l = iM(e, t, s, {
            maxIterations: 100,
            linearSubset: r
        });
        return isFinite(l.MSE) && (l
            .MSE < c.MSE || Li(l
                .MSE, c.MSE, 8)
        ) ? l : c
    }

    function cM(e) {
        return {
            chunk: e,
            isLazy: !0
        }
    }

    function vA(e) {
        return e.slice()
    }

    function Dh(e) {
        if (!e.isLazy) return e;
        let t = e.chunk.copy();
        return t
            .reopenFinalBlock(), {
            chunk: t,
            forwardParameterMap: vA,
            reverseParameterMap: vA,
            isLazy: !1,
            valueMap: Dz(e.chunk
                .instructionsLength()
            ),
            replacementMask: vp(
                e.chunk
                    .argNames
                    .length)
        }
    }

    function DA(e) {
        let {
            chunk: t,
            forwardParameterMap: n,
            reverseParameterMap: r,
            isLazy: i,
            valueMap: s,
            replacementMask: o,
            didShiftScale: a
        } = e;
        return {
            chunk: t.copy(),
            forwardParameterMap: n,
            reverseParameterMap: r,
            isLazy: i,
            valueMap: s.slice(),
            replacementMask: o
                .slice(),
            didShiftScale: a
        }
    }

    function Tz(e) {
        var t = 1 / 0,
            n = -1 / 0,
            r = e.length;
        for (let i of e) t = Math
            .min(t, i), n = Math
                .max(n, i);
        return {
            min: t,
            max: n,
            length: r
        }
    }

    function CA(e) {
        let t = e.getInstruction(e
            .getReturnIndex());
        if (t.type !== 48) return;
        let n = t.args[0],
            r = e.getReturnIndex() -
                n,
            i = e.getInstruction(n);
        if (i.args.length !== 2)
            return;
        let s = i.args[0],
            o = i.args[r],
            a = [],
            u = [];
        a.push(s), u.push({
            min: 1,
            max: yo(e, e
                .getReturnIndex(),
                "Programming error: cannot optimize regression on non-constant-length list"
            ),
            length: yo(e, e
                .getReturnIndex(),
                "Programming error: cannot optimize regression on non-constant-length list"
            )
        });
        let c = !1,
            l = !1;
        for (let y = s + 1; y <=
            o; y++) {
            let h = e
                .getInstruction(y);
            if (h.type === 39 || h
                .type === 41 || h
                    .type === 40) {
                if (h.args[1] !== s)
                    continue;
                let b = h.args[0];
                if (e
                    .getInstruction(
                        b)
                    .valueType !==
                    se || !bt(e
                        .getInstruction(
                            b)))
                    continue;
                let x = ln(e, b),
                    P = Tz(x);
                if (!isFinite(P
                    .min) || !
                    isFinite(P.max))
                    continue;
                a.push(y), u.push(P)
            } else if (h.type ===
                37) h.symbol ===
                    "exp" ? l = !0 : OA(
                        h) && (c = !0);
            else if (h.type ===
                12 || h.type === 13)
                l = !0;
            else if (ri(h) || Ti(h))
                return
        }
        if (a.length === 0 || !l &&
            !c) return;
        let p = [];
        for (let y = 0; y <=
            o; y++) {
            let h = a.indexOf(y);
            if (h !== -1) {
                let b = vp(a
                    .length);
                b[h] = !0, p.push(b)
            } else p.push(vh(e, p, a
                .length, y))
        }
        let f = [];
        for (let y = 0; y <= e
            .getReturnIndex(); y++)
            if (e.getInstruction(y)
                .type === 2) {
                let b = vp(e
                    .argNames
                    .length);
                b[y] = !0, f.push(b)
            } else f.push(vh(e, f, e
                .argNames
                .length, y));
        let m = {
            listAccessDependencyTable: p,
            listAccesses: a,
            listStatisticsTable: u
        },
            g;
        for (let y = s + 1; y <= e
            .getReturnIndex(); y++
        ) {
            let h = e
                .getInstruction(y);
            switch (h.type) {
                case 37: {
                    if (h.symbol ===
                        "exp") {
                        let $ = h
                            .args[
                            0],
                            w = lM(
                                m, $
                            );
                        if (w ===
                            void 0
                        ) {
                            Fa(e, f, g,
                                y
                            );
                            break
                        }
                        let {
                            listStatistics: Y,
                            listAccessIndex: de
                        } = w, re =
                                Td(cM(
                                    e),
                                    y,
                                    $,
                                    de,
                                    Y);
                        re ? g = [
                            re] :
                            Fa(e, f,
                                g, y
                            )
                    }
                    break
                }
                case 12:
                case 13: {
                    let [$, w] = h
                        .args, Y =
                            lM(m, w);
                    if (Y ===
                        void 0 ||
                        SA(m, $)) {
                        Fa(e, f, g,
                            y);
                        break
                    }
                    let {
                        listStatistics: de,
                        listAccessIndex: re
                    } = Y, ie = Ez(
                        cM(e),
                        y, re,
                        de);
                    ie ? g = [ie] :
                        Fa(e, f, g,
                            y);
                    break
                }
                case 10:
                    if (g && g
                        .length > 1
                    ) {
                        Fa(e, f, g,
                            y);
                        break
                    }
                    let b = g && g
                        .length >
                        0 ? g[0] :
                        cM(e),
                        [x, P] = h
                            .args,
                        M = b
                            .isLazy ?
                            x : b
                                .valueMap[
                            x],
                        I = b
                            .isLazy ?
                            P : b
                                .valueMap[
                            P],
                        E = b.chunk
                            .getInstruction(
                                M),
                        v = b.chunk
                            .getInstruction(
                                I),
                        O, A, N;
                    if (E.type ===
                        37) O = x,
                            N = E, A =
                            P;
                    else if (v
                        .type === 37
                    ) O = P, N =
                        v, A = x;
                    else {
                        Fa(e, f, g,
                            y);
                        break
                    }
                    let L = lM(m,
                        O);
                    if (L ===
                        void 0 ||
                        SA(m, A)) {
                        Fa(e, f, g,
                            y);
                        break
                    }
                    let {
                        listAccessIndex
                        : z,
                        listStatistics:
                        G
                    } = L;
                    if (N.symbol ===
                        "exp") {
                        let $ = Mz(
                            b,
                            y,
                            A,
                            O,
                            z, G
                        );
                        if ($) {
                            g = $;
                            break
                        }
                    } else if (OA(
                        N)) {
                        let $ = Iz(
                            b,
                            y,
                            A,
                            O, z
                        );
                        if ($) {
                            g = [$];
                            break
                        }
                    }
                    Fa(e, f, g, y);
                    break;
                default: {
                    Fa(e, f, g, y);
                    break
                }
            }
        }
        if (g === void 0 || g
            .length === 0) return;
        let d = [];
        for (let y of g) d.push({
            chunk: y.chunk,
            forwardParameterMap: y
                .forwardParameterMap,
            reverseParameterMap: y
                .reverseParameterMap
        });
        return d
    }

    function Fa(e, t, n, r) {
        if (n === void 0) return;
        let i = e.getInstruction(r);
        if (be(i))
            for (let s of n) s
                .valueMap[r] = r;
        else
            for (let s of n) {
                let {
                    chunk: o,
                    valueMap: a
                } = s, u = [], c =
                        0;
                for (let l of i
                    .args) {
                    if (a[l] !==
                        l) {
                        if (c += 1,
                            c > 1) {
                            n.length =
                                0;
                            return
                        }
                    } else {
                        let p = t[
                            l];
                        for (let f =
                            0; f <
                            p
                                .length; f++
                        )
                            if (p[
                                f] &&
                                s
                                    .replacementMask[
                                f
                                ]
                            ) {
                                n.length =
                                    0;
                                return
                            }
                    }
                    u.push(a[l])
                }
                a[r] = c > 0 ? Mn(o,
                    i, u) : r
            }
    }

    function lM(e, t) {
        let {
            listAccessDependencyTable: n,
            listAccesses: r,
            listStatisticsTable: i
        } = e, s, o = n[t];
        for (let a = 0; a < o
            .length; a++)
            if (o[a]) {
                if (s) return;
                s = {
                    listAccessIndex: r[
                        a],
                    listStatistics: i[
                        a]
                }
            } return s
    }

    function SA(e, t) {
        let {
            listAccessDependencyTable: n
        } = e, r = n[t];
        for (let i of r)
            if (i) return !0;
        return !1
    }

    function pM(e, t) {
        let n = [];
        for (let s = 0; s <= t; s++)
            if (e.getInstruction(s)
                .type === 2) {
                let a = vp(e
                    .argNames
                    .length);
                a[s] = !0, n.push(a)
            } else n.push(vh(e, n, e
                .argNames
                .length, s));
        let r, i = n[t];
        for (let s = 0; s < i
            .length; s++)
            if (i[s]) {
                if (r !== void 0)
                    return;
                r = s
            } return r
    }

    function Iz(e, t, n, r, i) {
        let s = e.chunk,
            o = pM(s, n);
        if (o === void 0) return;
        let a = fM(e, n, o);
        if (a === void 0) return;
        let u = s.getInstruction(r),
            c = u.args[0];
        if (a = RA(a, c, i), a ===
            void 0) return;
        let {
            chunk: l,
            valueMap: p
        } = a, f = l.getInstruction(
            p[c]);
        if (f.type !== 8) return;
        let m = f.args[1],
            g = l.getInstruction(f
                .args[0]);
        if (g.type !== 10) return;
        let [d, y] = g.args, h = o,
            b = m, x = d, P = y, M =
                l.Multiply([x, P]), I =
                l
                    .SyntheticNativeFunction(
                        "cos", [M]), E = l
                            .SyntheticNativeFunction(
                                "sin", [M]), v = u
                                    .symbol === "sin" ? l
                                        .Add([l.Multiply([h,
                                            E]), l.Multiply(
                                                [b, I])
                                        ]) : l.Subtract([l
                                            .Multiply([h,
                                                I]), l
                                                    .Multiply([b,
                                                        E])
                                        ]);
        p[t] = v;

        function O(L) {
            let z = a
                .forwardParameterMap(
                    L),
                G = z[o],
                $ = z[m],
                w = G * Math.cos($),
                Y = G * Math.sin($);
            return z[o] = w, z[m] =
                Y, z
        }

        function A(L) {
            let z = L.slice(),
                G = L[o],
                $ = L[m],
                w = po(G, $),
                Y = Math.atan2($,
                    G);
            return z[o] = w, z[m] =
                Y, a
                    .reverseParameterMap(
                        z)
        }
        let N = a.replacementMask
            .slice();
        return N[o] = !0, N[d] = !0,
            N[m] = !0, {
            chunk: l,
            forwardParameterMap: O,
            reverseParameterMap: A,
            valueMap: p,
            replacementMask: N,
            isLazy: !1
        }
    }

    function Ez(e, t, n, r) {
        let i = e.chunk,
            s = i.getInstruction(t),
            [o, a] = s.args,
            u = i.getInstruction(o);
        if (u.type === 1 && u
            .valueType === T && q(u
                .value) > 0) {
            let b = Dh(e),
                {
                    chunk: x,
                    valueMap: P
                } = b,
                M = x.Multiply([x
                    .SyntheticNativeFunction(
                        "ln", [
                        P[o]
                    ]), P[a]
                ]);
            return P[a] = M, P[t] =
                x
                    .SyntheticNativeFunction(
                        "exp", [M]), Td(
                            b, t, a, n, r
                        ) || b
        }
        let c = pM(i, o);
        if (c === void 0) return;
        let l = fM(e, o, c);
        if (l === void 0) return;
        let {
            chunk: p,
            valueMap: f
        } = l, m = p.Multiply([f[o],
        f[a]
        ]);
        f[a] = m, f[t] = p
            .SyntheticNativeFunction(
                "exp", [m]);

        function g(b) {
            let x = l
                .forwardParameterMap(
                    b),
                P = x[c],
                M = Math.log(P);
            return x[c] = M, x
        }

        function d(b) {
            let x = b.slice(),
                P = x[c],
                M = Math.exp(P);
            return x[c] = M, l
                .reverseParameterMap(
                    x)
        }
        let y = l.replacementMask
            .slice();
        y[c] = !0;
        let h = {
            chunk: p,
            forwardParameterMap: g,
            reverseParameterMap: d,
            isLazy: !1,
            valueMap: f,
            replacementMask: y
        };
        return Td(h, t, a, n, r) ||
            h
    }

    function Mz(e, t, n, r, i, s) {
        if (!e.isLazy && e
            .didShiftScale) return;
        let o = e.isLazy ? e : DA(
            e),
            a = e.chunk,
            u = pM(a, n);
        if (u === void 0) return;
        let c = fM(e, n, u);
        if (c === void 0) return;
        let {
            chunk: l,
            valueMap: p
        } = c, f = l.getInstruction(
            p[r]).args[0], m = l
                .Add([f, p[n]]);
        p[n] = m, p[t] = l
            .SyntheticNativeFunction(
                "exp", [m]);

        function g(I) {
            let E = c
                .forwardParameterMap(
                    I),
                v = E[u],
                O = Math.log(v);
            return E[u] = O, E
        }

        function d(I) {
            let E = I.slice(),
                v = E[u],
                O = Math.exp(v);
            return E[u] = O, c
                .reverseParameterMap(
                    E)
        }

        function y(I) {
            let E = c
                .forwardParameterMap(
                    I),
                v = E[u],
                O = Math.log(-v);
            return E[u] = O, E
        }

        function h(I) {
            let E = I.slice(),
                v = E[u],
                O = -Math.exp(v);
            return E[u] = O, c
                .reverseParameterMap(
                    E)
        }
        let b = c.replacementMask
            .slice();
        b[u] = !0;
        let x = Dh(o);
        x.valueMap[t] = x.chunk
            .Multiply([x.valueMap[
                n], x.valueMap[
            r]
            ]);
        let P = {
            chunk: l,
            forwardParameterMap: g,
            reverseParameterMap: d,
            isLazy: !1,
            valueMap: p,
            replacementMask: b
        },
            M = DA(P);
        return M
            .forwardParameterMap =
            y, M
                .reverseParameterMap =
            h, P = Td(P, t, n, i,
                s) || P, M = Td(M, t, n,
                    i, s) || M, M
                        .valueMap[t] = M.chunk
                            .Negative([M.valueMap[
                                t]]), [x, P, M]
    }

    function Td(e, t, n, r, i) {
        let s = vz(e, n, r, i);
        if (s !== void 0) return s
            .valueMap[t] = s
                .chunk
                .SyntheticNativeFunction(
                    "exp", [s
                        .valueMap[n]
                ]), s
    }

    function vz(e, t, n, r) {
        let i = RA(e, t, n);
        if (i === void 0) return;
        let {
            chunk: s,
            valueMap: o
        } = i, a = s.getInstruction(
            o[t]);
        if (a.type !== 8) return;
        let u = a.args[1],
            c = s.getInstruction(a
                .args[0]);
        if (c.type !== 10) return;
        let [l, p] = c.args, {
            min: f,
            max: m
        } = r, g = m - f, d =
                .5 * (m + f), y = s
                    .Divide([s.Subtract([p,
                        s
                            .Constant(
                                d)
                    ]), s.Constant(
                        g)]), h = s.Add([s
                            .Multiply([l,
                                y]), u
                        ]);
        o[t] = h;

        function b(P) {
            let M = i
                .forwardParameterMap(
                    P),
                I = M[l],
                E = M[u],
                v = I * g,
                O = E + d * I;
            return M[l] = v, M[u] =
                O, M
        }

        function x(P) {
            let M = P.slice(),
                I = P[l],
                E = P[u],
                v = I / g,
                O = E - v * d;
            return M[l] = v, M[u] =
                O, i
                    .reverseParameterMap(
                        M)
        }
        return {
            chunk: s,
            forwardParameterMap: b,
            reverseParameterMap: x,
            isLazy: !1,
            valueMap: o,
            replacementMask: i
                .replacementMask,
            didShiftScale: !0
        }
    }

    function fM(e, t, n) {
        let r = e.chunk,
            i = Lr(r, n, {
                allowRestriction:
                    !1,
                allowClosedBlockReferences:
                    !1
            });
        if (en(i, t) !== 1) return;
        let s = ws(i, t),
            [o, a] = Hn(s, t);
        if (a === void 0) return;
        let u = s.newChunk
            .getInstruction(o);
        if (u.type !== 1 || u
            .valueType !== T)
            return;
        let c = s.newChunk
            .getInstruction(a);
        if (c.type !== 1 || c
            .valueType !== T)
            return;
        let l = Dh(e),
            {
                chunk: p,
                valueMap: f
            } = l,
            m = q(u.value),
            g = q(c.value);
        f[t] = n;

        function d(b) {
            let x = l
                .forwardParameterMap(
                    b),
                P = x[n],
                M = m + g * P;
            return x[n] = M, x
        }

        function y(b) {
            let x = b.slice(),
                M = (x[n] - m) / g;
            return x[n] = M, l
                .reverseParameterMap(
                    x)
        }
        let h = l.replacementMask
            .slice();
        return h[n] = !0, {
            chunk: p,
            forwardParameterMap: d,
            reverseParameterMap: y,
            isLazy: !1,
            valueMap: f,
            replacementMask: h
        }
    }

    function RA(e, t, n) {
        let r = e.chunk,
            i = e.isLazy ? t : e
                .valueMap[t],
            s = Lr(r, n, {
                allowRestriction:
                    !1,
                allowClosedBlockReferences:
                    !0
            });
        if (en(s, i) !== 1) return;
        e.isLazy && (s = Lr(r.copy()
            .reopenFinalBlock(),
            n, {
            allowRestriction:
                !1,
            allowClosedBlockReferences:
                !1
        }));
        let o = ws(s, i),
            [a, u] = Hn(o, i);
        if (u === void 0) return;
        let c = o.newChunk,
            l = Math.max(u, a),
            p = [];
        for (let Z = 0; Z <= l; Z++)
            if (c.getInstruction(Z)
                .type === 2) {
                let Ne = vp(c
                    .argNames
                    .length);
                Ne[Z] = !0, p.push(
                    Ne)
            } else p.push(vh(c, p, c
                .argNames
                .length, Z));
        let f, m;
        for (let Z = 0; Z < r
            .argNames.length; Z++)
            if (p[u][Z])
                if (f === void 0)
                    f = Z;
                else return;
            else if (p[a][Z])
                if (m === void 0) m = Z;
                else return;
        if (f === void 0 || m ===
            void 0) return;
        let g = Lr(c, f, {
            allowRestriction:
                !1,
            allowClosedBlockReferences:
                !1
        });
        if (en(g, u) !== 1) return;
        let d = Lr(c, m, {
            allowRestriction:
                !1,
            allowClosedBlockReferences:
                !1
        });
        if (en(d, a) !== 1) return;
        let y = ws(g, u),
            h = ws(d, a),
            [b, x] = Hn(y, u),
            P = y.newChunk
                .getInstruction(b);
        if (P.type !== 1 || P
            .valueType !== T)
            return;
        let M = y.newChunk
            .getInstruction(x);
        if (M.type !== 1 || M
            .valueType !== T)
            return;
        let I = Dh(e),
            {
                chunk: E,
                valueMap: v
            } = I,
            O = E.Add([E.Multiply([
                f, n
            ]), m]);
        v[t] = O;
        let A = c.copy();
        A.List([u, a]);
        let N = A
            .getCompiledFunction()
            .fn;

        function L(Z) {
            let Re = I
                .forwardParameterMap(
                    Z),
                [Ne, Te] = N.apply(
                    null, Re);
            return Re[f] = Ne, Re[
                m] = Te, Re
        }
        let z = q(P.value),
            G = q(M.value),
            [$, w] = Hn(h, a),
            Y = h.newChunk.copy();
        Y.List([$, w]);
        let de = Y
            .getCompiledFunction()
            .fn;

        function re(Z) {
            let Re = Z.slice(),
                Ne = Z[f],
                Te = Z[m],
                Me = (Ne - z) / G,
                ve = Z.slice();
            ve[f] = Me, ve.splice(m,
                1);
            let [Q, U] = de.apply(
                null, ve), xe =
                    (Te - Q) / U;
            return Re[f] = Me, Re[
                m] = xe, I
                    .reverseParameterMap(
                        Re)
        }
        let ie = I.replacementMask
            .slice();
        return ie[f] = !0, ie[m] = !
            0, {
            chunk: E,
            forwardParameterMap: L,
            reverseParameterMap: re,
            isLazy: !1,
            valueMap: v,
            replacementMask: ie
        }
    }

    function vh(e, t, n, r) {
        let i = e.getInstruction(r),
            s = vp(n);
        if (be(i)) return s;
        for (let o of i.args) {
            let a = t[o];
            for (let u = 0; u < a
                .length; u++) s[u] =
                    s[u] || a[u]
        }
        return s
    }

    function vp(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(!1);
        return t
    }

    function Dz(e) {
        let t = [];
        for (let n = 0; n < e; n++)
            t.push(n);
        return t
    }

    function OA(e) {
        return e.type === 37 && (e
            .symbol === "sin" ||
            e.symbol === "cos")
    }

    function xt(e, t) {
        switch (e) {
            case T:
            case ge:
                return new D
                    .Constant(t);
            case ot:
                return new D.Seed(
                    t);
            case R:
                return new D
                    .ParenSeq([xt(T,
                        t[0]
                    ),
                    xt(T, t[
                        1])
                    ]);
            case V:
                return new D
                    .ParenSeq([xt(T,
                        t[0]
                    ),
                    xt(T, t[
                        1]),
                    xt(T, t[
                        2])
                    ]);
            case Nt:
                return new D
                    .FunctionCall(
                        "segment", [
                        xt(V, t[
                            0]),
                        xt(V, t[
                            1])
                    ]);
            case Se:
                return new D
                    .FunctionCall(
                        "vector", [
                        xt(V, t[
                            0]),
                        xt(V, t[
                            1])
                    ]);
            case In:
                return new D
                    .FunctionCall(
                        "triangle",
                        [xt(V, t[
                            0]), xt(
                                V,
                                t[1]
                            ),
                        xt(V, t[
                            2])
                        ]);
            case Nn:
                return new D
                    .FunctionCall(
                        "sphere", [
                        xt(V, t[
                            0]),
                        xt(T, t[
                            1])
                    ]);
            case Ut:
                return new D
                    .FunctionCall(
                        "rgb", [xt(
                            T,
                            t[0]
                        ),
                        xt(T, t[
                            1]),
                        xt(T, t[
                            2])
                    ]);
            case Be:
                return new D
                    .FunctionCall(
                        "polygon", [
                        xt(Pt,
                            t)
                    ]);
            case Ie:
                return new D
                    .FunctionCall(
                        "segment", [
                        xt(R, t[
                            0]),
                        xt(R, t[
                            1])
                    ]);
            case fe:
                return new D
                    .FunctionCall(
                        "line", [xt(
                            R,
                            t[0]
                        ),
                        xt(R, t[
                            1])
                    ]);
            case Le:
                return new D
                    .FunctionCall(
                        "ray", [xt(
                            R,
                            t[0]
                        ),
                        xt(R, t[
                            1])
                    ]);
            case he:
                return new D
                    .FunctionCall(
                        "mathVector",
                        [xt(R, t[
                            0]), xt(
                                R,
                                t[1]
                            )
                        ]);
            case pe:
                return new D
                    .FunctionCall(
                        "circle", [
                        xt(R, t[
                            0]),
                        xt(T, t[
                            1])
                    ]);
            case ce:
                return new D
                    .FunctionCall(
                        "arc", [xt(
                            R,
                            t[0]
                        ),
                        xt(R, t[
                            1]),
                        xt(R, t[
                            2])
                    ]);
            case Ge:
                return new D
                    .FunctionCall(
                        "angle", [
                        xt(R, t[
                            0]),
                        xt(T, t[
                            1]),
                        xt(T, t[
                            2])
                    ]);
            case Ae:
                return new D
                    .FunctionCall(
                        "directedangle",
                        [xt(R, t[
                            0]), xt(
                                T,
                                t[1]
                            ),
                        xt(T, t[
                            2])
                        ]);
            case We:
            case se:
            case Ln:
            case Pt:
            case Zn:
            case Rn:
            case Tn:
            case Bn:
            case Gn:
            case kn:
            case gn:
            case hn:
            case Fn:
            case Vn:
            case Kn:
            case er:
            case nr:
            case tr:
            case yr:
            case Ur: {
                let r = [],
                    i = ke(e);
                for (let s of t) r
                    .push(xt(i, s));
                return new D.List(r)
            }
            case Ht:
            case St:
            case sn:
            case wn:
            case rt:
            case Ue:
            case mr:
            case no:
            case Wn:
            case jn:
            case sr:
            case or:
            case Dr:
            case Sr:
            case Or:
            case Cr:
            case Vt:
            case Hr:
                throw new Error(
                    `Programming error: cannot create parse node from valueType: ${on(e)}`
                );
            case mn:
                return new D
                    .FunctionCall(
                        "tone", [xt(
                            T,
                            t[0]
                        ),
                        xt(T, t[
                            1])
                    ]);
            default:
                let n = e;
                throw new Error(
                    `Programming error: unexpected valueType: ${on(n)}`
                )
        }
    }

    function VA(e, t) {
        try {
            return Sz(e, t)
        } catch (n) {
            return n instanceof D
                .Error ? n : J(n)
        }
    }

    function Sz(e, t) {
        let {
            policy: n,
            frame: r,
            exportFrame: i,
            lastExportFrame: s,
            priorAnalysis: o
        } = e, a = t._lhs
            .buildIRExpression(n,
                r, {
                coerceToNumber:
                    !0
            }), u = t._rhs
                .buildIRExpression(n,
                    r, {
                    coerceToNumber:
                        !0
                });
        if (a.isError) throw a;
        if (u.isError) throw u;
        if (a.valueType !== T && a
            .valueType !== se || u
                .valueType !== T && u
                    .valueType !== se)
            throw Wb([ne(a
                .valueType),
            ne(u
                .valueType)
            ]);
        let c = t._difference
            .buildIRExpression(n,
                r, {
                wrapInList: !0,
                coerceToNumber:
                    !0
            });
        if (c.isError) throw c;
        for (let M of c
            .getDependencies())
            if (!n
                .validRegressionParameter(
                    M)) throw CP(M);
        let l = Cz(c
            .getDependencies(),
            t.userData
                .regressionParameters,
            s),
            {
                parameters: p,
                residuals: f,
                isLinear: m,
                parameterWarning: g
            } = FA(l, c),
            d = {
                policy: n,
                frame: r
            },
            y = NA(d, t, p),
            h = Az(t, a, y),
            b;
        if (t.userData
            .isLogModeRegression &&
            (h === di.LOGLIN ||
                h === di.LOGLOG)) {
            let M = t._logDifference
                .buildIRExpression(
                    n, r, {
                    wrapInList:
                        !0,
                    coerceToNumber:
                        !0
                });
            if (M.isError) throw M;
            let I = t._logLhs
                .buildIRExpression(
                    n, r, {
                    wrapInList:
                        !0,
                    coerceToNumber:
                        !0
                });
            if (I.isError) throw I;
            ({
                parameters: p,
                isLinear: m,
                parameterWarning: g
            } = FA(l, M)), y = NA(d,
                t, p), f = wA(d,
                    t._difference, p
                );
            let E = wA(d, t
                ._logDifference,
                p);
            b = LA(t, I, y, E, t
                .userData
                .isLogModeRegression,
                h)
        } else b = LA(t, a, y, f, t
            .userData
            .isLogModeRegression,
            h);
        let x = Oz(t, i),
            P = Nz(t, x, o, n);
        return t.userData
            .residualVariable = ur(
                x), new D
                    .OptimizedRegression(p,
                        xt(se, f), b, y
                        .substituted, {
                        isModelValid: y
                            .isValid,
                        residualVariable: x,
                        residualSuggestionId: P,
                        shouldSuggestLogMode: h !==
                            di.NONE,
                        isLinear: m,
                        parameterWarning: g
                    })
    }

    function Oz(e, t) {
        if (e.userData && e.userData
            .residualVariable) {
            let s = Lo(e.userData
                .residualVariable
            );
            if (!t[s]) return s
        }
        let n = e.getDependencies()
            .filter(s => s[0] !==
                "_"),
            r;
        for (let s of n) {
            let o = s.match(
                /_(.*)/);
            if (o && (r = "e_" + o[
                1], !t[r]))
                return r
        }
        let i = 1;
        for (; ;) {
            if (r = "e_" + i, !t[r])
                return r;
            i++
        }
    }

    function NA({
        policy: e,
        frame: t
    }, n, r) {
        let i = n._rhs
            .getDependencies(),
            s, o;
        for (let p of i) {
            if (r.hasOwnProperty(p))
                continue;
            let f = t[p];
            if (!f || (f.type ===
                "Assignment" &&
                (f = f
                    ._expression
                ), !f
                    .buildIRExpression
            )) continue;
            let m = f
                .buildIRExpression(
                    e, t, {
                    coerceToNumber:
                        !0
                });
            if (!m.isError && m
                .valueType === se) {
                if (s !== void 0) {
                    s = void 0, o =
                        void 0;
                    break
                }
                m.getDependencies()
                    .length === 0 &&
                    (s = p, o = m)
            }
        }
        let a = Object.create(t);
        s !== void 0 && (a[s] =
            void 0);
        let u = n._rhs
            .buildIRExpression(e,
                a, {
                coerceToNumber:
                    !0
            }),
            c = Object.create(a);
        for (let p in r) c[p] = r[
            p];
        let l = n._rhs
            .buildIRExpression(e,
                c, {
                coerceToNumber:
                    !0
            });
        return o ? {
            node: u,
            substituted: l,
            listNode: o,
            isValid: !0
        } : {
            node: u,
            substituted: l,
            listNode: o,
            isValid: !1
        }
    }

    function Cz(e, t, n) {
        let r = [];
        t || (t = {}), n || (
            n = {});
        for (let i of e) {
            let s = ur(i);
            n[i] && isFinite(n[i]
                .asValue()) ? r
                    .push(+n[i]
                        .asValue()) : t
                            .hasOwnProperty(
                                s) && isFinite(+t[
                                    s]) ? r.push(+t[
                                        s]) : r.push(1)
        }
        return r
    }

    function AA(e, t) {
        let n = t.getDependencies(),
            r = t
                .getCompiledFunction(n)
                .fn;
        if (n.length) {
            let i = t
                .findLinearSubset(
                    n),
                s = i.every(a => a),
                o = [];
            for (let a of n) o.push(
                t
                    .takeDerivative(
                        a)
                    .getCompiledFunction(
                        n).fn);
            if (s) {
                let a = n.map(() =>
                    De(0, 1)),
                    u = t
                        .interpretWithParameters(
                            a),
                    c = [];
                for (let m of n) c
                    .push(t
                        .takeDerivative(
                            m)
                        .interpretWithParameters(
                            a));
                let l = aM(u, c);
                if (l) {
                    let m = t
                        .interpretWithParameters(
                            l);
                    return {
                        solution: l,
                        residuals: m,
                        MSE: mM(m),
                        isLinear: s
                    }
                }
                let {
                    solution: p,
                    MSE: f
                } = oM(r, uM(r, o));
                return {
                    solution: p,
                    residuals: r
                        .apply(
                            void 0,
                            p),
                    MSE: f,
                    isLinear: s
                }
            } else {
                let a = [];
                for (let p of n) a
                    .push(t
                        .boundDomain(
                            p));
                let u = {
                    linearSubset: i,
                    bounds: a,
                    preferredInitialGuess: e
                },
                    {
                        solution: c,
                        MSE: l
                    } = oM(r, MA(r,
                        o, u));
                return {
                    solution: c,
                    residuals: r
                        .apply(
                            void 0,
                            c),
                    MSE: l,
                    isLinear: s
                }
            }
        } else return {
            solution: [],
            residuals: t
                .interpretWithParameters(
                    []),
            MSE: Bu(r, []),
            isLinear: !0
        }
    }

    function _A(e, t) {
        let n = {},
            r = t.getDependencies();
        for (let i = 0; i < r
            .length; i++) {
            let s = new D
                .RegressionParameter(
                    e[i]);
            n[r[i]] = s
        }
        return n
    }

    function LA(e, t, n, r, i, s) {
        let o = mM(r);
        if (!isFinite(o))
            throw RP();
        if (t.getDependencies()
            .length > 0) return {
                RMSE: Math.sqrt(o)
            };
        let a = W(t.valueType) ? wf(
            t.asValue()) : 0;
        if (t.getDependencies()
            .length || !isFinite(
                a) || a <= 0 || !e
                    .isLhsSimple) return {
                        RMSE: Math.sqrt(o)
                    };
        {
            let u = 1 - o / a;
            if (n.isValid) {
                let c = [],
                    l = [],
                    p = i && (s ===
                        di.LINLOG ||
                        s === di
                            .LOGLOG);
                D.List.eachArgs([n
                    .listNode,
                    t
                ], function (
                    m) {
                    let g =
                        m[0]
                            .isConstant ?
                            m[0]
                                .asCompilerValue() :
                            NaN,
                        d =
                            m[1]
                                .isConstant ?
                                m[1]
                                    .asCompilerValue() :
                                NaN;
                    c.push(p ?
                        Math
                            .log(
                                q(
                                    g)
                            ) :
                        g
                    ),
                        l
                            .push(
                                d
                            )
                });
                let f = By(c.map(
                    m => q(
                        m)),
                    l.map(m =>
                        q(m)));
                if (Li(Rz(c, l).MSE,
                    o, 8))
                    return {
                        r: f,
                        rsquared: f *
                            f
                    }
            }
            return {
                Rsquared: u
            }
        }
    }

    function Rz(e, t) {
        let n = t,
            r = [e.map(a => hi(a)),
            e.map(() => De(-1,
                1))
            ],
            i = aM(n, r);
        if (i) {
            let [a, u] = i, c = [];
            for (let l = 0; l < t
                .length; l++) c
                    .push(ji(t[l], us(
                        cs(a, e[
                            l]),
                        u)));
            return {
                solution: i,
                MSE: mM(c)
            }
        }

        function s(a, u) {
            let c = [];
            for (let l = 0; l < e
                .length; l++) c
                    .push(q(t[l]) - (a *
                        q(e[l]) + u
                    ));
            return c
        }
        return uM(s, [function () {
            return e
                .map(
                    function (
                        a
                    ) {
                        return -
                            q(
                                a)
                    })
        }, function () {
            return e
                .map(
                    function () {
                        return -
                            1
                    })
        }])
    }

    function Nz(e, t, n, r) {
        let i = e._rhs
            .getDependencies(),
            s;
        for (let o in n) {
            if (!n.hasOwnProperty(
                o)) continue;
            let a = n[o]
                .concreteTree;
            if (!Gs(a) || !a
                .columns[0])
                continue;
            let u = n[o].rawTree
                .columns;
            if (!u || !u.length)
                continue;
            let c = u[0].getExports(
                r);
            if (c.length === 1 && i
                .indexOf(c[0]) !== -
                1) {
                for (let l = 1; l <
                    u.length; l++)
                    if (u[l]
                        .getDependencies()
                        .indexOf(
                            t) !== -1)
                        return;
                s = s || o
            }
        }
        return s || void 0
    }

    function dM(e, t) {
        let n = e.length,
            r = e[0],
            i = t[0],
            s = e[n - 1],
            o = t[n - 1];
        if (!isFinite(r) || !
            isFinite(s) || !
            isFinite(i) || !
            isFinite(o) || o - i ===
            0) return !1;
        let a = s - r;
        if (a === 0) return !1;
        for (let u = 1; u < n -
            1; u++) {
            let c = e[u],
                l = t[u],
                p = (o * (c - r) +
                    i * (s - c)) /
                    a;
            if (!Li(l, p, 5))
                return !1
        }
        return !0
    }
    var di = {
        NONE: 0,
        LOGLIN: 1,
        LOGLOG: 2,
        LINLOG: 3
    };

    function Az(e, t, n) {
        if (!e.isLhsSimple || !n
            .isValid) return di
                .NONE;
        let r = n.substituted;
        if (r.isError || r
            .valueType !== T)
            return di.NONE;
        let i = r.getDependencies();
        if (i.length !== 1 ||
            isFinite(n.node
                .polynomialOrder(i[
                    0]))) return di
                        .NONE;
        let s = r
            .getCompiledFunction(i)
            .fn,
            o = n.listNode;
        if (r.valueType !== T)
            return di.NONE;
        let a = o.mapElements(f => +
            f.asValue());
        if (a.length < 3) return di
            .NONE;
        a.sort(function (f, m) {
            return f - m
        });
        let u = a.map(s),
            c = u.map(Math.log),
            l = a.map(Math.log),
            p = !0;
        return D.List.wrap(t)
            .eachElement(f => {
                isFinite(Math
                    .log(+f
                        .asValue()
                    )
                ) || (
                        p = !1)
            }), dM(a, c) && p ? di
                .LOGLIN : dM(l, c) &&
                    p ? di.LOGLOG : dM(l,
                        u) ? di.LINLOG : di.NONE
    }

    function wA({
        policy: e,
        frame: t
    }, n, r) {
        let i = Object.create(t);
        for (let a in r) r
            .hasOwnProperty(a) && (
                i[a] = r[a]);
        let s = mp({
            policy: e,
            frame: i,
            wrapInList: !0
        }, n),
            o = s.getError();
        if (o) throw o;
        return s.asCompilerValue()
    }

    function mM(e) {
        let t = 0;
        for (let n of e) {
            let r = q(n);
            t += r * r
        }
        return t / e.length
    }

    function FA(e, t) {
        let n, r, i = t._chunk;
        if (i && (r = CA(i)), !r ||
            r.length === 0)
            return t = t
                .deriveRegressionRestrictions(),
                n = AA(e, t), {
                parameters: _A(n
                    .solution,
                    t),
                residuals: n
                    .residuals,
                isLinear: n
                    .isLinear,
                parameterWarning:
                    !1
            };
        let s = t.getDependencies(),
            o = t
                .getCompiledFunction(s)
                .fn,
            a = 1 / 0,
            u = {},
            c, l = !1;
        for (let p of r) {
            let f = new pn(p.chunk);
            if (f = f
                .deriveRegressionRestrictions(),
                n = AA(p
                    .forwardParameterMap(
                        e), f), n
                            .MSE < a) {
                let m = p
                    .reverseParameterMap(
                        n.solution
                            .map(d => q(
                                d))),
                    g = Bu(o, m);
                if (u && (!isFinite(
                    g) ||
                    g >= a)) {
                    isFinite(g) || (
                        l = !0);
                    continue
                }
                a = n.MSE, u = _A(m,
                    t), c = o
                        .apply(void 0,
                            m)
            }
        }
        return {
            parameters: u,
            residuals: c,
            isLinear: !1,
            parameterWarning: l
        }
    }
    D.Base.prototype.analyze =
        function (e, t) {
            return Gr(this) ? kr(e,
                t, this) :
                new k(e, t, this,
                    this
                        .tryGetConcreteTree(
                            e, t))
        };

    function Sh(e, t, n, r) {
        if (r.isError) return new k(
            e, t, n, r);
        if (!e
            .areAllScalesLinear() && !
            Zc(r.valueType)) {
            let u = cl(ne(r
                .valueType));
            return u
                .setCursorContext(r
                    .getCursorContext()
                ), new k(e, t,
                    n, u)
        }
        var i = Cs(e, r),
            s = r.getDependencies();
        let o;
        switch (r.valueType) {
            case St:
            case wn:
            case We: {
                o = r;
                break
            }
            case Ut:
            case Zn:
            case Ie:
            case Tn:
            case pe:
            case Fn:
            case ce:
            case Vn:
            case fe:
            case Bn:
            case Le:
            case Gn:
            case he:
            case kn:
            case Ge:
            case gn:
            case Ae:
            case hn:
            case Ue:
            case mr:
            case rt:
            case Be:
            case Rn:
            case Nt:
            case er:
            case Se:
            case nr:
            case In:
            case tr:
            case Nn:
            case yr:
            case mn:
            case Ur:
                i.length ? o = tn(n
                    .getSliderVariables(
                        e, r))
                    .setDependencies(
                        i) : o = r;
                break;
            case R:
            case V:
            case Pt:
            case Kn:
                if (i.length)
                    if (e
                        .validParametricVariables(
                            i)) o =
                                r;
                    else {
                        var a = n
                            .getSliderVariables(
                                e, r
                            );
                        o = tn(a)
                            .setDependencies(
                                a)
                    }
                else o = r;
                break;
            case Wn:
            case sr:
            case jn:
            case or:
            case Dr:
            case Or:
            case Sr:
            case Cr: {
                i.length === 0 ? o =
                    r : o = tn(n
                        .getSliderVariables(
                            e, r))
                        .setDependencies(
                            i);
                break
            }
            case T:
            case se:
                i.length === 0 ? o =
                    r : i.length <=
                        (e.is3dPolicy() ?
                            2 : 1) ? e
                                .is3dPolicy() &&
                                s.length > i
                                    .length && !e
                                        .validImplicitVariables(
                                            s) ? o = tn(
                                                n
                                                    .getSliderVariables(
                                                        e, r))
                                                .setDependencies(
                                                    s) : e
                                                        .validExpressionVariables(
                                                            i) ? o = r :
                    o = Nm(e
                        .implicitDependency(
                            i))
                        .setDependencies(
                            i) : e
                                .validImplicitVariables(
                                    i) ? o =
                Nm()
                    .setDependencies(
                        i) : o = tn(
                            n
                                .getSliderVariables(
                                    e, r))
                            .setDependencies(
                                s);
                break;
            default:
                o = J(
                    `Programming error: unexpected value type ${r.valueType}`)
        }
        return xo(o) && o
            .setCursorContext(r
                .getCursorContext()
            ), o = Hc(e, n, o),
            new k(e, t, n, o)
    }

    function BA(e) {
        return new D.FunctionCall(
            "pdf", [e, new D
                .Identifier("x")
        ])
    }
    D.Identifier.prototype.analyze =
        function (e, t) {
            let n = this
                .tryGetConcreteTree(
                    e, t, {
                    coerceToNumber:
                        !0
                }),
                r = Sh(e, t, this,
                    n);
            return Gr(this) && !gM(
                r) ? kr(e, t,
                    this) : r
        };
    D.FunctionCall.prototype
        .analyze = function (e, t,
            n) {
            var r;
            wg[this._symbol] && Nc(
                t, this)
                .length === 0 && !e
                    .is3dPolicy() ? r =
            BA(this)
                .tryGetConcreteTree(
                    e, t) : r = this
                        .tryGetConcreteTree(
                            e, t);
            var i = Sh(e, t, this,
                r);
            if (Gr(this) && !gM(i))
                return kr(e, t,
                    this);
            var s = this
                .getMoveStrategy(e,
                    t, r, n);
            if (s) {
                var o = this
                    .getDefaultDragMode(
                        s),
                    a = r
                        .asCompilerValue(),
                    u = [new D
                        .Constant(a[
                            0]),
                    new D
                        .Constant(a[
                            1])
                    ];
                return new k(e, t,
                    this, new D
                        .MovablePoint(
                            u, s, o)
                )
            }
            return i
        };
    D.Expression.prototype.analyze =
        function (e, t) {
            var n = Sh(e, t, this,
                this
                    .tryGetConcreteTree(
                        e, t));
            return Gr(this) && !gM(
                n) ? kr(e, t,
                    this) : n
        };
    D.FunctionDefinition.prototype
        .analyze = function (e, t) {
            if (Gr(this)) return kr(
                e, t, this);
            if (Ke[this._symbol])
                return this
                    .asEquation()
                    .analyze(e, t);
            var n = this._symbol
                .split("_")[0];
            if (Ke[n] && Ke[n]
                .isFunction)
                return new k(e, t,
                    this, fl(
                        this
                            ._symbol,
                        n));
            let r = this
                .tryGetConcreteTree(
                    e, t);
            if (r instanceof D
                .Error && !r
                    .blocksExport &&
                this._argSymbols
                    .length === 1) {
                let u = Object
                    .create(t);
                u[this._argSymbols[
                    0]] =
                    new ze(
                        "identityTransformation"
                    );
                let c = this
                    ._expression
                    .tryGetConcreteTree(
                        e, u);
                if (!(c instanceof D
                    .Error))
                    return new k(e,
                        t, this,
                        c)
            }
            if (r.isError)
                return new k(e, t,
                    this, r);
            var i = this
                ._argSymbols,
                s = r
                    .getDependencies();
            if (s.indexOf(this
                ._symbol) !== -
                1) return new k(e,
                    t, this, $a(
                        [this
                            ._symbol
                        ]));
            var o = s.filter(
                function (u) {
                    return i
                        .indexOf(
                            u
                        ) ===
                        -1
                });
            if (e
                .unplottablePolarFunction(
                    this._symbol, s)
            ) return new k(e, t,
                this, bP());
            if (e.is3dPolicy() && e
                .assignmentForbidden(
                    this._symbol))
                return new k(e, t,
                    this, Bm(
                        this
                            ._symbol
                    ));
            if (o.some(function (u) {
                return e
                    .assignmentForbidden(
                        u)
            })) return new k(e,
                t, this, rf(
                    o, this
                    ._symbol,
                    i)
                    .setDependencies(
                        s));
            if (o.length) {
                var a = this
                    .getSliderVariables(
                        e, r);
                return new k(e, t,
                    this, tn(a)
                        .setDependencies(
                            a))
            }
            return !e
                .areAllScalesLinear() &&
                !Zc(r.valueType) ?
                new k(e, t, this,
                    cl(ne(r
                        .valueType))
                ) : (r = Hc(e,
                    this, r),
                    new k(e, t,
                        this, r))
        };
    D.Assignment.prototype.analyze =
        function (e, t, n) {
            if (Gr(this)) return kr(
                e, t, this);
            var r = this._symbol;
            if (!e.validLHS(r))
                return new k(e, t,
                    this, hP(r));
            if (Ke[r]) return this
                .asEquation()
                .analyze(e, t);
            var i;
            if (this
                ._expression instanceof D
                    .FunctionCall && wg[
                this._expression
                    ._symbol] && Nc(
                        t, this)
                        .length === 0 && !e
                            .is3dPolicy()) i =
                                BA(this._expression)
                                    .tryGetConcreteTree(
                                        e, t);
            else {
                var s = Object
                    .create(t);
                s[r] = e
                    .validSolvedVariable(
                        r) ?
                    void 0 : rc(),
                    i = this
                        .tryGetConcreteTree(
                            e, s)
            }
            if (i.isError)
                return new k(e, t,
                    this, i);
            if (!e
                .areAllScalesLinear() &&
                !Zc(i.valueType))
                return new k(e, t,
                    this, cl(ne(
                        i
                            .valueType
                    )));
            if (this.isEquation(e,
                i)) return this
                    .asEquation()
                    .analyze(e, t);
            let o = i.valueType ===
                Ut || i
                    .valueType === Zn;
            if (e
                .assignmentForbidden(
                    r) && o) {
                let g = yP(r)
                    .allowExport()
                    .setDependencies(
                        [r]);
                return new k(e, t,
                    this, g)
            }
            let a = i
                .getDependencies(),
                u = Cs(e, i),
                c = u.includes(
                    "x") || u.includes(
                        "y"),
                l = u.includes(
                    "r") || u.includes(
                        "theta");
            if (r === "r" && a
                .includes("phi")) {
                let g = u.includes(
                    "z") ?
                    Dm() : fP();
                return new k(e, t,
                    this, g)
            }
            if (r === "rho" && u
                .includes("z")) {
                let g = a.includes(
                    "phi") ?
                    Dm() : dP();
                return new k(e, t,
                    this, g)
            }
            let p = this
                .getSliderVariables(
                    e, i, a);
            if (e
                .tooManySliderVariables(
                    a, p, o) || c &&
                l) {
                let g = tn(p)
                    .allowExport()
                    .setDependencies(
                        p);
                return new k(e, t,
                    this, g)
            }
            var f = this
                .getMoveStrategy(e,
                    t, i, n);
            if (f) {
                var m = this
                    .getDefaultDragMode(
                        f);
                return i = new D
                    .MovablePoint([i
                        .elementAt(
                            0),
                    i
                        .elementAt(
                            1)
                    ], f, m), new k(
                        e, t, this,
                        i)
            }
            return i = Hc(e, this,
                i), new k(e, t,
                    this, i)
        };
    D.RecursiveFunctionBaseCase
        .prototype.analyze =
        function (e, t) {
            if (Gr(this)) return kr(
                e, t, this);
            if (!this.specifiedArg
                .valid)
                return new k(e, t,
                    this, this
                        .specifiedArg
                    .error);
            let n = this
                .tryGetConcreteTree(
                    e, t);
            if (n.isError)
                return new k(e, t,
                    this, n);
            var r = this
                ._argSymbols,
                i = n
                    .getDependencies();
            if (e.is3dPolicy() && e
                .assignmentForbidden(
                    this._symbol))
                return new k(e, t,
                    this, Bm(
                        this
                            ._symbol
                    ));
            var s = i.filter(
                function (a) {
                    return r
                        .indexOf(
                            a
                        ) ===
                        -1
                });
            if (s.includes(this
                .specifiedArg
                .argSymbol))
                return new k(e, t,
                    this, pb(
                        this
                            .specifiedArg
                            .argSymbol
                    ));
            for (let a of s)
                if (e
                    .assignmentForbidden(
                        a))
                    return new k(e,
                        t, this,
                        lb(a));
            if (s.length) {
                var o = this
                    .getSliderVariables(
                        e, n);
                return new k(e, t,
                    this, tn(o)
                        .setDependencies(
                            o))
            }
            return !e
                .areAllScalesLinear() &&
                !Zc(n.valueType) ?
                new k(e, t, this,
                    cl(ne(n
                        .valueType))
                ) : new k(e, t,
                    this, n)
        };
    D.CoordinateEquation.prototype
        .analyze = function (e, t) {
            if (!e
                .validCoordinateEquationSymbol(
                    this
                        ._concatenatedSymbol
                )) return this
                    .asEquation()
                    .analyze(e, t);
            if (Gr(this)) return kr(
                e, t, this);
            let n = this
                .tryGetConcreteTree(
                    e, t);
            return n = Hc(e, this,
                n), new k(e, t,
                    this, n)
        };
    D.Regression.prototype.analyze =
        function (e, t, n, r, i) {
            if (Gr(this)) return kr(
                e, t, this);
            var s = {
                policy: e,
                frame: t,
                exportFrame: n,
                lastExportFrame: r,
                priorAnalysis: i
            };
            return new k(e, t, this,
                VA(s, this))
        };

    function yM(e, t) {
        var n = this
            .tryGetConcreteTree(e,
                t),
            r = n.getDependencies();
        return r.length ? new k(e,
            t, this, tn(this
                .getSliderVariables(
                    e, n))
                .setDependencies(r)
        ) : new k(e, t,
            this, this
                .tryGetConcreteTree(
                    e, t))
    }
    D.Histogram.prototype.analyze =
        function (e, t) {
            return Gr(this) ? kr(e,
                t, this) : e
                    .areAllScalesLinear() ?
                yM.call(this, e,
                    t) : new k(e, t,
                        this, nx())
        };
    D.DotPlot.prototype.analyze =
        function (e, t) {
            return Gr(this) ? kr(e,
                t, this) : e
                    .areAllScalesLinear() ?
                yM.call(this, e,
                    t) : new k(e, t,
                        this, rx())
        };
    D.BoxPlot.prototype.analyze =
        function (e, t) {
            return Gr(this) ? kr(e,
                t, this) : e
                    .areAllScalesLinear() ?
                yM.call(this, e,
                    t) : new k(e, t,
                        this, ix())
        };

    function GA(e) {
        return function (t, n) {
            if (Gr(this))
                return kr(t, n,
                    this);
            var r = this
                .tryGetConcreteTree(
                    t, n),
                i = r
                    .getDependencies();
            if (i.length)
                return new k(t,
                    n, this,
                    tn(this
                        .getSliderVariables(
                            t,
                            r
                        )
                    )
                        .setDependencies(
                            i));
            var s = new k(t, n,
                this, this
                    .tryGetConcreteTree(
                        t, n));
            if (!r.isError) {
                s.evaluationState
                    .expression_type =
                    "TTEST";
                var o = r.args
                    .map(
                        function (
                            a) {
                            return a
                                .asValue()
                        });
                s.evaluationState
                    .ttest_results =
                    e.apply(
                        null, o)
            }
            return s
        }
    }
    D.TTest.prototype.analyze = GA(
        uI);
    D.IndependentTTest.prototype
        .analyze = GA(cI);
    D.Stats.prototype.analyze =
        function (e, t) {
            if (Gr(this)) return kr(
                e, t, this);
            var n = this
                .tryGetConcreteTree(
                    e, t),
                r = n
                    .getDependencies();
            if (r.length)
                return new k(e, t,
                    this, tn(
                        this
                            .getSliderVariables(
                                e, n
                            ))
                        .setDependencies(
                            r));
            var i = new k(e, t,
                this, this
                    .tryGetConcreteTree(
                        e, t));
            if (!n.isError) {
                i.evaluationState
                    .expression_type =
                    "STATS";
                var s = n.args.map(
                    function (
                        o) {
                        return o
                            .asValue()
                    });
                i.evaluationState
                    .stats_results =
                    lI.apply(null,
                        s)
            }
            return i
        };
    D.Equation.prototype.analyze = D
        .CallAssignment.prototype
        .analyze = D.BaseComparator
            .prototype.analyze = _z;

    function _z(e, t) {
        if (Gr(this)) return kr(e,
            t, this);
        var n = this
            .getOperator() !== "=";
        if (n && !rs
            .plotInequalities)
            return new k(e, t, this,
                Sm());
        var r = eA({
            policy: e,
            frame: t
        }, this);
        if (r.isError) return new k(
            e, t, this, r);
        let i = Cs(e, r);
        if (r instanceof D
            .SolvedEquation && i
                .length) {
            var s = i.concat(r
                ._symbol);
            if (!e
                .validImplicitVariables(
                    s))
                return new k(e, t,
                    this, rc()
                        .setDependencies(
                            s))
        }
        return this.getGraphMode(e,
            r) === 8 && !e
                .validImplicitVariables(
                    i) ? new k(e, t,
                        this, rc()
                            .setDependencies(i)
                    ) : (r = Hc(e, this,
                        r), new k(e, t,
                            this, r))
    }
    D.DoubleInequality.prototype
        .analyze = function (e, t) {
            if (Gr(this)) return kr(
                e, t, this);
            if (!rs
                .plotInequalities)
                return new k(e, t,
                    this, Sm());
            var n = this
                .tryGetConcreteTree(
                    e, t);
            if (n.isError)
                return new k(e, t,
                    this, n);
            var r = n
                .getDependencies();
            return Rr[this
                ._operators[0]]
                .direction !== Rr[
                    this._operators[
                    1]]
                    .direction ? new k(
                        e, t, this, Cm()
                    ) : e
                        .validDoubleInequalitySymbol(
                            n._symbol) ? e
                                .validDoubleInequalityVariables(
                                    r) ? r.length >
                                        2 ? new k(e, t,
                                            this, tn(this
                                                .getSliderVariables(
                                                    e, n))
                                                .setDependencies(
                                                    r)) : n
                                                        ._expressions[0]
                                                        .getDependencies()
                                                        .indexOf(n
                                                            ._symbol) !== -1 ||
                                                        n._expressions[1]
                                                            .getDependencies()
                                                            .indexOf(n
                                                                ._symbol) !== -1 ?
                new k(e, t, this,
                    Rm()
                        .setDependencies(
                            r)) : new k(
                                e, t, this, n) :
                new k(e, t, this,
                    Om()
                        .setDependencies(
                            r)) : new k(
                                e, t, this, Om()
                                    .setDependencies(
                                        r))
        };
    D.ComparatorChain.prototype
        .analyze = function (e, t) {
            if (Gr(this)) return kr(
                e, t, this);
            var n = this
                .tryGetConcreteTree(
                    e, t);
            if (n.isError)
                return new k(e, t,
                    this, n);
            var r = n
                .getDependencies();
            if (r.length)
                if (e
                    .is3dPolicy()) {
                    if (!e
                        .validImplicitVariables(
                            r))
                        return new k(
                            e,
                            t,
                            this,
                            (this
                                .symbols
                                .includes(
                                    "="
                                ) ?
                                PP() :
                                MP()
                            )
                                .setDependencies(
                                    r
                                )
                        );
                    if (!(this
                        .symbols
                        .every(
                            s =>
                                s ===
                                "<" ||
                                s ===
                                "<="
                        ) ||
                        this
                            .symbols
                            .every(
                                s =>
                                    s ===
                                    ">" ||
                                    s ===
                                    ">="
                            ) ||
                        this
                            .symbols
                            .every(
                                s =>
                                    s ===
                                    "=")
                    ))
                        return new k(
                            e,
                            t,
                            this,
                            Cm()
                                .setDependencies(
                                    r
                                )
                        );
                    if (this.symbols
                        .includes(
                            "=") &&
                        !r.includes(
                            "z"))
                        return new k(
                            e,
                            t,
                            this,
                            vP()
                                .setDependencies(
                                    r
                                )
                        );
                    let i = this
                        ._difference
                        .tryGetConcreteTree(
                            e, t);
                    return i = Hc(e,
                        this, i
                    ),
                        new k(e, t,
                            this, i)
                } else return this
                    .symbols
                    .includes(
                        "=") ?
                    new k(e, t,
                        this,
                        DP()) :
                    this.symbols
                        .length >
                        2 ? new k(e,
                            t, this,
                            Mb()) :
                        e
                            .validDoubleInequalityVariables(
                                r) ?
                            new k(e, t,
                                this,
                                Rm()) :
                            new k(e, t,
                                this,
                                tn(this
                                    .getSliderVariables(
                                        e,
                                        n
                                    )
                                )
                                    .setDependencies(
                                        r));
            return new k(e, t, this,
                n)
        };
    D.ParenSeq.prototype.analyze =
        function (e, t, n) {
            if (Gr(this)) return kr(
                e, t, this);
            var r = this
                .tryGetConcreteTree(
                    e, t);
            if (r.isError)
                return new k(e, t,
                    this, r);
            var i = this
                .getMoveStrategy(e,
                    t, r, n);
            if (i) {
                var s = this
                    .getDefaultDragMode(
                        i),
                    o = r
                        .asCompilerValue(),
                    a = [new D
                        .Constant(o[
                            0]),
                    new D
                        .Constant(o[
                            1])
                    ];
                return new k(e, t,
                    this, new D
                        .MovablePoint(
                            a, i, s)
                )
            }
            return Sh(e, t, this, r)
        };

    function Lz(e, t) {
        return e.filter(function (
            n) {
            return !t[n]
        })
    }

    function wz(e) {
        for (var t = {}, n = 0; n <
            e.length; n++) {
            var r = e[n];
            if (r instanceof pc && r
                .header instanceof D
                    .Identifier) {
                var i = r.header
                    ._symbol;
                t[i] === void 0 && (
                    t[i] = 0),
                    t[i] += 1
            }
        }
        return t
    }
    D.Table.prototype.analyze =
        function (e, t) {
            var n = Object.create(
                t),
                r = [],
                i = wz(this
                    .columns),
                s;
            for (s = 0; s < this
                .columns.length; s++
            ) {
                var o = this
                    .columns[s];
                if (o instanceof pc &&
                    o
                        .header instanceof D
                        .Identifier) {
                    var a = o.header
                        ._symbol,
                        u = n[a],
                        c = i[a] >
                            1;
                    u && u
                        .isError &&
                        (u.isTableCycleWithoutGlobalDefinition ||
                            u
                                .isMultiplyDefinedByTables &&
                            !c) && (
                            n[a] =
                            void 0)
                }
                var l = o.analyze(e,
                    n);
                if (s === 0 && l
                    .concreteTree
                    .isIndependent
                ) {
                    var p = l
                        .concreteTree
                        .getDependencies()[
                        0];
                    e.validFirstColumnVariable(
                        p) || (
                            l =
                            new k(e,
                                t,
                                o,
                                OP()
                            ))
                }
                if (l.concreteTree
                    .isIndependent)
                    l.rawTree
                        .exportToLocal(
                            e, l
                            .concreteTree,
                            n);
                else if (!l
                    .concreteTree
                    .isError) {
                    var f = l
                        .concreteTree
                        .header
                        .getDependencies(),
                        m = Lz(f,
                            n);
                    m.length && (l =
                        new k(e,
                            t,
                            o,
                            tn(
                                m)
                                .setDependencies(
                                    m
                                )
                        ))
                }
                r.push(l
                    .concreteTree)
            }
            var g = 1;
            for (s = 0; s < r
                .length; s++) r[s]
                    .isError || (g =
                        Math.max(r[s]
                            .values
                            .length, g)
                    );
            for (s = 0; s < r
                .length; s++)
                if (!r[s].isError &&
                    r[s].header
                        .isConstant) {
                    for (var d = [],
                        y =
                            0; y <
                        g; y++) d
                            .push(r[s]
                                .header
                            );
                    r[s] = new D
                        .TableColumn(
                            r[s]
                                .header,
                            d)
                } var h = new D
                    .Table(r),
                    b = new k(e, t,
                        this, h);
            return b.evaluationState
                .is_graphable = !0,
                b
        };
    D.TableColumn.prototype
        .analyze = function (e, t) {
            var n = this.header
                .tableError();
            if (n) return new k(e,
                t, this, SP(
                    n));
            var r = this
                .tryGetConcreteTree(
                    e, t);
            if (r.isError)
                return new k(e, t,
                    this, r);
            if (r.header.isError)
                return new k(e, t,
                    this, r
                    .header);
            if (r.values.isError)
                return new k(e, t,
                    this, r
                    .values);
            for (var i = 0; i < r
                .values.length; i++)
                if (!r.values[i]
                    .isError) {
                    var s = this
                        .values[
                        i] && this
                            .values[i]
                            .tableError();
                    if (s) {
                        r.values[
                            i] = ml(
                                s);
                        continue
                    }
                    var o = r
                        .values[i]
                        .getDependencies();
                    o.length && (r
                        .values[
                        i] =
                        tn(o)
                            .setDependencies(
                                o))
                } return new k(e, t,
                    this, r)
        };
    D.Image.prototype.analyze =
        function (e, t, n) {
            var r = this
                .tryGetConcreteTree(
                    e, t);
            if (r.radianAngle
                .isError || r.center
                    .isError || r.width
                    .isError || r.height
                    .isError || r
                        .opacity.isError)
                return new k(e, t,
                    this, r);
            var i = r.center
                .getDependencies(),
                s = r.radianAngle
                    .getDependencies(),
                o = r.width
                    .getDependencies(),
                a = r.height
                    .getDependencies(),
                u = r.opacity
                    .getDependencies();
            return i.length || s
                .length || o
                    .length || a
                    .length || u
                    .length ? new k(e,
                        t, this, new D
                            .Image({
                                center: i
                                    .length ?
                                    tn(
                                        s)
                                        .setDependencies(
                                            i
                                        ) :
                                    r
                                        .center,
                                radianAngle: s
                                    .length ?
                                    tn(
                                        s)
                                        .setDependencies(
                                            s
                                        ) :
                                    r
                                        .radianAngle,
                                width: o
                                    .length ?
                                    tn(
                                        o)
                                        .setDependencies(
                                            o
                                        ) :
                                    r
                                        .width,
                                height: a
                                    .length ?
                                    tn(
                                        a)
                                        .setDependencies(
                                            a
                                        ) :
                                    r
                                        .height,
                                opacity: u
                                    .length ?
                                    tn(
                                        u)
                                        .setDependencies(
                                            u
                                        ) :
                                    r
                                        .opacity
                            })) : (r
                                .moveStrategy =
                                this
                                    .getMoveStrategy(
                                        e, t, r, n),
                                new k(e, t,
                                    this, r))
        };
    D.Slider.prototype.analyze =
        function (e, t) {
            if (Gr(this)) return kr(
                e, t, this);
            var n = this
                .tryGetConcreteTree(
                    e, t),
                r = n.sliderInfo,
                i;
            if (r.missingVars
                .length) {
                var s = wp(r
                    .missingVars
                );
                i = new k(e, t,
                    this, tn(e
                        .sliderVariables(
                            s))
                        .setDependencies(
                            s)
                        .allowExport()
                )
            } else i = new k(e, t,
                this, n);
            var o = i
                .evaluationState;
            if (rs.sliders) {
                o.assignment = r
                    .exportedSymbol,
                    o
                        .slider_min_number =
                    r.values.min, o
                        .slider_max_number =
                    r.values.max, o
                        .slider_step_number =
                    r.values.step, o
                        .slider_min_valid =
                    r.valids.min, o
                        .slider_max_valid =
                    r.valids.max, o
                        .slider_step_valid =
                    r.valids.step;
                var a = o
                    .slider_min_valid &&
                    o
                        .slider_max_valid &&
                    o
                        .slider_step_valid;
                o.is_slider = !0, o
                    .raw_slider_latex =
                    this
                        .getInputString(),
                    o.is_slidable =
                    a, o
                        .is_animatable =
                    o.is_slidable &&
                    !o.is_graphable,
                    r.errMsg && (o
                        .error = r
                            .errMsg
                            .getError())
            }
            return delete o
                .is_evaluable,
                delete o
                    .zero_values, i
        };

    function Gr(e) {
        return e.userData &&
            "latex" in e.userData &&
            wo(e.userData.latex)
                .slice(-1) === "="
    }

    function kr(e, t, n) {
        return new k(e, t, n, tf(
            "="))
    }

    function gM(e) {
        return e.concreteTree
            .isConstant && e
                .concreteTree
                .valueType === T
    }
    D.Base.prototype
        .analyzeFourFunction =
        function (e, t) {
            var n = this
                .tryGetConcreteTree(
                    e, t);
            return n.isError ?
                new k(e, t, this,
                    n) : new k(e, t,
                        this, J(
                            `Unexpected node type ${this.type}`
                        ))
        };
    D.Expression.prototype
        .analyzeFourFunction =
        function (e, t) {
            var n = this
                .tryGetConcreteTree(
                    e, t);
            if (n.isError)
                return new k(e, t,
                    this, n);
            var r = n
                .getDependencies();
            if (r.length > 0) {
                var i = r[0],
                    s, o = Ke[i];
                return o ? s = o
                    .isFunction ?
                    ms(i) : ic(i) :
                    s = cf(i),
                    new k(e, t,
                        this, s)
            }
            return new k(e, t, this,
                n)
        };
    D.Assignment.prototype
        .analyzeFourFunction =
        function (e, t) {
            return new k(e, t, this,
                lf())
        };
    D.FunctionDefinition.prototype
        .analyzeFourFunction =
        function (e, t) {
            return new k(e, t, this,
                pf())
        };

    function kA(e, t) {
        return new k(e, t, this,
            ma())
    }
    D.Equation.prototype
        .analyzeFourFunction = kA;
    D.CallAssignment.prototype
        .analyzeFourFunction = kA;

    function hM(e, t) {
        return new k(e, t, this,
            sc())
    }
    D.DoubleInequality.prototype
        .analyzeFourFunction = hM;
    D.ComparatorChain.prototype
        .analyzeFourFunction = hM;
    D.BaseComparator.prototype
        .analyzeFourFunction = hM;
    D.Regression.prototype
        .analyzeFourFunction =
        function (e, t) {
            return new k(e, t, this,
                oc())
        };
    D.ParenSeq.prototype
        .analyzeFourFunction =
        function (e, t) {
            return new k(e, t, this,
                ac())
        };
    D.Base.prototype
        .analyzeScientific =
        function (e, t) {
            var n = this
                .tryGetConcreteTree(
                    e, t);
            return n.isError ?
                new k(e, t, this,
                    n) : new k(e, t,
                        this, J(
                            `Unexpected node type ${this.type}`
                        ))
        };
    D.Expression.prototype
        .analyzeScientific =
        function (e, t) {
            var n = this
                .tryGetConcreteTree(
                    e, t);
            if (n.isError)
                return new k(e, t,
                    this, n);
            var r = n
                .getDependencies();
            return r.length > 0 ?
                new k(e, t, this,
                    tn(r)) : new k(
                        e, t, this, n)
        };
    D.Assignment.prototype
        .analyzeScientific =
        function (e, t) {
            var n = this._symbol;
            if (Ke[n]) return new k(
                e, t, this,
                fl(n));
            var r = Object.create(
                t);
            r[n] = ma();
            var i = this
                .tryGetConcreteTree(
                    e, r);
            if (i.isError)
                return new k(e, t,
                    this, i);
            var s = i
                .getDependencies();
            return this.isEquation(
                e, i) ? new k(e,
                    t, this, ma()) :
                s.length > 0 ?
                    new k(e, t, this,
                        tn(s)) : new k(
                            e, t, this, i)
        };
    D.FunctionDefinition.prototype
        .analyzeScientific =
        function (e, t) {
            if (Ke[this._symbol])
                return new k(e, t,
                    this, fl(
                        this
                            ._symbol
                    ));
            var n = this
                .tryGetConcreteTree(
                    e, t);
            if (n.isError)
                return new k(e, t,
                    this, n);
            var r = this
                ._argSymbols,
                i = n
                    .getDependencies();
            if (i.indexOf(this
                ._symbol) !== -
                1) return new k(e,
                    t, this, $a(
                        [this
                            ._symbol
                        ]));
            var s = i.filter(
                function (o) {
                    return r
                        .indexOf(
                            o
                        ) ===
                        -1
                });
            return s.length ? new k(
                e, t, this, rf(
                    s, this
                    ._symbol, r)
            ) : new k(e, t,
                this, n)
        };

    function zA(e, t) {
        return new k(e, t, this,
            ma())
    }
    D.Equation.prototype
        .analyzeScientific = zA;
    D.CallAssignment.prototype
        .analyzeScientific = zA;

    function bM(e, t) {
        return new k(e, t, this,
            sc())
    }
    D.DoubleInequality.prototype
        .analyzeScientific = bM;
    D.ComparatorChain.prototype
        .analyzeScientific = bM;
    D.BaseComparator.prototype
        .analyzeScientific = bM;
    D.Regression.prototype
        .analyzeScientific =
        function (e, t) {
            return new k(e, t, this,
                oc())
        };
    D.ParenSeq.prototype
        .analyzeScientific =
        function (e, t) {
            return new k(e, t, this,
                ac())
        };
    D.Base.prototype
        .analyzeSingleExpressionScientific =
        function (e, t) {
            var n = this
                .tryGetConcreteTree(
                    e, t);
            return n.isError ?
                new k(e, t, this,
                    n) : new k(e, t,
                        this, J(
                            `Unexpected node type ${this.type}`
                        ))
        };
    D.Expression.prototype
        .analyzeSingleExpressionScientific =
        function (e, t) {
            var n = this
                .tryGetConcreteTree(
                    e, t);
            if (n.isError)
                return new k(e, t,
                    this, n);
            var r = n
                .getDependencies();
            if (r.length > 0) {
                var i = r[0],
                    s, o = Ke[i];
                return o ? s = o
                    .isFunction ?
                    ms(i) : ic(i) :
                    s = cf(i),
                    new k(e, t,
                        this, s)
            }
            return new k(e, t, this,
                n)
        };
    D.Assignment.prototype
        .analyzeSingleExpressionScientific =
        function (e, t) {
            return new k(e, t, this,
                lf())
        };
    D.FunctionDefinition.prototype
        .analyzeSingleExpressionScientific =
        function (e, t) {
            return new k(e, t, this,
                pf())
        };

    function HA(e, t) {
        return new k(e, t, this,
            ma())
    }
    D.Equation.prototype
        .analyzeSingleExpressionScientific =
        HA;
    D.CallAssignment.prototype
        .analyzeSingleExpressionScientific =
        HA;

    function xM(e, t) {
        return new k(e, t, this,
            sc())
    }
    D.DoubleInequality.prototype
        .analyzeSingleExpressionScientific =
        xM;
    D.ComparatorChain.prototype
        .analyzeSingleExpressionScientific =
        xM;
    D.BaseComparator.prototype
        .analyzeSingleExpressionScientific =
        xM;
    D.Regression.prototype
        .analyzeSingleExpressionScientific =
        function (e, t) {
            return new k(e, t, this,
                oc())
        };
    D.ParenSeq.prototype
        .analyzeSingleExpressionScientific =
        function (e, t) {
            return new k(e, t, this,
                ac())
        };
    D.Base.prototype.getGraphInfo =
        function (e, t) {
            var n = t
                .getDependencies(),
                r, i;
            switch (n.length) {
                case 0:
                    r = UA(t), i = t
                        .boundDomain(
                            "x");
                    break;
                case 1:
                    i = t
                        .boundDomain(
                            n[0]),
                        Yi(i) && !
                        gi(i) && (
                            r = UA(
                                t));
                    break;
                default:
                    i = Xn();
                    break
            }
            return {
                graphMode: this
                    .getGraphMode(e,
                        t),
                color: sa(this
                    .userData,
                    this
                        .metaData),
                pointStyle: this
                    .userData
                    .pointStyle,
                lineStyle: this
                    .userData
                    .lineStyle,
                arrowMode: this
                    .userData
                    .arrowMode,
                operator: this
                    .getOperator(),
                isLinear: !!r,
                linearCoefficients: r,
                domainBound: i
            }
        };

    function UA(e) {
        switch (e.valueType) {
            case T:
                return PM(e);
            case R: {
                var t = PM(e
                    .elementAt(
                        0)),
                    n = PM(e
                        .elementAt(
                            1));
                return !t || !n ?
                    void 0 : [t, n]
            }
            default:
                return
        }
    }

    function PM(e) {
        var t = e.getDependencies();
        switch (t.length) {
            case 0:
                return [+e
                    .asValue(), 0
                ];
            case 1:
                if (e
                    .polynomialOrder(
                        t[0]) > 1)
                    return;
                var n = e
                    .getPolynomialCoefficients(
                        t[0]);
                return [n[0] ? +n[0]
                    .asValue() :
                    0, n[1] ? +
                        n[1]
                            .asValue() :
                    0
                ];
            default:
                return
        }
    }
    var qA = new D.Constant(De(0,
        1));
    D.Base.prototype
        .getMoveStrategy =
        function () { };
    D.Assignment.prototype
        .getMoveStrategy = function (
            e, t, n, r) {
            return this._expression
                .getMoveStrategy(e,
                    t, n, r)
        };

    function Fz(e) {
        return {
            type: "updateSliderNonlinear",
            id: e.id,
            initialValue: e
                .initialValue,
            min: e.min,
            max: e.max,
            compiled: e.compiled,
            movesOn: e.movesOn,
            hasLinearComponent: e
                .hasLinearComponent
        }
    }

    function Vz(e) {
        return {
            type: "updateGliderParameter",
            span: e.span,
            movesOn: e.movesOn
        }
    }

    function Bz(e) {
        return {
            type: "updateSliderForGlider",
            id: e.sliderId,
            movesOn: e.movesOn,
            min: e.min,
            max: e.max
        }
    }

    function $A(e, t, n, r, i, s) {
        var o = t.getDependencies();
        for (let y of o)
            if (i[y]) return;
        for (var a = o.length -
            1; a >= 0; a--) {
            var u = o[a];
            if (!s[u]) {
                var c = r[u];
                if (c !== void 0) {
                    var l = n[u];
                    if (l.order ===
                        1) {
                        var p = l
                            .tree,
                            f = p
                                .getPolynomialCoefficients(
                                    u),
                            m = f[
                                1] ||
                                qA,
                            g = f[
                                0] ||
                                qA;
                        if (!(!g.isConstant ||
                            !m
                                .isConstant
                        ) &&
                            !(!isFinite(
                                g
                                    .asValue()
                            ) ||
                                !
                                isFinite(
                                    m
                                        .asValue()
                                )
                            ) &&
                            m
                                .asValue() !==
                            0) {
                            var d = [
                                -
                                g
                                    .asValue() /
                                m
                                    .asValue(),
                                1 /
                                m
                                    .asValue()
                            ];
                            return {
                                symbol: u,
                                id: c,
                                coefficients: d
                            }
                        }
                    }
                }
            }
        }
    }

    function Gz(e, t) {
        for (var n in t) {
            var r = t[n]
                .evaluationState,
                i = r.assignment;
            if (i === e) return n
        }
    }

    function kz(e) {
        for (var t = {}, n = 0; n <
            e.length; n++) t[e[
                n]] = !0;
        return t
    }

    function TM(e, t) {
        var n = kz(e),
            r = {};
        for (var i in t) {
            var s = t[i]
                .evaluationState
                .assignment;
            t[i].evaluationState
                .is_slidable && n[
                s] && (r[s] = i)
        }
        return r
    }

    function YA(e, t, n, r) {
        for (var i = [], s = 0; s <
            n.length; s++) {
            var o = n[s],
                a = {};
            i.push(a);
            for (var u = 0; u < r
                .length; u++) {
                var c = r[u],
                    l = Object
                        .create(t);
                l[c] = void 0;
                var p = o
                    .tryGetConcreteTree(
                        e, l);
                if (p.isError) {
                    a[c] = {
                        tree: p,
                        order: 1 /
                            0
                    };
                    continue
                } else a[c] = {
                    tree: p,
                    order: p
                        .polynomialOrder(
                            c)
                }
            }
        }
        return i
    }

    function XA(e, t, n) {
        for (var r = 0; r < e
            .length; r++) {
            var i = e[r];
            t[i].order !== 0 && (n[
                i] = !0)
        }
    }
    D.ParenSeq.prototype
        .getMoveStrategy = function (
            e, t, n, r) {
            if (n.valueType !== R ||
                n.getDependencies()
                    .length !== 0)
                return;
            for (var i = this
                .getDependencies(),
                s = TM(i, r),
                o = Object.keys(
                    s), a = this
                        .args, u = YA(e,
                            t, a, o),
                c = [], l = {},
                p = {}, f =
                    0; f < 2; f++) {
                var m = a[f];
                let I = m
                    .getInputSpan();
                if (m.isConstant) {
                    c[f] = I ? {
                        type: "updateCoordinate",
                        inputSpan: I
                    } : {
                        type: "none"
                    };
                    continue
                }
                var g = $A(e, m, u[
                    f], s,
                    l, p);
                g && (c[f] = {
                    type: "updateSlider",
                    id: g
                        .id,
                    coefficients: g
                        .coefficients
                }, l[g
                    .symbol
                ] = !0,
                    XA(o, u[f],
                        p)), c[
                        f] || (c[
                            f] = {
                            type: "none"
                        })
            }
            let [d, y] = c, h;
            if (d.type === "none" &&
                y.type === "none" &&
                o.length === 1 && (
                    h = o[0]), !h)
                return d.type !==
                    "none" || y
                        .type !==
                    "none" ? c :
                    void 0;
            var b = s[h],
                x;
            try {
                var P = Object
                    .create(t);
                P[h] = void 0, x =
                    this
                        .getConcreteTree(
                            e, P)
                        .getCompiledFunction()
            } catch (I) {
                return
            }
            MI(x);
            var M = r[b]
                .evaluationState;
            return [Fz({
                id: b,
                initialValue: M
                    .constant_value,
                min: M
                    .slider_min_number,
                max: M
                    .slider_max_number,
                compiled: x,
                hasLinearComponent: d
                    .type ===
                    "updateSlider" ||
                    y
                        .type ===
                    "updateSlider"
            }), {
                type: "none"
            }]
        };
    D.FunctionCall.prototype
        .getMoveStrategy = function (
            e, t, n, r) {
            if (this._symbol ===
                "glider" && !(!n
                    .isTypedConstant ||
                    n.valueType !==
                    R)) {
                var i, s, o;
                switch (this.args[1]
                    .type) {
                    case "Constant": {
                        var a = this
                            .args[1]
                            .asValue();
                        if (typeof a !=
                            "number" ||
                            (i = this
                                .args[
                                0
                            ]
                                .getConcreteTree(
                                    e,
                                    t
                                ),
                                !i
                                    .isTypedConstant
                            ))
                            return;
                        o = i
                            .asTypedValue();
                        let m = this
                            .args[1]
                            .getInputSpan();
                        return [m ?
                            Vz({
                                span: m,
                                movesOn: o
                            }) :
                            {
                                type: "none"
                            }, {
                            type: "none"
                        }
                        ]
                    }
                    case "Identifier": {
                        var u = this
                            .args[1]
                            ._symbol,
                            c = TM([
                                u],
                                r),
                            l = c[
                                u];
                        if (l ===
                            void 0)
                            return;
                        var p = r[l]
                            .evaluationState,
                            f =
                                Object
                                    .create(
                                        t);
                        return f[
                            u] =
                            void 0,
                            i = this
                                .args[0]
                                .getConcreteTree(
                                    e, f
                                ), i
                                    .isTypedConstant ?
                                (o = i
                                    .asTypedValue(),
                                    s = {
                                        min: p
                                            .slider_min_number,
                                        max: p
                                            .slider_max_number
                                    }, [Bz({
                                        min: s
                                            .min,
                                        max: s
                                            .max,
                                        movesOn: o,
                                        sliderId: l
                                    }),
                                    {
                                        type: "none"
                                    }]
                                ) :
                                void 0
                    }
                    default:
                        return
                }
            }
        };
    D.Image.prototype
        .getMoveStrategy = function (
            e, t, n, r) {
            if (!(n.center
                .valueType !==
                R || n.center
                    .getDependencies()
                    .length !== 0 ||
                !n.width
                    .isConstant || !
                n.height
                    .isConstant || !
                n.radianAngle
                    .isConstant || !
                n.opacity
                    .isConstant)) {
                var i = this
                    .getDependencies(),
                    s = TM(i, r),
                    o = Object.keys(
                        s),
                    a = [this.width,
                    this.height
                    ];
                this.center.type ===
                    "ParenSeq" ? a
                        .push(this
                            .center
                            .args[0],
                            this.center
                                .args[1]) :
                    this.center
                        .type ===
                    "Identifier" &&
                    (this.center
                        .referencedStatementId =
                        Gz(this
                            .center
                            ._symbol,
                            r));
                for (var u = {},
                    c = {}, l =
                        YA(e, t, a,
                            o),
                    p = [],
                    f = [2, 3,
                        0, 1
                    ], m =
                        0; m < f
                            .length; m++) {
                    var g = f[m],
                        d = a[g];
                    if (!d) {
                        p[g] = {
                            type: "none"
                        };
                        continue
                    }
                    if (d
                        .isConstant) {
                        let h = d
                            .getInputSpan();
                        p[g] = h ? {
                            type: "updateCoordinate",
                            inputSpan: h
                        } : {
                            type: "none"
                        };
                        continue
                    }
                    var y = $A(e, d,
                        l[g], s,
                        u, c);
                    y && (p[g] = {
                        type: "updateSlider",
                        id: y
                            .id,
                        coefficients: y
                            .coefficients
                    }, u[y
                        .symbol
                    ] = !
                        0, XA(o,
                            l[
                            g],
                            c)),
                        p[g] || (p[
                            g] = {
                            type: "none"
                        })
                }
                if (!(p[0].type ===
                    "none" && p[
                        1]
                        .type ===
                    "none" && p[
                        2]
                        .type ===
                    "none" && p[
                        3]
                        .type ===
                    "none"))
                    return p
            }
        };
    D.Base.prototype
        .getDefaultDragMode =
        function (e) {
            return "NONE"
        };
    D.Assignment.prototype
        .getDefaultDragMode =
        function (e) {
            return e[0].type !==
                "none" && e[1]
                    .type !== "none" ?
                "XY" : e[0].type !==
                    "none" ? "X" : e[1]
                        .type !== "none" ?
                    "Y" : "NONE"
        };
    D.ParenSeq.prototype
        .getDefaultDragMode =
        function (e) {
            return e[0].type ===
                "updateSlider" && e[
                    1].type ===
                "updateSlider" ?
                "XY" : e[0].type ===
                    "updateSlider" ?
                    "X" : e[1].type ===
                        "updateSlider" ?
                        "Y" : e[0].type ===
                            "updateSliderNonlinear" &&
                            e[0]
                                .hasLinearComponent ?
                            "X" : "NONE"
        };
    D.FunctionCall.prototype
        .getDefaultDragMode =
        function (e) {
            return this._symbol !==
                "glider" ? "NONE" :
                D.Assignment
                    .prototype
                    .getDefaultDragMode
                    .call(this, e)
        };
    var zz = D.List;
    D.Base.prototype.tableInfo =
        function (e, t) {
            return !1
        };
    D.Identifier.prototype
        .tableInfo = function (e,
            t) {
            return e
                .validFirstColumnVariable(
                    this._symbol) ?
                {
                    independent_variable: this
                        ._symbol,
                    dependent_column: this
                        .getInputString(),
                    by_reference: !1
                } : !1
        };
    D.Expression.prototype
        .tableInfo = function (e,
            t) {
            var n = t
                .getDependencies();
            if (Aa(this)) return !1;
            switch (t.valueType) {
                case R:
                case Pt:
                    if (n.length !==
                        0 || t
                            .isMovablePoint &&
                        (t.moveStrategy[
                            0]
                            .type ===
                            "updateSlider" ||
                            t
                                .moveStrategy[
                                1]
                                .type ===
                            "updateSlider"
                        ))
                        return !1;
                    var r = zz.wrap(
                        t)
                        .asValue();
                    return {
                        independent_variable
                            : "x",
                        dependent_column:
                            "y",
                        by_reference:
                            !1,
                        values:
                            r
                    };
                case T:
                    if (n.length !==
                        1) return !
                            1;
                    var i = n[0];
                    return e
                        .validFirstColumnVariable(
                            i) ? {
                        independent_variable: i,
                        dependent_column: this
                            .getInputString(),
                        by_reference:
                            !1
                    } : !1;
                default:
                    return !1
            }
        };
    D.Assignment.prototype
        .tableInfo = function (e,
            t) {
            if (t instanceof D
                .SolvedEquation || !
                this
                    .getInputString()
                    .length || Aa(
                        this) || Sp(t
                            .valueType))
                return !1;
            let n = t
                .getDependencies();
            if (n.length > 1)
                return !1;
            let r;
            if (n.length === 0) {
                if (!e
                    .tableableAsConstant(
                        this._symbol
                    )) return !
                        1;
                r = e
                    .implicitIndependent(
                        this._symbol
                    )
            } else r = n[0];
            if (!e
                .validFirstColumnVariable(
                    r)) return !1;
            let i = e
                .assignmentForbidden(
                    this._symbol) ?
                wo(this
                    .getInputString()
                    .replace(
                        /[^=]*=/, ""
                    )) : wo(this
                        .getInputString()
                        .split("=")[0]);
            return {
                independent_variable: r,
                dependent_column: i,
                by_reference: !e
                    .assignmentForbidden(
                        this._symbol
                    )
            }
        };
    D.FunctionDefinition.prototype
        .tableInfo = function (e,
            t) {
            if (this._argSymbols
                .length !== 1 || !
                this
                    .getInputString()
                    .length) return !1;
            var n = t
                .getDependencies();
            if (n.length > 1)
                return !1;
            var r = this
                ._argSymbols[0];
            if (!e
                .validFirstColumnVariable(
                    r)) return !1;
            var i = e
                .assignmentForbidden(
                    this._symbol),
                s = i ? wo(this
                    .getInputString()
                    .replace(
                        /[^=]*=/, ""
                    )) : wo(this
                        .getInputString()
                        .split("=")[0]);
            return {
                independent_variable: r,
                dependent_column: s,
                by_reference: !i
            }
        };
    D.BaseComparator.prototype
        .tableInfo = function (e,
            t) {
            return !1
        };
    D.ComparatorChain.prototype
        .tableInfo = function (e,
            t) {
            return !1
        };
    D.DoubleInequality.prototype
        .tableInfo = function (e,
            t) {
            return !1
        };
    D.Equation.prototype.tableInfo =
        function (e, t) {
            return !1
        };
    D.Base.prototype.tableError =
        function () {
            return this
                .isInequality() ? S(
                    "shared-calculator-error-table-inequality-supplement"
                ) : !(
                    this instanceof D
                        .Expression) &&
                    !(this instanceof D
                        .IRExpression) ?
                S(
                    "shared-calculator-error-table-generic-supplement") :
                !1
        };
    D.List.prototype.tableError =
        function () {
            return S(
                "shared-calculator-error-table-list-supplement"
            )
        };
    D.Equation.prototype
        .tableError = D.Assignment
            .prototype.tableError =
        function () {
            return S(
                "shared-calculator-error-table-equation-supplement"
            )
        };
    D.ComparatorChain.prototype
        .tableError = function () {
            return this.symbols
                .includes("=") ? S(
                    "shared-calculator-error-table-equation-supplement"
                ) : S(
                    "shared-calculator-error-table-inequality-supplement"
                )
        };
    D.FunctionDefinition.prototype
        .tableError = function () {
            return S(
                "shared-calculator-error-table-function-definition-supplement"
            )
        };
    D.Regression.prototype
        .tableError = function () {
            return S(
                "shared-calculator-error-table-regression-supplement"
            )
        };
    D.List.prototype.elementAt =
        function (e) {
            return e = Math.floor(
                e), e >= 0 && e <
                    this.args.length ?
                    this.args[e] : new D
                        .Constant(NaN)
        };
    D.List.prototype.eachElement =
        function (t) {
            for (var n = 0; n < this
                .length; n++) t(this
                    .elementAt(n), n
                )
        };
    D.List.prototype.mapElements =
        function (t) {
            for (var n = [], r =
                0; r < this
                    .length; r++) n
                        .push(t(this
                            .elementAt(
                                r), r));
            return n
        };
    D.IRExpression.prototype
        .elementAt = function (e) {
            var t = this._chunk
                .elementAt(e);
            return new pn(t)
        };
    D.ParenSeq.prototype.elementAt =
        function (e) {
            return e < 0 || e > this
                .args.length - 1 ?
                new D.Constant(
                    NaN) : this.args[e]
        };

    function Hz() {
        return ur(this._symbol) +
            " "
    }
    D.Identifier.prototype
        .printLatex = Hz;
    D.Constant.prototype
        .printLatex = function () {
            return ta(this
                .asValue())
        };
    D.Ticker.prototype.printLatex =
        function () {
            return "\\ticker\\left(" +
                this.args.map(mi)
                    .join(", ") +
                "\\right)"
        };
    D.Negative.prototype
        .printLatex = function () {
            return "-\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)"
        };
    D.Add.prototype.printLatex =
        function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)+\\left(" +
                this.args[1]
                    .printLatex() +
                "\\right)"
        };
    D.PercentOf.prototype
        .printLatex = function () {
            return this.args[0]
                .printLatex() +
                " \\% \\operatorname{of} " +
                this.args[1]
                    .printLatex()
        };
    D.Subtract.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)-\\left(" +
                this.args[1]
                    .printLatex() +
                "\\right)"
        };
    D.Multiply.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)*\\left(" +
                this.args[1]
                    .printLatex() +
                "\\right)"
        };
    D.DotMultiply.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)\\cdot\\left(" +
                this.args[1]
                    .printLatex() +
                "\\right)"
        };
    D.CrossMultiply.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)\\times\\left(" +
                this.args[1]
                    .printLatex() +
                "\\right)"
        };
    D.Divide.prototype.printLatex =
        function () {
            return "\\frac{" + this
                .args[0]
                .printLatex() +
                "}{" + this.args[1]
                    .printLatex() + "}"
        };
    D.Exponent.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)^{" + this
                    .args[1]
                    .printLatex() + "}"
        };
    D.Assignment.prototype
        .printLatex = function () {
            return ur(this
                ._symbol) + "=" +
                this._expression
                    .printLatex()
        };
    D.CoordinateEquation.prototype
        .printLatex = function () {
            return "\\left(" + this
                ._symbols.map(e =>
                    ur(e)).join(
                        ",") + "\\right)=" +
                this._expression
                    .printLatex()
        };
    D.Equation.prototype
        .printLatex = D
            .CallAssignment.prototype
            .printLatex = function () {
                return this._lhs
                    .printLatex() +
                    "=" + this._rhs
                        .printLatex()
            };

    function Oh(e) {
        switch (e) {
            case ">":
                return ">";
            case "<":
                return "<";
            case ">=":
                return "\\ge ";
            case "<=":
                return "\\le ";
            case "=":
                return "="
        }
        return ""
    }
    D.BaseComparator.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)" + Oh(this
                    .operator) +
                "\\left(" + this
                    .args[1]
                    .printLatex() +
                "\\right)"
        };
    D.ComparatorChain.prototype
        .printLatex = function () {
            let e = "";
            for (let t = 0; t < this
                .symbols.length; t++
            ) e +=
                `\\left(${this.args[t].printLatex()}\\right)${Oh(this.symbols[t])}`;
            return e +=
                `\\left(${this.args[this.args.length - 1].printLatex()}\\right)`,
                e
        };
    D.DoubleInequality.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)" + Oh(this
                    .args[1]) + this
                        .args[2]
                        .printLatex() + Oh(
                            this.args[3]) +
                "\\left(" + this
                    .args[4]
                    .printLatex() +
                "\\right)"
        };
    D.Or.prototype.printLatex =
        function () {
            return this.args[0]
                .printLatex() +
                "," + this.args[1]
                    .printLatex()
        };

    function mi(e) {
        return e.printLatex()
    }

    function Uz() {
        switch (this._symbol) {
            case "sqrt":
                return "\\sqrt{" +
                    this.args[0]
                        .printLatex() +
                    "}";
            case "nthroot":
                return "\\sqrt[" +
                    this.args[1]
                        .printLatex() +
                    "]{" + this
                        .args[0]
                        .printLatex() +
                    "}";
            case "logbase":
                return "\\log_{" +
                    this.args[1]
                        .printLatex() +
                    "}\\left(" +
                    this.args[0]
                        .printLatex() +
                    "\\right)";
            default:
                return ur(this
                    ._symbol) +
                    "\\left(" + this
                        .args.map(mi)
                        .join(", ") +
                    "\\right)"
        }
    }
    D.FunctionCall.prototype
        .printLatex = Uz;
    D.RecursiveFunctionBaseCase
        .prototype.printLatex =
        function () {
            return this.originalNode
                .printLatex()
        };
    D.SeededFunctionCall.prototype
        .printLatex = function () {
            return ur(this
                ._symbol) +
                "\\left(" + this
                    .args.slice(1).map(
                        mi).join(", ") +
                "\\right)"
        };
    D.DotAccess.prototype
        .printLatex = function () {
            return "(" + this.args[
                0]
                .printLatex() + ").(" +
                this.args[1]
                    .printLatex() + ")"
        };
    D.Prime.prototype.printLatex =
        function () {
            switch (this.args[0]
                ._symbol) {
                case "logbase":
                    return "\\log_{" +
                        this.args[0]
                            .args[1]
                            .printLatex() +
                        "}" + Array(
                            this
                                .order +
                            1).join(
                                "'") +
                        "\\left(" +
                        this.args[0]
                            .args[0]
                            .printLatex() +
                        "\\right)";
                default:
                    return ur(this
                        .args[0]
                        ._symbol
                    ) +
                        Array(this
                            .order +
                            1).join(
                                "'") +
                        "\\left(" +
                        this.args[0]
                            .args.map(
                                mi)
                            .join(
                                ", ") +
                        "\\right)"
            }
        };
    D.List.prototype.printLatex =
        function () {
            return "\\left[" + this
                .args.map(mi).join(
                    ", ") +
                "\\right]"
        };
    D.Range.prototype.printLatex =
        function () {
            return "\\left[" + this
                .args[0].args.map(
                    mi).join(", ") +
                " ... " + this.args[
                    1].args.map(mi)
                    .join(", ") +
                "\\right]"
        };
    D.UpdateRule.prototype
        .printLatex = function () {
            return this.args[0]
                .printLatex() +
                "\\to(" + this.args[
                    1]
                    .printLatex() + ")"
        };
    D.ListAccess.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args[0]
                .printLatex() +
                "\\right)\\left[" +
                this.args[1]
                    .printLatex() +
                "\\right]"
        };
    D.ParenSeq.prototype
        .printLatex = function () {
            return "\\left(" + this
                .args.map(mi).join(
                    ", ") +
                "\\right)"
        };
    D.BareSeq.prototype.printLatex =
        function () {
            return this.args.map(mi)
                .join(", ")
        };
    D.NamedCoordinateAccess
        .prototype.printLatex =
        function () {
            return "\\left(\\left(" +
                this.args[0]
                    .printLatex() +
                "\\right)." + this
                    .symbol + "\\right)"
        };
    D.Norm.prototype.printLatex =
        function () {
            return "\\left|" + this
                .args[0]
                .printLatex() +
                "\\right|"
        };
    D.Sum.prototype.printLatex =
        function () {
            return "\\sum_{" + this
                .args[0]
                .printLatex() +
                "=" + this.args[1]
                    .printLatex() +
                "}^{" + this.args[2]
                    .printLatex() +
                "}\\left(" + this
                    .args[3]
                    .printLatex() +
                "\\right)"
        };
    D.Product.prototype.printLatex =
        function () {
            return "\\prod_{" + this
                .args[0]
                .printLatex() +
                "=" + this.args[1]
                    .printLatex() +
                "}^{" + this.args[2]
                    .printLatex() +
                "}\\left(" + this
                    .args[3]
                    .printLatex() +
                "\\right)"
        };
    D.Integral.prototype
        .printLatex = function () {
            return "\\int_{" + this
                .args[1]
                .printLatex() +
                "}^{" + this.args[2]
                    .printLatex() +
                "}\\left(" + this
                    .args[3]
                    .printLatex() +
                "\\right)d" + this
                    .args[0]
                    .printLatex()
        };
    D.FunctionExponent.prototype
        .printLatex = function () {
            return this.args[0]
                .printLatex() +
                "\\left(" + this
                    .args[1]
                    .printLatex() +
                "\\right)^{" + this
                    .args[2]
                    .printLatex() + "}"
        };
    D.FunctionFactorial.prototype
        .printLatex = function () {
            return this.args[0]
                .printLatex() +
                "\\left(" + this
                    .args[1]
                    .printLatex() +
                "\\right)!"
        };

    function IM(e) {
        return e.isConstant && e
            .asValue() === !0
    }

    function qz(e) {
        return e.isConstant && e
            .isNaN()
    }
    D.Piecewise.prototype
        .printLatex = function () {
            var e = this;
            if (IM(e.args[0]))
                return e.args[1]
                    .printLatex();
            for (var t = [
                "\\left\\{"
            ]; ;) {
                if (IM(e.args[0])) {
                    t.push(e.args[1]
                        .printLatex()
                    );
                    break
                }
                if (t.push(e.args[0]
                    .printLatex(),
                    ": "), qz(e
                        .args[2])) {
                    t.push(e.args[1]
                        .printLatex()
                    );
                    break
                }
                if (t.push(e.args[1]
                    .printLatex(),
                    ", "), !(e
                        .args[
                        2] instanceof D
                            .Piecewise
                    )) {
                    t.push(e.args[2]
                        .printLatex()
                    );
                    break
                }
                e = e.args[2]
            }
            return t.push(
                "\\right\\}"), t
                    .join("")
        };
    D.Restriction.prototype
        .printLatex = function () {
            return IM(this.args[
                0]) ?
                "\\left\\{\\right\\}" :
                "\\left\\{" + this
                    .args[0]
                    .printLatex() +
                "\\right\\}"
        };
    D.FunctionDefinition.prototype
        .printLatex = function () {
            return ur(this
                ._symbol) +
                "\\left(" + this
                    ._argSymbols.map(ur)
                    .join(", ") +
                "\\right) = " + this
                    ._expression
                    .printLatex()
        };
    D.Derivative.prototype
        .printLatex = function () {
            return "\\frac{d}{d" +
                ur(this._symbol) +
                "}\\left(" + this
                    .args[0]
                    .printLatex() +
                "\\right)"
        };
    D.Regression.prototype
        .printLatex = function () {
            return "\\left(" + this
                ._lhs.printLatex() +
                "\\right)\\sim\\left(" +
                this._rhs
                    .printLatex() +
                "\\right)"
        };
    D.Histogram.prototype
        .printLatex = function () {
            return "\\histogram\\left(" +
                this.args.map(mi)
                    .join(", ") +
                "\\right)"
        };
    D.DotPlot.prototype.printLatex =
        function () {
            return "\\dotplot\\left(" +
                this.args.map(mi)
                    .join(", ") +
                "\\right)"
        };
    D.BoxPlot.prototype.printLatex =
        function () {
            return "\\boxplot\\left(" +
                this.args.map(mi)
                    .join(", ") +
                "\\right)"
        };
    D.TTest.prototype.printLatex =
        function () {
            return "\\TTest\\left(" +
                this.args.map(mi)
                    .join(", ") +
                "\\right)"
        };
    D.IndependentTTest.prototype
        .printLatex = function () {
            return "\\IndependentTTest\\left(" +
                this.args.map(mi)
                    .join(", ") +
                "\\right)"
        };
    D.Stats.prototype.printLatex =
        function () {
            return "\\Stats\\left(" +
                this.args.map(mi)
                    .join(", ") +
                "\\right)"
        };
    D.AssignmentExpression.prototype
        .printLatex = function () {
            return ur(this
                ._symbol) + "=" +
                this.args[1]
                    .printLatex()
        };
    D.ListComprehension.prototype
        .printLatex = function () {
            return "\\left[" + this
                ._body
                .printLatex() +
                "\\operatorname{for}" +
                this._inputLists
                    .map(mi).join(
                        ", ") + "\\right]"
        };
    D.Substitution.prototype
        .printLatex = function () {
            return "\\left(\\left(" +
                this._body
                    .printLatex() +
                "\\right)\\operatorname{with}" +
                this._assignments
                    .map(mi).join(
                        ", ") + "\\right)"
        };
    D.Construction.prototype
        .printLatex = function () {
            return "\\construction "
        };
    D.Base.prototype
        .getExpressionType =
        function (e, t) {
            switch (e) {
                case 114:
                case 115:
                case 116:
                    return t && W(
                        t) ?
                        "POINT3D_LIST" :
                        "POINT3D";
                case 100:
                case 101:
                case 102:
                case 128:
                    return "CURVE3D_xyz_t";
                case 119:
                    return "SEGMENT3D";
                case 129:
                    return "VECTOR3D";
                case 130:
                case 103:
                case 104:
                case 105:
                    return "SURFACE_xyz_uv";
                case 110:
                    return "SURFACE_r_z";
                case 124:
                    return "SURFACE_r_z_AMBIGUOUS";
                case 109:
                    return "SURFACE_z_r";
                case 111:
                    return "SURFACE_r_";
                case 107:
                case 108:
                case 106:
                    return "SURFACE";
                case 118:
                    return "SPHERE3D";
                case 117:
                    return "TRIANGLE3D";
                case 120:
                case 121:
                    return "SURFACE_AMBIGUOUS";
                case 122:
                case 123:
                    return "SURFACE_CONSTANT_AMBIGUOUS";
                case 112:
                case 113:
                case 210:
                    return "IMPLICIT_SURFACE";
                case 126:
                case 127:
                    return "IMPLICIT_SURFACE_AMBIGUOUS";
                case 3:
                case 4:
                    return t && W(
                        t) ?
                        "POINT_LIST" :
                        "SINGLE_POINT";
                case 1:
                case 2:
                    return "X_OR_Y";
                case 5:
                    return "PARAMETRIC";
                case 6:
                    return "POLAR";
                case 8:
                    return "IMPLICIT";
                case 24:
                case 17:
                    return "VECTOR2D";
                case 200:
                case 201:
                case 202:
                case 205:
                case 209:
                    return "SLICE";
                case 211:
                case 206:
                    return "SLICE_rz_at_z";
                case 203:
                    return "SLICE_zr_at_r";
                case 204:
                    return "SLICE_zr_at_";
                case 213:
                    return "SLICE_zr_at_xyz";
                case 207:
                    return "SLICE_r_at_";
                case 208:
                    return "SLICE_r_at_";
                case 212:
                    return "SLICE_r_at_xyz";
                case 214:
                case 215:
                    return "SLICE_xyz_uv";
                default:
                    return t !==
                        void 0 &&
                        oe(t, Be) ?
                        "POLYGON" :
                        "X_OR_Y"
            }
        };
    D.Histogram.prototype
        .getExpressionType =
        function (e, t) {
            return "HISTOGRAM"
        };
    D.DotPlot.prototype
        .getExpressionType =
        function (e, t) {
            return "DOTPLOT"
        };
    D.BoxPlot.prototype
        .getExpressionType =
        function (e, t) {
            return "BOXPLOT"
        };
    var Ch = class extends j { };
    var Rh = class extends j {
        constructor(t) {
            super(t), this
                ._symbol =
                "sphere"
        }
    };

    function $z(e) {
        return function (n) {
            return new e(n)
        }
    }
    var Yz = [Ql, Il, qa, Cl, ep,
        tp, xi, Ch, uu, Ol, cu,
        El, Ml, Sl, Nl, Tl, Vo,
        Ua, Kl, np, al, rp, Qi,
        ip, hr, ol, xl, Pl, vl,
        Rh, Al, ni, Rl, Dl
    ];
    for (let e of Yz) e.prototype
        .copyWithArgs = $z(e);
    Ns.prototype.copyWithArgs =
        function (e) {
            return new qr[this
                .operator](e)
        };
    Xa.prototype.copyWithArgs =
        function (e) {
            return new Xa(this
                .symbols, e)
        };
    Zt.prototype.copyWithArgs =
        function (e) {
            return new Zt(this
                ._constantValue)
        };
    ju.prototype.copyWithArgs =
        function (e) {
            return new ju(this
                .constructedObjectIds
            )
        };
    cc.prototype.copyWithArgs =
        function (e) {
            return new cc(this
                ._symbol, e)
        };
    dc.prototype.copyWithArgs =
        function (e) {
            return new dc(this.tag,
                e)
        };
    cn.prototype.copyWithArgs =
        function (e) {
            return new cn(new ze(
                this._symbol
            ), e)
        };
    ze.prototype.copyWithArgs =
        function (e) {
            return new ze(this
                ._symbol)
        };
    ya.prototype.copyWithArgs =
        function (e) {
            return new ya(e[0], e[
                1], e.slice(2),
                this
                    .shouldCoerceToList,
                this.parameters)
        };
    Ju.prototype.copyWithArgs =
        function (e) {
            return new Ju(this
                .symbol, e)
        };
    uc.prototype.copyWithArgs =
        function (e) {
            return new uc(this
                .order, e)
        };
    lc.prototype.copyWithArgs =
        function (e) {
            return new lc(this
                .value)
        };
    Go.prototype.copyWithArgs =
        function (e) {
            return new Go(e[0], e
                .slice(1))
        };
    fc.prototype.copyWithArgs =
        function (e) {
            return new fc(this
                ._stringValue)
        };

    function Id(e, t, n) {
        let r = [],
            i = {},
            s = {},
            o = {},
            a = {},
            u = {},
            c = {},
            l = new Set,
            p = {},
            f = new Set,
            m = {},
            g = 0,
            d = [],
            y = [];
        if (!n) {
            n = [];
            for (let P in t) t
                .hasOwnProperty(
                    P) && n.push(P)
        }
        for (let P in t) {
            if (!t.hasOwnProperty(
                P)) continue;
            let M = t[P]
                .exportPenalty || 0;
            for (; r.length < M +
                1;) r.push([]);
            r[M].push(P)
        }
        for (let P of r) {
            let M = {};
            for (let I of P) {
                let E = t[I],
                    v = t[I]
                        .exportPenalty ||
                        0,
                    O = Gs(E),
                    A = E
                        .getLegalExports(
                            e);
                for (let N of A) Ke[
                    N] || i[
                    N] || (O && (u[
                        N] = !
                        0),
                        v === 0 && (
                            a[N] = !
                            0), M[
                            N] = M[N] ||
                        [], M[N]
                            .push(I), M[
                                N]
                                .length >
                            1 && (!s[
                                N] &&
                                O && (o[
                                    N] = !
                                    0),
                                s[N] = !
                                0))
            }
            for (let I in M) o[I] ||
                (i[I] = M[I])
        }
        for (let P of n) m
            .hasOwnProperty(P) || h(
                P);

        function h(P) {
            m[P] = m[P] || {};
            let M = m[P],
                I;
            M.id = P, M.index = g, M
                .lowlink = g, d
                    .push(M), M
                        .instack = !0, g++;
            let E = t[P]
                .getDependencies();
            for (let v of E) {
                if (!i
                    .hasOwnProperty(
                        v))
                    continue;
                let O = i[v];
                for (let A of O) m
                    .hasOwnProperty(
                        A) ? (I = m[
                            A], I
                                .instack &&
                            (M.lowlink =
                                Math
                                    .min(M
                                        .lowlink,
                                        I
                                            .index
                                    ))
                ) : (h(A),
                    I = m[A], M
                        .lowlink =
                    Math.min(M
                        .lowlink,
                        I
                            .lowlink
                    ))
            }
            if (M.lowlink === M
                .index)
                if (I = d.pop(), I
                    .instack = !1,
                    I === M) b(M);
                else {
                    let v = [I];
                    for (; I = d
                        .pop(), I
                            .instack = !
                        1, v.push(
                            I), I !== M;
                    );
                    x(v)
                }
        }

        function b(P) {
            y.push(P.id);
            let M = t[P.id];
            M instanceof cr && M
                ._expression
                .getDependencies()
                .indexOf(M
                    ._symbol) !== -1 &&
                (p[P.id] = {
                    [P.id]: M
                }, f.add(M
                    ._symbol))
        }

        function x(P) {
            let M = [],
                I = !0,
                E = {},
                v = new Set;
            for (let O = P.length -
                1; O >=
                0; O--) {
                let A = P[O],
                    N = t[A.id],
                    L = N
                        .getLegalExports(
                            e);
                Array.prototype.push
                    .apply(M, L), M
                        .push(L[0]), v
                            .add(A.id), y
                                .push(A.id),
                    N instanceof cr &&
                        !s[L[0]] ? E[A
                            .id] = N :
                        I = !1,
                    N instanceof wi &&
                    l.add(A.id)
            }
            if (M = wp(M), M.sort(),
                I) {
                for (let O of [...
                    v]) p[O] = E;
                for (let O of M) f
                    .add(O)
            }
            for (let O of M) c[O] =
                M
        }
        return {
            resolved: y,
            globallyDefined: a,
            tableDefined: u,
            multiplyDefined: s,
            multiplyDefinedByTables: o,
            cyclicallyDefined: c,
            recursiveFunctionGroups: p,
            recursiveFunctionSymbols: f,
            recursiveFunctionBaseCasesWithCycles: l
        }
    }
    var Xz = 100;

    function Nh(e) {
        for (var t = [], n = 0; n <
            e; n++) t[n] = {
                x: [],
                y: [],
                intersects: []
            };
        return t
    }

    function Zz(e, t, n, r) {
        return n === 1 && r === 1 ||
            n === 2 && r === 2 ?
            function (i) {
                return t(i) - e(i)
            } : n === 1 && r ===
                2 || n === 2 && r ===
                1 ? function (i) {
                    return i - t(e(i))
                } : !1
    }

    function WA(e, t) {
        t instanceof D
            .SolvedEquation ? t = t
                ._expression :
            t instanceof D
                .OptimizedRegression &&
            (t = t.model);
        var n = [],
            r = [];
        return t instanceof D
            .DoubleInequality ? D
                .List.eachArgs(t
                    ._expressions,
                    function (i) {
                        n.push(i[0]
                            .getCompiledFunction()
                        ), r
                            .push(i[0]
                                .isConstant &&
                                i[1]
                                    .isNaN()
                            ), n
                                .push(i[1]
                                    .getCompiledFunction()
                                ), r
                                    .push(i[1]
                                        .isConstant &&
                                        i[1]
                                            .isNaN()
                                    )
                    }) : D.List.wrap(t)
                        .eachElement(function (
                            i) {
                            n.push(i
                                .getCompiledFunction()),
                                r.push(i
                                    .isConstant &&
                                    i
                                        .isNaN()
                                )
                        }), {
            functions: n,
            skipIntersecting: r
        }
    }

    function Wz(e, t) {
        var n = [];
        for (var r in e)
            if (e.hasOwnProperty(
                r) && String(r) !==
                String(t) && e[r]
                    .shouldIntersect()
            ) {
                var i = e[r],
                    s = WA(i.policy,
                        i
                            .concreteTree
                    );
                n.push({
                    id: r,
                    graphMode: i
                        .getGraphMode(),
                    functions: s
                        .functions,
                    skipIntersecting: s
                        .skipIntersecting
                })
            } return n
    }

    function jz(e, t) {
        e.intersects = Array(e.x
            .length);
        for (var n = 0; n < e.x
            .length; n++) e
                .intersects[n] = t
    }

    function Jz(e, t) {
        if (t === 1) {
            var n = e.y;
            e.y = e.x, e.x = n
        }
    }

    function Qz(e, t) {
        Array.prototype.push.apply(e
            .x, t.x), Array
                .prototype.push.apply(e
                    .y, t.y), e
                        .intersects && t
                        .intersects && Array
                            .prototype.push.apply(e
                                .intersects, t
                                .intersects)
    }

    function Kz(e, t, n) {
        var r = N0(e, t),
            i = r.poi.zeros,
            s = r.poi.extrema,
            o = [],
            a = 0,
            u = 0;
        for (a = 0; a < i.x
            .length; a++) {
            for (; u < s.x.length &&
                s.x[u] < i.x[a]; u++
            ) Li(s.y[u], 0) && o
                .push(s.x[u]);
            o.push(i.x[a])
        }
        for (; u < s.x.length; u++)
            Li(s.y[u], 0) && o.push(
                s.x[u]);
        return {
            x: o,
            y: o.map(n)
        }
    }

    function jA(e, t, n) {
        var r = e[n],
            i = r.getGraphInfo(),
            s = r.getGraphMode(),
            o, a, u;
        try {
            o = WA(r.policy, r
                .concreteTree),
                a = Nh(o.functions
                    .length), u =
                Wz(e, n)
        } catch (x) {
            return Nh(0)
        }
        if (!u) return a;
        for (var c = 0, l = 0; l < u
            .length; l++)
            for (var p = u[l], f =
                0; f < o.functions
                    .length; f++)
                if (!o
                    .skipIntersecting[
                    f]) {
                    for (var m = o
                        .functions[
                        f]
                        .fn, g =
                            Ip(t, i,
                                m),
                        d =
                            0; d < p
                                .functions
                                .length; d++
                    )
                        if (!u[l]
                            .skipIntersecting[
                            d]
                        ) {
                            var y =
                                p
                                    .functions[
                                    d
                                ]
                                    .fn,
                                h =
                                    Zz(m,
                                        y,
                                        s,
                                        p
                                            .graphMode
                                    );
                            if (h) {
                                var
                                    b;
                                try {
                                    b = Kz(h,
                                        g,
                                        m
                                    )
                                } catch (
                                x
                                ) {
                                    return Nh(
                                        0
                                    )
                                }
                                if (c +=
                                    b
                                        .x
                                        .length,
                                    c >
                                    Xz
                                )
                                    return Nh(
                                        o
                                            .functions
                                            .length
                                    );
                                jz(b, p
                                    .id),
                                    Jz(b,
                                        s
                                    ),
                                    Qz(a[
                                        f],
                                        b
                                    )
                            }
                        }
                } return a
    }

    function eH(e) {
        if (e.length < 2)
            return "text";
        let t = e.split("`")
            .length - 1;
        return t < 2 ? "text" :
            t === 2 && e[0] ===
                "`" && e[e.length -
                1] === "`" ? "latex" :
                "mixed"
    }

    function tH(e) {
        if (e.length === 0) return [
            ""
        ];
        let t = [],
            n = e.split(/(`)/),
            r = !1,
            i = "";
        for (let s = 0; s < n
            .length; s++) {
            let o = n[s];
            o.length && (o === "`" ?
                (i += "`", r = !
                    r, r || (t
                        .push(
                            i), i =
                        "")) : (
                    i += o, r ||
                    (t.push(i),
                        i = ""))
            )
        }
        return i.length && t.push(
            i), t
    }

    function EM(e) {
        return tH(e).map(nH)
    }

    function nH(e) {
        let n = "\\$({" + [
            "[a-zA-Z][0-9]*",
            "[a-zA-Z]_[a-zA-Z0-9]+",
            "[a-zA-Z]_\\{[a-zA-Z0-9]+\\}",
            "\\\\[a-zA-Z]+",
            "\\\\[a-zA-Z]+_{[a-zA-Z0-9]+}",
            "\\\\[a-zA-Z]+_[a-zA-Z0-9]+"
        ].join("})|\\$({") +
            "})",
            r = new RegExp(n, "g"),
            i = [],
            s = 0,
            o = 0,
            a;
        for (; a = r.exec(e);) {
            o = a.index, o > s && i
                .push(e.substr(s,
                    o - s));
            let u = a[0],
                c = u.replace(
                    /[{}\$]/g, "")
                    .replace(
                        /^([a-zA-Z])([0-9]+)$/,
                        "$1_$2");
            i.push({
                symbol: c,
                str: u
            }), s = a.index + u
                .length
        }
        return s < e.length && i
            .push(e.substr(s)), {
            raw: e,
            parts: i
        }
    }

    function JA(e, t) {
        return t ? "{" + Qh(e, {
            bigCutoff: 1e7,
            digits: 8
        }) + "}" : Yd(e, {
            bigCutoff: 1e7,
            digits: 8
        })
    }

    function MM(e, t, n, r) {
        return e.map(i => rH(i, t,
            n, r)).join("")
    }

    function rH(e, t, n, r) {
        let i = [],
            s = eH(e.raw) ===
                "latex";
        for (let o of e.parts)
            if (typeof o ==
                "string") i.push(o);
            else {
                let a = new D
                    .Identifier(o
                        .symbol)
                    .tryGetConcreteTree(
                        t, n);
                if (a.valueType ===
                    T && a
                        .getDependencies()
                        .length === 0) {
                    let u = a
                        .asValue();
                    if (typeof u ==
                        "number") {
                        i.push(JA(u,
                            s));
                        continue
                    }
                } else if (a
                    .valueType ===
                    se && r < a
                        .length && a
                            .getDependencies()
                            .length === 0) {
                    let u = a
                        .elementAt(
                            r)
                        .asValue();
                    if (typeof u ==
                        "number") {
                        i.push(JA(u,
                            s));
                        continue
                    }
                }
                s ? i.push("{?}") :
                    i.push("?")
            } return i.join("")
    }

    function QA() {
        let e = {},
            t = {},
            n = {},
            r = [];
        for (let i in this
            .statements) {
            if (!this.statements
                .hasOwnProperty(i))
                continue;
            let s = this.statements[
                i];
            if (!(s.type ===
                "Construction" &&
                !this.policy
                    .isGeometryEnabled()
            ) && s.type !==
                "Ticker") switch (s
                    .type) {
                    case "Error":
                        break;
                    case "Regression": {
                        n[i] = [], r
                            .push(
                                i);
                        break
                    }
                    default: {
                        let o = s
                            .getLegalExports(
                                this
                                    .policy
                            );
                        if (o) {
                            for (let u of
                                o)
                                s
                                    .exportPenalty !==
                                    void 0 &&
                                    s
                                        .exportPenalty >
                                    0 ?
                                    t[
                                    u] =
                                    i :
                                    e[
                                    u] =
                                    i;
                            let
                                a = [];
                            for (let u of
                                s
                                    .getDependencies())
                                a
                                    .push(
                                        u
                                    );
                            n[i] =
                                Xh(a,
                                    s
                                        .getDummyDependencies(),
                                    o
                                )
                        }
                        break
                    }
                }
        }
        for (let i of r) {
            let s = this.statements[
                i],
                o = Lo(s.userData
                    .residualVariable
                );
            o && (t[o] = i);
            let a = s
                .getDependencies()
                .slice(),
                u = {},
                c;
            for (; c = a.pop();) {
                if (u[c]) continue;
                u[c] = !0;
                let l = e[c] || t[
                    c];
                if (l) {
                    a.push(...n[l]),
                        n[i].push(
                            c);
                    continue
                }
                t[c] = i
            }
        }
        return {
            exportMap: e,
            weakExportMap: t,
            dependencyMap: n
        }
    }
    var Ed = class {
        constructor() {
            this.data = {}
        }
        getChildIntersections(
            t) {
            return this
                .data[t] ||
            {
                count: 0
            }
        }
        addListParent(t, n, r) {
            if (Op(r.valueType,
                [R, Pt]
            ), n !==
                void 0) r
                    .valueType ===
                    Pt ? this
                        .addPoint(t,
                            n, r
                                .value[
                        n]
                        ) : this
                            .addPoint(t,
                                n, r
                                .value);
            else {
                Op(r.valueType,
                    [Pt]
                );
                for (let i =
                    0; i <
                    r.value
                        .length; i++
                ) this
                    .addPoint(
                        t,
                        i, r
                            .value[
                    i
                    ]
                    )
            }
        }
        addPrimitiveParent(t,
            n) {
            if (Op(n.valueType,
                [R, Pt]
            ), n
                .valueType ===
                R) this
                    .addPoint(t,
                        0, n
                        .value);
            else
                for (let r =
                    0; r <
                    n.value
                        .length; r++
                ) this
                    .addPoint(
                        t,
                        0, n
                            .value[
                    r
                    ]
                    )
        }
        addPoint(t, n, r) {
            var s;
            let i = this
                .data[t] ||
            {
                count: 0
            };
            this.data[t] ||
                (this.data[
                    t] =
                    i), i[
                    n] || (i[
                        n] = []
                ), (s =
                    i[n]) ==
                null || s
                    .push(r), i
                        .count++
        }
    };
    var Md = class {
        constructor(t) {
            this.singleExpression =
                t
                    .singleExpression
        }
        isGeometryEnabled() {
            return !1
        }
        is3dProduct() {
            return !1
        }
        is3dPolicy() {
            return !1
        }
        isBeta3d() {
            return !1
        }
        areAllScalesLinear() {
            return !0
        }
        assignmentForbidden(t) {
            return this
                .substitutionForbidden(
                    t)
        }
        substitutionForbidden(
            t) {
            return t.slice(
                0, 3
            ) !==
                "ans"
        }
        isValidSlider(t) {
            return !1
        }
        sliderVariables() {
            return []
        }
        graphingEnabled() {
            return !1
        }
        ansEnabled() {
            return !this
                .singleExpression
        }
        dimensionVarsEnabled() {
            return !1
        }
        disabledFeatures() {
            return ["Sum",
                "Product",
                "Integral",
                "List",
                "Derivative",
                "Piecewise",
                "Exponent",
                "PercentOf",
                "Substitution"
            ]
        }
    };
    var vd = class {
        constructor(t) {
            this.singleExpression =
                t
                    .singleExpression
        }
        isGeometryEnabled() {
            return !1
        }
        is3dProduct() {
            return !1
        }
        is3dPolicy() {
            return !1
        }
        isBeta3d() {
            return !1
        }
        areAllScalesLinear() {
            return !0
        }
        assignmentForbidden(t) {
            return this
                .substitutionForbidden(
                    t)
        }
        substitutionForbidden(
            t) {
            return this
                .singleExpression ?
                t.slice(0,
                    3) !==
                "ans" : t
                    .slice(0,
                        3) === "tmp"
        }
        isValidSlider(t) {
            return !1
        }
        sliderVariables() {
            return []
        }
        graphingEnabled() {
            return !1
        }
        ansEnabled() {
            return !this
                .singleExpression
        }
        dimensionVarsEnabled() {
            return !1
        }
        disabledFeatures() {
            return this
                .singleExpression ?
                ["Sum",
                    "Product",
                    "Integral",
                    "Derivative",
                    "Piecewise",
                    "Substitution",
                    "PercentOf"
                ] : ["Sum",
                    "Product",
                    "Integral",
                    "Derivative",
                    "Piecewise",
                    "Substitution"
                ]
        }
    };

    function KA(e, t, n, r) {
        try {
            let i = aH(e, t, r);
            for (let s in i) n[s] =
                i[s], n[s].exportTo(
                    e, t)
        } catch (i) {
            if (!(i instanceof C))
                throw i;
            for (let s in r) n[s] =
                new k(e, t, r[s],
                    i), n[s].exportTo(e,
                        t)
        }
    }

    function aH(e, t, n) {
        let r = {};
        for (let u in n) r[n[u]
            ._symbol] = n[u];
        let i = new vM(r),
            s = {},
            o = {
                definitions: s,
                baseCases: i
                    .getBaseCases()
            };
        for (let u in n) {
            let c = n[u];
            uH(i, c, o)
        }
        for (let u of i
            .getBaseCaseExports()) {
            let c = u.analyze(e,
                t, {});
            for (let l of u
                .getLegalExports(
                    e))
                delete t[l];
            c.exportTo(e, t)
        }
        let a = {};
        for (let u in n) {
            let c = n[u],
                l = c._symbol,
                p = s[l];
            p.userData = c.userData,
                p.metaData = c
                    .metaData,
                p instanceof C ? a[
                    u] = new k(e, t,
                        c, p) : a[u] = p
                            .analyze(e, t, a)
        }
        return a
    }
    var vM = class {
        constructor(t) {
            this
                .baseCases = {};
            this
                .baseCaseExports = [];
            this
                .analyzedFunctions = {};
            this.recursiveFunctionGroup =
                t;
            for (let n in t)
                this
                    .baseCases[
                    n] = [];
            for (let n in
                this
                    .recursiveFunctionGroup)
                this
                    .analyzeRecursiveFunctionDefinition(
                        this
                            .recursiveFunctionGroup[
                        n])
        }
        analyzeRecursiveFunctionDefinition
            (t) {
            let n;
            for (let r of t
                .getExternalBaseCases())
                this
                    .addBaseCase(
                        r);
            if (t
                ._expression instanceof hr
            ) {
                n = t
                    ._expression;
                do {
                    let r =
                        n
                            .args[
                        0
                        ],
                        i =
                            n
                                .args[
                            1
                            ];
                    if (this
                        .recursiveParameterIndex !==
                        void 0 &&
                        r instanceof qr[
                        "="
                        ]
                    ) {
                        let s =
                            t
                                ._argSymbols[
                            this
                                .recursiveParameterIndex
                            ],
                            o =
                                r
                                    .args
                                    .findIndex(
                                        p =>
                                            p instanceof ze &&
                                            p
                                                ._symbol ===
                                            s
                                    );
                        if (o ===
                            -
                            1
                        )
                            break;
                        let a =
                            r
                                .args[
                            1 -
                            o
                            ];
                        if (!
                            (
                                a instanceof Zt)
                        )
                            break;
                        let u =
                            a
                                .asValue(),
                            c =
                                t
                                    ._argSymbols
                                    .filter(
                                        (p,
                                            f) =>
                                            f !==
                                            this
                                                .recursiveParameterIndex
                                    )
                                    .map(
                                        p =>
                                            new ze(
                                                p
                                            )
                                    ),
                            l =
                                new wi(
                                    t
                                        ._symbol,
                                    c, {
                                    valid:
                                        !
                                        0,
                                    argIndex: this
                                        .recursiveParameterIndex,
                                    argValue: u,
                                    functionDefArgSymbols: t
                                        ._argSymbols,
                                    argSymbol: t
                                        ._argSymbols[
                                        this
                                            .recursiveParameterIndex
                                    ]
                                },
                                    i,
                                    i
                                );
                        this.baseCaseExports
                            .push(
                                l
                            ),
                            this
                                .addBaseCase(
                                    l
                                )
                    } else
                        break;
                    n = n
                        .args[
                        2
                    ]
                } while (
                    n instanceof hr
                )
            } else if (t
                ._expression instanceof Go
            ) {
                let r = [];
                for (let i of
                    t
                        ._expression
                        ._assignments) {
                    let s =
                        wi
                            .fromCallAssignment(
                                this
                                    .recursiveFunctionGroup,
                                i
                            );
                    if ((s ==
                        null ?
                        void 0 :
                        s
                            .specifiedArg
                            .valid
                    ) ===
                        !1)
                        throw s
                            .specifiedArg
                            .error;
                    s && t
                        ._symbol ===
                        s
                            ._symbol ?
                        (this
                            .baseCaseExports
                            .push(
                                s
                            ),
                            this
                                .addBaseCase(
                                    s
                                )
                        ) :
                        r
                            .push(
                                i
                            )
                }
                r.length >
                    0 ? n =
                new Go(t
                    ._expression
                    ._body,
                    r) :
                    n = t
                        ._expression
                        ._body
            } else n = t
                ._expression;
            this.analyzedFunctions[
                t
                    ._symbol
            ] = {
                recursiveExpression: n
            }
        }
        addBaseCase(t) {
            this.baseCases[t
                ._symbol
            ].push(
                t)
        }
        getBaseCases() {
            return this
                .baseCases
        }
        getBaseCaseExports() {
            return this
                .baseCaseExports
        }
        getFunctionAnalysis(t) {
            return this
                .analyzedFunctions[
                t]
        }
    };

    function uH(e, t, n) {
        let r = e
            .getFunctionAnalysis(t
                ._symbol);
        if (!r) {
            n.definitions[t
                ._symbol] = t;
            return
        }
        let i = new cr(new ze(t
            ._symbol), t
                ._argSymbols.map(
                    s => new ze(s)),
            r
                .recursiveExpression,
            n);
        i.setExternalBaseCases(t
            .getExternalBaseCases()
        ), n.definitions[t
            ._symbol] = i
    }
    var Va = typeof performance !=
        "undefined" ? () =>
        performance.now() : () =>
        Date.now(),
        {
            Constant: eo,
            Seed: t_,
            FunctionCall: mH,
            Image: yH,
            Slider: gH,
            Table: hH,
            TableColumn: bH,
            Construction: xH
        } = D;

    function PH(e, t, n, r) {
        switch (e) {
            case "fourFunction":
                return new Md({
                    singleExpression:
                        !1
                });
            case "singleExpressionFourFunction":
                return new Md({
                    singleExpression:
                        !0
                });
            case "scientific":
                return new vd({
                    singleExpression:
                        !1
                });
            case "singleExpressionScientific":
                return new vd({
                    singleExpression:
                        !0
                });
            case "graphing":
                return new Ep({
                    enableGeometry:
                        !1,
                    enable3d: t,
                    beta3d: n,
                    scales: r
                });
            case "geometry":
                return new Ep({
                    enableGeometry:
                        !0,
                    enable3d:
                        !1,
                    beta3d:
                        !1,
                    scales: r
                });
            case "graphing_3d":
                return new dh(n)
        }
    }
    var TH = {
        fourFunction: Jd,
        singleExpressionFourFunction: Jd,
        scientific: ib,
        singleExpressionScientific: sb,
        graphing: Bp,
        graphing_3d: Bp,
        geometry: Bp
    },
        Co =
            "**geo_construction_statement_id**";

    function _i(e, t) {
        var n = Vs(e, t);
        return n.isError ||
            n instanceof D
                .Expression ? n : Up()
    }

    function IH(e) {
        let t = e.rawTree.userData,
            n = e.rawTree.metaData;
        return !!(t.cdf && t.cdf
            .show && n
                .distributionSpec)
    }

    function EH(e) {
        let t = e.evaluationState
            .expression_type,
            n = e.rawTree.userData;
        return !n.clickableInfo || !
            n.clickableInfo
                .enabled ? !1 : rd(e
                    .rawTree) ? !0 : e
                        .getGraphMode() === 4 ?
            !1 : XE(t)
    }

    function un(e, t) {
        let n = "id" + e;
        for (let [r, i] of t || [])
            n += "::" + r + i;
        return n
    }
    var MH = new eo(De(0, 1)),
        vH = new eo(De(1, 1)),
        DH = new eo(NaN);

    function $i(e, t) {
        return e ? e === "0" ? MH :
            e === "1" ? vH : _i(e,
                t) : DH
    }

    function Gu(e, t) {
        if (e) return _i(e, t)
    }

    function SH(e) {
        return e.slice(0, 3) !==
            "ans"
    }

    function OH(e) {
        return e.slice(0, 6) !==
            "idref_"
    }

    function n_(e, t, n) {
        let {
            multiplyDefined: r,
            multiplyDefinedByTables: i,
            cyclicallyDefined: s,
            recursiveFunctionSymbols: o
        } = e;
        for (let a in s) {
            if (!s.hasOwnProperty(
                a) || n && o.has(a))
                continue;
            let u = e.tableDefined[
                a] && !e
                    .globallyDefined[a],
                c = s[a].filter(SH)
                    .filter(OH);
            t[a] = u ? Kx(c) : vm(c)
        }
        for (let a in r) r
            .hasOwnProperty(a) && (
                t[a] = i[a] ? Qx(
                    a) : dl(a))
    }

    function Sd(e, t, n) {
        for (let r of n) e[r] || (e[
            r] = []), e[r].push(
                t)
    }

    function r_(e, t, n) {
        if (n.extraDepNodes)
            for (let r of n
                .extraDepNodes)
                r && Sd(e, t, r
                    .getDependencies()
                );
        n.clickHandler && Sd(e, t, n
            .clickHandler
            .getDependencies())
    }

    function CH(e, t, n) {
        let r = e.evaluationState,
            i = e.rawTree,
            s = i.metaData.cdfMin,
            o = i.metaData.cdfMax,
            a = {},
            u = i.type ===
                "Assignment" ? i
                ._expression : i,
            c = u && u.metaData && u
                .metaData
                .distributionSpec,
            l = oa(t, n, s, a, -1 /
                0),
            p = oa(t, n, o, a, 1 /
                0),
            f = !0,
            m = !0;
        if (isNaN(l) && (f = !1, l =
            NaN), isNaN(p) && (
                m = !1, p = NaN),
            f ? m ? l > p && (f = !
                1, m = !1, r.error =
                pP().getError()) : r
                    .error = lP()
                        .getError() : r.error = cP()
                            .getError(), f && m) {
            let y = new mH("cdf", [
                u, new eo(
                    l), new eo(
                        p)
            ]);
            r.cdf_evaluation = +y
                .tryGetConcreteTree(
                    t, n).asValue()
        }
        let g = -1 / 0,
            d = 1 / 0;
        if (c && (c.discrete && (g =
            0), c.symbol ===
            "binomialdist" && u
                .args && u.args[0]
        )) {
            let y = +u.args[0]
                .asValue();
            isFinite(y) && (d = y)
        }
        i.metaData.evaluatedCDFMin =
            l, i.metaData
                .evaluatedCDFMax = p, r
                    .cdf_min_valid = f, r
                        .cdf_max_valid = m, r
                            .cdf_min_default = g, r
                                .cdf_max_default = d, r
                                    .is_single_identifier = !
            1, Fu(r, t, a)
    }

    function RH(e, t, n, r, i) {
        let s = {},
            o = !0,
            a = NaN,
            u, c = !1;
        if (n) {
            let l = n
                .tryGetConcreteTree(
                    e, t);
            u = l.getDependencies()
                .length === 0 ? l
                    .asValue() : NaN,
                c = Array.isArray(
                    u), a = c ? u : +u;
            for (let p of l
                .getDependencies())
                s[p] = !0
        }
        if (c) {
            for (let l of a)
                if (!isFinite(+l)) {
                    o = !1, a = NaN;
                    break
                }
        } else isFinite(+a) ? i !==
            void 0 && a > i && (a =
                i) : (o = !1, a =
                    NaN);
        return n || (o = !0, r !==
            void 0 && (a = r)
        ), {
            value: a,
            valid: o,
            missingVarsMap: s
        }
    }
    var Dd = {
        lineWidth: {
            parseNode: "lineWidth",
            valueOutputProp: "computedLineWidth",
            formulaOutputProp: "",
            validOutputProp: "line_width_valid",
            default: (e, t, n,
                r) => {
                let i = n
                    .isGeometryEnabled(),
                    s = n
                        .is3dPolicy(),
                    o =
                        r !==
                        void 0 &&
                        oe(r,
                            Be);
                return i &&
                    o ?
                    1.5 :
                    s ? 1 :
                        2.5
            },
            transform: void 0,
            shouldEvaluate: void 0,
            seed: "lw"
        },
        resolution: {
            parseNode: "resolution",
            valueOutputProp: "computedResolution",
            formulaOutputProp: "",
            validOutputProp: "resolution_valid",
            default: () => { },
            transform: void 0,
            shouldEvaluate: void 0,
            seed: "re"
        },
        lineOpacity: {
            parseNode: "lineOpacity",
            valueOutputProp: "computedLineOpacity",
            formulaOutputProp: "",
            validOutputProp: "line_opacity_valid",
            default: () => 1,
            transform: void 0,
            shouldEvaluate: void 0,
            seed: "lo"
        },
        pointOpacity: {
            parseNode: "pointOpacity",
            valueOutputProp: "computedPointOpacity",
            formulaOutputProp: "",
            validOutputProp: "point_opacity_valid",
            default: () => 1,
            transform: void 0,
            shouldEvaluate: void 0,
            seed: "po"
        },
        pointSize: {
            parseNode: "pointSize",
            valueOutputProp: "computedPointSize",
            formulaOutputProp: "",
            validOutputProp: "point_size_valid",
            default: (e, t,
                n) => n
                    .is3dProduct() ?
                    3 : 8,
            shouldEvaluate: void 0,
            transform: void 0,
            seed: "ps"
        },
        movablePointSize: {
            parseNode: "movablePointSize",
            valueOutputProp: "computedMovablePointSize",
            formulaOutputProp: "",
            validOutputProp: "movable_point_size_valid",
            default: () => 8,
            shouldEvaluate: void 0,
            transform: void 0,
            seed: "ps"
        },
        fillOpacity: {
            parseNode: "fillOpacity",
            valueOutputProp: "computedFillOpacity",
            formulaOutputProp: "",
            validOutputProp: "fill_opacity_valid",
            default: (e, t, n,
                r) => n
                    .is3dProduct() ?
                    1 : .4,
            transform: void 0,
            shouldEvaluate: e => {
                if (!e)
                    return !
                        1;
                let {
                    expression_type: t,
                    is_inequality: n
                } = e
                        .evaluationState;
                return !!(
                    t ===
                    "POLYGON" ||
                    t ===
                    "PARAMETRIC" ||
                    t ===
                    "CURVE3D_xyz_t" ||
                    t ===
                    "SURFACE" ||
                    t ===
                    "SPHERE3D" ||
                    t ===
                    "SURFACE_AMBIGUOUS" ||
                    t ===
                    "SURFACE_CONSTANT_AMBIGUOUS" ||
                    t ===
                    "IMPLICIT_SURFACE" ||
                    t ===
                    "IMPLICIT_SURFACE_AMBIGUOUS" ||
                    t ===
                    "SURFACE_xyz_uv" ||
                    t ===
                    "SURFACE_z_r" ||
                    t ===
                    "SURFACE_r_z" ||
                    t ===
                    "SURFACE_r_" ||
                    t ===
                    "SURFACE_r_z_AMBIGUOUS" ||
                    t ===
                    "TRIANGLE3D" ||
                    n)
            },
            seed: "fo"
        },
        labelSize: {
            parseNode: "labelSize",
            valueOutputProp: "computedLabelSize",
            formulaOutputProp: "",
            validOutputProp: "label_size_valid",
            transform: void 0,
            default: () => 1,
            shouldEvaluate: void 0,
            seed: "ls"
        },
        labelAngle: {
            parseNode: "labelAngle",
            valueOutputProp: "computedLabelAngle",
            formulaOutputProp: "label_angle_value",
            validOutputProp: "label_angle_valid",
            default: () => 0,
            transform: e =>
                `-\\trigAngleMultiplier*(${e})`,
            shouldEvaluate: void 0,
            seed: "la"
        }
    };

    function i_(e, t, n, r, i, s,
        o) {
        let a = Dd[s],
            u;
        e && (u = e
            .tryGetConcreteTree(
                r, i));
        let c = a.default && a
            .default(e, u, r, o),
            l = ["lineWidth",
                "pointSize",
                "movablePointSize"
            ].indexOf(s) >= 0,
            p = RH(r, i, n[a
                .parseNode], c,
                l ? 1e4 : void 0);
        n[a.valueOutputProp] = p
            .value, a
                .formulaOutputProp && (
                t[a
                    .formulaOutputProp] =
                p.value), t[a
                    .validOutputProp] =
            p.valid, Fu(t, r, p
                .missingVarsMap)
    }

    function NH(e, t, n, r) {
        let i, s, o;
        if (Gs(e.rawTree) && e
            .evaluationState
            .column_data && e
                .rawTree.columns)
            for (let a = 0; a < e
                .evaluationState
                .column_data
                .length; a++) {
                i = e
                    .evaluationState
                    .column_data[a];
                let u = e.rawTree
                    .columns[a];
                xo(u) || (s = u
                    .header
                    .metaData,
                    o = s[r],
                    i_(o, i, s,
                        t, n, r,
                        e
                            .concreteTree
                            .valueType
                    ))
            } else i = e
                .evaluationState,
                s = e.rawTree
                    .metaData, o = s[r],
                i_(o, i, s, t, n, r,
                    e.concreteTree
                        .valueType)
    }

    function s_(e) {
        return xc(e[0], e[1], e[2])
            .formatHex()
    }

    function o_(e, t, n, r, i) {
        let s;
        if (e) {
            let o = e
                .tryGetConcreteTree(
                    r, i),
                a = o
                    .getDependencies()
                    .length > 0 ?
                    void 0 : o
                        .asValue(),
                {
                    valueType: u
                } = o;
            if (s = !!(a && (u ===
                Ut || u ===
                Zn)), s) {
                let c = o && o
                    .valueType ===
                    Ut ? s_(a) : a
                        .map(s_);
                t.colorLatexValue =
                    c, n
                        .color_latex_value =
                    c
            } else delete t
                .colorLatexValue,
                delete n
                    .color_latex_value
        } else s = !0;
        n.color_latex_valid = s
    }

    function AH(e, t, n) {
        let r, i, s;
        if (Gs(e.rawTree) && e
            .evaluationState
            .column_data && e
                .rawTree.columns)
            for (let o = 0; o < e
                .evaluationState
                .column_data
                .length; o++) {
                r = e
                    .evaluationState
                    .column_data[o];
                let a = e.rawTree
                    .columns[o];
                xo(a) || (i = a
                    .header
                    .metaData,
                    s = i
                        .colorLatex,
                    o_(s, i, r,
                        t, n))
            } else r = e
                .evaluationState,
                i = e.rawTree
                    .metaData, s = i
                        .colorLatex, o_(s,
                            i, r, t, n)
    }

    function _H(e) {
        if (e.concreteTree
            .valueType === Ut && e
                .concreteTree
                .getDependencies()
                .length > 0) {
            let t = e.concreteTree
                ._chunk;
            try {
                e.evaluationState
                    .shader = Wo(t,
                        0)
            } catch (n) {
                e.evaluationState
                    .error =
                    n instanceof D
                        .Error ? n
                            .getError() : J(
                                n)
                                .getError()
            }
        }
    }

    function LH(e, t, n) {
        let r = e.evaluationState,
            i = e.rawTree,
            s = {},
            o = i.metaData
                .clickHandler;
        if (!o) return;
        let a = o
            .tryGetConcreteTree(t,
                n);
        !a.isError && a
            .valueType !== rt && (
                a = jp(ne(a
                    .valueType)));
        for (let c of a
            .getDependencies())
            t.validActionVariable(
                c) || (s[c] = !0);
        let u = Object.keys(s);
        u.length > 0 && (a = tn(u)
            .setDependencies(a
                .getDependencies()
            )), a.isError &&
                !tM(t, a) ? r
                    .click_handler = {
                status: "error",
                error: a.getError()
            } : a.isEmptyAction ? r
                .click_handler = {
                status: "empty"
            } : r.click_handler = {
                status: "maybe-valid"
            }, Fu(r, t, s)
    }

    function wH(e, t, n) {
        let r, i = e
            .evaluationState,
            s = e.rawTree,
            o, a;
        i.internal_domain_dependency ?
            (r = i
                .internal_domain_dependency,
                r === "u" ? (o = s
                    .metaData
                    .parametricDomain3DuMin,
                    a = s.metaData
                        .parametricDomain3DuMax
                ) : r === "v" ?
                    (o = s.metaData
                        .parametricDomain3DvMin,
                        a = s.metaData
                            .parametricDomain3DvMax
                    ) : (o = s
                        .metaData
                        .parametricDomainMin,
                        a = s.metaData
                            .parametricDomainMax
                    )) : i
                        .expression_type ===
                        "POLAR" || $R(i
                            .expression_type) ?
                (o = s.metaData
                    .polarDomainMin, a =
                    s.metaData
                        .polarDomainMax, r =
                    "theta") : (o = s
                        .metaData
                        .parametricDomainMin,
                        a = s.metaData
                            .parametricDomainMax,
                        r = "t");
        let u = {},
            c = !!(o || a),
            l = oa(t, n, o, u, 0),
            p = NaN;
        a ? p = oa(t, n, a, u,
            NaN) : i
                .expression_type ===
                "PARAMETRIC" || i
                    .expression_type ===
                "CURVE3D_xyz_t" ? p =
        1 : i
            .expression_type ===
            "POLAR" ? p = Math.PI *
            12 / +n
                .trigAngleMultiplier
                .asValue() : (i
                    .expression_type ===
                    "SURFACE_r_z" || i
                        .expression_type ===
                    "SURFACE_r_z_AMBIGUOUS" ||
                    i
                        .expression_type ===
                    "SLICE_rz_at_z") &&
        (p = Math.PI * 2 / +n
            .trigAngleMultiplier
            .asValue());
        let f = OM(l, p, i);
        ({
            min: l,
            max: p
        } = f), s.metaData
            .evaluatedDomainMin = l,
            s.metaData
                .evaluatedDomainMax = p,
            (i.expression_type ===
                "POLAR" || i
                    .expression_type ===
                "SURFACE_r_z" || i
                    .expression_type ===
                "SURFACE_r_z_AMBIGUOUS" ||
                i
                    .expression_type ===
                "SLICE_rz_at_z") &&
            (s.metaData
                .isExplicitDomain =
                c), i.domains = [{
                    variable: r,
                    minNumber: l,
                    maxNumber: p,
                    minValid: f
                        .minValid,
                    maxValid: f
                        .maxValid
                }], i
                    .expression_type ===
                "PARAMETRIC" && delete u
                    .t, i
                        .expression_type ===
                    "CURVE3D_xyz_t" && (
                delete u.t, delete u
                    .u, delete u.v), Fu(
                        i, t, u)
    }

    function FH(e, t, n) {
        let r = e.evaluationState,
            i = r.expression_type,
            s = e.rawTree,
            o, a, u, c, l = {},
            p = 0,
            f = 1,
            m = 0,
            g = 1;
        var d, y;
        UR(i) ? (d = "theta", y =
            "phi", o = s
                .metaData
                .polarDomainMin, a =
            s.metaData
                .polarDomainMax, u =
            s.metaData
                .parametricDomain3DphiMin,
            c = s.metaData
                .parametricDomain3DphiMax,
            f = 2 * Math.PI / +n
                .trigAngleMultiplier
                .asValue(), g = Math
                    .PI / +n
                        .trigAngleMultiplier
                        .asValue()) : qR(
                            i) ? (d = "r", y =
                                "theta", o = s
                                    .metaData
                                    .parametricDomain3DrMin,
                                a = s.metaData
                                    .parametricDomain3DrMax,
                                u = s.metaData
                                    .polarDomainMin, c =
                                s.metaData
                                    .polarDomainMax, f =
                                lr.xmax, g = 2 *
                                Math.PI / +n
                                    .trigAngleMultiplier
                                    .asValue()) : (d =
                                        "u", y = "v", o = s
                                            .metaData
                                            .parametricDomain3DuMin,
                                        a = s.metaData
                                            .parametricDomain3DuMax,
                                        u = s.metaData
                                            .parametricDomain3DvMin,
                                        c = s.metaData
                                            .parametricDomain3DvMax
        ), p = oa(t, n, o,
            l, p), f = oa(t, n,
                a, l, f), m = oa(t,
                    n, u, l, m), g = oa(
                        t, n, c, l, g);
        let h = OM(p, f, r);
        ({
            min: p,
            max: f
        } = h);
        let b = OM(m, g, r);
        ({
            min: m,
            max: g
        } = b), s.metaData
            .evaluatedDomain3DMin1 =
            p, s.metaData
                .evaluatedDomain3DMax1 =
            f, s.metaData
                .evaluatedDomain3DMin2 =
            m, s.metaData
                .evaluatedDomain3DMax2 =
            g, r.domains = [{
                variable: d,
                minNumber: p,
                minValid: h
                    .minValid,
                maxNumber: f,
                maxValid: h
                    .maxValid
            }, {
                variable: y,
                minNumber: m,
                minValid: b
                    .minValid,
                maxNumber: g,
                maxValid: b
                    .maxValid
            }], (r
                .expression_type ===
                "SURFACE_xyz_uv" ||
                r
                    .expression_type ===
                "SLICE_xyz_uv") && (
                delete l.u, delete l
                    .v), Fu(r, t, l)
    }

    function oa(e, t, n, r, i) {
        if (n) {
            let s = n
                .tryGetConcreteTree(
                    e, t);
            for (let o of s
                .getDependencies())
                r[o] = !0;
            return s.isConstant ? +s
                .asValue() : NaN
        } else return i
    }

    function OM(e, t, n) {
        let r = !0,
            i = !0;
        return isFinite(e) || (r = !
            1, e = NaN),
            isFinite(t) || (i = !1,
                t = NaN), r ? i ?
                    e > t && (r = !1, i = !
                        1, n.error = uP()
                            .getError()) : n
                                .error = aP()
                                    .getError() : n.error = oP()
                                        .getError(), {
            min: e,
            max: t,
            minValid: r,
            maxValid: i
        }
    }

    function VH(e, t, n) {
        let r = e.evaluationState,
            i = e.rawTree,
            s = i.metaData
                .vizAxisOffset,
            o = i.metaData
                .vizBreadth,
            a = {},
            u = oa(t, n, s, a, 1),
            c = oa(t, n, o, a, 1),
            l = !0,
            p = !0;
        isFinite(u) || (l = !1, u =
            NaN), isFinite(c) ||
            (p = !1, c = NaN), l ?
                p || (r.error = fx()
                    .getError()) : r
                        .error = px()
                            .getError(), i.metaData
                                .evaluatedAxisOffset =
            u, i.metaData
                .evaluatedBreadth = c, r
                    .viz_values = {
                axisOffset: u,
                breadth: c
            }, r.viz_valids = {
                axisOffset: l,
                breadth: p
            }, Fu(r, t, a)
    }

    function BH(e) {
        return e.globalRandomSeed ||
            []
    }

    function DM(e, t, n, r, i) {
        let s = {},
            o = {},
            a = [],
            u = [];
        for (let c in r) r[c] && (o[
            c] = !0, a.push(
                c));
        for (let c in i) i[c] && (s[
            c] = !0, u.push(
                c));
        for (; a.length || u
            .length;) {
            for (; a.length;) {
                let c = a.pop(),
                    l = t[c];
                if (l)
                    for (let p of l
                        .getLegalExports(
                            e))
                        s[p] || (s[
                            p] = !
                            0, u
                                .push(p)
                        )
            }
            for (; u.length;) {
                let c = u.pop(),
                    l = n[c];
                if (l)
                    for (let p of l)
                        o[p] || (o[
                            p] = !
                            0, a
                                .push(p)
                        )
            }
        }
        return {
            ids: o,
            symbols: s
        }
    }

    function SM(e, t, n) {
        if (e.isError || e
            .getDependencies()
            .length || e
                .valueType !== rt)
            return;
        let r = e.asValue();
        if (r)
            for (let i in r
                .updateRules) {
                t[i] = WE(r, i);
                let {
                    value: s,
                    valueType: o
                } = r.updateRules[
                    i];
                n[i] = new D
                    .Assignment(i,
                        xt(o, s))
            }
    }
    var Ah = class {
        constructor() {
            this.childIntersections =
                new Ed;
            this.getCLSymbolMap =
                QA;
            this.statements = {},
                this
                    .analysis = {},
                this
                    .currentStatus = {},
                this
                    .currentLabel = {},
                this
                    .unpublishedIds = {},
                this
                    .dimensions = {
                    width: 0,
                    height: 0
                }, this
                    .intersectId =
                void 0, this
                    .dirtyExportedSymbolRoots = {},
                this
                    .dirtyStatementRoots = {},
                this
                    .markedRegressionDirty = !
                1, this
                    .use_degrees = !
                1, this
                    .initialEvaluation = !
                1, this
                    .globalEventCount =
                0, this
                    .actions = !
                0, this
                    .substitutions = !
                0, this
                    .intervalComprehensions = !
                1, this
                    .recursion = !
                1, this
                    .setEvaluationMode(
                        "graphing"
                    ), this
                        .setProduct(
                            "graphing"
                        ), this
                            .setBeta3d(!
                                1), this
                                    .setRestrictedFunctions(
                                        !1),
                this
                    .setForceEnableGeometryFunctions(
                        !1),
                this
                    .setFunctionDefinition(
                        !0),
                this
                    .setReplaceRoundWithReciprocal(
                        !1),
                this
                    .setDistributions(
                        !0),
                this
                    .invalidate()
        }
        invalidate() {
            delete this
                .statements[
                Co];
            for (let n in
                this
                    .statements)
                this
                    .statements
                    .hasOwnProperty(
                        n) &&
                    this
                        .markAsDirtyRoot(
                            n);
            this.currentStatus = {},
                this
                    .analysis = {};
            let t = this
                .viewState ?
                {
                    xAxisScale: this
                        .viewState
                        .xAxisScale,
                    yAxisScale: this
                        .viewState
                        .yAxisScale
                } : void 0;
            this.policy =
                PH(this
                    .evaluationMode,
                    this
                        .product ===
                    "graphing-3d",
                    this
                        .beta3d,
                    t), this
                        .parent_frame =
                TH[this
                    .evaluationMode
                ]
                    .getFrame({
                        restrictedFunctions: this
                            .restrictedFunctions,
                        forceEnableGeometryFunctions: this
                            .forceEnableGeometryFunctions,
                        isGeometryCalculator: this
                            .evaluationMode ===
                            "geometry",
                        is3DCalculator: this
                            .product ===
                            "graphing-3d",
                        replaceRoundWithReciprocal: this
                            .replaceRoundWithReciprocal,
                        distributions: this
                            .distributions,
                        additionalFunctions: this
                            .additionalFunctions,
                        trigAngleMultiplier: new eo(
                            this
                                .use_degrees ?
                                Math
                                    .PI /
                                180 :
                                De(1,
                                    1
                                )
                        ),
                        initialEvaluation: new eo(
                            this
                                .initialEvaluation ?
                                1 :
                                0
                        ),
                        globalEventCount: new eo(
                            0
                        ),
                        globalRandomSeed: new t_(
                            this
                                .globalRandomSeedString ||
                            ""
                        ),
                        width: this
                            .policy
                            .dimensionVarsEnabled() ?
                            new eo(
                                De(this
                                    .dimensions
                                    .width,
                                    1
                                )
                            ) :
                            Vm(
                                "width"),
                        height: this
                            .policy
                            .dimensionVarsEnabled() ?
                            new eo(
                                De(this
                                    .dimensions
                                    .height,
                                    1
                                )
                            ) :
                            Vm(
                                "height")
                    }), this
                        .frame =
                Object
                    .create(this
                        .parent_frame
                    ), this
                        .lastFrame =
                Object
                    .create(this
                        .parent_frame
                    ), this
                        .regressionFrame =
                Object
                    .create(this
                        .parent_frame
                    ), this
                        .lastClockTickTime =
                void 0
        }
        getAllActionUpdateSymbols
            () {
            var n;
            let t = new Set;
            for (let r in
                this
                    .statements) {
                let i = this
                    .statements[
                    r];
                i.getUpdateSymbols()
                    .forEach(
                        o =>
                            t
                                .add(
                                    o
                                )
                    ),
                    i instanceof D
                        .Ticker &&
                    i
                        .handler
                        .getUpdateSymbols()
                        .forEach(
                            o =>
                                t
                                    .add(
                                        o
                                    )
                        );
                let s = this
                    .analysis[
                    r];
                (rd(i) ||
                    s && s
                        .getGraphMode() !==
                    4 && XE(
                        s
                            .evaluationState
                            .expression_type
                    )
                ) && ((
                    n =
                    i
                        .metaData
                        .clickHandler
                ) ==
                    null ||
                    n
                        .getUpdateSymbols()
                        .forEach(
                            o =>
                                t
                                    .add(
                                        o
                                    )
                        ))
            }
            return [...
                new Set(
                    t)
            ]
        }
        processChangeSet(t) {
            let n = Va(),
                r = {
                    cacheWrites: 0,
                    cacheReads: 0,
                    cacheHits: 0,
                    cacheMisses: 0
                };
            fR(r);
            let i = {
                intersections: {},
                graphs: {}
            };
            t.isCompleteState &&
                (this
                    .invalidate(),
                    this
                        .statements = {},
                    this
                        .currentLabel = {}
                );
            let s = !!t
                .isCompleteState &&
                !t
                    .isUndoRedoState;
            s !== this
                .initialEvaluation &&
                (this
                    .initialEvaluation =
                    s, this
                        .parent_frame
                        .initialEvaluation =
                    new eo(
                        s ?
                            1 :
                            0)),
                t
                    .hasOwnProperty(
                        "logInternalErrors"
                    ) && ub(
                        t
                            .logInternalErrors
                    ), t
                        .viewState &&
                this
                    .setViewState(
                        t
                            .viewState
                    ), t
                        .hasOwnProperty(
                            "degreeMode"
                        ) &&
                this
                    .setDegreeMode(
                        t
                            .degreeMode
                    ), t
                        .hasOwnProperty(
                            "globalRandomSeed"
                        ) &&
                this
                    .setGlobalRandomSeed(
                        t
                            .globalRandomSeed
                    ), t
                        .hasOwnProperty(
                            "evaluationMode"
                        ) &&
                this
                    .setEvaluationMode(
                        t
                            .evaluationMode
                    ), t
                        .hasOwnProperty(
                            "additionalFunctions"
                        ) &&
                this
                    .setAdditionalFunctions(
                        t
                            .additionalFunctions
                    ), t
                        .hasOwnProperty(
                            "restrictedFunctions"
                        ) &&
                this
                    .setRestrictedFunctions(
                        t
                            .restrictedFunctions
                    ), t
                        .hasOwnProperty(
                            "forceEnableGeometryFunctions"
                        ) &&
                this
                    .setForceEnableGeometryFunctions(
                        t
                            .forceEnableGeometryFunctions
                    ), t
                        .hasOwnProperty(
                            "distributions"
                        ) &&
                this
                    .setDistributions(
                        t
                            .distributions
                    ), t
                        .hasOwnProperty(
                            "functionDefinition"
                        ) &&
                this
                    .setFunctionDefinition(
                        t
                            .functionDefinition
                    ), t
                        .hasOwnProperty(
                            "replaceRoundWithReciprocal"
                        ) &&
                this
                    .setReplaceRoundWithReciprocal(
                        t
                            .replaceRoundWithReciprocal
                    ), t
                        .hasOwnProperty(
                            "pointsOfInterest"
                        ) &&
                this
                    .setWorkerConfigProperty(
                        "pointsOfInterest",
                        t
                            .pointsOfInterest
                    ), t
                        .hasOwnProperty(
                            "plotSingleVariableImplicitEquations"
                        ) &&
                this
                    .setWorkerConfigProperty(
                        "plotSingleVariableImplicitEquations",
                        t
                            .plotSingleVariableImplicitEquations
                    ), t
                        .hasOwnProperty(
                            "plotImplicits"
                        ) &&
                this
                    .setWorkerConfigProperty(
                        "plotImplicits",
                        t
                            .plotImplicits
                    ), t
                        .hasOwnProperty(
                            "plotInequalities"
                        ) &&
                this
                    .setWorkerConfigProperty(
                        "plotInequalities",
                        t
                            .plotInequalities
                    ), t
                        .hasOwnProperty(
                            "sliders"
                        ) &&
                this
                    .setWorkerConfigProperty(
                        "sliders",
                        t
                            .sliders
                    ), t
                        .hasOwnProperty(
                            "actions"
                        ) &&
                this
                    .setActions(
                        !!t
                            .actions
                    ), t
                        .hasOwnProperty(
                            "substitutions"
                        ) &&
                this
                    .setSubstitutions(
                        !!t
                            .substitutions
                    ), t
                        .hasOwnProperty(
                            "intervalComprehensions"
                        ) &&
                this
                    .setIntervalComprehensions(
                        !!t
                            .intervalComprehensions
                    ), t
                        .hasOwnProperty(
                            "recursion"
                        ) &&
                this
                    .setRecursion(
                        !!t
                            .recursion
                    );
            let o = t
                .recursionDepthLimit;
            o !== void 0 &&
                o > 0 &&
                o <= 10 **
                6 && nI(o),
                t
                    .hasOwnProperty(
                        "beta3d"
                    ) &&
                this
                    .setBeta3d(!
                        !t
                            .beta3d
                    ), t
                        .hasOwnProperty(
                            "product"
                        ) &&
                this
                    .setProduct(
                        t
                            .product
                    );
            let a;
            if (t
                .hasOwnProperty(
                    "selectedIds"
                )) {
                let f = t
                    .selectedIds ||
                    {};
                (this
                    .intersectId ===
                    void 0 ||
                    !f[this
                        .intersectId
                    ]
                ) && ([
                    a] =
                    Object
                        .keys(
                            f), this
                                .intersectId =
                    a)
            }
            t.hasOwnProperty(
                "dimensions"
            ) &&
                this
                    .setDimensions(
                        t
                            .dimensions
                    );
            let u = Va();
            this.processStatements(
                t, i);
            let c = Va();
            r.processStatements =
                c - u, u =
                c, this
                    .updateAnalysis(),
                c = Va(), r
                    .updateAnalysis =
                c - u, u =
                c, a !==
                void 0 &&
                this
                    ._updateIntersections(
                        a, i),
                c = Va(), r
                    .updateIntersections =
                c - u, u =
                c;
            let l = this
                ._publishAllStatuses();
            c = Va(), r
                .publishAllStatuses =
                c - u, u =
                c, this
                    ._computeAllLabels(),
                c = Va(), r
                    .computeAllLabels =
                c - u, u =
                c, this
                    ._computeAriaDescriptions(),
                c = Va(), r
                    .computeAriaDescriptions =
                c - u, u =
                c, this
                    ._graphAllChanged(
                        i), c =
                Va(), r
                    .graphAllChanges =
                c - u;
            let p = this
                .processEvents(
                    t.events
                );
            return this
                .unpublishedIds = {},
                r
                    .timeInWorker =
                c - n, {
                syncId: t
                    .syncId,
                isCompleteState: t
                    .isCompleteState,
                intersectionChanges: i
                    .intersections,
                statusChanges: l,
                graphChanges: i
                    .graphs,
                timingData: r,
                eventUpdates: p
            }
        }
        processStatements(t,
            n) {
            if (t.removes)
                for (let r in
                    t
                        .removes) {
                    let i;
                    if (!t
                        .isCompleteState &&
                        this
                            .statements
                            .hasOwnProperty(
                                r
                            ) &&
                        (i = this
                            .statements[
                            r
                        ]
                            .getAllIds()
                        ),
                        this
                            .removeStatement(
                                r,
                                n
                            ),
                        !t
                            .isCompleteState &&
                        i)
                        for (
                            let s of
                            i
                        )
                            n
                                .graphs[
                                s
                            ] =
                                void 0
                }
            if (t
                .statements)
                for (let r in
                    t
                        .statements) {
                    let i =
                        t
                            .statements[
                        r
                        ];
                    i ===
                        null ||
                        this
                            .addStatement(
                                i,
                                n
                            )
                }
        }
        setViewState(t) {
            if (_o(t, this
                .viewState
            ))
                return;
            let n = !!(this
                .viewState &&
                t
                    .xAxisScale ===
                this
                    .viewState
                    .xAxisScale &&
                t
                    .yAxisScale ===
                this
                    .viewState
                    .yAxisScale
            );
            if (this
                .viewState =
                t, n)
                for (let r in
                    this
                        .statements)
                    this
                        .statements
                        .hasOwnProperty(
                            r
                        ) &&
                        (this
                            .unpublishedIds[
                            r
                        ] = !
                            0);
            else this
                .invalidate()
        }
        getViewState() {
            return this
                .viewState
        }
        setDegreeMode(t) {
            this.use_degrees =
                t, this
                    .invalidate()
        }
        setDimensions(t) {
            t !== void 0 &&
                (this
                    .dimensions =
                    t, this
                        .invalidate()
                )
        }
        setGlobalRandomSeed(t) {
            this.globalRandomSeedString =
                t, this
                    .parent_frame
                    .globalRandomSeed =
                new t_(t),
                this
                    .dirtyExportedSymbolRoots
                    .globalRandomSeed = !
                0
        }
        setEvaluationMode(t) {
            this.evaluationMode =
                t, this
                    .invalidate()
        }
        setProduct(t) {
            this.product =
                t, this
                    .invalidate()
        }
        setBeta3d(t) {
            this.beta3d = t,
                this
                    .invalidate()
        }
        setAdditionalFunctions(
            t) {
            this.additionalFunctions =
                t, this
                    .invalidate()
        }
        setRestrictedFunctions(
            t) {
            this.restrictedFunctions =
                t, this
                    .invalidate()
        }
        setForceEnableGeometryFunctions
            (t) {
            this.forceEnableGeometryFunctions =
                t, this
                    .invalidate()
        }
        setDistributions(t) {
            this.distributions =
                t, this
                    .invalidate()
        }
        setFunctionDefinition(
            t) {
            this.functionDefinition =
                t, this
                    .invalidate()
        }
        setReplaceRoundWithReciprocal
            (t) {
            this.replaceRoundWithReciprocal =
                t, this
                    .invalidate()
        }
        setActions(t) {
            t !== this
                .actions &&
                (this
                    .actions =
                    t, this
                        .invalidate()
                )
        }
        setSubstitutions(t) {
            t !== this
                .substitutions &&
                (this
                    .substitutions =
                    t, this
                        .invalidate()
                )
        }
        setIntervalComprehensions
            (t) {
            t !== this
                .intervalComprehensions &&
                (this
                    .intervalComprehensions =
                    t, this
                        .invalidate()
                )
        }
        setRecursion(t) {
            t !== this
                .recursion &&
                (this
                    .recursion =
                    t, this
                        .invalidate()
                )
        }
        setWorkerConfigProperty(
            t, n) {
            n !== rs[t] && (
                rs[t] =
                n, this
                    .invalidate()
            )
        }
        _publishAllStatuses() {
            let t = {},
                n = this
                    .currentStatus;
            this
                .currentStatus = {};
            for (let r in
                this
                    .unpublishedIds) {
                if (!this
                    .analysis
                    .hasOwnProperty(
                        r))
                    continue;
                let i = this
                    .analysis[
                    r]
                    .evaluationState;
                _o(i, n[
                    r]) || (
                        t[
                        r] =
                        i),
                    this
                        .currentStatus[
                    r] =
                    i
            }
            return t
        }
        _computeAllLabels() {
            for (let t in
                this
                    .currentLabel) {
                let n = this
                    .statements[
                    t];
                if (!n)
                    continue;
                let r = n
                    .tryGetConcreteTree(
                        this
                            .policy,
                        this
                            .frame
                    ),
                    i = 1;
                (r.valueType ===
                    Pt || r
                        .valueType ===
                    Tn || r
                        .valueType ===
                    Rn || r
                        .valueType ===
                    gn || r
                        .valueType ===
                    hn) && (
                        i = r
                            .length
                    );
                let s = [],
                    o = this
                        .currentLabel[
                        t];
                if (mo(o))
                    for (let a =
                        0; a <
                        i; a++
                    ) s
                        .push(
                            MM(o,
                                this
                                    .policy,
                                this
                                    .frame,
                                a
                            )
                        );
                _o(s, n
                    .computedLabels) ||
                    (n.computedLabels =
                        s,
                        this
                            .unpublishedIds[
                        t
                        ] = !
                        0)
            }
        }
        _computeAriaDescriptions
            () {
            for (let t in
                this
                    .analysis) {
                let n = this
                    .analysis[
                    t],
                    r = n
                        .evaluationState,
                    s = n
                        .rawTree
                        .userData,
                    o;
                if (s
                    .description ?
                    o = s
                        .description :
                    s
                        .label &&
                    (o = s
                        .label
                    ), o
                ) {
                    r
                        .computed_description = [];
                    let a =
                        1;
                    n.concreteTree
                        .isList ?
                        a =
                        n
                            .concreteTree
                            .length :
                        r
                            .dimensions &&
                        r
                            .dimensions
                            .x &&
                        Array
                            .isArray(
                                r
                                    .dimensions
                                    .x
                            ) &&
                        (a = r
                            .dimensions
                            .x
                            .length
                        );
                    for (let u =
                        0; u <
                        a; u++
                    ) r
                        .computed_description
                        .push(
                            MM(EM(
                                o),
                                this
                                    .policy,
                                this
                                    .frame,
                                u
                            )
                        )
                }
            }
        }
        _graphAllChanged(t) {
            let n = this
                .getViewState(),
                r = !1;
            if (!(!n || !vN(
                n))) {
                for (let i in
                    this
                        .unpublishedIds) {
                    if (!
                        this
                            .analysis
                            .hasOwnProperty(
                                i
                            )
                    )
                        continue;
                    let s =
                        this
                            .analysis[
                        i
                        ],
                        o =
                            s
                                .evaluationState
                                .expression_type,
                        a =
                            o ===
                            "SINGLE_POINT" ||
                            o ===
                            "POINT_LIST";
                    if (Gs(s
                        .rawTree)) {
                        let u =
                            s
                                .graph(
                                    n,
                                    void 0
                                ),
                            c =
                                s
                                    .rawTree
                                    .getAllIds();
                        for (
                            let l of
                            c
                        )
                            u[
                                l] ?
                                this
                                    ._notifyGraphComputed(
                                        l,
                                        u[
                                        l],
                                        t
                                    ) :
                                this
                                    ._notifyGraphRemoved(
                                        l,
                                        t
                                    )
                    } else s
                        .evaluationState
                        .is_graphable &&
                        (s.rawTree
                            .userData
                            .shouldGraph ||
                            s
                                .rawTree
                                .userData
                                .showLabel &&
                            a
                        ) ?
                        (this
                            ._notifyGraphComputed(
                                i,
                                s
                                    .graph(
                                        n,
                                        this
                                            .childIntersections
                                            .getChildIntersections(
                                                i
                                            )
                                    ),
                                t
                            ),
                            this
                                .intersectId ===
                            i &&
                            (r = !
                                0
                            )
                        ) :
                        this
                            ._notifyGraphRemoved(
                                i,
                                t
                            )
                }
                bi(this
                    .unpublishedIds)
                    .length &&
                    this
                        .intersectId !==
                    void 0 &&
                    (this
                        .unpublishedIds
                        .hasOwnProperty(
                            this
                                .intersectId
                        ) ||
                        (r = !
                            0
                        )
                    ),
                    r &&
                    this
                        ._updateIntersections(
                            this
                                .intersectId,
                            t)
            }
        }
        _notifyGraphRemoved(t,
            n) {
            n.graphs[t] =
                void 0
        }
        _notifyGraphComputed(t,
            n, r) {
            nS(n), r.graphs[
                t] = n
        }
        _updateIntersections(t,
            n) {
            if (!this
                .viewState)
                return;
            if (!this
                .analysis[
                t] || !this
                    .analysis[t]
                    .shouldIntersect()
            ) {
                n.intersections[
                    t
                ] = [];
                return
            }
            let r = jA(this
                .analysis,
                this
                    .viewState,
                t);
            n.intersections[
                t] = r
        }
        getDisabledFeatures() {
            let t = this
                .policy
                .disabledFeatures();
            this.functionDefinition ===
                !1 && (t = t
                    .concat(
                        "FunctionDefinition"
                    )),
                this
                    .actions ===
                !1 && (t = t
                    .concat(
                        "UpdateRule"
                    )),
                this
                    .substitutions ===
                !1 && (t = t
                    .concat(
                        ["Substitution",
                            "ListComprehension"
                        ]));
            let n = this
                .additionalFunctions ||
                [];
            return t = t
                .filter(r =>
                    !(r ===
                        "Exponent" &&
                        n
                            .indexOf(
                                "exponent"
                            ) !==
                        -
                        1 ||
                        r ===
                        "PercentOf" &&
                        n
                            .indexOf(
                                "percent"
                            ) !==
                        -1)
                ), t
        }
        areFractionsDisallowed
            () {
            let {
                evaluationMode: t
            } = this;
            return t !==
                "fourFunction" &&
                t !==
                "singleExpressionFourFunction" ?
                !1 : !this
                    .additionalFunctions ||
                this
                    .additionalFunctions
                    .indexOf(
                        "fraction"
                    ) === -1
        }
        addStatement(t, n) {
            if (!t) return;
            let r = t.id;
            this.markExportsDirty(
                r), this
                    .markAsDirtyRoot(
                        r);
            let i;
            if (t.type ===
                "statement"
            ) {
                let c = t
                    .latexSelection;
                i = c && {
                    input: t
                        .latex,
                    start: c
                        .start,
                    end: c
                        .end
                }
            }
            let s = {
                index: this
                    .policy
                    .ansEnabled() ?
                    t
                        .index :
                    void 0,
                disabledFeatures: this
                    .getDisabledFeatures(),
                disallowFrac: this
                    .areFractionsDisallowed(),
                allowIntervalComprehensions:
                    !!
                    this
                        .intervalComprehensions,
                seedPrefix: un(
                    r
                ),
                writeIntegral: this
                    .evaluationMode ===
                    "geometry",
                selection: i,
                specializeDoubleInequalities:
                    !
                    this
                        .policy
                        .is3dProduct()
            },
                o = {
                    extraDepNodes: []
                };
            switch (t
                .type) {
                case "table":
                    let
                        c = [];
                    this.statements
                        .hasOwnProperty(
                            r
                        ) &&
                        (c = this
                            .statements[
                            r
                        ]
                            .getAllIds()
                        ),
                        t
                            .shouldGraph = !
                        0;
                    let l =
                        t
                            .columns,
                        p = [],
                        f =
                            I =>
                                !I
                                    .replace(
                                        /\\space|\\ /g,
                                        ""
                                    )
                                    .match(
                                        /\S/
                                    );
                    for (let I =
                        0; I <
                        l
                            .length; I++
                    ) {
                        let E,
                            v,
                            O,
                            A =
                                l[
                                I];
                        E = Vs(A.latex, {
                            ...
                            s,
                            seedPrefix: un(
                                r,
                                [
                                    ["tr",
                                        0
                                    ],
                                    ["tc",
                                        I
                                    ]
                                ]
                            )
                        }),
                            v = [];
                        let N = -
                            1;
                        for (
                            let L =
                                0; L <
                            l[
                                I]
                                .values
                                .length; L++
                        )
                            f(A.values[
                                L
                            ]) ?
                                v
                                    .push(
                                        new eo(
                                            NaN
                                        )
                                    ) :
                                (v.push(Vs(A.values[
                                    L
                                ], {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["tr",
                                                L +
                                                1
                                            ],
                                            ["tc",
                                                I
                                            ]
                                        ]
                                    )
                                })),
                                    N =
                                    L
                                );
                        if (v =
                            v
                                .slice(
                                    0,
                                    N +
                                    1
                                ),
                            O =
                            new bH(
                                E,
                                v
                            ),
                            O
                                .id =
                            A
                                .id,
                            O
                                .header
                        ) {
                            if (O
                                .header
                                .userData =
                                A,
                                O
                                    .header
                                    .metaData = {
                                    extraDepNodes: []
                                },
                                A
                                    .colorLatex
                            ) {
                                let L =
                                    _i(A.colorLatex, {
                                        ...
                                        s,
                                        seedPrefix: un(
                                            r,
                                            [
                                                ["tr",
                                                    0
                                                ],
                                                ["tc",
                                                    I
                                                ],
                                                ["cl",
                                                    I
                                                ]
                                            ]
                                        )
                                    });
                                O.header
                                    .metaData
                                    .colorLatex =
                                    L,
                                    O
                                        .header
                                        .metaData
                                        .extraDepNodes
                                        .push(
                                            L
                                        )
                            }
                            if (A
                                .pointSize
                            ) {
                                let L =
                                    _i(A.pointSize, {
                                        ...
                                        s,
                                        seedPrefix: un(
                                            r,
                                            [
                                                ["tr",
                                                    0
                                                ],
                                                ["tc",
                                                    I
                                                ],
                                                ["ps",
                                                    I
                                                ]
                                            ]
                                        )
                                    });
                                O.header
                                    .metaData
                                    .pointSize =
                                    L,
                                    O
                                        .header
                                        .metaData
                                        .extraDepNodes
                                        .push(
                                            L
                                        )
                            }
                            if (A
                                .pointOpacity
                            ) {
                                let L =
                                    _i(A.pointOpacity, {
                                        ...
                                        s,
                                        seedPrefix: un(
                                            r,
                                            [
                                                ["tr",
                                                    0
                                                ],
                                                ["tc",
                                                    I
                                                ],
                                                ["po",
                                                    I
                                                ]
                                            ]
                                        )
                                    });
                                O.header
                                    .metaData
                                    .pointOpacity =
                                    L,
                                    O
                                        .header
                                        .metaData
                                        .extraDepNodes
                                        .push(
                                            L
                                        )
                            }
                            if (A
                                .lineWidth
                            ) {
                                let L =
                                    _i(A.lineWidth, {
                                        ...
                                        s,
                                        seedPrefix: un(
                                            r,
                                            [
                                                ["tr",
                                                    0
                                                ],
                                                ["tc",
                                                    I
                                                ],
                                                ["lw",
                                                    I
                                                ]
                                            ]
                                        )
                                    });
                                O.header
                                    .metaData
                                    .lineWidth =
                                    L,
                                    O
                                        .header
                                        .metaData
                                        .extraDepNodes
                                        .push(
                                            L
                                        )
                            }
                            if (A
                                .lineOpacity
                            ) {
                                let L =
                                    _i(A.lineOpacity, {
                                        ...
                                        s,
                                        seedPrefix: un(
                                            r,
                                            [
                                                ["tr",
                                                    0
                                                ],
                                                ["tc",
                                                    I
                                                ],
                                                ["lo",
                                                    I
                                                ]
                                            ]
                                        )
                                    });
                                O.header
                                    .metaData
                                    .lineOpacity =
                                    L,
                                    O
                                        .header
                                        .metaData
                                        .extraDepNodes
                                        .push(
                                            L
                                        )
                            }
                        }
                        p.push(
                            O)
                    }
                    this.statements[
                        r
                    ] =
                        new hH(
                            p
                        );
                    let m =
                        this
                            .statements[
                            r
                        ]
                            .getAllIds();
                    c.forEach(
                        I => {
                            m.indexOf(
                                I
                            ) ===
                                -
                                1 &&
                                this
                                    ._notifyGraphRemoved(
                                        I,
                                        n
                                    )
                        }
                    );
                    break;
                case "image":
                    let g =
                        "-\\trigAngleMultiplier*(" +
                        t
                            .angle +
                        ")",
                        d =
                            _i(t.center, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["ic",
                                            r
                                        ]
                                    ]
                                )
                            }),
                        y =
                            _i(g, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["ia",
                                            r
                                        ]
                                    ]
                                )
                            }),
                        h =
                            _i(t.width, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["iw",
                                            r
                                        ]
                                    ]
                                )
                            }),
                        b =
                            _i(t.height, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["ih",
                                            r
                                        ]
                                    ]
                                )
                            }),
                        x =
                            _i(t.opacity, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["io",
                                            r
                                        ]
                                    ]
                                )
                            });
                    this.statements[
                        r
                    ] =
                        new yH({
                            center: d,
                            radianAngle: y,
                            width: h,
                            height: b,
                            opacity: x
                        },
                            void 0
                        );
                    break;
                case "ticker": {
                    this.statements[
                        r
                    ] =
                        new D
                            .Ticker({
                                handler: _i(
                                    t
                                        .handlerLatex, {
                                    ...
                                    s,
                                    allowDt:
                                        !
                                        0
                                }
                                ),
                                minStep: _i(
                                    t
                                        .minStepLatex ||
                                    "0",
                                    s
                                )
                            });
                    break
                }
                case "geometry-toolbar-predicate": {
                    this.statements[
                        r
                    ] =
                        _i(`\\{${t.latex}:1,0\\}`, {
                            ...
                            s
                        });
                    break
                }
                default:
                    t = t;
                    let P,
                        M =
                            wo(t
                                .latex);
                    M.slice(-
                        1
                    ) ===
                        "=" ?
                        P =
                        M
                            .substring(
                                0,
                                M
                                    .length -
                                1
                            ) :
                        P =
                        t
                            .latex,
                        this
                            .statements[
                        r
                        ] =
                        Vs(P,
                            s
                        );
                    for (let I in
                        Dd) {
                        let E =
                            I;
                        if (t[
                            E]) {
                            let v =
                                Dd[
                                E],
                                O =
                                    t[
                                    E];
                            v.transform &&
                                (O = v
                                    .transform(
                                        O
                                    )
                                );
                            let A =
                                $i(O, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            [v.seed,
                                                r
                                            ]
                                        ]
                                    )
                                });
                            o[E] =
                                A,
                                o
                                    .extraDepNodes
                                    .push(
                                        A
                                    )
                        }
                    }
                    if (t
                        .colorLatex
                    ) {
                        let I =
                            Gu(t.colorLatex, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["ac",
                                            r
                                        ]
                                    ]
                                )
                            });
                        o.colorLatex =
                            I,
                            o
                                .extraDepNodes
                                .push(
                                    I
                                )
                    }
                    if (t
                        .polarDomain &&
                        t
                            .polarDomain
                            .min &&
                        (o.polarDomainMin =
                            $i(t.polarDomain
                                .min, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lm",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .polarDomainMin
                                )
                        ),
                        t
                            .polarDomain &&
                        t
                            .polarDomain
                            .max &&
                        (o.polarDomainMax =
                            $i(t.polarDomain
                                .max, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lM",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .polarDomainMax
                                )
                        ),
                        t
                            .parametricDomain &&
                        t
                            .parametricDomain
                            .min &&
                        (o.parametricDomainMin =
                            $i(t.parametricDomain
                                .min, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lm",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomainMin
                                )
                        ),
                        t
                            .parametricDomain &&
                        t
                            .parametricDomain
                            .max &&
                        (o.parametricDomainMax =
                            $i(t.parametricDomain
                                .max, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lM",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomainMax
                                )
                        ),
                        t
                            .parametricDomain3Du &&
                        t
                            .parametricDomain3Du
                            .min &&
                        (o.parametricDomain3DuMin =
                            $i(t.parametricDomain3Du
                                .min, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lm",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DuMin
                                )
                        ),
                        t
                            .parametricDomain3Du &&
                        t
                            .parametricDomain3Du
                            .max &&
                        (o.parametricDomain3DuMax =
                            $i(t.parametricDomain3Du
                                .max, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lM",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DuMax
                                )
                        ),
                        t
                            .parametricDomain3Dv &&
                        t
                            .parametricDomain3Dv
                            .min &&
                        (o.parametricDomain3DvMin =
                            $i(t.parametricDomain3Dv
                                .min, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lm",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DvMin
                                )
                        ),
                        t
                            .parametricDomain3Dv &&
                        t
                            .parametricDomain3Dv
                            .max &&
                        (o.parametricDomain3DvMax =
                            $i(t.parametricDomain3Dv
                                .max, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lM",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DvMax
                                )
                        ),
                        t
                            .parametricDomain3Dr &&
                        t
                            .parametricDomain3Dr
                            .min &&
                        (o.parametricDomain3DrMin =
                            $i(t.parametricDomain3Dr
                                .min, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lm",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DrMin
                                )
                        ),
                        t
                            .parametricDomain3Dr &&
                        t
                            .parametricDomain3Dr
                            .max &&
                        (o.parametricDomain3DrMax =
                            $i(t.parametricDomain3Dr
                                .max, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lM",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DrMax
                                )
                        ),
                        t
                            .parametricDomain3Dphi &&
                        t
                            .parametricDomain3Dphi
                            .min &&
                        (o.parametricDomain3DphiMin =
                            $i(t.parametricDomain3Dphi
                                .min, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lm",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DphiMin
                                )
                        ),
                        t
                            .parametricDomain3Dphi &&
                        t
                            .parametricDomain3Dphi
                            .max &&
                        (o.parametricDomain3DphiMax =
                            $i(t.parametricDomain3Dphi
                                .max, {
                                ...
                                s,
                                seedPrefix: un(
                                    r,
                                    [
                                        ["lM",
                                            r
                                        ]
                                    ]
                                )
                            }
                            ),
                            o
                                .extraDepNodes
                                .push(
                                    o
                                        .parametricDomain3DphiMax
                                )
                        ),
                        t
                            .vizProps &&
                        (t.vizProps
                            .axisOffset &&
                            (o.vizAxisOffset =
                                $i(t.vizProps
                                    .axisOffset, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["vo",
                                                r
                                            ]
                                        ]
                                    )
                                }
                                ),
                                o
                                    .extraDepNodes
                                    .push(
                                        o
                                            .vizAxisOffset
                                    )
                            ),
                            t
                                .vizProps
                                .breadth &&
                            (o.vizBreadth =
                                $i(t.vizProps
                                    .breadth, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["vb",
                                                r
                                            ]
                                        ]
                                    )
                                }
                                ),
                                o
                                    .extraDepNodes
                                    .push(
                                        o
                                            .vizBreadth
                                    )
                            )
                        ),
                        t
                            .cdf &&
                        t
                            .cdf
                            .show
                    ) {
                        let I =
                            HR(t
                                .latex);
                        I && I
                            .type ===
                            "distribution" &&
                            (o.distributionSpec =
                                I,
                                o
                                    .cdfMin =
                                Gu(t.cdf
                                    .min, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["lm",
                                                r
                                            ]
                                        ]
                                    )
                                }
                                ),
                                o
                                    .extraDepNodes
                                    .push(
                                        o
                                            .cdfMin
                                    ),
                                o
                                    .cdfMax =
                                Gu(t.cdf
                                    .max, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["lM",
                                                r
                                            ]
                                        ]
                                    )
                                }
                                ),
                                o
                                    .extraDepNodes
                                    .push(
                                        o
                                            .cdfMax
                                    )
                            )
                    }
                    if (this
                        .statements[
                        r
                    ]
                        .shouldPromoteToSlider(
                            this
                                .policy
                        )
                    ) {
                        let I =
                            t
                                .slider,
                            E = !
                                !
                                (I &&
                                    I
                                        .isPlayingOnce
                                ),
                            v =
                                Gu(I &&
                                    I
                                        .softMin,
                                    s
                                ),
                            O =
                                Gu(I &&
                                    I
                                        .softMax,
                                    s
                                ),
                            A =
                                Gu(I &&
                                    I
                                        .min, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["lm",
                                                r
                                            ]
                                        ]
                                    )
                                }
                                ),
                            N =
                                Gu(I &&
                                    I
                                        .max, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["lM",
                                                r
                                            ]
                                        ]
                                    )
                                }
                                ),
                            L =
                                Gu(I &&
                                    I
                                        .step, {
                                    ...
                                    s,
                                    seedPrefix: un(
                                        r,
                                        [
                                            ["ls",
                                                r
                                            ]
                                        ]
                                    )
                                }
                                );
                        this.statements[
                            r
                        ] =
                            new gH(
                                this
                                    .statements[
                                r
                                ], {
                                sliderMin: A,
                                sliderMax: N,
                                sliderStep: L,
                                sliderIsPlayingOnce: E,
                                sliderSoftMin: v,
                                sliderSoftMax: O
                            }
                            )
                    }
            }
            let a = t
                .clickableInfo;
            a && a
                .enabled &&
                a.latex && (
                    o
                        .clickHandler =
                    _i(a.latex, {
                        ...
                        s,
                        allowIndex:
                            !
                            0
                    })),
                this
                    .statements[
                    r]
                    .userData =
                t, this
                    .statements[
                    r]
                    .metaData =
                o;
            let u = t.label;
            if (u) {
                let c = this
                    .currentLabel[
                    r];
                (!c || c
                    .raw !==
                    u) && (
                        this
                            .currentLabel[
                        r] =
                        EM(u))
            } else
                delete this
                    .currentLabel[
                    r]
        }
        removeStatement(t, n) {
            let r = this
                .statements[
                t];
            if (r) {
                if (this
                    .markExportsDirty(
                        t),
                    Gs(r)) {
                    let i =
                        this;
                    r.getAllIds()
                        .forEach(
                            function (
                                s
                            ) {
                                i._notifyGraphRemoved(
                                    s,
                                    n
                                )
                            }
                        )
                } else this
                    ._notifyGraphRemoved(
                        t, n
                    );
                delete this
                    .currentLabel[
                    t],
                    delete this
                        .statements[
                    t],
                    delete this
                        .analysis[
                    t],
                    delete this
                        .currentStatus[
                    t]
            }
        }
        markExportsDirty(t) {
            if (this
                .statements[
                t]) {
                fp(this.statements[
                    t
                ]) &&
                    (this
                        .markedRegressionDirty = !
                        0);
                for (let n of
                    this
                        .statements[
                        t
                    ]
                        .getLegalExports(
                            this
                                .policy
                        ))
                    this
                        .dirtyExportedSymbolRoots[
                        n
                    ] = !
                        0
            }
        }
        markAsDirtyRoot(t) {
            this.dirtyStatementRoots[
                t] = !0
        }
        getFrame() {
            return this
                .updateAnalysis(),
                this.frame
        }
        getAnalysis() {
            return this
                .updateAnalysis(),
                this
                    .analysis
        }
        getEvaluationState(t) {
            if (this
                .updateAnalysis(),
                !!this
                    .analysis[t]
            ) return this
                .analysis[
                t]
                .evaluationState
        }
        _updateRegressions(t) {
            let n = this
                .frame,
                r = this
                    .lastFrame,
                i = this
                    .regressionFrame;
            if (!this.policy
                .graphingEnabled()
            ) return;
            let s = [];
            for (let l in t)
                t
                    .hasOwnProperty(
                        l) &&
                    fp(t[l]) &&
                    s.push(l);
            let o = this;
            s.sort(function (
                l, p
            ) {
                let f =
                    o
                        .statements[
                        l
                    ]
                        .userData &&
                    o
                        .statements[
                        l
                    ]
                        .userData
                        .residualVariable,
                    m =
                        o
                            .statements[
                            p
                        ]
                            .userData &&
                        o
                            .statements[
                            p
                        ]
                            .userData
                            .residualVariable;
                return f &&
                    !
                    m ?
                    -
                    1 :
                    m &&
                        !
                        f ?
                        1 :
                        0
            });
            let a = Id(this
                .policy,
                t, s);
            n_(a, i, this
                .recursion
            );
            let u = a
                .resolved,
                c = {};
            for (let l of u)
                if (l !==
                    Co)
                    if (fp(this
                        .statements[
                        l
                    ]
                    ))
                        this
                            .analysis[
                            l
                        ] =
                            t[l]
                                .analyze(
                                    this
                                        .policy,
                                    i,
                                    n,
                                    r,
                                    c
                                ),
                            this
                                .analysis[
                                l
                            ]
                                .exportTo(
                                    this
                                        .policy,
                                    n
                                ),
                            delete t[
                            l
                            ];
                    else {
                        let p =
                            t[
                                l]
                                .tryGetConcreteTree(
                                    this
                                        .policy,
                                    i
                                );
                        t[l].exportTo(
                            this
                                .policy,
                            p,
                            i
                        ),
                            c[
                            l] = {
                                rawTree: t[
                                    l
                                ],
                                concreteTree: p
                            }
                    }
        }
        buildSymbolToExpressionDirtyMap
            () {
            let t = {};
            for (let n in
                this
                    .statements) {
                if (!this
                    .statements
                    .hasOwnProperty(
                        n))
                    continue;
                let r = this
                    .statements[
                    n],
                    i = r
                        .metaData;
                if (Sd(t, n,
                    r
                        .getDependencies()
                ),
                    Sd(t, n,
                        r
                            .getLegalExports(
                                this
                                    .policy
                            )
                    ),
                    fp(r) &&
                    r
                        .userData &&
                    r
                        .userData
                        .residualVariable &&
                    Sd(t, n,
                        [Lo(r.userData
                            .residualVariable
                        )]
                    ),
                    r_(t, n,
                        i),
                    Gs(r) &&
                    r
                        .columns
                )
                    for (let s =
                        0; s <
                        r
                            .columns
                            .length; s++
                    ) {
                        let o =
                            r
                                .columns[
                            s
                            ];
                        !xo(o) &&
                            o
                                .header &&
                            o
                                .header
                                .metaData &&
                            r_(t,
                                n,
                                o
                                    .header
                                    .metaData
                            )
                    }
            }
            return t
        }
        buildChildIntersectionMap
            () {
            var r, i;
            let t = this
                .childIntersections,
                n = new Ed;
            for (let s in
                this
                    .analysis) {
                let o = this
                    .analysis[
                    s],
                    {
                        geometry: a
                    } = o
                            .evaluationState;
                if (a !=
                    null &&
                    a
                        .call &&
                    a.call
                        .symbol ===
                    "intersection" &&
                    this
                        .statements[
                        s]
                        .userData
                        .shouldGraph &&
                    !o
                        .concreteTree
                        .isError
                ) {
                    let u = !
                        !
                        this
                            .unpublishedIds[
                        s
                        ],
                        c =
                            o
                                .concreteTree
                                .asTypedValue();
                    for (let l of
                        a
                            .call
                            .parents) {
                        let p =
                            l &&
                            this
                                .frame[
                            l[
                            0]
                            ],
                            f =
                                p &&
                                p
                                    .userData
                                    .id;
                        if (f ==
                            null
                        )
                            continue;
                        let m =
                            l &&
                            l[
                            1],
                            g =
                                this
                                    .analysis[
                                f
                                ];
                        W(g.concreteTree
                            .asTypedValue()
                            .valueType
                        ) ?
                            n
                                .addListParent(
                                    f,
                                    m ===
                                        void 0 ?
                                        void 0 :
                                        m -
                                        1,
                                    c
                                ) :
                            n
                                .addPrimitiveParent(
                                    f,
                                    c
                                ),
                            u &&
                            (this
                                .unpublishedIds[
                                f
                            ] = !
                                0
                            )
                    }
                }
            }
            for (let s in t
                .data) {
                let o = ((r =
                    t
                        .data[
                    s
                    ]
                ) ==
                    null ?
                    void 0 :
                    r
                        .count
                ) ||
                    0;
                (((i = n.data[
                    s]) ==
                    null ?
                    void 0 :
                    i
                        .count
                ) ||
                    0) < o
                    && (this
                        .unpublishedIds[
                        s
                    ] = !
                        0)
            }
            return n
        }
        updateConstruction() {
            if (!this.policy
                .isGeometryEnabled
            ) {
                this.parent_frame
                    .construction =
                    ff();
                return
            }
            let t = [];
            for (let o in
                this
                    .statements)
                this
                    .statements[
                    o]
                    .userData
                    .isInConstructionsFolder &&
                    t.push(o);
            let n = this
                .statements[
                Co],
                r = new xH(
                    t);
            r.metaData = {
                extraDepNodes: []
            }, r
                .userData = {};
            let i = {};
            for (let o of (
                n ==
                    null ?
                    void 0 :
                    n
                        .getDependencies()
            ) ||
                []) i[
                    o] = !0;
            let s = {};
            for (let o of r
                .getDependencies())
                s[o] = !0;
            (!n || !_o(i,
                s)) && (this
                    .statements[
                    Co] = r,
                    this
                        .parent_frame
                        .construction =
                    r, this
                        .markAsDirtyRoot(
                            Co),
                    this
                        .markExportsDirty(
                            Co))
        }
        analyzeExternalRecursiveBaseCases
            () {
            if (!this
                .recursion)
                return;
            let t = [],
                n = {};
            for (let a in
                this
                    .statements) {
                if (!this
                    .statements
                    .hasOwnProperty(
                        a))
                    continue;
                let u = this
                    .statements[
                    a];
                u instanceof cr
                    && !Ke[u
                        ._symbol
                    ] &&
                    (t.push(
                        a),
                        n[u
                            ._symbol] =
                        u)
            }
            let r = Id(this
                .policy,
                this
                    .statements,
                t),
                i = new Set;
            for (let a of
                t) {
                let u = this
                    .statements[
                    a];
                u instanceof cr
                    && r
                        .recursiveFunctionGroups[
                    a
                    ] &&
                    i.add(u
                        ._symbol
                    )
            }
            let s = {},
                o = [];
            for (let a in
                this
                    .statements) {
                let u = this
                    .statements[
                    a];
                if (u instanceof ja &&
                    i.has(u
                        ._lhs
                        ._symbol
                    )) {
                    let c =
                        wi
                            .fromCallAssignment(
                                n,
                                u
                            );
                    if (!c)
                        continue;
                    this.markExportsDirty(
                        a
                    ),
                        this
                            .markAsDirtyRoot(
                                a
                            ),
                        this
                            .statements[
                        a
                        ] =
                        c,
                        s[c
                            ._symbol] ||
                        (s[c
                            ._symbol] = []),
                        s[c
                            ._symbol]
                            .push(
                                c
                            ),
                        c
                            .getDependencies()
                            .length &&
                        o
                            .push(
                                a
                            )
                } else
                    u instanceof wi &&
                        (i.has(u
                            ._symbol) ?
                            (s[u._symbol] ||
                                (s[u
                                    ._symbol] = []),
                                s[u
                                    ._symbol]
                                    .push(
                                        u
                                    ),
                                u
                                    .getDependencies()
                                    .length &&
                                o
                                    .push(
                                        a
                                    )
                            ) :
                            (this
                                .markExportsDirty(
                                    a
                                ),
                                this
                                    .markAsDirtyRoot(
                                        a
                                    ),
                                this
                                    .statements[
                                a
                                ] =
                                u
                                    .originalNode
                            )
                        )
            }
            for (let a in
                n) {
                let u = n[
                    a],
                    c = u
                        .getExternalBaseCases(),
                    l = s[
                        a] ||
                        [],
                    p = !1;
                if (c
                    .length ===
                    l.length
                ) {
                    for (let f =
                        0; f <
                        l
                            .length; f++
                    )
                        if (l[
                            f] !==
                            c[
                            f]
                        ) {
                            p = !
                                0;
                            break
                        }
                } else p = !
                    0;
                p && (u.setExternalBaseCases(
                    l
                ),
                    this
                        .markExportsDirty(
                            u
                                .userData
                                .id
                        ),
                    this
                        .markAsDirtyRoot(
                            u
                                .userData
                                .id
                        )
                )
            }
            if (o.length) {
                let a = Id(
                    this
                        .policy,
                    this
                        .statements,
                    o);
                for (let u of
                    a
                        .recursiveFunctionBaseCasesWithCycles) {
                    let c =
                        this
                            .statements[
                        u
                        ];
                    if (
                        c instanceof wi) {
                        let l =
                            n[c
                                ._symbol];
                        l.setExternalBaseCases(
                            l
                                .getExternalBaseCases()
                                .filter(
                                    p =>
                                        p !==
                                        c
                                )
                        ),
                            this
                                .statements[
                            u
                            ] =
                            c
                                .originalNode
                    }
                }
            }
        }
        updateAnalysis() {
            var m;
            this.updateConstruction(),
                this
                    .analyzeExternalRecursiveBaseCases();
            let t = this
                .buildSymbolToExpressionDirtyMap(),
                n = DM(this
                    .policy,
                    this
                        .statements,
                    t, this
                    .dirtyStatementRoots,
                    this
                        .dirtyExportedSymbolRoots
                ),
                r = this
                    .markedRegressionDirty;
            for (let g in n
                .ids)
                this
                    .statements[
                    g] &&
                    fp(this
                        .statements[
                        g]
                    ) && (
                        r = !0);
            let i = {};
            if (r) {
                for (let g in
                    this
                        .statements)
                    this
                        .statements[
                        g
                    ] &&
                        (i[g] =
                            this
                                .statements[
                            g
                            ]
                        );
                this.frame =
                    Object
                        .create(
                            this
                                .parent_frame
                        ),
                    this
                        .regressionFrame =
                    Object
                        .create(
                            this
                                .parent_frame
                        )
            } else {
                let g = n
                    .ids;
                for (let y in
                    g)
                    this
                        .statements[
                        y
                    ] &&
                        (i[y] =
                            this
                                .statements[
                            y
                            ]
                        );
                let d = n
                    .symbols;
                for (let y in
                    d)
                    d[y] &&
                        (delete this
                            .frame[
                            y
                        ],
                            delete this
                                .regressionFrame[
                            y
                            ]
                        )
            }
            for (let g in i)
                i[g] && (
                    this
                        .unpublishedIds[
                    g
                    ] = !
                    0);
            this.markedRegressionDirty = !
                1, this
                    .dirtyExportedSymbolRoots = {},
                this
                    .dirtyStatementRoots = {};
            let s = this
                .analysis,
                o = this
                    .frame;
            (this
                .evaluationMode ===
                "graphing" ||
                this
                    .evaluationMode ===
                "geometry" ||
                this
                    .evaluationMode ===
                "graphing_3d"
            ) && this
                ._updateRegressions(
                    i);
            let a = Id(this
                .policy,
                i);
            n_(a, o, this
                .recursion
            );
            let u = a
                .resolved,
                c = new Set;
            for (let g of u)
                if (g !==
                    Co)
                    switch (
                    this
                        .evaluationMode
                    ) {
                        case "fourFunction":
                        case "singleExpressionFourFunction":
                            s[g] =
                                this
                                    .statements[
                                    g
                                ]
                                    .analyzeFourFunction(
                                        this
                                            .policy,
                                        o,
                                        s
                                    ),
                                s[
                                    g]
                                    .exportTo(
                                        this
                                            .policy,
                                        o
                                    );
                            break;
                        case "scientific":
                            s[g] =
                                this
                                    .statements[
                                    g
                                ]
                                    .analyzeScientific(
                                        this
                                            .policy,
                                        o,
                                        s
                                    ),
                                s[
                                    g]
                                    .exportTo(
                                        this
                                            .policy,
                                        o
                                    );
                            break;
                        case "singleExpressionScientific":
                            s[g] =
                                this
                                    .statements[
                                    g
                                ]
                                    .analyzeSingleExpressionScientific(
                                        this
                                            .policy,
                                        o,
                                        s
                                    ),
                                s[
                                    g]
                                    .exportTo(
                                        this
                                            .policy,
                                        o
                                    );
                            break;
                        case "graphing":
                        case "graphing_3d":
                        case "geometry":
                            if (!
                                this
                                    .policy
                                    .graphingEnabled()
                            )
                                break;
                            if (c
                                .has(
                                    g
                                )
                            )
                                continue;
                            let d =
                                a
                                    .recursiveFunctionGroups[
                                g
                                ];
                            if (o
                                .r
                            ) {
                                let y =
                                    Object
                                        .create(
                                            o
                                        );
                                if (y
                                    .r =
                                    void 0,
                                    s[
                                    g] =
                                    this
                                        .statements[
                                        g
                                    ]
                                        .analyze(
                                            this
                                                .policy,
                                            y,
                                            s
                                        ),
                                    s[
                                        g]
                                        .getGraphMode() ===
                                    6
                                ) {
                                    s[g].exportTo(
                                        this
                                            .policy,
                                        o
                                    );
                                    continue
                                }
                            }
                            if (d &&
                                this
                                    .recursion
                            ) {
                                KA(this.policy,
                                    o,
                                    s,
                                    d
                                );
                                for (
                                    let y in
                                    d
                                )
                                    c
                                        .add(
                                            y
                                        )
                            } else
                                s[
                                    g] =
                                    this
                                        .statements[
                                        g
                                    ]
                                        .analyze(
                                            this
                                                .policy,
                                            o,
                                            s
                                        ),
                                    s[
                                        g]
                                        .exportTo(
                                            this
                                                .policy,
                                            o
                                        );
                            break
                    }
            if (this.policy
                .graphingEnabled()
            ) {
                for (let g of
                    u) {
                    if (g ===
                        Co)
                        continue;
                    let d =
                        s[
                        g],
                        y =
                            d
                                .evaluationState
                                .expression_type;
                    for (let h in
                        Dd) {
                        let b =
                            h;
                        var l =
                            Dd[
                            b];
                        this.evaluationMode !==
                            "graphing_3d" &&
                            b ===
                            "resolution" ||
                            (!l.shouldEvaluate ||
                                l
                                    .shouldEvaluate(
                                        d
                                    )
                            ) &&
                            NH(d,
                                this
                                    .policy,
                                o,
                                b
                            )
                    }
                    AH(d, this
                        .policy,
                        o
                    ),
                        this
                            .product ===
                        "graphing-3d" &&
                        _H(
                            d),
                        this
                            .actions &&
                        EH(
                            d) &&
                        LH(d,
                            this
                                .policy,
                            o
                        ),
                        y ===
                            "PARAMETRIC" ||
                            y ===
                            "CURVE3D_xyz_t" ||
                            y ===
                            "POLAR" ||
                            y ===
                            "SURFACE_r_z" ||
                            y ===
                            "SURFACE_r_z_AMBIGUOUS" ||
                            y ===
                            "SLICE_rz_at_z" ?
                            wH(d,
                                this
                                    .policy,
                                o
                            ) :
                            y ===
                                "SURFACE_xyz_uv" ||
                                y ===
                                "SLICE_xyz_uv" ||
                                y ===
                                "SURFACE_r_" ||
                                y ===
                                "SURFACE_z_r" ||
                                y ===
                                "SLICE_zr_at_r" ||
                                y ===
                                "SLICE_zr_at_" ||
                                y ===
                                "SLICE_zr_at_xyz" ||
                                y ===
                                "SLICE_r_at_" ||
                                y ===
                                "SLICE_r_at_" ||
                                y ===
                                "SLICE_r_at_xyz" ?
                                FH(d,
                                    this
                                        .policy,
                                    o
                                ) :
                                y ===
                                    "BOXPLOT" ?
                                    VH(d,
                                        this
                                            .policy,
                                        o
                                    ) :
                                    IH(
                                        d) &&
                                    CH(d,
                                        this
                                            .policy,
                                        o
                                    )
                }
                this.childIntersections =
                    this
                        .buildChildIntersectionMap()
            }
            BH(t).forEach(
                function (
                    g) {
                    s[g].evaluationState
                        .depends_on_random_seed = !
                        0
                });
            let p = DM(this
                .policy,
                this
                    .statements,
                t, {
                [
                    Co]: !
                    0
            }, {
                construction:
                    !
                    0
            });
            for (let g in p
                .ids) {
                if (g ===
                    Co)
                    continue;
                let d = s[g]
                    .evaluationState;
                d.geometry &&
                    (d.geometry
                        .unconstructable = !
                        0)
            }
            let f;
            for (let g in
                this
                    .statements)
                if ((m = this
                    .statements[
                    g
                ]
                    .parseOptions
                ) !=
                    null &&
                    m
                        .selection
                ) {
                    f = g;
                    break
                } if (f) {
                    let g = DM(
                        this
                            .policy,
                        this
                            .statements,
                        t, {
                        [
                            f]:
                            !
                            0
                    }, {
                        [
                            `idref_${f}`]:
                            !
                            0
                    });
                    for (let d in
                        g
                            .ids) {
                        if (d ===
                            Co)
                            continue;
                        let y =
                            s[d]
                                .evaluationState;
                        y.geometry &&
                            (y.geometry
                                .depends_on_selected = !
                                0
                            )
                    }
                }
            this.lastFrame =
                Object
                    .create(this
                        .parent_frame
                    );
            for (let g in o)
                o
                    .hasOwnProperty(
                        g) && (
                        this
                            .lastFrame[
                        g] =
                        o[g])
        }
        processEvents(t) {
            if (!t || !this
                .actions)
                return;
            let n = Object
                .create(this
                    .frame),
                r = {},
                i = !1,
                s = !1,
                o;
            for (let c of t)
                switch (this
                    .globalEventCount +=
                1, n
                    .globalEventCount =
                new D
                    .Constant(
                        this
                            .globalEventCount
                    ), c
                    .type) {
                    case "step": {
                        let p =
                            this
                                .statements[
                            c
                                .expressionId
                            ];
                        if (!
                            p
                        )
                            continue;
                        let f =
                            p
                                .tryGetConcreteTree(
                                    this
                                        .policy,
                                    n
                                );
                        s = !
                            0,
                            SM(f,
                                r,
                                n
                            );
                        break
                    }
                    case "click": {
                        let p =
                            this
                                .statements[
                            c
                                .expressionId
                            ];
                        if (!
                            p ||
                            !
                            p
                                .metaData
                                .clickHandler
                        )
                            continue;
                        n.index =
                            new D
                                .Constant(
                                    c
                                        .indexVar +
                                    1
                                );
                        let f =
                            p
                                .metaData
                                .clickHandler
                                .tryGetConcreteTree(
                                    this
                                        .policy,
                                    n
                                );
                        s = !
                            0,
                            i = !
                            0,
                            SM(f,
                                r,
                                n
                            );
                        break
                    }
                    case "clock-tick": {
                        (o ===
                            void 0 ||
                            c
                                .isFirstTick &&
                            !
                            o
                                .isFirstTick
                        ) &&
                            (o =
                                c);
                        break
                    }
                    default:
                        return c
                }
            if (o) {
                let c = this
                    .statements[
                    o.id
                ];
                if (c &&
                    c instanceof D
                        .Ticker
                ) {
                    var a =
                        c
                            .minStep
                            .tryGetConcreteTree(
                                this
                                    .policy,
                                n
                            )
                            .asValue(),
                        u =
                            typeof a ==
                            "number" &&
                            a >=
                            0 &&
                            isFinite(
                                a
                            );
                    if (u) {
                        let l =
                            this
                                .lastClockTickTime;
                        if (this
                            .lastClockTickTime =
                            Date
                                .now(),
                            !
                            o
                                .isFirstTick &&
                            l !==
                            void 0
                        ) {
                            n.dt =
                                new D
                                    .Constant(
                                        this
                                            .lastClockTickTime -
                                        l
                                    );
                            let p =
                                c
                                    .handler
                                    .tryGetConcreteTree(
                                        this
                                            .policy,
                                        n
                                    );
                            SM(p, r,
                                n)
                        }
                    }
                }
            }
            return {
                objectClicked: i,
                userAction: s,
                updates: r
            }
        }
    };
    var a_ = class {
        constructor(t) {
            this.context =
                new Ah, this
                    .sendMessage =
                t
        }
        processChangeSet(t) {
            var n = this
                .context
                .processChangeSet(
                    t);
            this.sendMessage(
                "processChangeSet",
                n)
        }
    };
    Object.defineProperty(
        __dcg_chunk_exports__,
        'a', {
        get: () => GH
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'b', {
        get: () => kH
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'c', {
        get: () => zH
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'd', {
        get: () => No
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'e', {
        get: () => HH
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'f', {
        get: () => UH
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'g', {
        get: () => Dv
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'h', {
        get: () => Sv
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'i', {
        get: () => Bs
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'j', {
        get: () => ON
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'k', {
        get: () => dte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'l', {
        get: () => yi
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'm', {
        get: () => Cn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'n', {
        get: () => Ht
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'o', {
        get: () => T
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'p', {
        get: () => R
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'q', {
        get: () => sn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'r', {
        get: () => se
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        's', {
        get: () => Ln
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        't', {
        get: () => Pt
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'u', {
        get: () => wn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'v', {
        get: () => We
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'w', {
        get: () => Zn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'x', {
        get: () => Be
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'y', {
        get: () => Rn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'z', {
        get: () => Ie
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'A', {
        get: () => Tn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'B', {
        get: () => pe
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'C', {
        get: () => Fn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'D', {
        get: () => ce
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'E', {
        get: () => Vn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'F', {
        get: () => fe
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'G', {
        get: () => Bn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'H', {
        get: () => Le
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'I', {
        get: () => Gn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'J', {
        get: () => Ge
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'K', {
        get: () => gn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'L', {
        get: () => Ae
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'M', {
        get: () => hn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'N', {
        get: () => Ue
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'O', {
        get: () => mr
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'P', {
        get: () => he
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Q', {
        get: () => kn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'R', {
        get: () => Hr
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'S', {
        get: () => mn
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'T', {
        get: () => Ur
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'U', {
        get: () => V
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'V', {
        get: () => FM
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'W', {
        get: () => y_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'X', {
        get: () => on
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Y', {
        get: () => ne
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Z', {
        get: () => W
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '_', {
        get: () => ke
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '$', {
        get: () => Sp
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'aa', {
        get: () => zr
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ba', {
        get: () => _d
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ca', {
        get: () => oe
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'da', {
        get: () => ca
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ea', {
        get: () => Oe
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'fa', {
        get: () => BM
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ga', {
        get: () => Ld
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ha', {
        get: () => bU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ia', {
        get: () => as
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ja', {
        get: () => pa
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ka', {
        get: () => Rs
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'la', {
        get: () => T_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ma', {
        get: () => PU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'na', {
        get: () => TU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'oa', {
        get: () => Li
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'pa', {
        get: () => IU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'qa', {
        get: () => Zt
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ra', {
        get: () => el
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'sa', {
        get: () => zd
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ta', {
        get: () => R_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ua', {
        get: () => RU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'va', {
        get: () => NU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'wa', {
        get: () => Qc
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'xa', {
        get: () => iv
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ya', {
        get: () => N_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'za', {
        get: () => _U
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Aa', {
        get: () => LU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ba', {
        get: () => wU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ca', {
        get: () => BU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Da', {
        get: () => GU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ea', {
        get: () => zU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Fa', {
        get: () => HU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ga', {
        get: () => L_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ha', {
        get: () => V_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ia', {
        get: () => YU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ja', {
        get: () => WU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ka', {
        get: () => jU
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'La', {
        get: () => bi
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ma', {
        get: () => Lp
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Na', {
        get: () => Y_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Oa', {
        get: () => _o
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Pa', {
        get: () => e8
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Qa', {
        get: () => tl
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ra', {
        get: () => nl
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Sa', {
        get: () => j_
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ta', {
        get: () => u8
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ua', {
        get: () => l8
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Va', {
        get: () => jh
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Wa', {
        get: () => sL
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Xa', {
        get: () => xv
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ya', {
        get: () => $d
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Za', {
        get: () => lL
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '_a', {
        get: () => Qh
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '$a', {
        get: () => ur
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ab', {
        get: () => Lo
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'bb', {
        get: () => wo
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'cb', {
        get: () => dL
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'db', {
        get: () => da
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'eb', {
        get: () => Ke
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'fb', {
        get: () => o3
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'gb', {
        get: () => Rr
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'hb', {
        get: () => kp
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ib', {
        get: () => Iq
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'jb', {
        get: () => ko
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'kb', {
        get: () => $r
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'lb', {
        get: () => cD
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'mb', {
        get: () => Pf
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'nb', {
        get: () => dy
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ob', {
        get: () => Ki
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'pb', {
        get: () => wD
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'qb', {
        get: () => C4
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'rb', {
        get: () => L4
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'sb', {
        get: () => po
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'tb', {
        get: () => $w
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ub', {
        get: () => rr
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'vb', {
        get: () => P1
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'wb', {
        get: () => Xl
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'xb', {
        get: () => jl
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'yb', {
        get: () => Jl
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'zb', {
        get: () => bI
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ab', {
        get: () => xI
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Bb', {
        get: () => QT
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Cb', {
        get: () => zV
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Db', {
        get: () => Z1
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Eb', {
        get: () => HV
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Fb', {
        get: () => Gy
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Gb', {
        get: () => Af
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Hb', {
        get: () => PI
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ib', {
        get: () => TI
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Jb', {
        get: () => j1
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Kb', {
        get: () => $V
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Lb', {
        get: () => J1
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Mb', {
        get: () => YV
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Nb', {
        get: () => Q1
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ob', {
        get: () => XV
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Pb', {
        get: () => rB
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Qb', {
        get: () => oB
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Rb', {
        get: () => aB
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Sb', {
        get: () => Yo
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Tb', {
        get: () => mo
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ub', {
        get: () => Y4
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Vb', {
        get: () => vB
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Wb', {
        get: () => D
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Xb', {
        get: () => lr
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Yb', {
        get: () => a6
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Zb', {
        get: () => Hy
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '_b', {
        get: () => sS
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '$b', {
        get: () => $I
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ac', {
        get: () => qS
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'bc', {
        get: () => ho
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'cc', {
        get: () => og
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'dc', {
        get: () => tO
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ec', {
        get: () => Un
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'fc', {
        get: () => Ce
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'gc', {
        get: () => sE
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'hc', {
        get: () => B9
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ic', {
        get: () => G9
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'jc', {
        get: () => RC
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'kc', {
        get: () => kC
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'lc', {
        get: () => Vs
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'mc', {
        get: () => xR
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'nc', {
        get: () => ea
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'oc', {
        get: () => HR
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'pc', {
        get: () => YE
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'qc', {
        get: () => XE
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'rc', {
        get: () => UR
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'sc', {
        get: () => qR
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'tc', {
        get: () => $R
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'uc', {
        get: () => ta
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'vc', {
        get: () => i2
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'wc', {
        get: () => CQ
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'xc', {
        get: () => dd
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'yc', {
        get: () => sN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'zc', {
        get: () => h0
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ac', {
        get: () => b0
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Bc', {
        get: () => x0
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Cc', {
        get: () => Zg
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Dc', {
        get: () => Wg
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ec', {
        get: () => Ou
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Fc', {
        get: () => gd
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Gc', {
        get: () => ch
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Hc', {
        get: () => hte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Ic', {
        get: () => xte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Jc', {
        get: () => Pte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Kc', {
        get: () => LN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Lc', {
        get: () => Tte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Mc', {
        get: () => dk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Nc', {
        get: () => Mte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Oc', {
        get: () => vte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Pc', {
        get: () => FN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Qc', {
        get: () => VN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Rc', {
        get: () => lh
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Sc', {
        get: () => BN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Tc', {
        get: () => GN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Uc', {
        get: () => kN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Vc', {
        get: () => Bte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Wc', {
        get: () => Gte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Xc', {
        get: () => mk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Yc', {
        get: () => kte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'Zc', {
        get: () => zte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '_c', {
        get: () => V0
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        '$c', {
        get: () => fh
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ad', {
        get: () => yk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'bd', {
        get: () => gk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'cd', {
        get: () => qN
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'dd', {
        get: () => ph
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ed', {
        get: () => bk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'fd', {
        get: () => Bc
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'gd', {
        get: () => xk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'hd', {
        get: () => Pk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'id', {
        get: () => qte
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'jd', {
        get: () => Tk
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'kd', {
        get: () => Ep
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'ld', {
        get: () => nz
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'md', {
        get: () => ZA
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'nd', {
        get: () => $H
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'od', {
        get: () => eH
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'pd', {
        get: () => tH
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'qd', {
        get: () => Md
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'rd', {
        get: () => vd
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'sd', {
        get: () => Ah
    });
    Object.defineProperty(
        __dcg_chunk_exports__,
        'td', {
        get: () => a_
    });

    return __dcg_chunk_exports__;
})();
